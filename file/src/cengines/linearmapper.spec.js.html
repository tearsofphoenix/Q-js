<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/cengines/linearmapper.spec.js | projectq</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#backends">backends</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/backends/printer.js~CommandPrinter.html">CommandPrinter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/backends/resource.js~ResourceCounter.html">ResourceCounter</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#backends-circuits">backends/circuits</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/backends/circuits/drawer.js~CircuitDrawer.html">CircuitDrawer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/backends/circuits/drawer.js~CircuitItem.html">CircuitItem</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/backends/circuits/tolatex.js~_Circ2Tikz.html">_Circ2Tikz</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#backends-ibm">backends/ibm</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/backends/ibm/ibm.js~IBMBackend.html">IBMBackend</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/backends/ibm/ibmhttpclient.js~IBMHTTPClient.html">IBMHTTPClient</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#backends-simulators">backends/simulators</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/backends/simulators/classicalsimulator.js~ClassicalSimulator.html">ClassicalSimulator</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/backends/simulators/jssim.js~Simulator.html">Simulator</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/backends/simulators/shared.spec.js~TrivialMapper.html">TrivialMapper</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/backends/simulators/simulator.js~Simulator.html">Simulator</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#cengines">cengines</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/cengines/basicmapper.js~BasicMapperEngine.html">BasicMapperEngine</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/cengines/basics.js~BasicEngine.html">BasicEngine</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/cengines/basics.js~ForwarderEngine.html">ForwarderEngine</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/cengines/cmdmodifier.js~CommandModifier.html">CommandModifier</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/cengines/ibm5qubitmapper.js~IBM5QubitMapper.html">IBM5QubitMapper</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/cengines/linearmapper.js~LinearMapper.html">LinearMapper</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/cengines/main.js~MainEngine.html">MainEngine</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/cengines/manualmapper.js~ManualMapper.html">ManualMapper</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/cengines/optimize.js~LocalOptimizer.html">LocalOptimizer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/cengines/swapandcnotflipper.js~SwapAndCNOTFlipper.html">SwapAndCNOTFlipper</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/cengines/tagremover.js~TagRemover.html">TagRemover</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/cengines/testengine.js~CompareEngine.html">CompareEngine</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/cengines/testengine.js~DummyEngine.html">DummyEngine</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/cengines/twodmapper.js~GridMapper.html">GridMapper</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/cengines/twodmapper.js~Position.html">Position</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ibmqx4_connections">ibmqx4_connections</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#cengines-replacer">cengines/replacer</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/cengines/replacer/decompositionrule.js~DecompositionRule.html">DecompositionRule</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/cengines/replacer/decompositionruleset.js~DecompositionRuleSet.html">DecompositionRuleSet</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/cengines/replacer/replacer.js~AutoReplacer.html">AutoReplacer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/cengines/replacer/replacer.js~InstructionFilter.html">InstructionFilter</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#libs">libs</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-len">len</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-classHierachy">classHierachy</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-instanceOf">instanceOf</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isKindclassOf">isKindclassOf</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isSubclassOf">isSubclassOf</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-tuple">tuple</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#libs-math">libs/math</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/libs/math/gates.js~AddConstant.html">AddConstant</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/libs/math/gates.js~AddConstantModN.html">AddConstantModN</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/libs/math/gates.js~MultiplyByConstantModN.html">MultiplyByConstantModN</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-SubConstant">SubConstant</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-SubConstantModN">SubConstantModN</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#meta">meta</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/meta/compute.js~ComputeEngine.html">ComputeEngine</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/meta/compute.js~UncomputeEngine.html">UncomputeEngine</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/meta/control.js~ControlEngine.html">ControlEngine</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/meta/dagger.js~DaggerEngine.html">DaggerEngine</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/meta/error.js~LastEngineError.html">LastEngineError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/meta/error.js~NoGateDecompositionError.html">NoGateDecompositionError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/meta/error.js~NotMergeable.html">NotMergeable</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/meta/error.js~NotYetMeasuredError.html">NotYetMeasuredError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/meta/error.js~QubitManagementError.html">QubitManagementError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/meta/loop.js~LoopEngine.html">LoopEngine</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/meta/loop.js~LoopTag.html">LoopTag</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/meta/tag.js~ComputeTag.html">ComputeTag</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/meta/tag.js~DirtyQubitTag.html">DirtyQubitTag</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/meta/tag.js~LogicalQubitIDTag.html">LogicalQubitIDTag</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/meta/tag.js~UncomputeTag.html">UncomputeTag</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-Compute">Compute</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-CustomUncompute">CustomUncompute</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-Uncompute">Uncompute</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-Control">Control</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-Dagger">Dagger</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-Loop">Loop</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-dropEngineAfter">dropEngineAfter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-insertEngine">insertEngine</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#ops">ops</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ops/basics.js~BasicGate.html">BasicGate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ops/basics.js~BasicMathGate.html">BasicMathGate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ops/basics.js~BasicPhaseGate.html">BasicPhaseGate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ops/basics.js~BasicRotationGate.html">BasicRotationGate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ops/basics.js~ClassicalInstructionGate.html">ClassicalInstructionGate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ops/basics.js~FastForwardingGate.html">FastForwardingGate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ops/basics.js~SelfInverseGate.html">SelfInverseGate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ops/command.js~Command.html">Command</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ops/gates.js~AllocateDirtyQubitGate.html">AllocateDirtyQubitGate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ops/gates.js~AllocateQubitGate.html">AllocateQubitGate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ops/gates.js~BarrierGate.html">BarrierGate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ops/gates.js~DeallocateQubitGate.html">DeallocateQubitGate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ops/gates.js~EntangleGate.html">EntangleGate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ops/gates.js~FlushGate.html">FlushGate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ops/gates.js~HGate.html">HGate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ops/gates.js~MeasureGate.html">MeasureGate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ops/gates.js~Ph.html">Ph</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ops/gates.js~R.html">R</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ops/gates.js~Rx.html">Rx</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ops/gates.js~Ry.html">Ry</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ops/gates.js~Rz.html">Rz</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ops/gates.js~SGate.html">SGate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ops/gates.js~SqrtSwapGate.html">SqrtSwapGate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ops/gates.js~SqrtXGate.html">SqrtXGate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ops/gates.js~SwapGate.html">SwapGate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ops/gates.js~TGate.html">TGate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ops/gates.js~XGate.html">XGate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ops/gates.js~YGate.html">YGate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ops/gates.js~ZGate.html">ZGate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ops/metagates.js~ControlledGate.html">ControlledGate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ops/metagates.js~DaggeredGate.html">DaggeredGate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ops/metagates.js~Tensor.html">Tensor</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ops/qftgate.js~QFTGate.html">QFTGate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ops/qubitoperator.js~QubitOperator.html">QubitOperator</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ops/timeevolution.js~TimeEvolution.html">TimeEvolution</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getInverse">getInverse</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-C">C</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-stringToArray">stringToArray</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-CRz">CRz</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Allocate">Allocate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-AllocateDirty">AllocateDirty</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Entangle">Entangle</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-H">H</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Measure">Measure</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-NOT">NOT</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-S">S</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-SqrtSwap">SqrtSwap</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-SqrtX">SqrtX</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Swap">Swap</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-T">T</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-X">X</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Y">Y</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Z">Z</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-All">All</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-QFT">QFT</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-CNOT">CNOT</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-CX">CX</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-CZ">CZ</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Toffoli">Toffoli</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#setups">setups</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getEngineList">getEngineList</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getEngineList">getEngineList</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getEngineList">getEngineList</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getEngineList">getEngineList</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getEngineList">getEngineList</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getEngineList">getEngineList</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ibmqx5_connections">ibmqx5_connections</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#types">types</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/types/qubit.js~BasicQubit.html">BasicQubit</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/types/qubit.js~Qubit.html">Qubit</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-Qureg">Qureg</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/cengines/linearmapper.spec.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import {expect} from &apos;chai&apos;
import deepEqual from &apos;deep-eql&apos;
import {return_swap_depth} from &apos;./linearmapper&apos;
import LinearMapper from &apos;./linearmapper&apos;;
import {BasicQubit} from &apos;../types/qubit&apos;;
import Command from &apos;../ops/command&apos;;
import {tuple} from &apos;../libs/util&apos;;
import {
  Allocate, BasicGate, CNOT, Deallocate, FlushGate, QFT, X
} from &apos;../ops&apos;;
import {len, setEqual} from &apos;../libs/polyfill&apos;;
import {DummyEngine} from &apos;./testengine&apos;;
import {LogicalQubitIDTag} from &apos;../meta&apos;;

describe(&apos;linearmapper test&apos;, () =&gt; {
  it(&apos;should test_return_swap_depth&apos;, () =&gt; {
    let swaps = []
    expect(return_swap_depth(swaps)).to.equal(0)
    swaps = [[0, 1], [0, 1], [1, 2]]
    expect(return_swap_depth(swaps)).to.equal(3)
    swaps.push([2, 3])
    expect(return_swap_depth(swaps)).to.equal(4)
  });

  it(&apos;should test_is_available&apos;, () =&gt; {
    const mapper = new LinearMapper(5, false)
    const qb0 = new BasicQubit(null, 0)
    const qb1 = new BasicQubit(null, 1)
    const qb2 = new BasicQubit(null, 2)
    const cmd0 = new Command(null, new BasicGate(), tuple([qb0]))
    expect(mapper.isAvailable(cmd0)).to.equal(true)
    const cmd1 = new Command(null, new BasicGate(), tuple([qb0]), [qb1])
    expect(mapper.isAvailable(cmd1)).to.equal(true)
    const cmd2 = new Command(null, new BasicGate(), tuple([qb0], [qb1, qb2]))
    expect(mapper.isAvailable(cmd2)).to.equal(false)
    const cmd3 = new Command(null, new BasicGate(), tuple([qb0], [qb1]), [qb2])
    expect(mapper.isAvailable(cmd3)).to.equal(false)
  });

  it(&apos;should test_returnNewMapping_too_many_qubits&apos;, () =&gt; {
    const mapper = new LinearMapper(3, false)
    const qb0 = new BasicQubit(null, 0)
    const qb1 = new BasicQubit(null, 1)
    const qb2 = new BasicQubit(null, 2)
    const cmd0 = new Command(null, QFT, tuple([qb0], [qb1, qb2]))
    mapper._stored_commands = [cmd0]

    expect(() =&gt; LinearMapper.returnNewMapping(
      mapper.num_qubits,
      mapper.cyclic,
      mapper._currently_allocated_ids,
      mapper._stored_commands,
      mapper.currentMapping
    )).to.throw()
    const cmd1 = new Command(null, new BasicGate(), tuple([]))
    mapper._stored_commands = [cmd1]

    expect(() =&gt; LinearMapper.returnNewMapping(
      mapper.num_qubits,
      mapper.cyclic,
      mapper._currently_allocated_ids,
      mapper._stored_commands,
      mapper.currentMapping
    )).to.throw()
  });

  it(&apos;should test_return_new_mapping_allocate_qubits&apos;, () =&gt; {
    const mapper = new LinearMapper(2, false)
    const qb0 = new BasicQubit(null, 0)
    const qb1 = new BasicQubit(null, 1)
    mapper._currently_allocated_ids = new Set([4])
    const cmd0 = new Command(null, Allocate, tuple([qb0]))
    const cmd1 = new Command(null, Allocate, tuple([qb1]))
    mapper._stored_commands = [cmd0, cmd1]
    const new_mapping = LinearMapper.returnNewMapping(
      mapper.num_qubits,
      mapper.cyclic,
      mapper._currently_allocated_ids,
      mapper._stored_commands,
      mapper.currentMapping
    )
    expect(setEqual(mapper._currently_allocated_ids, new Set([4]))).to.equal(true)
    expect(mapper._stored_commands).to.deep.equal([cmd0, cmd1])
    expect(len(new_mapping)).to.equal(2)
    expect(4 in new_mapping &amp;&amp; 0 in new_mapping).to.equal(true)
  });

  it(&apos;should test_return_new_mapping_allocate_only_once&apos;, () =&gt; {
    const mapper = new LinearMapper(1, false)
    const qb0 = new BasicQubit(null, 0)
    const qb1 = new BasicQubit(null, 1)
    mapper._currently_allocated_ids = new Set()
    const cmd0 = new Command(null, Allocate, tuple([qb0]))
    const cmd1 = new Command(null, Deallocate, tuple([qb0]))
    // Test if loop stops after deallocate gate has been used.
    // This would otherwise trigger an error (test by 2)
    const cmd2 = null
    mapper._stored_commands = [cmd0, cmd1, cmd2]
    const new_mapping = LinearMapper.returnNewMapping(
      mapper.num_qubits,
      mapper.cyclic,
      mapper._currently_allocated_ids,
      mapper._stored_commands,
      mapper.currentMapping
    )
  });

  it(&apos;should test_return_new_mapping_possible_map&apos;, () =&gt; {
    const mapper = new LinearMapper(3, false)
    const qb0 = new BasicQubit(null, 0)
    const qb1 = new BasicQubit(null, 1)
    const qb2 = new BasicQubit(null, 2)
    const cmd0 = new Command(null, Allocate, tuple([qb0]))
    const cmd1 = new Command(null, Allocate, tuple([qb1]))
    const cmd2 = new Command(null, Allocate, tuple([qb2]))
    const cmd3 = new Command(null, CNOT, tuple([qb0]), [qb1])
    const cmd4 = new Command(null, CNOT, tuple([qb2]), [qb1])
    const cmd5 = new Command(null, X, tuple([qb0]))
    mapper._stored_commands = [cmd0, cmd1, cmd2, cmd3, cmd4, cmd5]
    const new_mapping = LinearMapper.returnNewMapping(
      mapper.num_qubits,
      mapper.cyclic,
      mapper._currently_allocated_ids,
      mapper._stored_commands,
      mapper.currentMapping
    )
    const array = [{0: 2, 1: 1, 2: 0}, {0: 0, 1: 1, 2: 2}]
    const idx = array.findIndex(item =&gt; deepEqual(item, new_mapping))
    expect(idx).to.not.equal(-1)
  });

  it(&apos;should test_return_new_mapping_previous_error&apos;, () =&gt; {
    const mapper = new LinearMapper(2, false)
    const qb0 = new BasicQubit(null, 0)
    const qb1 = new BasicQubit(null, 1)
    const qb2 = new BasicQubit(null, 2)
    const qb3 = new BasicQubit(null, 3)
    const cmd0 = new Command(null, Allocate, tuple([qb0]))
    const cmd1 = new Command(null, Allocate, tuple([qb1]))
    const cmd2 = new Command(null, Allocate, tuple([qb2]))
    const cmd3 = new Command(null, Allocate, tuple([qb3]))
    const cmd4 = new Command(null, CNOT, tuple([qb2]), [qb3])
    mapper._stored_commands = [cmd0, cmd1, cmd2, cmd3, cmd4]
    const new_mapping = LinearMapper.returnNewMapping(
      mapper.num_qubits,
      mapper.cyclic,
      mapper._currently_allocated_ids,
      mapper._stored_commands,
      mapper.currentMapping
    )
  });

  it(&apos;should test_process_two_qubit_gate_not_in_segments_test0&apos;, () =&gt; {
    const mapper = new LinearMapper(5, false)
    const segments = [[0, 1]]
    const active_qubits = new Set([0, 1, 4, 6])
    const neighbour_ids = {
      0: new Set([1]), 1: new Set([0]), 4: new Set(), 6: new Set()
    }
    LinearMapper._processTwoQubitGate(mapper.num_qubits,
      mapper.cyclic,
      4,
      6,
      active_qubits,
      segments,
      neighbour_ids)
    expect(len(segments)).to.equal(2)
    expect(segments[0]).to.deep.equal([0, 1])
    expect(segments[1]).to.deep.equal([4, 6])
    expect(neighbour_ids[4]).to.deep.equal(new Set([6]))
    expect(neighbour_ids[6]).to.deep.equal(new Set([4]))
    expect(active_qubits).to.deep.equal(new Set([0, 1, 4, 6]))
  });

  it(&apos;should test_process_two_qubit_gate_not_in_segments_test1&apos;, () =&gt; {
    const mapper = new LinearMapper(5, false)
    const segments = []
    const active_qubits = new Set([4, 6])
    const neighbour_ids = {4: new Set(), 6: new Set()}
    LinearMapper._processTwoQubitGate(mapper.num_qubits,
      mapper.cyclic,
      5,
      6,
      active_qubits,
      segments,
      neighbour_ids)
    expect(len(segments)).to.equal(0)
    expect(active_qubits).to.deep.equal(new Set([4]))
  });

  it(&apos;should test_process_two_qubit_gate_one_qb_free_one_qb_in_segment&apos;, () =&gt; {
    const qubits = [[1, 2], [2, 1]]
    qubits.forEach(([qb0, qb1]) =&gt; {
      // add on the right to segment
      const mapper = new LinearMapper(3, false)
      const segments = [[0, 1]]
      const active_qubits = new Set([0, 1, 2])
      const neighbour_ids = {0: new Set([1]), 1: new Set([0]), 2: new Set()}
      LinearMapper._processTwoQubitGate(mapper.num_qubits,
        mapper.cyclic,
        qb0,
        qb1,
        active_qubits,
        segments,
        neighbour_ids)
      expect(segments).to.deep.equal([[0, 1, 2]])
      expect(active_qubits).to.deep.equal(new Set([0, 1, 2]))
      expect(neighbour_ids[1]).to.deep.equal(new Set([0, 2]))
      expect(neighbour_ids[2]).to.deep.equal(new Set([1]))
    })
  });

  it(&apos;should test_process_two_qubit_gate_one_qb_free_one_qb_in_segment2&apos;, () =&gt; {
    const qubits = [[0, 1], [1, 0]]

    qubits.forEach(([qb0, qb1]) =&gt; {
    // add on the left to segment
      const mapper = new LinearMapper(3, false)
      const segments = [[1, 2]]
      const active_qubits = new Set([0, 1, 2])
      const neighbour_ids = {0: new Set([]), 1: new Set([2]), 2: new Set([1])}
      LinearMapper._processTwoQubitGate(mapper.num_qubits,
        mapper.cyclic,
        qb0,
        qb1,
        active_qubits,
        segments,
        neighbour_ids)
      expect(segments).to.deep.equal([[0, 1, 2]])
      expect(active_qubits).to.deep.equal(new Set([0, 1, 2]))
      expect(neighbour_ids[1]).to.deep.equal(new Set([0, 2]))
      expect(neighbour_ids[0]).to.deep.equal(new Set([1]))
    })
  });

  it(&apos;should test_process_two_qubit_gate_one_qb_free_one_qb_in_segment_cycle&apos;, () =&gt; {
    const qubits = [[1, 2], [2, 1]]
    qubits.forEach(([qb0, qb1]) =&gt; {
      const mapper = new LinearMapper(3, true)
      const segments = [[0, 1]]
      const active_qubits = new Set([0, 1, 2])
      const neighbour_ids = {0: new Set([1]), 1: new Set([0]), 2: new Set()}
      LinearMapper._processTwoQubitGate(mapper.num_qubits,
        mapper.cyclic,
        qb0,
        qb1,
        active_qubits,
        segments,
        neighbour_ids)
      expect(segments).to.deep.equal([[0, 1, 2]])
      expect(active_qubits).to.deep.equal(new Set([0, 1, 2]))
      expect(neighbour_ids[1]).to.deep.equal(new Set([0, 2]))
      expect(neighbour_ids[2]).to.deep.equal(new Set([1, 0]))
    })
  });

  it(&apos;should test_process_two_qubit_gate_one_qb_free_one_qb_in_seg_cycle2&apos;, () =&gt; {
    const qubits = [[1, 2], [2, 1]]
    qubits.forEach(([qb0, qb1]) =&gt; {
      // not yet long enough segment for cycle
      const mapper = new LinearMapper(4, true)
      const segments = [[0, 1]]
      const active_qubits = new Set([0, 1, 2])
      const neighbour_ids = {0: new Set([1]), 1: new Set([0]), 2: new Set()}
      LinearMapper._processTwoQubitGate(mapper.num_qubits,
        mapper.cyclic,
        qb0,
        qb1,
        active_qubits,
        segments,
        neighbour_ids)
      expect(segments).to.deep.equal([[0, 1, 2]])
      expect(active_qubits).to.deep.equal(new Set([0, 1, 2]))
      expect(neighbour_ids[1]).to.deep.equal(new Set([0, 2]))
      expect(neighbour_ids[2]).to.deep.equal(new Set([1]))
    })
  });

  it(&apos;should test_process_two_qubit_gate_one_qubit_in_middle_of_segment&apos;, () =&gt; {
    const mapper = new LinearMapper(5, false)
    const segments = []
    const active_qubits = new Set([0, 1, 2, 3])
    const neighbour_ids = {
      0: new Set([1]), 1: new Set([0, 2]), 2: new Set([1]), 3: new Set()
    }
    LinearMapper._processTwoQubitGate(mapper.num_qubits,
      mapper.cyclic,
      1,
      3,
      active_qubits,
      segments,
      neighbour_ids)
    expect(len(segments)).to.equal(0)
    expect(active_qubits).to.deep.equal(new Set([0, 2]))
  });

  it(&apos;should test_process_two_qubit_gate_both_in_same_segment&apos;, () =&gt; {
    const mapper = new LinearMapper(3, false)
    const segments = [[0, 1, 2]]
    const active_qubits = new Set([0, 1, 2])
    const neighbour_ids = {0: new Set([1]), 1: new Set([0, 2]), 2: new Set([1])}
    LinearMapper._processTwoQubitGate(mapper.num_qubits,
      mapper.cyclic,
      0,
      2,
      active_qubits,
      segments,
      neighbour_ids)
    expect(segments).to.deep.equal([[0, 1, 2]])
    expect(active_qubits).to.deep.equal(new Set([1]))
  });

  it(&apos;should test_process_two_qubit_gate_already_connected&apos;, () =&gt; {
    const mapper = new LinearMapper(3, false)
    const segments = [[0, 1, 2]]
    const active_qubits = new Set([0, 1, 2])
    const neighbour_ids = {0: new Set([1]), 1: new Set([0, 2]), 2: new Set([1])}
    LinearMapper._processTwoQubitGate(mapper.num_qubits,
      mapper.cyclic,
      0,
      1,
      active_qubits,
      segments,
      neighbour_ids)
    expect(segments).to.deep.equal([[0, 1, 2]])
    expect(active_qubits).to.deep.equal(new Set([0, 1, 2]))
  });

  it(&apos;should test_process_two_qubit_gate_combine_segments&apos;, () =&gt; {
    const data = [
      [0, 2, [1, 0, 2, 3]],
      [0, 3, [2, 3, 0, 1]],
      [1, 2, [0, 1, 2, 3]],
      [1, 3, [0, 1, 3, 2]]
    ]
    data.forEach(([qb0, qb1, result_seg]) =&gt; {
      const mapper = new LinearMapper(4, false)
      const segments = [[0, 1], [2, 3]]
      const active_qubits = new Set([0, 1, 2, 3, 4])
      const neighbour_ids = {
        0: new Set([1]), 1: new Set([0]), 2: new Set([3]), 3: new Set([2])
      }
      LinearMapper._processTwoQubitGate(mapper.num_qubits,
        mapper.cyclic,
        qb0,
        qb1,
        active_qubits,
        segments,
        neighbour_ids)
      const r = deepEqual(segments, [result_seg]) || deepEqual(segments, [result_seg.reverse()])
      expect(r).to.equal(true)
      expect(neighbour_ids[qb0].has(qb1)).to.equal(true)
      expect(neighbour_ids[qb1].has(qb0)).to.equal(true)
    })
  });

  it(&apos;should test_process_two_qubit_gate_combine_segments_cycle&apos;, () =&gt; {
    const data = [
      [0, 2, [1, 0, 2, 3]], [0, 3, [2, 3, 0, 1]],
      [1, 2, [0, 1, 2, 3]], [1, 3, [0, 1, 3, 2]]
    ]
    data.forEach(([qb0, qb1, result_seg]) =&gt; {
      const mapper = new LinearMapper(4, true)
      const segments = [[0, 1], [2, 3]]
      const active_qubits = new Set([0, 1, 2, 3, 4])
      const neighbour_ids = {
        0: new Set([1]), 1: new Set([0]), 2: new Set([3]), 3: new Set([2])
      }
      LinearMapper._processTwoQubitGate(mapper.num_qubits,
        mapper.cyclic,
        qb0,
        qb1,
        active_qubits,
        segments,
        neighbour_ids)
      const r = deepEqual(segments, [result_seg]) || deepEqual(segments, [result_seg.reverse()])
      expect(r).to.equal(true)
      expect(neighbour_ids[qb0].has(qb1)).to.equal(true)
      expect(neighbour_ids[qb1].has(qb0)).to.equal(true)
      const last = result_seg[result_seg.length - 1]
      expect(neighbour_ids[last].has(result_seg[0])).to.equal(true)
      expect(neighbour_ids[result_seg[0]].has(last)).to.equal(true)
    })
  });

  it(&apos;should test_process_two_qubit_gate_combine_segments_cycle2&apos;, () =&gt; {
    const data = [
      [0, 2, [1, 0, 2, 3]], [0, 3, [2, 3, 0, 1]],
      [1, 2, [0, 1, 2, 3]],
      [1, 3, [0, 1, 3, 2]]
    ]
    data.forEach(([qb0, qb1, result_seg]) =&gt; {
      // // Not long enough segment for cyclic
      const mapper = new LinearMapper(5, true)
      const segments = [[0, 1], [2, 3]]
      const active_qubits = new Set([0, 1, 2, 3, 4])
      const neighbour_ids = {
        0: new Set([1]), 1: new Set([0]), 2: new Set([3]), 3: new Set([2])
      }
      LinearMapper._processTwoQubitGate(mapper.num_qubits,
        mapper.cyclic,
        qb0,
        qb1,
        active_qubits,
        segments,
        neighbour_ids)
      const r = deepEqual(segments, [result_seg]) || deepEqual(segments, [result_seg.reverse()])
      expect(r).to.equal(true)
      expect(neighbour_ids[qb0].has(qb1)).to.equal(true)
      expect(neighbour_ids[qb1].has(qb0)).to.equal(true)
      const last = result_seg[result_seg.length - 1]
      expect(neighbour_ids[last].has(result_seg[0])).to.equal(false)
      expect(neighbour_ids[result_seg[0]].has(last)).to.equal(false)
    })
  });

  it(&apos;should test_return_new_mapping_from_segments&apos;, () =&gt; {
    const data = [
      [[[0, 2, 4]], [0, 1, 2, 3, 4], [0, 2, 4, 3, 1], [0, 1, 2, 3, 4]],
      [[[0, 2, 4]], [0, 1, 2, 3, 4], [0, 2, 4, 3, null], [0, 2, 3, 4]],
      [[[1, 2], [3, 0]], [0, 1, 2, 3, 4], [null, 1, 2, 3, 0], [0, 1, 2, 3]],
      [[[1, 2], [3, 0]], [0, 1, 2, 3, 4], [1, 2, 3, 0, 4], [0, 1, 2, 3, 4]]
    ]
    data.forEach(([segments, current_chain, correct_chain, allocated_qubits]) =&gt; {
      const mapper = new LinearMapper(5, false)
      const currentMapping = {}
      current_chain.forEach((logical_id, pos) =&gt; currentMapping[logical_id] = pos)
      mapper.currentMapping = currentMapping
      const new_mapping = LinearMapper._returnNewMappingFromSegments(
        mapper.num_qubits,
        segments,
        allocated_qubits,
        mapper.currentMapping
      )
      const correct_mapping = {}
      correct_chain.forEach((logical_id, pos) =&gt; {
        if (logical_id !== null) {
          correct_mapping[logical_id] = pos
        }
      })
      expect(correct_mapping).to.deep.equal(new_mapping)
    })
  });
  it(&apos;should test_odd_even_transposition_sort_swaps&apos;, () =&gt; {
    const data = [
      [[0, 1, 2, 3, 4], [4, 3, 2, 1, 0]],
      [[2, 0, 14, 44, 12], [14, 12, 44, 0, 2]],
      [[2, null, 14, 44, 12], [14, 1, 44, 0, 2]],
      [[2, null, 14, 44, 12], [14, null, 44, 0, 2]]
    ]
    data.forEach(([old_chain, new_chain]) =&gt; {
      const mapper = new LinearMapper(5, false)
      const old_map = {}
      const new_map = {}
      old_chain.forEach((logical_id, pos) =&gt; {
        if (logical_id !== null) {
          old_map[logical_id] = pos
        }
      })

      new_chain.forEach((logical_id, pos) =&gt; {
        if (logical_id !== null) {
          new_map[logical_id] = pos
        }
      })
      const swaps = mapper._oddEvenTranspositionSortSwaps(old_map, new_map)
      const sorted_chain = old_chain.slice(0)
      // Remove all ids which are not in new_chain by null
      sorted_chain.forEach((item, i) =&gt; {
        if (!new_chain.includes(item)) {
          sorted_chain[i] = null
        }
      })
      swaps.forEach(([i, j]) =&gt; {
        const tmp = sorted_chain[i]
        sorted_chain[i] = sorted_chain[j]
        sorted_chain[j] = tmp
      })

      expect(len(sorted_chain)).to.equal(len(new_chain))
      sorted_chain.forEach((item, i) =&gt; {
        if (item !== null) {
          expect(sorted_chain[i]).to.equal(new_chain[i])
        }
      })
    })
  });
  it(&apos;should test_send_possible_commands_allocate&apos;, () =&gt; {
    const mapper = new LinearMapper(4, false)
    const backend = new DummyEngine(true)
    backend.isLastEngine = true
    mapper.next = backend
    const qb0 = new BasicQubit(null, 0)
    const cmd0 = new Command(null, Allocate, tuple([qb0]), [], [])
    mapper._stored_commands = [cmd0]
    mapper._currently_allocated_ids = new Set([10])
    // not in mapping:
    mapper.currentMapping = {}
    expect(len(backend.receivedCommands)).to.equal(0)
    mapper._sendPossibleCommands()
    expect(len(backend.receivedCommands)).to.equal(0)
    expect(mapper._stored_commands).to.deep.equal([cmd0])
    // in mapping:
    mapper.currentMapping = {0: 3}
    mapper._sendPossibleCommands()
    expect(len(mapper._stored_commands)).to.equal(0)
    expect(len(backend.receivedCommands)).to.equal(1)
    expect(backend.receivedCommands[0].gate.equal(Allocate)).to.equal(true)
    expect(backend.receivedCommands[0].qubits[0][0].id).to.equal(3)
    expect(backend.receivedCommands[0].tags).to.deep.equal([new LogicalQubitIDTag(0)])
    expect(mapper._currently_allocated_ids).to.deep.equal(new Set([10, 0]))
  });
  it(&apos;should test_send_possible_commands_deallocate&apos;, () =&gt; {
    const mapper = new LinearMapper(4, false)
    const backend = new DummyEngine(true)
    backend.isLastEngine = true
    mapper.next = backend
    const qb0 = new BasicQubit(null, 0)
    const cmd0 = new Command(null, Deallocate, tuple([qb0]), [], [])
    mapper._stored_commands = [cmd0]
    mapper.currentMapping = {}
    mapper._currently_allocated_ids = new Set([10])
    // not yet allocated:
    mapper._sendPossibleCommands()
    expect(len(backend.receivedCommands)).to.equal(0)
    expect(mapper._stored_commands).to.deep.equal([cmd0])
    // allocated:
    mapper.currentMapping = {0: 3}
    mapper._currently_allocated_ids.add(0)
    mapper._sendPossibleCommands()
    expect(len(backend.receivedCommands)).to.equal(1)
    expect(backend.receivedCommands[0].gate.equal(Deallocate)).to.equal(true)
    expect(backend.receivedCommands[0].qubits[0][0].id).to.equal(3)
    expect(backend.receivedCommands[0].tags).to.deep.equal([new LogicalQubitIDTag(0)])
    expect(len(mapper._stored_commands)).to.equal(0)
    expect(mapper.currentMapping).to.deep.equal({})
    expect(mapper._currently_allocated_ids).to.deep.equal(new Set([10]))
  });

  it(&apos;should test_send_possible_commands_keep_remaining_gates&apos;, () =&gt; {
    const mapper = new LinearMapper(4, false)
    const backend = new DummyEngine(true)
    backend.isLastEngine = true
    mapper.next = backend
    const qb0 = new BasicQubit(null, 0)
    const qb1 = new BasicQubit(null, 1)
    const cmd0 = new Command(null, Allocate, tuple([qb0]), [], [])
    const cmd1 = new Command(null, Deallocate, tuple([qb0]), [], [])
    const cmd2 = new Command(null, Allocate, tuple([qb1]), [], [])

    mapper._stored_commands = [cmd0, cmd1, cmd2]
    mapper.currentMapping = {0: 0}
    mapper._sendPossibleCommands()
    expect(mapper._stored_commands).to.deep.equal([cmd2])
  });

  it(&apos;should test_send_possible_commands_not_cyclic&apos;, () =&gt; {
    const mapper = new LinearMapper(4, false)
    const backend = new DummyEngine(true)
    backend.isLastEngine = true
    mapper.next = backend
    const qb0 = new BasicQubit(null, 0)
    const qb1 = new BasicQubit(null, 1)
    const qb2 = new BasicQubit(null, 2)
    const qb3 = new BasicQubit(null, 3)
    mapper._currently_allocated_ids = new Set([0, 1, 2, 3])
    const cmd0 = new Command(null, CNOT, tuple([qb0]), [qb2])
    const cmd1 = new Command(null, CNOT, tuple([qb1]), [qb2])
    const cmd2 = new Command(null, CNOT, tuple([qb1]), [qb3])
    const cmd3 = new Command(null, X, tuple([qb0]), [])
    mapper._stored_commands = [cmd0, cmd1, cmd2, cmd3]
    // Following chain 0 &lt;-&gt; 2 &lt;-&gt; 3 &lt;-&gt; 1
    mapper.currentMapping = {
      0: 0, 2: 1, 3: 2, 1: 3
    }
    mapper._sendPossibleCommands()
    expect(len(backend.receivedCommands)).to.equal(2)
    expect(backend.receivedCommands[0]).to.deep.equal(new Command(null, CNOT, tuple([qb0]), [qb1]))
    expect(backend.receivedCommands[1]).to.deep.equal(new Command(null, X, tuple([qb0])))
    // Following chain 0 &lt;-&gt; 2 &lt;-&gt; 1 &lt;-&gt; 3
    mapper.currentMapping = {
      0: 0, 2: 1, 3: 3, 1: 2
    }
    mapper._sendPossibleCommands()
    expect(len(backend.receivedCommands)).to.equal(4)
    expect(len(mapper._stored_commands)).to.equal(0)
  });

  it(&apos;should test_send_possible_commands_cyclic&apos;, () =&gt; {
    const mapper = new LinearMapper(4, true)
    const backend = new DummyEngine(true)
    backend.isLastEngine = true
    mapper.next = backend
    const qb0 = new BasicQubit(null, 0)
    const qb1 = new BasicQubit(null, 1)
    const qb2 = new BasicQubit(null, 2)
    const qb3 = new BasicQubit(null, 3)
    mapper._currently_allocated_ids = new Set([0, 1, 2, 3])
    const cmd0 = new Command(null, CNOT, tuple([qb0]), [qb1])
    const cmd1 = new Command(null, CNOT, tuple([qb1]), [qb2])
    const cmd2 = new Command(null, CNOT, tuple([qb1]), [qb3])
    const cmd3 = new Command(null, X, tuple([qb0]), [])
    mapper._stored_commands = [cmd0, cmd1, cmd2, cmd3]
    // Following chain 0 &lt;-&gt; 2 &lt;-&gt; 3 &lt;-&gt; 1
    mapper.currentMapping = {
      0: 0, 2: 1, 3: 2, 1: 3
    }
    mapper._sendPossibleCommands()
    expect(len(backend.receivedCommands)).to.equal(2)
    expect(backend.receivedCommands[0]).to.deep.equal(new Command(null, CNOT, tuple([qb0]), [qb3]))
    expect(backend.receivedCommands[1]).to.deep.equal(new Command(null, X, tuple([qb0])))
    // Following chain 0 &lt;-&gt; 2 &lt;-&gt; 1 &lt;-&gt; 3
    mapper.currentMapping = {
      0: 0, 2: 1, 3: 3, 1: 2
    }
    mapper._sendPossibleCommands()
    expect(len(backend.receivedCommands)).to.equal(4)
    expect(len(mapper._stored_commands)).to.equal(0)
  });

  it(&apos;should test_run_and_receive&apos;, () =&gt; {
    const mapper = new LinearMapper(3, false)
    const backend = new DummyEngine(true)
    backend.isLastEngine = true
    mapper.next = backend
    const qb0 = new BasicQubit(null, 0)
    const qb1 = new BasicQubit(null, 1)
    const qb2 = new BasicQubit(null, 2)
    const cmd0 = new Command(null, Allocate, tuple([qb0]))
    const cmd1 = new Command(null, Allocate, tuple([qb1]))
    const cmd2 = new Command(null, Allocate, tuple([qb2]))
    const cmd3 = new Command(null, X, tuple([qb0]), [qb1])
    const cmd4 = new Command(null, X, tuple([qb1]), [qb2])
    const cmd5 = new Command(null, Deallocate, tuple([qb1]))
    mapper.receive([cmd0, cmd1, cmd2, cmd3, cmd4, cmd5])
    expect(mapper._stored_commands).to.deep.equal([cmd0, cmd1, cmd2, cmd3, cmd4, cmd5])
    const qb3 = new BasicQubit(null, -1)
    const cmd_flush = new Command(null, new FlushGate(), tuple([qb3]))
    mapper.receive([cmd_flush])
    expect(mapper._stored_commands).to.deep.equal([])
    expect(len(backend.receivedCommands)).to.equal(7)
    expect(mapper._currently_allocated_ids).to.deep.equal(new Set([0, 2]))

    const f = deepEqual(mapper.currentMapping, {0: 2, 2: 0}) || deepEqual(mapper.currentMapping, {0: 0, 2: 2})
    expect(f).to.equal(f)
    const cmd6 = new Command(null, X, tuple([qb0]), [qb2])
    mapper.storage = 1
    mapper.receive([cmd6])
    expect(mapper._currently_allocated_ids).to.deep.equal(new Set([0, 2]))
    expect(mapper._stored_commands).to.deep.equal([])
    expect(len(mapper.currentMapping)).to.equal(2)
    expect(0 in mapper.currentMapping).to.equal(true)
    expect(2 in mapper.currentMapping).to.equal(true)
    expect(len(backend.receivedCommands)).to.equal(11)

    backend.receivedCommands.forEach(cmd =&gt; console.log(cmd.toString()))

    expect(backend.receivedCommands[backend.receivedCommands.length - 1]).to.deep.equal(new Command(null, X,
      tuple([new BasicQubit(null, mapper.currentMapping[qb0.id])]),
      [new BasicQubit(null, mapper.currentMapping[qb2.id])]))
    expect(mapper.num_mappings).to.equal(1)
  });

  it(&apos;should test_run_infinite_loop_detection&apos;, () =&gt; {
    const mapper = new LinearMapper(1, false)
    const backend = new DummyEngine(true)
    backend.isLastEngine = true
    mapper.next = backend
    const qb0 = new BasicQubit(null, 0)
    const qb1 = new BasicQubit(null, 1)
    const cmd0 = new Command(null, Allocate, tuple([qb0], ))
    const cmd1 = new Command(null, Allocate, tuple([qb1], ))
    const cmd2 = new Command(null, X, tuple([qb0]), [qb1])
    const qb2 = new BasicQubit(null, -1)
    const cmd_flush = new Command(null, new FlushGate(), tuple([qb2]))

    expect(() =&gt; mapper.receive([cmd0, cmd1, cmd2, cmd_flush])).to.throw()
  });

  it(&apos;should test_logical_id_tags_allocate_and_deallocate&apos;, () =&gt; {
    const mapper = new LinearMapper(4, false)
    const backend = new DummyEngine(true)
    backend.isLastEngine = true
    mapper.next = backend
    const qb0 = new BasicQubit(null, 0)
    const qb1 = new BasicQubit(null, 1)
    const cmd0 = new Command(null, Allocate, tuple([qb0], ))
    const cmd1 = new Command(null, Allocate, tuple([qb1], ))
    const cmd2 = new Command(null, X, tuple([qb0]), [qb1])
    const cmd3 = new Command(null, Deallocate, tuple([qb0], ))
    const cmd4 = new Command(null, Deallocate, tuple([qb1], ))
    mapper.currentMapping = {0: 0, 1: 3}
    const qb_flush = new BasicQubit(null, -1)
    const cmd_flush = new Command(null, new FlushGate(), tuple([qb_flush], ))
    mapper.receive([cmd0, cmd1, cmd2, cmd_flush])
    expect(backend.receivedCommands[0].gate.equal(Allocate)).to.equal(true)
    expect(backend.receivedCommands[0].qubits[0][0].id).to.equal(0)
    expect(backend.receivedCommands[0].tags).to.deep.equal([new LogicalQubitIDTag(0)])
    expect(backend.receivedCommands[1].gate.equal(Allocate)).to.equal(true)
    expect(backend.receivedCommands[1].qubits[0][0].id).to.equal(3)
    expect(backend.receivedCommands[1].tags).to.deep.equal([new LogicalQubitIDTag(1)])

    backend.receivedCommands.slice(2).forEach((cmd) =&gt; {
      if (cmd.gate.equal(Allocate)) {
        expect(cmd.tags).to.deep.equal([])
      } else if (cmd.gate.equal(Deallocate)) {
        expect(cmd.tags).to.deep.equal([])
      }
    })

    const mapped_id_for_0 = mapper.currentMapping[0]
    const mapped_id_for_1 = mapper.currentMapping[1]
    mapper.receive([cmd3, cmd4, cmd_flush])
    const c = backend.receivedCommands.length
    expect(backend.receivedCommands[c - 3].gate.equal(Deallocate)).to.equal(true)
    expect(backend.receivedCommands[c - 3].qubits[0][0].id).to.equal(mapped_id_for_0)
    expect(backend.receivedCommands[c - 3].tags).to.deep.equal([new LogicalQubitIDTag(0)])
    expect(backend.receivedCommands[c - 2].gate.equal(Deallocate)).to.equal(true)
    expect(backend.receivedCommands[c - 2].qubits[0][0].id).to.equal(mapped_id_for_1)
    expect(backend.receivedCommands[c - 2].tags).to.deep.equal([new LogicalQubitIDTag(1)])
  });

  it(&apos;should test_send_possible_cmds_before_new_mapping&apos;, () =&gt; {
    const mapper = new LinearMapper(3, false)
    const backend = new DummyEngine(true)
    backend.isLastEngine = true
    mapper.next = backend

    const dont_call_mapping = () =&gt; {
      throw new Error(&apos;&apos;)
    }

    mapper._return_new_mapping = dont_call_mapping
    mapper.currentMapping = {0: 1}
    const qb0 = new BasicQubit(null, 0)
    const cmd0 = new Command(null, Allocate, tuple([qb0]))
    const qb2 = new BasicQubit(null, -1)
    const cmd_flush = new Command(null, new FlushGate(), tuple([qb2]))
    mapper.receive([cmd0, cmd_flush])
  });
  it(&apos;should test_correct_stats&apos;, () =&gt; {
    // Should test stats for twice same mapping but depends on heuristic
    const mapper = new LinearMapper(3, false)
    const backend = new DummyEngine(true)
    backend.isLastEngine = true
    mapper.next = backend
    const qb0 = new BasicQubit(null, 0)
    const qb1 = new BasicQubit(null, 1)
    const qb2 = new BasicQubit(null, 2)
    const cmd0 = new Command(null, Allocate, tuple([qb0]))
    const cmd1 = new Command(null, Allocate, tuple([qb1]))
    const cmd2 = new Command(null, Allocate, tuple([qb2]))
    const cmd3 = new Command(null, X, tuple([qb0]), [qb1])
    const cmd4 = new Command(null, X, tuple([qb1]), [qb2])
    const cmd5 = new Command(null, X, tuple([qb0]), [qb2])
    const cmd6 = new Command(null, X, tuple([qb2]), [qb1])
    const cmd7 = new Command(null, X, tuple([qb0]), [qb1])
    const cmd8 = new Command(null, X, tuple([qb1]), [qb2])
    const qb_flush = new BasicQubit(null, -1)
    const cmd_flush = new Command(null, new FlushGate(), tuple([qb_flush]))
    mapper.receive([cmd0, cmd1, cmd2, cmd3, cmd4, cmd5, cmd6, cmd7, cmd8, cmd_flush])
    expect(mapper.num_mappings).to.equal(2)
  });
})
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
