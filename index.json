[
  {
    "__docId__": 1,
    "kind": "external",
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Infinity",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 2,
    "kind": "external",
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~NaN",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 3,
    "kind": "external",
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~undefined",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 4,
    "kind": "external",
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~null",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 5,
    "kind": "external",
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 6,
    "kind": "external",
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 7,
    "kind": "external",
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 8,
    "kind": "external",
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 9,
    "kind": "external",
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 10,
    "kind": "external",
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 11,
    "kind": "external",
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Symbol",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 12,
    "kind": "external",
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Error",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 13,
    "kind": "external",
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~EvalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 14,
    "kind": "external",
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~InternalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 15,
    "kind": "external",
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RangeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 16,
    "kind": "external",
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ReferenceError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 17,
    "kind": "external",
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~SyntaxError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 18,
    "kind": "external",
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~TypeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 19,
    "kind": "external",
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~URIError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 20,
    "kind": "external",
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 21,
    "kind": "external",
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 22,
    "kind": "external",
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Date",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 23,
    "kind": "external",
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~String",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 24,
    "kind": "external",
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~string",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 25,
    "kind": "external",
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RegExp",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 26,
    "kind": "external",
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 27,
    "kind": "external",
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 28,
    "kind": "external",
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 29,
    "kind": "external",
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8ClampedArray",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 30,
    "kind": "external",
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 31,
    "kind": "external",
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 32,
    "kind": "external",
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 33,
    "kind": "external",
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 34,
    "kind": "external",
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 35,
    "kind": "external",
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float64Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 36,
    "kind": "external",
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Map",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 37,
    "kind": "external",
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Set",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 38,
    "kind": "external",
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakMap",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 39,
    "kind": "external",
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakSet",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 40,
    "kind": "external",
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ArrayBuffer",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 41,
    "kind": "external",
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~DataView",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 42,
    "kind": "external",
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~JSON",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 43,
    "kind": "external",
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Promise",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 44,
    "kind": "external",
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Generator",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 45,
    "kind": "external",
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~GeneratorFunction",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 46,
    "kind": "external",
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Reflect",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 47,
    "kind": "external",
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Proxy",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 48,
    "kind": "file",
    "name": "src/backends/circuits/drawer.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport assert from 'assert'\r\nimport {LastEngineError} from '../../meta/error'\r\nimport {arrayEqual, len} from '../../libs/polyfill'\r\n\r\nimport {\r\n  Allocate, Deallocate, FlushGate, Measure\r\n} from '../../ops';\r\nimport {BasicEngine} from '../../cengines'\r\nimport ToLatex from './tolatex'\r\n\r\n/**\r\n * @class CircuitItem\r\n */\r\nexport class CircuitItem {\r\n  /**\r\n   * @constructor\r\n    @param {BasicGate} gate\r\n    @param {number[]} lines Circuit lines the gate acts on.\r\n    @param {number[]} ctrl_lines Circuit lines which control the gate.\r\n  */\r\n  constructor(gate, lines, ctrl_lines) {\r\n    this.gate = gate\r\n    this.lines = lines\r\n    this.ctrl_lines = ctrl_lines\r\n    this.id = -1\r\n  }\r\n\r\n  /**\r\n   * @return {CircuitItem}\r\n   */\r\n  copy() {\r\n    const l = Array.isArray(this.lines) ? this.lines.slice(0) : this.lines\r\n    const cl = Array.isArray(this.ctrl_lines) ? this.ctrl_lines.slice(0) : this.ctrl_lines\r\n    const inst = new CircuitItem(this.gate, l, cl)\r\n    inst.id = this.id\r\n    return inst\r\n  }\r\n\r\n  /**\r\n   * @param {(CircuitItem|Object)} other\r\n   * @return {boolean}\r\n   */\r\n  equal(other) {\r\n    if (other instanceof CircuitItem) {\r\n      let f = false\r\n      if (this.gate.equal) {\r\n        f = this.gate.equal(other.gate)\r\n      } else {\r\n        f = this.gate === other.gate\r\n      }\r\n      return f && arrayEqual(this.lines, other.lines)\r\n          && arrayEqual(this.ctrl_lines, other.ctrl_lines) && this.id === other.id\r\n    }\r\n    return false\r\n  }\r\n}\r\n\r\n/**\r\n * @class CircuitDrawer\r\n * @desc\r\nCircuitDrawer is a compiler engine which generates TikZ code for drawing\r\n  quantum circuits.\r\n\r\n    The circuit can be modified by editing the settings.json file which is\r\ngenerated upon first execution. This includes adjusting the gate width,\r\n    height, shadowing, line thickness, and many more options.\r\n\r\n    After initializing the CircuitDrawer, it can also be given the mapping\r\nfrom qubit IDs to wire location (via the :meth:`set_qubit_locations`\r\nfunction):\r\n\r\n  @example\r\n\r\nconst circuit_backend = new CircuitDrawer()\r\ncircuit_backend.setQubitLocations({0: 1, 1: 0}) // swap lines 0 and 1\r\nconst eng = new MainEngine(circuit_backend)\r\n\r\n... // run quantum algorithm on this main engine\r\n\r\nconsole.log(circuit_backend.getLatex()) // prints LaTeX code\r\n\r\nTo see the qubit IDs in the generated circuit, simply set the `draw_id`\r\noption in the settings.json file under \"gates\":\"AllocateQubitGate\" to\r\ntrue:\r\n\r\n @example\r\n\r\n\"gates\": {\r\n  \"AllocateQubitGate\": {\r\n    \"draw_id\": true,\r\n        \"height\": 0.15,\r\n        \"width\": 0.2,\r\n        \"pre_offset\": 0.1,\r\n        \"offset\": 0.1\r\n  },\r\n...\r\n\r\n  The settings.json file has the following structure:\r\n\r\n      @example\r\n\r\n  {\r\n    \"control\": { // settings for control \"circle\"\r\n    \"shadow\": false,\r\n        \"size\": 0.1\r\n  },\r\n    \"gate_shadow\": true, // enable/disable shadows for all gates\r\n    \"gates\": {\r\n    \"GateClassString\": {\r\n      GATE_PROPERTIES\r\n    }\r\n    \"GateClassString2\": {\r\n    ...\r\n    },\r\n    \"lines\": { // settings for qubit lines\r\n      \"double_classical\": true, // draw double-lines for classical bits\r\n      \"double_lines_sep\": 0.04, // gap between the two lines for double lines\r\n      \"init_quantum\": true, // start out with quantum bits\r\n      \"style\": \"very thin\" // line style\r\n    }\r\n  }\r\n\r\n    All gates (except for the ones requiring special treatment) support the\r\n    following properties:\r\n\r\n    @example\r\n\r\n    \"GateClassString\": {\r\n    \"height\": GATE_HEIGHT,\r\n        \"width\": GATE_WIDTH\r\n    \"pre_offset\": OFFSET_BEFORE_PLACEMENT,\r\n        \"offset\": OFFSET_AFTER_PLACEMENT,\r\n  },\r\n */\r\nexport class CircuitDrawer extends BasicEngine {\r\n  /**\r\n   * @constructor\r\n  Initialize a circuit drawing engine.\r\n\r\n      The TikZ code generator uses a settings file (settings.json), which\r\n    can be altered by the user. It contains gate widths, heights, offsets,\r\n      etc.\r\n\r\n    @param {boolean} accept_input If accept_input is true, the printer queries\r\n    the user to input measurement results if the CircuitDrawer is\r\n    the last engine. Otherwise, all measurements yield the result\r\n    default_measure (0 or 1).\r\n    @param {number} default_measure Default value to use as measurement\r\n    results if accept_input is false and there is no underlying\r\n    backend to register real measurement results.\r\n   */\r\n  constructor(accept_input = false, default_measure = 0) {\r\n    super()\r\n    this._accept_input = accept_input\r\n    this._default_measure = default_measure\r\n    this._qubit_lines = {}\r\n    this._free_lines = []\r\n    this._map = {}\r\n  }\r\n\r\n  /**\r\n  Specialized implementation of isAvailable: Returns true if the\r\n    CircuitDrawer is the last engine (since it can print any command).\r\n\r\n    @param {Command} cmd Command for which to check availability (all Commands can be printed).\r\n    @return {boolean} true, unless the next engine cannot handle the Command (if there is a next engine).\r\n   */\r\n  isAvailable(cmd) {\r\n    try {\r\n      return super.isAvailable(cmd)\r\n    } catch (e) {\r\n      if (e instanceof LastEngineError) {\r\n        return true\r\n      }\r\n    }\r\n    return false\r\n  }\r\n\r\n  /**\r\n  Sets the qubit lines to use for the qubits explicitly.\r\n\r\n      To figure out the qubit IDs, simply use the setting `draw_id` in the\r\n    settings file. It is located in \"gates\":\"AllocateQubitGate\".\r\n      If draw_id is true, the qubit IDs are drawn in red.\r\n\r\n      @param {Object} idToLoc Dictionary mapping qubit ids to qubit line numbers.\r\n\r\n      @throws {Error} If the mapping has already begun (this function\r\n  needs be called before any gates have been received).\r\n   */\r\n  setQubitLocations(idToLoc) {\r\n    if (len(this._map) > 0) {\r\n      throw new Error('set_qubit_locations() has to be called before applying gates!')\r\n    }\r\n\r\n    const min = Math.min(...Object.keys(idToLoc))\r\n    const max = Math.max(...Object.keys(idToLoc)) + 1\r\n    for (let k = min; k < max; ++k) {\r\n      if (!(k in idToLoc)) {\r\n        throw new Error('set_qubit_locations(): Invalid id_to_loc '\r\n        + 'mapping provided. All ids in the provided'\r\n        + ' range of qubit ids have to be mapped '\r\n        + 'somewhere.')\r\n      }\r\n    }\r\n    this._map = idToLoc\r\n  }\r\n\r\n  /**\r\n  Add the command cmd to the circuit diagram, taking care of potential\r\n    measurements as specified in the __init__ function.\r\n\r\n    Queries the user for measurement input if a measurement command\r\n    arrives if accept_input was set to true. Otherwise, it uses the\r\n    default_measure parameter to register the measurement outcome.\r\n\r\n      @param {Command} cmd Command to add to the circuit diagram.\r\n   */\r\n  printCMD(cmd) {\r\n    if (cmd.gate.equal(Allocate)) {\r\n      const qubit_id = cmd.qubits[0][0].id\r\n      if (!(qubit_id in this._map)) {\r\n        this._map[qubit_id] = qubit_id\r\n      }\r\n      this._qubit_lines[qubit_id] = []\r\n    }\r\n    if (cmd.gate.equal(Deallocate)) {\r\n      const qubit_id = cmd.qubits[0][0].id\r\n      this._free_lines.push(qubit_id)\r\n    }\r\n    if (this.isLastEngine && cmd.gate === Measure) {\r\n      assert(cmd.controlCount === 0)\r\n\r\n      cmd.qubits.forEach(qureg => qureg.forEach((qubit) => {\r\n        let m\r\n        if (this._accept_input) {\r\n          // TODO\r\n        } else {\r\n          m = this._default_measure\r\n        }\r\n        this.main.setMeasurementResult(qubit, m)\r\n      }))\r\n    }\r\n\r\n    const all_lines = []\r\n    cmd.allQubits.forEach(qr => qr.forEach(qb => all_lines.push(qb.id)))\r\n\r\n    const gate = cmd.gate\r\n    const lines = []\r\n    cmd.qubits.forEach(qr => qr.forEach(qb => lines.push(qb.id)))\r\n    const ctrl_lines = cmd.controlQubits.map(qb => qb.id)\r\n    const item = new CircuitItem(gate, lines, ctrl_lines)\r\n\r\n    all_lines.forEach(l => this._qubit_lines[l].push(item))\r\n  }\r\n\r\n  /**\r\n  Return the latex document string representing the circuit.\r\n\r\n      Simply write this string into a tex-file or, alternatively, pipe the\r\n    output directly to, e.g., pdflatex:\r\n\r\n   @example\r\n\r\n    node my_circuit.js | pdflatex\r\n\r\n    where my_circuit.js calls this function and prints it to the terminal.\r\n   @return {string}\r\n   */\r\n  getLatex() {\r\n    const qubit_lines = {}\r\n\r\n    const linesCount = len(this._qubit_lines)\r\n    for (let line = 0; line < linesCount; ++line) {\r\n      const new_line = this._map[line]\r\n      qubit_lines[new_line] = []\r\n\r\n      this._qubit_lines[line].forEach((cmd) => {\r\n        const lines = cmd.lines.map(qb_id => this._map[qb_id])\r\n        const ctrl_lines = cmd.ctrl_lines.map(qb_id => this._map[qb_id])\r\n        const {gate} = cmd\r\n        const new_cmd = new CircuitItem(gate, lines, ctrl_lines)\r\n        if (gate.equal(Allocate)) {\r\n          new_cmd.id = cmd.lines[0]\r\n        }\r\n        qubit_lines[new_line].push(new_cmd)\r\n      })\r\n    }\r\n\r\n\r\n    const circuit = []\r\n    Object.keys(qubit_lines).forEach(lines => circuit.push(qubit_lines[lines]))\r\n    return ToLatex.toLatex(qubit_lines)\r\n  }\r\n\r\n  /**\r\n  Receive a list of commands from the previous engine, print the\r\n    commands, and then send them on to the next engine.\r\n\r\n    @param {Command[]} commandList List of Commands to print (and potentially send on to the next engine).\r\n  */\r\n  receive(commandList) {\r\n    commandList.forEach((cmd) => {\r\n      if (!(cmd.gate instanceof FlushGate)) {\r\n        this.printCMD(cmd)\r\n      }\r\n      if (!this.isLastEngine) {\r\n        this.send([cmd])\r\n      }\r\n    })\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/backends/circuits/drawer.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 49,
    "kind": "class",
    "name": "CircuitItem",
    "memberof": "src/backends/circuits/drawer.js",
    "static": true,
    "longname": "src/backends/circuits/drawer.js~CircuitItem",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/backends/circuits/drawer.js",
    "importStyle": "{CircuitItem}",
    "description": "",
    "lineNumber": 30,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "CircuitItem"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 50,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/backends/circuits/drawer.js~CircuitItem",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/circuits/drawer.js~CircuitItem#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 37,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "BasicGate"
        ],
        "spread": false,
        "optional": false,
        "name": "gate",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "lines",
        "description": "Circuit lines the gate acts on."
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "ctrl_lines",
        "description": "Circuit lines which control the gate."
      }
    ]
  },
  {
    "__docId__": 51,
    "kind": "member",
    "name": "gate",
    "memberof": "src/backends/circuits/drawer.js~CircuitItem",
    "static": false,
    "longname": "src/backends/circuits/drawer.js~CircuitItem#gate",
    "access": "public",
    "description": null,
    "lineNumber": 38,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 52,
    "kind": "member",
    "name": "lines",
    "memberof": "src/backends/circuits/drawer.js~CircuitItem",
    "static": false,
    "longname": "src/backends/circuits/drawer.js~CircuitItem#lines",
    "access": "public",
    "description": null,
    "lineNumber": 39,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 53,
    "kind": "member",
    "name": "ctrl_lines",
    "memberof": "src/backends/circuits/drawer.js~CircuitItem",
    "static": false,
    "longname": "src/backends/circuits/drawer.js~CircuitItem#ctrl_lines",
    "access": "public",
    "description": null,
    "lineNumber": 40,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 54,
    "kind": "member",
    "name": "id",
    "memberof": "src/backends/circuits/drawer.js~CircuitItem",
    "static": false,
    "longname": "src/backends/circuits/drawer.js~CircuitItem#id",
    "access": "public",
    "description": null,
    "lineNumber": 41,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 55,
    "kind": "method",
    "name": "copy",
    "memberof": "src/backends/circuits/drawer.js~CircuitItem",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/circuits/drawer.js~CircuitItem#copy",
    "access": "public",
    "description": "",
    "lineNumber": 47,
    "return": {
      "nullable": null,
      "types": [
        "CircuitItem"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 56,
    "kind": "method",
    "name": "equal",
    "memberof": "src/backends/circuits/drawer.js~CircuitItem",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/circuits/drawer.js~CircuitItem#equal",
    "access": "public",
    "description": "",
    "lineNumber": 59,
    "params": [
      {
        "nullable": null,
        "types": [
          "CircuitItem",
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 57,
    "kind": "class",
    "name": "CircuitDrawer",
    "memberof": "src/backends/circuits/drawer.js",
    "static": true,
    "longname": "src/backends/circuits/drawer.js~CircuitDrawer",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/backends/circuits/drawer.js",
    "importStyle": "{CircuitDrawer}",
    "description": "CircuitDrawer is a compiler engine which generates TikZ code for drawing\nquantum circuits.\n\nThe circuit can be modified by editing the settings.json file which is\ngenerated upon first execution. This includes adjusting the gate width,\nheight, shadowing, line thickness, and many more options.\n\nAfter initializing the CircuitDrawer, it can also be given the mapping\nfrom qubit IDs to wire location (via the :meth:`set_qubit_locations`\nfunction):",
    "examples": [
      "\nconst circuit_backend = new CircuitDrawer()\ncircuit_backend.setQubitLocations({0: 1, 1: 0}) // swap lines 0 and 1\nconst eng = new MainEngine(circuit_backend)\n\n... // run quantum algorithm on this main engine\n\nconsole.log(circuit_backend.getLatex()) // prints LaTeX code\n\nTo see the qubit IDs in the generated circuit, simply set the `draw_id`\noption in the settings.json file under \"gates\":\"AllocateQubitGate\" to\ntrue:",
      "\n\"gates\": {\n\"AllocateQubitGate\": {\n\"draw_id\": true,\n\"height\": 0.15,\n\"width\": 0.2,\n\"pre_offset\": 0.1,\n\"offset\": 0.1\n},\n...\n\nThe settings.json file has the following structure:",
      "\n{\n\"control\": { // settings for control \"circle\"\n\"shadow\": false,\n\"size\": 0.1\n},\n\"gate_shadow\": true, // enable/disable shadows for all gates\n\"gates\": {\n\"GateClassString\": {\nGATE_PROPERTIES\n}\n\"GateClassString2\": {\n...\n},\n\"lines\": { // settings for qubit lines\n\"double_classical\": true, // draw double-lines for classical bits\n\"double_lines_sep\": 0.04, // gap between the two lines for double lines\n\"init_quantum\": true, // start out with quantum bits\n\"style\": \"very thin\" // line style\n}\n}\n\nAll gates (except for the ones requiring special treatment) support the\nfollowing properties:",
      "\n\"GateClassString\": {\n\"height\": GATE_HEIGHT,\n\"width\": GATE_WIDTH\n\"pre_offset\": OFFSET_BEFORE_PLACEMENT,\n\"offset\": OFFSET_AFTER_PLACEMENT,\n},"
    ],
    "lineNumber": 151,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "CircuitDrawer"
      }
    ],
    "interface": false,
    "extends": [
      "src/cengines.js~BasicEngine"
    ]
  },
  {
    "__docId__": 58,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/backends/circuits/drawer.js~CircuitDrawer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/circuits/drawer.js~CircuitDrawer#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 168,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": "Initialize a circuit drawing engine.\n\nThe TikZ code generator uses a settings file (settings.json), which\ncan be altered by the user. It contains gate widths, heights, offsets,\netc."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "accept_input",
        "description": "If accept_input is true, the printer queries\nthe user to input measurement results if the CircuitDrawer is\nthe last engine. Otherwise, all measurements yield the result\ndefault_measure (0 or 1)."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "default_measure",
        "description": "Default value to use as measurement\nresults if accept_input is false and there is no underlying\nbackend to register real measurement results."
      }
    ]
  },
  {
    "__docId__": 59,
    "kind": "member",
    "name": "_accept_input",
    "memberof": "src/backends/circuits/drawer.js~CircuitDrawer",
    "static": false,
    "longname": "src/backends/circuits/drawer.js~CircuitDrawer#_accept_input",
    "access": "private",
    "description": null,
    "lineNumber": 170,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 60,
    "kind": "member",
    "name": "_default_measure",
    "memberof": "src/backends/circuits/drawer.js~CircuitDrawer",
    "static": false,
    "longname": "src/backends/circuits/drawer.js~CircuitDrawer#_default_measure",
    "access": "private",
    "description": null,
    "lineNumber": 171,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 61,
    "kind": "member",
    "name": "_qubit_lines",
    "memberof": "src/backends/circuits/drawer.js~CircuitDrawer",
    "static": false,
    "longname": "src/backends/circuits/drawer.js~CircuitDrawer#_qubit_lines",
    "access": "private",
    "description": null,
    "lineNumber": 172,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 62,
    "kind": "member",
    "name": "_free_lines",
    "memberof": "src/backends/circuits/drawer.js~CircuitDrawer",
    "static": false,
    "longname": "src/backends/circuits/drawer.js~CircuitDrawer#_free_lines",
    "access": "private",
    "description": null,
    "lineNumber": 173,
    "undocument": true,
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 63,
    "kind": "member",
    "name": "_map",
    "memberof": "src/backends/circuits/drawer.js~CircuitDrawer",
    "static": false,
    "longname": "src/backends/circuits/drawer.js~CircuitDrawer#_map",
    "access": "private",
    "description": null,
    "lineNumber": 174,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 64,
    "kind": "method",
    "name": "isAvailable",
    "memberof": "src/backends/circuits/drawer.js~CircuitDrawer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/circuits/drawer.js~CircuitDrawer#isAvailable",
    "access": "public",
    "description": "Specialized implementation of isAvailable: Returns true if the\nCircuitDrawer is the last engine (since it can print any command).",
    "lineNumber": 184,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": "Command for which to check availability (all Commands can be printed)."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true, unless the next engine cannot handle the Command (if there is a next engine)."
    }
  },
  {
    "__docId__": 65,
    "kind": "method",
    "name": "setQubitLocations",
    "memberof": "src/backends/circuits/drawer.js~CircuitDrawer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/circuits/drawer.js~CircuitDrawer#setQubitLocations",
    "access": "public",
    "description": "Sets the qubit lines to use for the qubits explicitly.\n\nTo figure out the qubit IDs, simply use the setting `draw_id` in the\nsettings file. It is located in \"gates\":\"AllocateQubitGate\".\nIf draw_id is true, the qubit IDs are drawn in red.",
    "lineNumber": 207,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "idToLoc",
        "description": "Dictionary mapping qubit ids to qubit line numbers."
      }
    ],
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If the mapping has already begun (this function\nneeds be called before any gates have been received)."
      }
    ],
    "return": null
  },
  {
    "__docId__": 67,
    "kind": "method",
    "name": "printCMD",
    "memberof": "src/backends/circuits/drawer.js~CircuitDrawer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/circuits/drawer.js~CircuitDrawer#printCMD",
    "access": "public",
    "description": "Add the command cmd to the circuit diagram, taking care of potential\nmeasurements as specified in the __init__ function.\n\nQueries the user for measurement input if a measurement command\narrives if accept_input was set to true. Otherwise, it uses the\ndefault_measure parameter to register the measurement outcome.",
    "lineNumber": 235,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": "Command to add to the circuit diagram."
      }
    ],
    "return": null
  },
  {
    "__docId__": 68,
    "kind": "method",
    "name": "getLatex",
    "memberof": "src/backends/circuits/drawer.js~CircuitDrawer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/circuits/drawer.js~CircuitDrawer#getLatex",
    "access": "public",
    "description": "Return the latex document string representing the circuit.\n\nSimply write this string into a tex-file or, alternatively, pipe the\noutput directly to, e.g., pdflatex:",
    "examples": [
      "\nnode my_circuit.js | pdflatex\n\nwhere my_circuit.js calls this function and prints it to the terminal."
    ],
    "lineNumber": 286,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 69,
    "kind": "method",
    "name": "receive",
    "memberof": "src/backends/circuits/drawer.js~CircuitDrawer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/circuits/drawer.js~CircuitDrawer#receive",
    "access": "public",
    "description": "Receive a list of commands from the previous engine, print the\ncommands, and then send them on to the next engine.",
    "lineNumber": 318,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command[]"
        ],
        "spread": false,
        "optional": false,
        "name": "commandList",
        "description": "List of Commands to print (and potentially send on to the next engine)."
      }
    ],
    "return": null
  },
  {
    "__docId__": 70,
    "kind": "file",
    "name": "src/backends/circuits/tolatex.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport assert from 'assert'\r\nimport fs from 'fs'\r\nimport {Decimal} from 'decimal.js'\r\nimport {len, narray} from '../../libs/polyfill'\r\nimport {\r\n  DaggeredGate, X, Measure, Allocate, Deallocate, Z, Swap, SqrtSwap\r\n} from '../../ops'\r\nimport { getInverse } from '../../ops/_cycle'\r\n\r\n// decimalToString\r\nfunction dts(number) {\r\n  return new Decimal(number).toString()\r\n}\r\n\r\nfunction minmax(array) {\r\n  const min = Math.min(...array)\r\n  const max = Math.max(...array)\r\n  return [min, max]\r\n}\r\n\r\nfunction maxOfDecimals(decimals = []) {\r\n  let max = new Decimal(0)\r\n  decimals.forEach((d) => {\r\n    if (d.greaterThan(max)) {\r\n      max = d\r\n    }\r\n  })\r\n  return max\r\n}\r\n\r\n/**\r\n * @ignore\r\n * @type {{write_settings(Object): *, get_default_settings(): Object, _header(*): string, _body(Array<CircuitItem[]>, Object): string, _footer(): string}}\r\n * @private\r\n */\r\nexport const _exports = {\r\n  /**\r\nWrite all settings to a json-file.\r\n\r\n    @param {Object} settings: Settings dict to write.\r\n */\r\n  write_settings(settings) {\r\n    fs.writeFileSync('settings.json', JSON.stringify(settings))\r\n    return settings\r\n  },\r\n  /**\r\nReturn the default settings for the circuit drawing function to_latex().\r\n\r\n@return {Object} settings: Default circuit settings\r\n */\r\n  get_default_settings() {\r\n    const settings = {}\r\n    settings.gate_shadow = true\r\n    settings.lines = ({\r\n      'style': 'very thin',\r\n      'double_classical': true,\r\n      'init_quantum': true,\r\n      'double_lines_sep': 0.04\r\n    })\r\n    settings.gates = ({\r\n      'HGate': {\r\n        'width': 0.5,\r\n        'offset': 0.3,\r\n        'pre_offset': 0.1\r\n      },\r\n      'XGate': {\r\n        'width': 0.35,\r\n        'height': 0.35,\r\n        'offset': 0.1\r\n      },\r\n      'SqrtXGate': {\r\n        'width': 0.7,\r\n        'offset': 0.3,\r\n        'pre_offset': 0.1\r\n      },\r\n      'SwapGate': {\r\n        'width': 0.35,\r\n        'height': 0.35,\r\n        'offset': 0.1\r\n      },\r\n      'SqrtSwapGate': {\r\n        'width': 0.35,\r\n        'height': 0.35,\r\n        'offset': 0.1\r\n      },\r\n      'Rx': {\r\n        'width': 1.0,\r\n        'height': 0.8,\r\n        'pre_offset': 0.2,\r\n        'offset': 0.3\r\n      },\r\n      'Ry': {\r\n        'width': 1.0,\r\n        'height': 0.8,\r\n        'pre_offset': 0.2,\r\n        'offset': 0.3\r\n      },\r\n      'Rz': {\r\n        'width': 1.0,\r\n        'height': 0.8,\r\n        'pre_offset': 0.2,\r\n        'offset': 0.3\r\n      },\r\n      'Ph': {\r\n        'width': 1.0,\r\n        'height': 0.8,\r\n        'pre_offset': 0.2,\r\n        'offset': 0.3\r\n      },\r\n      'EntangleGate': {\r\n        'width': 1.8,\r\n        'offset': 0.2,\r\n        'pre_offset': 0.2\r\n      },\r\n      'DeallocateQubitGate': {\r\n        'height': 0.15,\r\n        'offset': 0.2,\r\n        'width': 0.2,\r\n        'pre_offset': 0.1\r\n      },\r\n      'AllocateQubitGate': {\r\n        'height': 0.15,\r\n        'width': 0.2,\r\n        'offset': 0.1,\r\n        'pre_offset': 0.1,\r\n        'draw_id': false,\r\n        'allocate_at_zero': false\r\n      },\r\n      'MeasureGate': {\r\n        'width': 0.75,\r\n        'offset': 0.2,\r\n        'height': 0.5,\r\n        'pre_offset': 0.2\r\n      }\r\n    })\r\n    settings.control = {'size': 0.1, 'shadow': false}\r\n    return settings\r\n  },\r\n  /**\r\nWrites the Latex header using the settings file.\r\n\r\n    The header includes all packages and defines all tikz styles.\r\n\r\n    @return {string} Header of the Latex document.\r\n */\r\n  _header(settings) {\r\n    const packages = ('\\\\documentclass{standalone}\\n\\\\usepackage[margin=1in]'\r\n      + '{geometry}\\n\\\\usepackage[hang,small,bf]{caption}\\n'\r\n      + '\\\\usepackage{tikz}\\n'\r\n      + '\\\\usepackage{braket}\\n\\\\usetikzlibrary{backgrounds,shadows.'\r\n      + 'blur,fit,decorations.pathreplacing,shapes}\\n\\n')\r\n\r\n\r\n    const init = ('\\\\begin{document}\\n'\r\n      + '\\\\begin{tikzpicture}[scale=0.8, transform shape]\\n\\n')\r\n\r\n    let gate_style = ('\\\\tikzstyle{basicshadow}=[blur shadow={shadow blur steps=8,'\r\n      + ' shadow xshift=0.7pt, shadow yshift=-0.7pt, shadow scale='\r\n      + '1.02}]')\r\n\r\n    if (!(settings.gate_shadow || settings.control.shadow)) {\r\n      gate_style = ''\r\n    }\r\n    gate_style += '\\\\tikzstyle{basic}=[draw,fill=white,'\r\n    if (settings.gate_shadow) {\r\n      gate_style += 'basicshadow'\r\n    }\r\n    gate_style += ']\\n'\r\n\r\n    gate_style += (`\\\\tikzstyle{operator}=[basic,minimum size=1.5em]\\n\\\\tikzstyle{phase}=[fill=black,shape=circle,minimum size=${settings.control.size}cm,inner sep=0pt,outer sep=0pt,draw=black`\r\n    )\r\n    if (settings.control.shadow) {\r\n      gate_style += ',basicshadow'\r\n    }\r\n    gate_style += (`]\\n\\\\tikzstyle{none}=[inner sep=0pt,outer sep=-.5pt,minimum height=0.5cm+1pt]\r\n\\\\tikzstyle{measure}=[operator,inner sep=0pt,minimum height=${settings.gates.MeasureGate.height}cm, minimum width=${settings.gates.MeasureGate.width}cm]\r\n\\\\tikzstyle{xstyle}=[circle,basic,minimum height=`)\r\n    const x_gate_radius = Math.min(settings.gates.XGate.height, settings.gates.XGate.width)\r\n    gate_style += (`${x_gate_radius}cm,minimum width=${x_gate_radius}cm,inner sep=-1pt,${settings.lines.style}]\\n`)\r\n    if (settings.gate_shadow) {\r\n      gate_style += ('\\\\tikzset{\\nshadowed/.style={preaction={transform '\r\n        + 'canvas={shift={(0.5pt,-0.5pt)}}, draw=gray, opacity='\r\n        + '0.4}},\\n}\\n')\r\n    }\r\n    gate_style += '\\\\tikzstyle{swapstyle}=['\r\n    gate_style += 'inner sep=-1pt, outer sep=-1pt, minimum width=0pt]\\n'\r\n    const edge_style = (`\\\\tikzstyle{edgestyle}=[${settings.lines.style\r\n    }]\\n`)\r\n\r\n    return packages + init + gate_style + edge_style\r\n  },\r\n  /**\r\nReturn the body of the Latex document, including the entire circuit in\r\nTikZ format.\r\n\r\n    @param {Array.<CircuitItem[]>} circuit Circuit to draw.\r\n    @param {Object} settings\r\n    @return {string} Latex string to draw the entire circuit.\r\n */\r\n  _body(circuit, settings) {\r\n    const code = []\r\n\r\n    const conv = new _Circ2Tikz(settings, len(circuit))\r\n    Object.keys(circuit).forEach((_, line) => code.push(conv.to_tikz(line, circuit)))\r\n\r\n    return code.join('')\r\n  },\r\n\r\n  /**\r\n  Return the footer of the Latex document.\r\n\r\n      @return {string} Latex document footer.\r\n   */\r\n  _footer() {\r\n    return '\\n\\n\\\\end{tikzpicture}\\n\\\\end{document}'\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\nTranslates a given circuit to a TikZ picture in a Latex document.\r\n\r\n    It uses a json-configuration file which (if it does not exist) is created\r\nautomatically upon running this function for the first time. The config\r\nfile can be used to determine custom gate sizes, offsets, etc.\r\n\r\n    New gate options can be added under settings['gates'], using the gate\r\nclass name string as a key. Every gate can have its own width, height, pre\r\noffset and offset.\r\n\r\n    @example\r\n settings['gates']['HGate'] = {'width': .5, 'offset': .15}\r\n\r\nThe default settings can be acquired using the get_default_settings()\r\nfunction, and written using write_settings().\r\n\r\n    @param {Array.<CircuitItem[]>} circuit Each qubit line is a list of\r\nCircuitItem objects, i.e., in circuit[line].\r\n\r\n    @return {string} Latex document string which can be compiled using, e.g., pdflatex.\r\n */\r\nfunction toLatex(circuit) {\r\n  let content\r\n  let settings\r\n  let text\r\n  if (fs.existsSync('settings.json')) {\r\n    content = fs.readFileSync('settings.json')\r\n    try {\r\n      settings = JSON.parse(content)\r\n    } catch (e) {\r\n      settings = _exports.get_default_settings()\r\n      _exports.write_settings(settings)\r\n    }\r\n  } else {\r\n    settings = _exports.get_default_settings()\r\n    _exports.write_settings(settings)\r\n  }\r\n\r\n  text = _exports._header(settings)\r\n  text += _exports._body(circuit, settings)\r\n  text += _exports._footer(settings)\r\n\r\n  return text\r\n}\r\n\r\n_exports.toLatex = toLatex\r\n\r\n/**\r\n * @class _Circ2Tikz\r\n * @desc\r\nThe Circ2Tikz class takes a circuit (list of lists of CircuitItem objects)\r\nand turns them into Latex/TikZ code.\r\n\r\n    It uses the settings dictionary for gate offsets, sizes, spacing, ...\r\n */\r\nexport class _Circ2Tikz {\r\n  /**\r\n   * @constructor\r\n  Initialize a circuit to latex converter object.\r\n\r\n    @param {Object} settings Dictionary of settings to use for the TikZ image.\r\n    @param {number} num_lines Number of qubit lines to use for the entire\r\ncircuit.\r\n   */\r\n  constructor(settings, num_lines) {\r\n    this.settings = settings\r\n    this.pos = narray(() => new Decimal(0.0), num_lines)\r\n    this.op_count = narray(0, num_lines)\r\n    this.is_quantum = narray(settings.lines.init_quantum, num_lines)\r\n  }\r\n\r\n  /**\r\n  Generate the TikZ code for one line of the circuit up to a certain\r\n  gate.\r\n\r\n  It modifies the circuit to include only the gates which have not been\r\n  drawn. It automatically switches to other lines if the gates on those\r\n  lines have to be drawn earlier.\r\n\r\n   @param {number} line Line to generate the TikZ code for.\r\n   @param {Array.<CircuitItem[]>} circuit The circuit to draw.\r\n   @param {number} end Gate index to stop at (for recursion).\r\n\r\n  @return {string} TikZ code representing the current qubit line\r\n  and, if it was necessary to draw other lines, those lines as\r\n  well.\r\n   */\r\n  to_tikz(line, circuit, end) {\r\n    if (typeof end === 'undefined') {\r\n      end = len(circuit[line])\r\n    }\r\n    const tikz_code = []\r\n\r\n    const cmds = circuit[line]\r\n    for (let i = 0; i < end; ++i) {\r\n      const {gate, lines, ctrl_lines} = cmds[i]\r\n      let all_lines = lines.concat(ctrl_lines)\r\n      const idx = all_lines.indexOf(line)\r\n      all_lines.splice(idx, 1) // remove current line\r\n      all_lines.forEach((l) => {\r\n        let gate_idx = 0\r\n        while (!circuit[l][gate_idx].equal(cmds[i])) {\r\n          gate_idx += 1\r\n        }\r\n\r\n        tikz_code.push(this.to_tikz(l, circuit, gate_idx))\r\n        // we are taking care of gate 0 (the current one)\r\n        circuit[l] = circuit[l].slice(1)\r\n      })\r\n\r\n      all_lines = lines.concat(ctrl_lines)\r\n      const tmp = []\r\n      const [min, max] = minmax(all_lines)\r\n      for (let l = min; l < max + 1; ++l) {\r\n        tmp.push(this.pos[l])\r\n      }\r\n      const pos = maxOfDecimals(tmp)\r\n      for (let l = min; l < max + 1; ++l) {\r\n        this.pos[l] = pos.add(this._gate_offset(gate))\r\n      }\r\n\r\n      let connections = ''\r\n      all_lines.forEach((l) => {\r\n        connections += this._line(this.op_count[l] - 1, this.op_count[l], l)\r\n      })\r\n\r\n      let add_str = ''\r\n      if (gate.equal(X)) {\r\n        // draw NOT-gate with controls\r\n        add_str = this._x_gate(lines, ctrl_lines)\r\n        // and make the target qubit quantum if one of the controls is\r\n        if (!this.is_quantum[lines[0]]) {\r\n          let sum = 0\r\n          ctrl_lines.forEach(iL => sum += this.is_quantum[iL])\r\n          if (sum > 0) {\r\n            this.is_quantum[lines[0]] = true\r\n          }\r\n        }\r\n      } else if (gate.equal(Z) && len(ctrl_lines) > 0) {\r\n        add_str = this._cz_gate(lines.concat(ctrl_lines))\r\n      } else if (gate.equal(Swap)) {\r\n        add_str = this._swap_gate(lines, ctrl_lines)\r\n      } else if (gate.equal(SqrtSwap)) {\r\n        add_str = this._sqrtswap_gate(lines, ctrl_lines, false)\r\n      } else if (gate.equal(getInverse(SqrtSwap))) {\r\n        add_str = this._sqrtswap_gate(lines, ctrl_lines, true)\r\n      } else if (gate.equal(Measure)) {\r\n        // draw measurement gate\r\n        lines.forEach((l) => {\r\n          const op = this._op(l)\r\n          const width = this._gate_width(Measure)\r\n          const height = this._gate_height(Measure)\r\n          const shift0 = new Decimal(height).mul(0.07)\r\n          const shift1 = new Decimal(height).mul(0.36)\r\n          const shift2 = new Decimal(width).mul(0.1)\r\n\r\n          add_str += `\\n\\\\node[measure,edgestyle] (${op}) at (${dts(this.pos[l])},-${l}) {};`\r\n          add_str += `\\n\\\\draw[edgestyle] ([yshift=-${shift1}cm,xshift=${shift2}cm]${op}.west) to [out=60,in=180] ([yshift=${shift0}cm]${op}.center) to [out=0, in=120] ([yshift=-${shift1}cm,xshift=-${shift2}cm]${op}.east);`\r\n          add_str += `\\n\\\\draw[edgestyle] ([yshift=-${shift1}cm]${op}.center) to ([yshift=-${shift2}cm,xshift=-${shift1}cm]${op}.north east);`\r\n\r\n          this.op_count[l] += 1\r\n          this.pos[l] = this.pos[l].add(this._gate_width(gate)).add(this._gate_offset(gate))\r\n          this.is_quantum[l] = false\r\n        })\r\n      } else if (gate.equal(Allocate)) {\r\n        // draw 'begin line'\r\n        let id_str = ''\r\n        if (this.settings.gates.AllocateQubitGate.draw_id) {\r\n          id_str = `^{\\\\textcolor{red}{${cmds[i].id}}}`\r\n        }\r\n        let xpos = this.pos[line]\r\n\r\n        if (this.settings.gates.AllocateQubitGate.allocate_at_zero) {\r\n          this.pos[line] = xpos.sub(this._gate_pre_offset(gate))\r\n          xpos = new Decimal(this._gate_pre_offset(gate))\r\n        }\r\n        this.pos[line] = maxOfDecimals([xpos.add(this._gate_offset(gate)).add(this._gate_width(gate)), this.pos[line]])\r\n        add_str = `\\n\\\\node[none] (${this._op(line)}) at (${dts(xpos)},-${line}) {$\\\\Ket{0}${id_str}$};`\r\n        this.op_count[line] += 1\r\n        this.is_quantum[line] = this.settings.lines.init_quantum\r\n      } else if (gate.equal(Deallocate)) {\r\n        // draw 'end of line'\r\n        const op = this._op(line)\r\n        add_str = `\\n\\\\node[none] (${op}) at (${dts(this.pos[line])},-${line}) {};`\r\n        const yshift = `${this._gate_height(gate)}cm]`\r\n        add_str += `\\n\\\\draw ([yshift=${yshift}${op}.center) edge [edgestyle] ([yshift=-${yshift}${op}.center);`\r\n\r\n        this.op_count[line] += 1\r\n        this.pos[line] = this.pos[line].add(this._gate_width(gate)).add(this._gate_offset(gate))\r\n      } else {\r\n        // regular gate must draw the lines it does not act upon\r\n        // if it spans multiple qubits\r\n        add_str = this._regular_gate(gate, lines, ctrl_lines)\r\n        lines.forEach(l => this.is_quantum[l] = true)\r\n      }\r\n      tikz_code.push(add_str)\r\n      if (!gate.equal(Allocate)) {\r\n        tikz_code.push(connections)\r\n      }\r\n    }\r\n\r\n    circuit[line] = circuit[line].slice(end)\r\n    return tikz_code.join('')\r\n  }\r\n\r\n  /**\r\n    Return the string representation of the gate.\r\n    Tries to use gate.tex_str and, if that is not available, uses str(gate) instead.\r\n\r\n    @param {BasicGate} gate Gate object of which to get the name / latex representation.\r\n    @return {string} Latex gate name.\r\n  */\r\n  _gate_name(gate) {\r\n    let name\r\n    if (gate.texString) {\r\n      name = gate.texString()\r\n    }\r\n    name = gate.toString()\r\n    return name\r\n  }\r\n\r\n  /**\r\n  Return the TikZ code for a Square-root Swap-gate.\r\n\r\n    @param {number[]} lines List of length 2 denoting the target qubit of the Swap gate.\r\n    @param {number[]} ctrl_lines List of qubit lines which act as controls.\r\n    @param {boolean} daggered Show the daggered one if true.\r\n   */\r\n  _sqrtswap_gate(lines, ctrl_lines, daggered) {\r\n    assert(len(lines) === 2) // sqrt swap gate acts on 2 qubits\r\n    const delta_pos = this._gate_offset(SqrtSwap)\r\n    const gate_width = this._gate_width(SqrtSwap)\r\n    lines.sort()\r\n\r\n    let gate_str = ''\r\n    lines.forEach((line) => {\r\n      const op = this._op(line)\r\n      const w = `${new Decimal(gate_width).mul(0.5).toString()}cm`\r\n      const s1 = `[xshift=-${w},yshift=-${w}]${op}.center`\r\n      const s2 = `[xshift=${w},yshift=${w}]${op}.center`\r\n      const s3 = `[xshift=-${w},yshift=${w}]${op}.center`\r\n      const s4 = `[xshift=${w},yshift=-${w}]${op}.center`\r\n      let swap_style = 'swapstyle,edgestyle'\r\n      if (this.settings.gate_shadow) {\r\n        swap_style += ',shadowed'\r\n      }\r\n      gate_str += `\\n\\\\node[swapstyle] (${op}) at (${dts(this.pos[line])},-${line}) {};`\r\n      gate_str += `\\n\\\\draw[${swap_style}] (${s1})--(${s2});`\r\n      gate_str += `\\n\\\\draw[${swap_style}] (${s3})--(${s4});`\r\n    })\r\n\r\n    // add a circled 1/2\r\n    const midpoint = (lines[0] + lines[1]) / 2.0\r\n    const pos = this.pos[lines[0]]\r\n    const op_mid = `line${lines[0]}-${lines[1]}_gate${this.op_count[lines[0]]}`\r\n    gate_str += `\\n\\\\node[xstyle] (${op_mid}) at (${dts(pos)},-${midpoint})\\\r\n                {\\\\scriptsize $\\\\frac{1}{2}${daggered ? '^{{\\\\dagger}}' : ''}$};`\r\n\r\n    // add two vertical lines to connect circled 1/2\r\n    gate_str += `\\n\\\\draw (${this._op(lines[0])}) edge[edgestyle] (${op_mid});`\r\n    gate_str += `\\n\\\\draw (${op_mid}) edge[edgestyle] (${this._op(lines[1])});`\r\n\r\n\r\n    ctrl_lines.forEach((ctrl) => {\r\n      gate_str += this._phase(ctrl, this.pos[lines[0]])\r\n      if (ctrl > lines[1] || ctrl < lines[0]) {\r\n        let closer_line = lines[0]\r\n        if (ctrl > lines[1]) {\r\n          closer_line = lines[1]\r\n        }\r\n        gate_str += this._line(ctrl, closer_line)\r\n      }\r\n    })\r\n\r\n    const all_lines = ctrl_lines.concat(lines)\r\n    const new_pos = this.pos[lines[0]].add(delta_pos).add(gate_width)\r\n    all_lines.forEach(i => this.op_count[i] += 1)\r\n    const [min, max] = minmax(all_lines)\r\n    for (let i = min; i < max + 1; ++i) {\r\n      this.pos[i] = new_pos\r\n    }\r\n    return gate_str\r\n  }\r\n\r\n  /**\r\n  Return the TikZ code for a Swap-gate.\r\n\r\n    @param {number[]} lines List of length 2 denoting the target qubit of the Swap gate.\r\n    @param {number[]} ctrl_lines List of qubit lines which act as controls.\r\n  */\r\n  _swap_gate(lines, ctrl_lines) {\r\n    assert(len(lines) === 2) // swap gate acts on 2 qubits\r\n    const delta_pos = this._gate_offset(Swap)\r\n    const gate_width = this._gate_width(Swap)\r\n    lines.sort()\r\n\r\n    let gate_str = ''\r\n    lines.forEach((line) => {\r\n      const op = this._op(line)\r\n      const w = `${new Decimal(gate_width).mul(0.5)}cm`\r\n      const s1 = `[xshift=-${w},yshift=-${w}]${op}.center`\r\n      const s2 = `[xshift=${w},yshift=${w}]${op}.center`\r\n      const s3 = `[xshift=-${w},yshift=${w}]${op}.center`\r\n      const s4 = `[xshift=${w},yshift=-${w}]${op}.center`\r\n      let swap_style = 'swapstyle,edgestyle'\r\n      if (this.settings.gate_shadow) {\r\n        swap_style += ',shadowed'\r\n      }\r\n      gate_str += `\\n\\\\node[swapstyle] (${op}) at (${dts(this.pos[line])},-${line}) {};`\r\n      gate_str += `\\n\\\\draw[${swap_style}] (${s1})--(${s2});`\r\n      gate_str += `\\n\\\\draw[${swap_style}] (${s3})--(${s4});`\r\n    })\r\n\r\n    gate_str += this._line(lines[0], lines[1])\r\n\r\n    ctrl_lines.forEach((ctrl) => {\r\n      gate_str += this._phase(ctrl, this.pos[lines[0]])\r\n      if (ctrl > lines[1] || ctrl < lines[0]) {\r\n        let closer_line = lines[0]\r\n        if (ctrl > lines[1]) {\r\n          closer_line = lines[1]\r\n        }\r\n        gate_str += this._line(ctrl, closer_line)\r\n      }\r\n    })\r\n\r\n    const all_lines = ctrl_lines.concat(lines)\r\n    const new_pos = this.pos[lines[0]].add(delta_pos).add(gate_width)\r\n    all_lines.forEach(i => this.op_count[i] += 1)\r\n    const [min, max] = minmax(all_lines)\r\n    for (let i = min; i < max + 1; ++i) {\r\n      this.pos[i] = new_pos\r\n    }\r\n    return gate_str\r\n  }\r\n\r\n  /**\r\n  Return the TikZ code for a NOT-gate.\r\n\r\n    @param {number[]} lines List of length 1 denoting the target qubit of the NOT / X gate.\r\n    @param {number[]} ctrl_lines List of qubit lines which act as controls.\r\n   */\r\n  _x_gate(lines, ctrl_lines = []) {\r\n    assert(len(lines) === 1) // NOT gate only acts on 1 qubit\r\n    const line = lines[0]\r\n    const delta_pos = this._gate_offset(X)\r\n    const gate_width = this._gate_width(X)\r\n    const op = this._op(line)\r\n    let gate_str = `\\n\\\\node[xstyle] (${op}) at (${dts(this.pos[line])},-${line}) {};`\r\n    gate_str += `\\n\\\\draw[edgestyle] (${op}.north)--(${op}.south);`\r\n    gate_str += `\\n\\\\draw[edgestyle] (${op}.west)--(${op}.east);`\r\n\r\n    ctrl_lines.forEach((ctrl) => {\r\n      gate_str += this._phase(ctrl, this.pos[line])\r\n      gate_str += this._line(ctrl, line)\r\n    })\r\n\r\n    ctrl_lines.push(line)\r\n    const all_lines = ctrl_lines\r\n    const new_pos = this.pos[line].add(delta_pos).add(gate_width)\r\n    all_lines.forEach(i => this.op_count[i] += 1)\r\n    const [min, max] = minmax(all_lines)\r\n    for (let i = min; i < max + 1; ++i) {\r\n      this.pos[i] = new_pos\r\n    }\r\n    return gate_str\r\n  }\r\n\r\n  /**\r\n  Return the TikZ code for an n-controlled Z-gate.\r\n\r\n    @param {number[]} lines List of all qubits involved.\r\n   */\r\n  _cz_gate(lines) {\r\n    assert(len(lines) > 1)\r\n    const line = lines[0]\r\n    const delta_pos = this._gate_offset(Z)\r\n    const gate_width = this._gate_width(Z)\r\n    let gate_str = this._phase(line, this.pos[line])\r\n\r\n    lines.slice(1).forEach((ctrl) => {\r\n      gate_str += this._phase(ctrl, this.pos[line])\r\n      gate_str += this._line(ctrl, line)\r\n    })\r\n\r\n    const new_pos = this.pos[line].add(delta_pos).add(gate_width)\r\n    lines.forEach(i => this.op_count[i] += 1)\r\n    const [min, max] = minmax(lines)\r\n    for (let i = min; i < max + 1; ++i) {\r\n      this.pos[i] = new_pos\r\n    }\r\n    return gate_str\r\n  }\r\n\r\n  /**\r\n  Return the gate width, using the settings (if available).\r\n\r\n    @return {number} Width of the gate. (settings['gates'][gate_class_name]['width'])\r\n  */\r\n  _gate_width(gate) {\r\n    if (gate instanceof DaggeredGate) {\r\n      gate = gate.gate\r\n    }\r\n\r\n    const {gates} = this.settings\r\n    const config = gates[gate.constructor.name] || {}\r\n    return config.width || 0.5\r\n  }\r\n\r\n  /**\r\n  Return the offset to use before placing this gate.\r\n\r\n    @return {number} Offset to use before the gate. (settings['gates'][gate_class_name]['pre_offset'])\r\n   */\r\n  _gate_pre_offset(gate) {\r\n    if (gate instanceof DaggeredGate) {\r\n      gate = gate._gate\r\n    }\r\n\r\n    const {gates} = this.settings\r\n    return gates[gate.constructor.name].pre_offset || this._gate_offset(gate)\r\n  }\r\n\r\n  /**\r\n  Return the offset to use after placing this gate and, if no pre_offset\r\nis defined, the same offset is used in front of the gate.\r\n\r\n    @return {number} Offset. (settings['gates'][gate_class_name]['offset'])\r\n   */\r\n  _gate_offset(gate) {\r\n    if (gate instanceof DaggeredGate) {\r\n      gate = gate.gate\r\n    }\r\n    const {gates} = this.settings\r\n    const config = gates[gate.constructor.name] || {}\r\n    return config.offset || 0.2\r\n  }\r\n\r\n  /**\r\n  Return the height to use for this gate.\r\n\r\n    @return {number} Height of the gate. (settings['gates'][gate_class_name]['height'])\r\n   */\r\n  _gate_height(gate) {\r\n    if (gate instanceof DaggeredGate) {\r\n      gate = gate.gate\r\n    }\r\n    const config = this.settings.gates[gate.constructor.name] || {}\r\n    return config.height || 0.5\r\n  }\r\n\r\n  /**\r\n  Places a phase / control circle on a qubit line at a given position.\r\n\r\n    @param {number} line Qubit line at which to place the circle.\r\n    @param {number} pos Position at which to place the circle.\r\n    @return {string} Latex string representing a control circle at the given position.\r\n   */\r\n  _phase(line, pos) {\r\n    return `\\n\\\\node[phase] (${this._op(line)}) at (${dts(pos)},-${line}) {};`\r\n  }\r\n\r\n  /**\r\n  Returns the gate name for placing a gate on a line.\r\n\r\n    @param {number} line Line number.\r\n    @param {?number} op Operation number or, by default, uses the current op count.\r\n    @param {number} offset\r\n    @return {string} Gate name.\r\n   */\r\n  _op(line, op = null, offset = 0) {\r\n    if (op === null) {\r\n      op = this.op_count[line] || 0\r\n    }\r\n    return `line${line}_gate${op + offset}`\r\n  }\r\n\r\n  /**\r\n  Connects p1 and p2, where p1 and p2 are either to qubit line indices,\r\nin which case the two most recent gates are connected, or two gate\r\nindices, in which case line denotes the line number and the two gates\r\nare connected on the given line.\r\n\r\n    @param {number} p1 Index of the first object to connect.\r\n    @param {number} p2 Index of the second object to connect.\r\n    @param {number} line (int or null) Line index - if provided, p1 and p2 are gate indices.\r\n\r\n    @return {string} Latex code to draw this / these line(s).\r\n   */\r\n  _line(p1, p2, line = null) {\r\n    const dbl_classical = this.settings.lines.double_classical\r\n\r\n    let quantum\r\n    let op1\r\n    let op2\r\n    let loc1\r\n    let loc2\r\n    let shift\r\n    if (line === null) {\r\n      quantum = !dbl_classical || this.is_quantum[p1]\r\n      op1 = this._op(p1)\r\n      op2 = this._op(p2)\r\n      loc1 = 'north'\r\n      loc2 = 'south'\r\n      shift = 'xshift='\r\n    } else {\r\n      quantum = !dbl_classical || this.is_quantum[line]\r\n      op1 = this._op(line, p1)\r\n      op2 = this._op(line, p2)\r\n      loc1 = 'west'\r\n      loc2 = 'east'\r\n      shift = 'yshift='\r\n    }\r\n    if (quantum) {\r\n      return `\\n\\\\draw (${op1}) edge[edgestyle] (${op2});`\r\n    } else {\r\n      if (p2 > p1) {\r\n        const tmp = loc1\r\n        loc1 = loc2\r\n        loc2 = tmp\r\n      }\r\n      const line_sep = this.settings.lines.double_lines_sep\r\n      const shift1 = `${shift}${line_sep / 2.0}cm`\r\n      const shift2 = `${shift}${-line_sep / 2.0}cm`\r\n      let edges_str = `\\n\\\\draw ([${shift1}]${op1}.${loc1}) edge[edgestyle] ([${shift2}]${op2}.${loc2});`\r\n      edges_str += `\\n\\\\draw ([${shift2}]${op1}.${loc1}) edge[edgestyle] ([${shift2}]${op2}.${loc2});`\r\n      return edges_str\r\n    }\r\n  }\r\n\r\n  /**\r\n  Draw a regular gate.\r\n\r\n    @param {BasicGate} gate Gate to draw.\r\n    @param {number[]} lines Lines the gate acts on.\r\n   @param {number[]} ctrl_lines Control lines.\r\n\r\n    @return {string} Latex string drawing a regular gate at the given location\r\n   */\r\n  _regular_gate(gate, lines, ctrl_lines) {\r\n    const [imin, imax] = minmax(lines)\r\n\r\n    const gate_lines = lines.concat(ctrl_lines)\r\n\r\n    const delta_pos = this._gate_offset(gate)\r\n    const gate_width = this._gate_width(gate)\r\n    const gate_height = this._gate_height(gate)\r\n\r\n    const name = this._gate_name(gate)\r\n\r\n    lines = []\r\n    for (let i = imin; i < imax + 1; ++i) {\r\n      lines.push(i)\r\n    }\r\n\r\n    let tex_str = ''\r\n    const pos = this.pos[lines[0]]\r\n\r\n    lines.forEach((l) => {\r\n      const node1 = `\\n\\\\node[none] (${this._op(l)}) at (${dts(pos)},-${l}) {};`\r\n      const at = pos.add(new Decimal(gate_width).div(2.0)).toString()\r\n      const node2 = `\\n\\\\node[none,minimum height=${gate_height}cm,outer sep=0] (${this._op(l, null, 1)}) at (${at},-${l}) {};`\r\n      const node3 = `\\n\\\\node[none] (${this._op(l, null, 2)}) at (${dts(pos.add(gate_width))},-${l}) {};`\r\n      tex_str += node1 + node2 + node3\r\n      if (!gate_lines.includes(l)) {\r\n        tex_str += this._line(this.op_count[l] - 1, this.op_count[l], l)\r\n      }\r\n    })\r\n\r\n    const half_height = 0.5 * gate_height\r\n    const op1 = this._op(imin)\r\n    const op2 = this._op(imax, null, 2)\r\n    tex_str += `\\n\\\\draw[operator,edgestyle,outer sep=${gate_width}cm] ([yshift=${half_height}cm]${op1}) rectangle ([yshift=-${half_height}cm]${op2}) node[pos=.5] {${name}};`\r\n\r\n    lines.forEach((l) => {\r\n      this.pos[l] = new Decimal(pos).add(new Decimal(gate_width).div(2.0))\r\n      this.op_count[l] += 1\r\n    })\r\n\r\n    ctrl_lines.forEach((ctrl) => {\r\n      if (!lines.includes(ctrl)) {\r\n        tex_str += this._phase(ctrl, pos.add(new Decimal(gate_width).div(2.0)))\r\n        let connect_to = imax\r\n        if (Math.abs(connect_to - ctrl) > Math.abs(imin - ctrl)) {\r\n          connect_to = imin\r\n        }\r\n        tex_str += this._line(ctrl, connect_to)\r\n        this.pos[ctrl] = new Decimal(pos).add(delta_pos).add(gate_width)\r\n        this.op_count[ctrl] += 1\r\n      }\r\n    })\r\n\r\n    lines.forEach(l => this.op_count[l] += 2)\r\n\r\n    const all = ctrl_lines.concat(lines)\r\n    const [min, max] = minmax(all)\r\n    for (let l = min; l < max + 1; ++l) {\r\n      this.pos[l] = pos.add(delta_pos).add(gate_width)\r\n    }\r\n    return tex_str\r\n  }\r\n}\r\n\r\n/**\r\n * @ignore\r\n */\r\nexport default _exports\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/backends/circuits/tolatex.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 71,
    "kind": "function",
    "name": "dts",
    "memberof": "src/backends/circuits/tolatex.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/backends/circuits/tolatex.js~dts",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/backends/circuits/tolatex.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "params": [
      {
        "name": "number",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 72,
    "kind": "function",
    "name": "minmax",
    "memberof": "src/backends/circuits/tolatex.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/backends/circuits/tolatex.js~minmax",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/backends/circuits/tolatex.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "params": [
      {
        "name": "array",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "undefined[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 73,
    "kind": "function",
    "name": "maxOfDecimals",
    "memberof": "src/backends/circuits/tolatex.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/backends/circuits/tolatex.js~maxOfDecimals",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/backends/circuits/tolatex.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "params": [
      {
        "name": "decimals",
        "optional": true,
        "types": [
          "*[]"
        ],
        "defaultRaw": [],
        "defaultValue": "[]"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 74,
    "kind": "variable",
    "name": "_exports",
    "memberof": "src/backends/circuits/tolatex.js",
    "static": true,
    "longname": "src/backends/circuits/tolatex.js~_exports",
    "access": "private",
    "export": true,
    "importPath": "projectq/src/backends/circuits/tolatex.js",
    "importStyle": "{_exports}",
    "description": "",
    "lineNumber": 52,
    "ignore": true,
    "type": {
      "nullable": null,
      "types": [
        "{write_settings(Object): *, get_default_settings(): Object, _header(*): string, _body(Array<CircuitItem[]>, Object): string, _footer(): string}"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 75,
    "kind": "function",
    "name": "toLatex",
    "memberof": "src/backends/circuits/tolatex.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/backends/circuits/tolatex.js~toLatex",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/backends/circuits/tolatex.js",
    "importStyle": null,
    "description": "Translates a given circuit to a TikZ picture in a Latex document.\n\nIt uses a json-configuration file which (if it does not exist) is created\nautomatically upon running this function for the first time. The config\nfile can be used to determine custom gate sizes, offsets, etc.\n\nNew gate options can be added under settings['gates'], using the gate\nclass name string as a key. Every gate can have its own width, height, pre\noffset and offset.",
    "examples": [
      "settings['gates']['HGate'] = {'width': .5, 'offset': .15}\n\nThe default settings can be acquired using the get_default_settings()\nfunction, and written using write_settings()."
    ],
    "lineNumber": 259,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array.<CircuitItem[]>"
        ],
        "spread": false,
        "optional": false,
        "name": "circuit",
        "description": "Each qubit line is a list of\nCircuitItem objects, i.e., in circuit[line]."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "Latex document string which can be compiled using, e.g., pdflatex."
    },
    "ignore": true
  },
  {
    "__docId__": 76,
    "kind": "class",
    "name": "_Circ2Tikz",
    "memberof": "src/backends/circuits/tolatex.js",
    "static": true,
    "longname": "src/backends/circuits/tolatex.js~_Circ2Tikz",
    "access": "private",
    "export": true,
    "importPath": "projectq/src/backends/circuits/tolatex.js",
    "importStyle": "{_Circ2Tikz}",
    "description": "The Circ2Tikz class takes a circuit (list of lists of CircuitItem objects)\nand turns them into Latex/TikZ code.\n\nIt uses the settings dictionary for gate offsets, sizes, spacing, ...",
    "lineNumber": 293,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "_Circ2Tikz"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 77,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/backends/circuits/tolatex.js~_Circ2Tikz",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/circuits/tolatex.js~_Circ2Tikz#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 302,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": "Initialize a circuit to latex converter object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "Dictionary of settings to use for the TikZ image."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "num_lines",
        "description": "Number of qubit lines to use for the entire\ncircuit."
      }
    ]
  },
  {
    "__docId__": 78,
    "kind": "member",
    "name": "settings",
    "memberof": "src/backends/circuits/tolatex.js~_Circ2Tikz",
    "static": false,
    "longname": "src/backends/circuits/tolatex.js~_Circ2Tikz#settings",
    "access": "public",
    "description": null,
    "lineNumber": 303,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 79,
    "kind": "member",
    "name": "pos",
    "memberof": "src/backends/circuits/tolatex.js~_Circ2Tikz",
    "static": false,
    "longname": "src/backends/circuits/tolatex.js~_Circ2Tikz#pos",
    "access": "public",
    "description": null,
    "lineNumber": 304,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 80,
    "kind": "member",
    "name": "op_count",
    "memberof": "src/backends/circuits/tolatex.js~_Circ2Tikz",
    "static": false,
    "longname": "src/backends/circuits/tolatex.js~_Circ2Tikz#op_count",
    "access": "public",
    "description": null,
    "lineNumber": 305,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 81,
    "kind": "member",
    "name": "is_quantum",
    "memberof": "src/backends/circuits/tolatex.js~_Circ2Tikz",
    "static": false,
    "longname": "src/backends/circuits/tolatex.js~_Circ2Tikz#is_quantum",
    "access": "public",
    "description": null,
    "lineNumber": 306,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 82,
    "kind": "method",
    "name": "to_tikz",
    "memberof": "src/backends/circuits/tolatex.js~_Circ2Tikz",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/circuits/tolatex.js~_Circ2Tikz#to_tikz",
    "access": "public",
    "description": "Generate the TikZ code for one line of the circuit up to a certain\ngate.\n\nIt modifies the circuit to include only the gates which have not been\ndrawn. It automatically switches to other lines if the gates on those\nlines have to be drawn earlier.",
    "lineNumber": 325,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "line",
        "description": "Line to generate the TikZ code for."
      },
      {
        "nullable": null,
        "types": [
          "Array.<CircuitItem[]>"
        ],
        "spread": false,
        "optional": false,
        "name": "circuit",
        "description": "The circuit to draw."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "end",
        "description": "Gate index to stop at (for recursion)."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "TikZ code representing the current qubit line\nand, if it was necessary to draw other lines, those lines as\nwell."
    }
  },
  {
    "__docId__": 83,
    "kind": "method",
    "name": "_gate_name",
    "memberof": "src/backends/circuits/tolatex.js~_Circ2Tikz",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/circuits/tolatex.js~_Circ2Tikz#_gate_name",
    "access": "private",
    "description": "Return the string representation of the gate.\nTries to use gate.tex_str and, if that is not available, uses str(gate) instead.",
    "lineNumber": 450,
    "params": [
      {
        "nullable": null,
        "types": [
          "BasicGate"
        ],
        "spread": false,
        "optional": false,
        "name": "gate",
        "description": "Gate object of which to get the name / latex representation."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "Latex gate name."
    }
  },
  {
    "__docId__": 84,
    "kind": "method",
    "name": "_sqrtswap_gate",
    "memberof": "src/backends/circuits/tolatex.js~_Circ2Tikz",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/circuits/tolatex.js~_Circ2Tikz#_sqrtswap_gate",
    "access": "private",
    "description": "Return the TikZ code for a Square-root Swap-gate.",
    "lineNumber": 466,
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "lines",
        "description": "List of length 2 denoting the target qubit of the Swap gate."
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "ctrl_lines",
        "description": "List of qubit lines which act as controls."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "daggered",
        "description": "Show the daggered one if true."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 85,
    "kind": "method",
    "name": "_swap_gate",
    "memberof": "src/backends/circuits/tolatex.js~_Circ2Tikz",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/circuits/tolatex.js~_Circ2Tikz#_swap_gate",
    "access": "private",
    "description": "Return the TikZ code for a Swap-gate.",
    "lineNumber": 528,
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "lines",
        "description": "List of length 2 denoting the target qubit of the Swap gate."
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "ctrl_lines",
        "description": "List of qubit lines which act as controls."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 86,
    "kind": "method",
    "name": "_x_gate",
    "memberof": "src/backends/circuits/tolatex.js~_Circ2Tikz",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/circuits/tolatex.js~_Circ2Tikz#_x_gate",
    "access": "private",
    "description": "Return the TikZ code for a NOT-gate.",
    "lineNumber": 580,
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "lines",
        "description": "List of length 1 denoting the target qubit of the NOT / X gate."
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "ctrl_lines",
        "description": "List of qubit lines which act as controls."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 87,
    "kind": "method",
    "name": "_cz_gate",
    "memberof": "src/backends/circuits/tolatex.js~_Circ2Tikz",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/circuits/tolatex.js~_Circ2Tikz#_cz_gate",
    "access": "private",
    "description": "Return the TikZ code for an n-controlled Z-gate.",
    "lineNumber": 611,
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "lines",
        "description": "List of all qubits involved."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 88,
    "kind": "method",
    "name": "_gate_width",
    "memberof": "src/backends/circuits/tolatex.js~_Circ2Tikz",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/circuits/tolatex.js~_Circ2Tikz#_gate_width",
    "access": "private",
    "description": "Return the gate width, using the settings (if available).",
    "lineNumber": 637,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Width of the gate. (settings['gates'][gate_class_name]['width'])"
    },
    "params": [
      {
        "name": "gate",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 89,
    "kind": "method",
    "name": "_gate_pre_offset",
    "memberof": "src/backends/circuits/tolatex.js~_Circ2Tikz",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/circuits/tolatex.js~_Circ2Tikz#_gate_pre_offset",
    "access": "private",
    "description": "Return the offset to use before placing this gate.",
    "lineNumber": 652,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Offset to use before the gate. (settings['gates'][gate_class_name]['pre_offset'])"
    },
    "params": [
      {
        "name": "gate",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 90,
    "kind": "method",
    "name": "_gate_offset",
    "memberof": "src/backends/circuits/tolatex.js~_Circ2Tikz",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/circuits/tolatex.js~_Circ2Tikz#_gate_offset",
    "access": "private",
    "description": "Return the offset to use after placing this gate and, if no pre_offset\nis defined, the same offset is used in front of the gate.",
    "lineNumber": 667,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Offset. (settings['gates'][gate_class_name]['offset'])"
    },
    "params": [
      {
        "name": "gate",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 91,
    "kind": "method",
    "name": "_gate_height",
    "memberof": "src/backends/circuits/tolatex.js~_Circ2Tikz",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/circuits/tolatex.js~_Circ2Tikz#_gate_height",
    "access": "private",
    "description": "Return the height to use for this gate.",
    "lineNumber": 681,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Height of the gate. (settings['gates'][gate_class_name]['height'])"
    },
    "params": [
      {
        "name": "gate",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 92,
    "kind": "method",
    "name": "_phase",
    "memberof": "src/backends/circuits/tolatex.js~_Circ2Tikz",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/circuits/tolatex.js~_Circ2Tikz#_phase",
    "access": "private",
    "description": "Places a phase / control circle on a qubit line at a given position.",
    "lineNumber": 696,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "line",
        "description": "Qubit line at which to place the circle."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "pos",
        "description": "Position at which to place the circle."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "Latex string representing a control circle at the given position."
    }
  },
  {
    "__docId__": 93,
    "kind": "method",
    "name": "_op",
    "memberof": "src/backends/circuits/tolatex.js~_Circ2Tikz",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/circuits/tolatex.js~_Circ2Tikz#_op",
    "access": "private",
    "description": "Returns the gate name for placing a gate on a line.",
    "lineNumber": 708,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "line",
        "description": "Line number."
      },
      {
        "nullable": true,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "op",
        "description": "Operation number or, by default, uses the current op count."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "offset",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "Gate name."
    }
  },
  {
    "__docId__": 94,
    "kind": "method",
    "name": "_line",
    "memberof": "src/backends/circuits/tolatex.js~_Circ2Tikz",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/circuits/tolatex.js~_Circ2Tikz#_line",
    "access": "private",
    "description": "Connects p1 and p2, where p1 and p2 are either to qubit line indices,\nin which case the two most recent gates are connected, or two gate\nindices, in which case line denotes the line number and the two gates\nare connected on the given line.",
    "lineNumber": 727,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "p1",
        "description": "Index of the first object to connect."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "p2",
        "description": "Index of the second object to connect."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "line",
        "description": "(int or null) Line index - if provided, p1 and p2 are gate indices."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "Latex code to draw this / these line(s)."
    }
  },
  {
    "__docId__": 95,
    "kind": "method",
    "name": "_regular_gate",
    "memberof": "src/backends/circuits/tolatex.js~_Circ2Tikz",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/circuits/tolatex.js~_Circ2Tikz#_regular_gate",
    "access": "private",
    "description": "Draw a regular gate.",
    "lineNumber": 777,
    "params": [
      {
        "nullable": null,
        "types": [
          "BasicGate"
        ],
        "spread": false,
        "optional": false,
        "name": "gate",
        "description": "Gate to draw."
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "lines",
        "description": "Lines the gate acts on."
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "ctrl_lines",
        "description": "Control lines."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "Latex string drawing a regular gate at the given location"
    }
  },
  {
    "__docId__": 96,
    "kind": "file",
    "name": "src/backends/ibm/ibm.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport assert from 'assert'\r\nimport {BasicEngine} from '../../cengines/basics'\r\nimport Gates, {\r\n  Allocate, Barrier, Deallocate, FlushGate, H, Measure, NOT, Rx, Ry, Rz, S, T, Y, Z\r\n} from '../../ops/gates'\r\nimport {LogicalQubitIDTag} from '../../meta/tag';\r\nimport IBMHTTPClient from './ibmhttpclient'\r\nimport {instanceOf} from '../../libs/util'\r\nimport '../../ops/metagates'\r\n\r\nconst {Tdag, Sdag} = Gates\r\n/**\r\n * @class IBMBackend\r\n * @desc\r\nThe IBM Backend class, which stores the circuit, transforms it to JSON\r\nQASM, and sends the circuit through the IBM API.\r\n */\r\nexport default class IBMBackend extends BasicEngine {\r\n  /**\r\n   * @constructor\r\n  @param {{use_hardware: boolean, num_runs: number, verbose: boolean, user: string, password: string, device: string, retrieve_execution: ?string}} args\r\n    use_hardware: If true, the code is run on the IBM quantum chip (instead of using the IBM simulator)\r\n    num_runs: Number of runs to collect statistics. (default is 1024)\r\n    verbose: If true, statistics are printed, in addition to the measurement result being registered (at the end of the circuit).\r\n    user: IBM Quantum Experience user name\r\n    password: IBM Quantum Experience password\r\n    device: Device to use ('ibmqx4', or 'ibmqx5') if use_hardware is set to true. Default is ibmqx4.\r\n    retrieve_execution: Job ID to retrieve instead of re-running the circuit (e.g., if previous run timed out).\r\n  */\r\n  constructor(...args) {\r\n    super()\r\n    this._reset()\r\n    this._errors = []\r\n    let use_hardware = false\r\n    let num_runs = 1024\r\n    let verbose = false\r\n    let user = null\r\n    let password = null\r\n    let device = 'ibmqx4'\r\n    let retrieve_execution = null\r\n\r\n    if (typeof args[0] === 'object') {\r\n      const obj = args[0]\r\n      use_hardware = use_hardware || obj.use_hardware\r\n      num_runs = num_runs || obj.num_runs\r\n      verbose = verbose || obj.verbose\r\n      user = user || obj.user\r\n      password = password || obj.password\r\n      device = device || obj.device\r\n      retrieve_execution = retrieve_execution || obj.retrieve_execution\r\n    } else {\r\n      [use_hardware, num_runs, verbose, user, password, device, retrieve_execution] = args\r\n    }\r\n\r\n    num_runs = num_runs || 1024\r\n    device = device || 'ibmqx4'\r\n    if (use_hardware) {\r\n      this.device = device\r\n    } else {\r\n      this.device = 'simulator'\r\n    }\r\n    this._num_runs = num_runs\r\n    this._verbose = verbose\r\n    this._user = user\r\n    this._password = password\r\n    this._probabilities = {}\r\n    this.qasm = ''\r\n    this._measured_ids = []\r\n    this._allocated_qubits = new Set()\r\n    this._retrieve_execution = retrieve_execution\r\n  }\r\n\r\n  /**\r\n  Return true if the command can be executed.\r\n\r\n    The IBM quantum chip can do X, Y, Z, T, Tdag, S, Sdag,\r\n    rotation gates, barriers, and CX / CNOT.\r\n\r\n    @param {Command} cmd Command for which to check availability\r\n    @return {boolean}\r\n   */\r\n  isAvailable(cmd) {\r\n    const g = cmd.gate\r\n    const controlCount = cmd.controlCount\r\n    if (g.equal(NOT) && controlCount <= 1) {\r\n      return true\r\n    }\r\n    if (controlCount === 0) {\r\n      const set = [T, Tdag, S, Sdag, H, Y, Z]\r\n      if (set.includes(g)) {\r\n        return true\r\n      }\r\n      if (g instanceof Rx || g instanceof Ry || g instanceof Rz) {\r\n        return true\r\n      }\r\n    }\r\n    const set = [Measure, Allocate, Deallocate, Barrier]\r\n    if (set.includes(g)) {\r\n      return true\r\n    }\r\n    return false\r\n  }\r\n\r\n  // Reset all temporary variables (after flush gate).\r\n  _reset() {\r\n    this._clear = true\r\n    this._measured_ids = []\r\n  }\r\n\r\n  /**\r\nTemporarily store the command cmd.\r\n\r\n  Translates the command and stores it in a local variable (this._cmds).\r\n\r\n  @param {Command} cmd Command to store\r\n  */\r\n  _store(cmd) {\r\n    if (this._clear) {\r\n      this._probabilities = {}\r\n      this._clear = false\r\n      this.qasm = ''\r\n      this._allocated_qubits = new Set()\r\n    }\r\n\r\n    const {gate} = cmd\r\n\r\n    if (gate.equal(Allocate)) {\r\n      this._allocated_qubits.add(cmd.qubits[0][0].id)\r\n      return\r\n    }\r\n\r\n    if (gate.equal(Deallocate)) {\r\n      return\r\n    }\r\n\r\n    if (gate.equal(Measure)) {\r\n      assert(cmd.qubits.length === 1 && cmd.qubits[0].length === 1)\r\n      const qb_id = cmd.qubits[0][0].id\r\n      let logical_id\r\n      for (let i = 0; i < cmd.tags.length; ++i) {\r\n        const t = cmd.tags[i]\r\n        if (t instanceof LogicalQubitIDTag) {\r\n          logical_id = t.logical_qubit_id\r\n          break\r\n        }\r\n      }\r\n      assert(typeof logical_id !== 'undefined')\r\n      this._measured_ids.push(logical_id)\r\n    } else if (gate === NOT && cmd.controlCount === 1) {\r\n      const ctrl_pos = cmd.controlQubits[0].id\r\n      const qb_pos = cmd.qubits[0][0].id\r\n      this.qasm += `\\ncx q[${ctrl_pos}], q[${qb_pos}];`\r\n    } else if (gate === Barrier) {\r\n      const qb_pos = []\r\n      cmd.qubits.forEach(qr => qr.forEach(qb => qb_pos.push(qb.id)))\r\n      this.qasm += '\\nbarrier '\r\n      let qb_str = ''\r\n      qb_pos.forEach((pos) => {\r\n        qb_str += `q[${pos}]`\r\n      })\r\n\r\n      this.qasm += `${qb_str.substring(0, qb_str.length - 2)};`\r\n    } else if (instanceOf(gate, [Rx, Ry, Rz])) {\r\n      assert(cmd.controlCount === 0)\r\n      const qb_pos = cmd.qubits[0][0].id\r\n      const u_strs = {\r\n        Rx: a => `u3(${a}, -pi/2, pi/2)`,\r\n        Ry: a => `u3(${a}, 0, 0)`,\r\n        Rz: a => `u1(${a})`\r\n      }\r\n      const gateASM = u_strs[gate.toString().substring(0, 2)](gate.angle)\r\n      this.qasm += `\\n${gateASM} q[${qb_pos}];`\r\n    } else {\r\n      if (cmd.controlCount !== 0) {\r\n        console.log(187, cmd.toString())\r\n      }\r\n      assert(cmd.controlCount === 0)\r\n      const key = gate.toString()\r\n      const v = IBMBackend.gateNames[key]\r\n      let gate_str\r\n      if (typeof v !== 'undefined') {\r\n        gate_str = v\r\n      } else {\r\n        gate_str = key.toLowerCase()\r\n      }\r\n\r\n      const qb_pos = cmd.qubits[0][0].id\r\n      this.qasm += `\\n${gate_str} q[${qb_pos}];`\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n  Return the physical location of the qubit with the given logical id.\r\n\r\n    @param {number} qbID ID of the logical qubit whose position should be returned.\r\n   */\r\n  _logicalToPhysical(qbID) {\r\n    assert(!!this.main.mapper)\r\n    const mapping = this.main.mapper.currentMapping\r\n    const v = mapping[qbID]\r\n    if (typeof v === 'undefined') {\r\n      throw new Error(`Unknown qubit id ${qbID}. Please make sure \r\n      eng.flush() was called and that the qubit \r\n      was eliminated during optimization.`)\r\n    }\r\n    return v\r\n  }\r\n\r\n  /**\r\n  Return the list of basis states with corresponding probabilities.\r\n\r\n    The measured bits are ordered according to the supplied quantum\r\nregister, i.e., the left-most bit in the state-string corresponds to\r\nthe first qubit in the supplied quantum register.\r\n\r\n    Warning:\r\nOnly call this function after the circuit has been executed!\r\n\r\n    @param {Array.<Qubit>|Qureg} qureg Quantum register determining the order of the qubits.\r\n\r\n    @return {Object} Dictionary mapping n-bit strings to probabilities.\r\n\r\n    @throws {Error} If no data is available (i.e., if the circuit has\r\nnot been executed). Or if a qubit was supplied which was not\r\npresent in the circuit (might have gotten optimized away).\r\n   */\r\n  getProbabilities(qureg) {\r\n    if (Object.keys(this._probabilities).length === 0) {\r\n      throw new Error('Please, run the circuit first!')\r\n    }\r\n\r\n    const probability_dict = {}\r\n\r\n    this._probabilities.forEach((state) => {\r\n      const mapped_state = []\r\n      for (let i = 0; i < qureg.length; ++i) {\r\n        mapped_state.push('0')\r\n      }\r\n\r\n      for (let i = 0; i < qureg.length; ++i) {\r\n        mapped_state[i] = state[this._logicalToPhysical(qureg[i].id)]\r\n      }\r\n      const probability = this._probabilities[state]\r\n      probability_dict[mapped_state.join('')] = probability\r\n    })\r\n\r\n    return probability_dict\r\n  }\r\n\r\n  /**\r\n  Run the circuit.\r\n\r\n    Send the circuit via the IBM API (JSON QASM) using the provided user\r\ndata / ask for username & password.\r\n   */\r\n  async run() {\r\n    if (this.qasm.length === 0) {\r\n      return\r\n    }\r\n    // finally: add measurements (no intermediate measurements are allowed)\r\n    this._measured_ids.forEach((measured_id) => {\r\n      const qb_loc = this.main.mapper.currentMapping[measured_id]\r\n      this.qasm += `measure q[${qb_loc}] -> c[${qb_loc}];`\r\n    })\r\n    let max_qubit_id = -1\r\n    this._allocated_qubits.forEach((id) => {\r\n      if (id > max_qubit_id) {\r\n        max_qubit_id = id\r\n      }\r\n    })\r\n\r\n    const nq = max_qubit_id + 1\r\n    const qasm = `\\ninclude \\\"qelib1.inc\\\";\\nqreg q[${nq}];\\ncreg c[${nq}];${this.qasm}`\r\n    const info = {}\r\n    info.qasms = [{qasm}]\r\n    info.shots = this._num_runs\r\n    info.maxCredits = 5\r\n    info.backend = {'name': this.device}\r\n    const infoJSON = JSON.stringify(info)\r\n\r\n    try {\r\n      let res\r\n      if (!this._retrieve_execution) {\r\n        res = await IBMHTTPClient.send(infoJSON, this.device, this._user, this._password, this._num_runs, this._verbose)\r\n      } else {\r\n        res = await IBMHTTPClient.retrieve(this.device, this._user, this._password, this._retrieve_execution)\r\n      }\r\n      const {counts} = res.data\r\n      // Determine random outcome\r\n      const P = Math.random()\r\n      let p_sum = 0.0\r\n      let measured = ''\r\n      Object.keys(counts).forEach((state) => {\r\n        const probability = counts[state] * 1.0 / this._num_runs\r\n        if (Array.isArray(state)) {\r\n          state = state.slice(0).reverse()\r\n          state = ''.join(state)\r\n        }\r\n        p_sum += probability\r\n        let star = ''\r\n        if (p_sum >= P && measured === '') {\r\n          measured = state\r\n          star = '*'\r\n        }\r\n        this._probabilities[state] = probability\r\n        if (this._verbose && probability > 0) {\r\n          console.log(`${state.toString()} with p = ${probability.toString()}${star}`)\r\n        }\r\n      })\r\n\r\n      class QB {\r\n        constructor(ID) {\r\n          this.id = ID\r\n        }\r\n      }\r\n\r\n      // register measurement result\r\n      this._measured_ids.forEach((ID) => {\r\n        const location = this._logicalToPhysical(ID)\r\n        const result = measured[location]\r\n        this.main.setMeasurementResult(new QB(ID), result)\r\n      })\r\n      this._reset()\r\n    } catch (e) {\r\n      console.log(347, e)\r\n      throw new Error('Failed to run the circuit. Aborting.')\r\n    }\r\n  }\r\n\r\n  /**\r\n  Receives a command list and, for each command, stores it until\r\ncompletion.\r\n\r\n    @param {Command[]} commandList List of commands to execute\r\n   */\r\n  receive(commandList) {\r\n    commandList.forEach((cmd) => {\r\n      if (!(cmd.gate instanceof FlushGate)) {\r\n        this._store(cmd)\r\n      } else {\r\n        this.run()\r\n          .then(() => this._reset())\r\n          .catch((e) => {\r\n            console.log(e)\r\n            this.addError(e)\r\n          }).finally(() => {\r\n            if (this.didRunCallback) {\r\n              this.didRunCallback()\r\n            }\r\n          })\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * @return {Error[]}\r\n   */\r\n  get errors() {\r\n    return this._errors\r\n  }\r\n\r\n  addError(error) {\r\n    this._errors.push(error)\r\n  }\r\n\r\n  /**\r\n   * @return {function}\r\n   */\r\n  get didRunCallback() {\r\n    return this._didRunCallback\r\n  }\r\n\r\n  /**\r\n   * @param {function} callback\r\n   */\r\n  set didRunCallback(callback) {\r\n    this._didRunCallback = callback\r\n  }\r\n}\r\n\r\nIBMBackend.gateNames = {\r\n  [Tdag.toString()]: 'tdg',\r\n  [Sdag.toString()]: 'sdg'\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/backends/ibm/ibm.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 97,
    "kind": "variable",
    "name": "Tdag",
    "memberof": "src/backends/ibm/ibm.js",
    "static": true,
    "longname": "src/backends/ibm/ibm.js~Tdag",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/backends/ibm/ibm.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 98,
    "kind": "class",
    "name": "IBMBackend",
    "memberof": "src/backends/ibm/ibm.js",
    "static": true,
    "longname": "src/backends/ibm/ibm.js~IBMBackend",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/backends/ibm/ibm.js",
    "importStyle": "IBMBackend",
    "description": "The IBM Backend class, which stores the circuit, transforms it to JSON\nQASM, and sends the circuit through the IBM API.",
    "lineNumber": 34,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "IBMBackend"
      }
    ],
    "interface": false,
    "extends": [
      "src/cengines/basics.js~BasicEngine"
    ]
  },
  {
    "__docId__": 99,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/backends/ibm/ibm.js~IBMBackend",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/ibm/ibm.js~IBMBackend#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 46,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "{use_hardware: boolean, num_runs: number, verbose: boolean, user: string, password: string, device: string, retrieve_execution: ?string}"
        ],
        "spread": false,
        "optional": false,
        "name": "args",
        "description": "use_hardware: If true, the code is run on the IBM quantum chip (instead of using the IBM simulator)\nnum_runs: Number of runs to collect statistics. (default is 1024)\nverbose: If true, statistics are printed, in addition to the measurement result being registered (at the end of the circuit).\nuser: IBM Quantum Experience user name\npassword: IBM Quantum Experience password\ndevice: Device to use ('ibmqx4', or 'ibmqx5') if use_hardware is set to true. Default is ibmqx4.\nretrieve_execution: Job ID to retrieve instead of re-running the circuit (e.g., if previous run timed out)."
      }
    ]
  },
  {
    "__docId__": 100,
    "kind": "member",
    "name": "_errors",
    "memberof": "src/backends/ibm/ibm.js~IBMBackend",
    "static": false,
    "longname": "src/backends/ibm/ibm.js~IBMBackend#_errors",
    "access": "private",
    "description": null,
    "lineNumber": 49,
    "undocument": true,
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 101,
    "kind": "member",
    "name": "device",
    "memberof": "src/backends/ibm/ibm.js~IBMBackend",
    "static": false,
    "longname": "src/backends/ibm/ibm.js~IBMBackend#device",
    "access": "public",
    "description": null,
    "lineNumber": 74,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 103,
    "kind": "member",
    "name": "_num_runs",
    "memberof": "src/backends/ibm/ibm.js~IBMBackend",
    "static": false,
    "longname": "src/backends/ibm/ibm.js~IBMBackend#_num_runs",
    "access": "private",
    "description": null,
    "lineNumber": 78,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 104,
    "kind": "member",
    "name": "_verbose",
    "memberof": "src/backends/ibm/ibm.js~IBMBackend",
    "static": false,
    "longname": "src/backends/ibm/ibm.js~IBMBackend#_verbose",
    "access": "private",
    "description": null,
    "lineNumber": 79,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 105,
    "kind": "member",
    "name": "_user",
    "memberof": "src/backends/ibm/ibm.js~IBMBackend",
    "static": false,
    "longname": "src/backends/ibm/ibm.js~IBMBackend#_user",
    "access": "private",
    "description": null,
    "lineNumber": 80,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 106,
    "kind": "member",
    "name": "_password",
    "memberof": "src/backends/ibm/ibm.js~IBMBackend",
    "static": false,
    "longname": "src/backends/ibm/ibm.js~IBMBackend#_password",
    "access": "private",
    "description": null,
    "lineNumber": 81,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 107,
    "kind": "member",
    "name": "_probabilities",
    "memberof": "src/backends/ibm/ibm.js~IBMBackend",
    "static": false,
    "longname": "src/backends/ibm/ibm.js~IBMBackend#_probabilities",
    "access": "private",
    "description": null,
    "lineNumber": 82,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 108,
    "kind": "member",
    "name": "qasm",
    "memberof": "src/backends/ibm/ibm.js~IBMBackend",
    "static": false,
    "longname": "src/backends/ibm/ibm.js~IBMBackend#qasm",
    "access": "public",
    "description": null,
    "lineNumber": 83,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 109,
    "kind": "member",
    "name": "_measured_ids",
    "memberof": "src/backends/ibm/ibm.js~IBMBackend",
    "static": false,
    "longname": "src/backends/ibm/ibm.js~IBMBackend#_measured_ids",
    "access": "private",
    "description": null,
    "lineNumber": 84,
    "undocument": true,
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 110,
    "kind": "member",
    "name": "_allocated_qubits",
    "memberof": "src/backends/ibm/ibm.js~IBMBackend",
    "static": false,
    "longname": "src/backends/ibm/ibm.js~IBMBackend#_allocated_qubits",
    "access": "private",
    "description": null,
    "lineNumber": 85,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 111,
    "kind": "member",
    "name": "_retrieve_execution",
    "memberof": "src/backends/ibm/ibm.js~IBMBackend",
    "static": false,
    "longname": "src/backends/ibm/ibm.js~IBMBackend#_retrieve_execution",
    "access": "private",
    "description": null,
    "lineNumber": 86,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 112,
    "kind": "method",
    "name": "isAvailable",
    "memberof": "src/backends/ibm/ibm.js~IBMBackend",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/ibm/ibm.js~IBMBackend#isAvailable",
    "access": "public",
    "description": "Return true if the command can be executed.\n\nThe IBM quantum chip can do X, Y, Z, T, Tdag, S, Sdag,\nrotation gates, barriers, and CX / CNOT.",
    "lineNumber": 98,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": "Command for which to check availability"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 113,
    "kind": "method",
    "name": "_reset",
    "memberof": "src/backends/ibm/ibm.js~IBMBackend",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/ibm/ibm.js~IBMBackend#_reset",
    "access": "private",
    "description": null,
    "lineNumber": 121,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 114,
    "kind": "member",
    "name": "_clear",
    "memberof": "src/backends/ibm/ibm.js~IBMBackend",
    "static": false,
    "longname": "src/backends/ibm/ibm.js~IBMBackend#_clear",
    "access": "private",
    "description": null,
    "lineNumber": 122,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 116,
    "kind": "method",
    "name": "_store",
    "memberof": "src/backends/ibm/ibm.js~IBMBackend",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/ibm/ibm.js~IBMBackend#_store",
    "access": "private",
    "description": "Temporarily store the command cmd.\n\nTranslates the command and stores it in a local variable (this._cmds).",
    "lineNumber": 133,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": "Command to store"
      }
    ],
    "return": null
  },
  {
    "__docId__": 126,
    "kind": "method",
    "name": "_logicalToPhysical",
    "memberof": "src/backends/ibm/ibm.js~IBMBackend",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/ibm/ibm.js~IBMBackend#_logicalToPhysical",
    "access": "private",
    "description": "Return the physical location of the qubit with the given logical id.",
    "lineNumber": 214,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "qbID",
        "description": "ID of the logical qubit whose position should be returned."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 127,
    "kind": "method",
    "name": "getProbabilities",
    "memberof": "src/backends/ibm/ibm.js~IBMBackend",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/ibm/ibm.js~IBMBackend#getProbabilities",
    "access": "public",
    "description": "Return the list of basis states with corresponding probabilities.\n\nThe measured bits are ordered according to the supplied quantum\nregister, i.e., the left-most bit in the state-string corresponds to\nthe first qubit in the supplied quantum register.\n\nWarning:\nOnly call this function after the circuit has been executed!",
    "lineNumber": 244,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array.<Qubit>",
          "Qureg"
        ],
        "spread": false,
        "optional": false,
        "name": "qureg",
        "description": "Quantum register determining the order of the qubits."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Dictionary mapping n-bit strings to probabilities."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If no data is available (i.e., if the circuit has\nnot been executed). Or if a qubit was supplied which was not\npresent in the circuit (might have gotten optimized away)."
      }
    ]
  },
  {
    "__docId__": 128,
    "kind": "method",
    "name": "run",
    "memberof": "src/backends/ibm/ibm.js~IBMBackend",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/backends/ibm/ibm.js~IBMBackend#run",
    "access": "public",
    "description": "Run the circuit.\n\nSend the circuit via the IBM API (JSON QASM) using the provided user\ndata / ask for username & password.",
    "lineNumber": 273,
    "params": [],
    "return": null
  },
  {
    "__docId__": 130,
    "kind": "method",
    "name": "receive",
    "memberof": "src/backends/ibm/ibm.js~IBMBackend",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/ibm/ibm.js~IBMBackend#receive",
    "access": "public",
    "description": "Receives a command list and, for each command, stores it until\ncompletion.",
    "lineNumber": 353,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command[]"
        ],
        "spread": false,
        "optional": false,
        "name": "commandList",
        "description": "List of commands to execute"
      }
    ],
    "return": null
  },
  {
    "__docId__": 131,
    "kind": "get",
    "name": "errors",
    "memberof": "src/backends/ibm/ibm.js~IBMBackend",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/ibm/ibm.js~IBMBackend#errors",
    "access": "public",
    "description": "",
    "lineNumber": 375,
    "return": {
      "nullable": null,
      "types": [
        "Error[]"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 132,
    "kind": "method",
    "name": "addError",
    "memberof": "src/backends/ibm/ibm.js~IBMBackend",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/ibm/ibm.js~IBMBackend#addError",
    "access": "public",
    "description": null,
    "lineNumber": 379,
    "undocument": true,
    "params": [
      {
        "name": "error",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 133,
    "kind": "get",
    "name": "didRunCallback",
    "memberof": "src/backends/ibm/ibm.js~IBMBackend",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/ibm/ibm.js~IBMBackend#didRunCallback",
    "access": "public",
    "description": "",
    "lineNumber": 386,
    "return": {
      "nullable": null,
      "types": [
        "function"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 134,
    "kind": "set",
    "name": "didRunCallback",
    "memberof": "src/backends/ibm/ibm.js~IBMBackend",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/ibm/ibm.js~IBMBackend#didRunCallback",
    "access": "public",
    "description": "",
    "lineNumber": 393,
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 135,
    "kind": "member",
    "name": "_didRunCallback",
    "memberof": "src/backends/ibm/ibm.js~IBMBackend",
    "static": false,
    "longname": "src/backends/ibm/ibm.js~IBMBackend#_didRunCallback",
    "access": "private",
    "description": null,
    "lineNumber": 394,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 136,
    "kind": "file",
    "name": "src/backends/ibm/ibmhttpclient.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport axios from 'axios'\r\nconst _api_url = 'https://quantumexperience.ng.bluemix.net/api/'\r\n/**\r\n * @class IBMHTTPClient\r\n */\r\nexport default class IBMHTTPClient {\r\n  static async isOnline(device) {\r\n    const url = `Backends/${device}/queue/status`\r\n    const result = await axios.get(`${_api_url}${url}`)\r\n    return result.state\r\n  }\r\n\r\n  /**\r\n  Retrieves a previously run job by its ID.\r\n\r\n    @param {string} device Device on which the code was run / is running.\r\n    @param {string} user IBM quantum experience user (e-mail)\r\n    @param {string} password IBM quantum experience password\r\n    @param {string} jobid Id of the job to retrieve\r\n  */\r\n  static async retrieve(device, user, password, jobid) {\r\n    const [user_id, access_token] = await IBMHTTPClient.authenticate(user, password)\r\n    return IBMHTTPClient.getResult(device, jobid, access_token)\r\n  }\r\n\r\n  static async sleep(interval) {\r\n    return new Promise((resolve) => {\r\n      setTimeout(resolve, interval)\r\n    })\r\n  }\r\n\r\n  /**\r\n  Sends QASM through the IBM API and runs the quantum circuit.\r\n\r\n   @param {string} info Contains QASM representation of the circuit to run.\r\n   @param {string} device Either 'simulator', 'ibmqx4', or 'ibmqx5'.\r\n   @param {string} user IBM quantum experience user.\r\n   @param {string} password IBM quantum experience user password.\r\n   @param {number} shots Number of runs of the same circuit to collect statistics.\r\n   @param {boolean} verbose If true, additional information is printed, such as\r\nmeasurement statistics. Otherwise, the backend simply registers\r\none measurement result (same behavior as the projectq Simulator).\r\n   */\r\n  static async send(info, device = 'sim_trivial_2', user = '', password = '', shots = 1, verbose = false) {\r\n    try {\r\n      // check if the device is online\r\n      if (['ibmqx4', 'ibmqx5'].includes(device)) {\r\n        const online = await IBMHTTPClient.isOnline(device)\r\n        if (!online) {\r\n          console.log('The device is offline (for maintenance?). Use the simulator instead or try again later.')\r\n          throw new Error('Device is offline')\r\n        }\r\n      }\r\n      if (verbose) {\r\n        console.log('- Authenticating...')\r\n      }\r\n      const [user_id, access_token] = await IBMHTTPClient.authenticate(user, password)\r\n      if (verbose) {\r\n        const obj = JSON.parse(info)\r\n        console.log(`- Running code: ${obj.qasms[0].qasm}`)\r\n      }\r\n      const execution_id = await IBMHTTPClient.run(info, device, user_id, access_token, shots)\r\n      if (verbose) {\r\n        console.log('- Waiting for results...')\r\n      }\r\n      const res = await IBMHTTPClient.getResult(device, execution_id, access_token)\r\n      if (verbose) {\r\n        console.log('- Done.')\r\n      }\r\n      return res\r\n    } catch (e) {\r\n      console.log(e)\r\n    }\r\n  }\r\n\r\n  static async authenticate(email = '', password = '') {\r\n    const result = await axios.post(`${_api_url}users/login`, {email, password})\r\n    const {userId, id} = result.data\r\n    return [userId, id]\r\n  }\r\n\r\n  static async run(qasm, device, user_id, access_token, shots) {\r\n    const suffix = 'Jobs'\r\n    const params = {\r\n      'access_token': access_token,\r\n      'deviceRunType': device,\r\n      'fromCache': 'false',\r\n      'shots': shots\r\n    }\r\n    const resp = await axios({\r\n      method: 'post',\r\n      url: `${_api_url}${suffix}`,\r\n      headers: {'Content-Type': 'application/json'},\r\n      data: qasm,\r\n      params\r\n    })\r\n\r\n    return resp.data.id\r\n  }\r\n\r\n  static async getResult(device, execution_id, access_token, num_retries = 3000,\r\n    interval = 1) {\r\n    const suffix = `Jobs/${execution_id}`\r\n    const status_url = `${_api_url}Backends/${device}/queue/status`\r\n\r\n    console.log(`Waiting for results. [Job ID: ${execution_id}]`)\r\n\r\n    for (let retries = 0; retries < num_retries; ++retries) {\r\n      const resp = await axios.get(`${_api_url}${suffix}`, {params: {access_token}})\r\n      const {data} = resp\r\n      const {qasms} = data\r\n      if (qasms) {\r\n        const {result} = qasms[0]\r\n        if (result) {\r\n          return result\r\n        }\r\n      }\r\n      await IBMHTTPClient.sleep(interval)\r\n      if (['ibmqx4', 'ibmqx5'].includes(device) && retries % 60 === 0) {\r\n        const stateResp = await axios.get(status_url)\r\n        const {state, lengthQueue} = stateResp.data\r\n        if (typeof state !== 'undefined' && !state) {\r\n          throw new Error(`Device went offline. The ID of your submitted job is ${execution_id}`)\r\n        }\r\n\r\n        if (lengthQueue) {\r\n          console.log(`Currently there are ${lengthQueue} jobs queued for execution on ${device}.`)\r\n        }\r\n      }\r\n    }\r\n    throw new Error(`Timeout. The ID of your submitted job is ${execution_id}.`)\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/backends/ibm/ibmhttpclient.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 137,
    "kind": "variable",
    "name": "_api_url",
    "memberof": "src/backends/ibm/ibmhttpclient.js",
    "static": true,
    "longname": "src/backends/ibm/ibmhttpclient.js~_api_url",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/backends/ibm/ibmhttpclient.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 138,
    "kind": "class",
    "name": "IBMHTTPClient",
    "memberof": "src/backends/ibm/ibmhttpclient.js",
    "static": true,
    "longname": "src/backends/ibm/ibmhttpclient.js~IBMHTTPClient",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/backends/ibm/ibmhttpclient.js",
    "importStyle": "IBMHTTPClient",
    "description": "",
    "lineNumber": 22,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "IBMHTTPClient"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 139,
    "kind": "method",
    "name": "isOnline",
    "memberof": "src/backends/ibm/ibmhttpclient.js~IBMHTTPClient",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/backends/ibm/ibmhttpclient.js~IBMHTTPClient.isOnline",
    "access": "public",
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "params": [
      {
        "name": "device",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 140,
    "kind": "method",
    "name": "retrieve",
    "memberof": "src/backends/ibm/ibmhttpclient.js~IBMHTTPClient",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/backends/ibm/ibmhttpclient.js~IBMHTTPClient.retrieve",
    "access": "public",
    "description": "Retrieves a previously run job by its ID.",
    "lineNumber": 37,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "device",
        "description": "Device on which the code was run / is running."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": "IBM quantum experience user (e-mail)"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "password",
        "description": "IBM quantum experience password"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "jobid",
        "description": "Id of the job to retrieve"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 141,
    "kind": "method",
    "name": "sleep",
    "memberof": "src/backends/ibm/ibmhttpclient.js~IBMHTTPClient",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/backends/ibm/ibmhttpclient.js~IBMHTTPClient.sleep",
    "access": "public",
    "description": null,
    "lineNumber": 42,
    "undocument": true,
    "params": [
      {
        "name": "interval",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 142,
    "kind": "method",
    "name": "send",
    "memberof": "src/backends/ibm/ibmhttpclient.js~IBMHTTPClient",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/backends/ibm/ibmhttpclient.js~IBMHTTPClient.send",
    "access": "public",
    "description": "Sends QASM through the IBM API and runs the quantum circuit.",
    "lineNumber": 60,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "info",
        "description": "Contains QASM representation of the circuit to run."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "device",
        "description": "Either 'simulator', 'ibmqx4', or 'ibmqx5'."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": "IBM quantum experience user."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "password",
        "description": "IBM quantum experience user password."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "shots",
        "description": "Number of runs of the same circuit to collect statistics."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "verbose",
        "description": "If true, additional information is printed, such as\nmeasurement statistics. Otherwise, the backend simply registers\none measurement result (same behavior as the projectq Simulator)."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 143,
    "kind": "method",
    "name": "authenticate",
    "memberof": "src/backends/ibm/ibmhttpclient.js~IBMHTTPClient",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/backends/ibm/ibmhttpclient.js~IBMHTTPClient.authenticate",
    "access": "public",
    "description": null,
    "lineNumber": 92,
    "undocument": true,
    "params": [
      {
        "name": "email",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": "",
        "defaultValue": ""
      },
      {
        "name": "password",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": "",
        "defaultValue": ""
      }
    ],
    "return": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 144,
    "kind": "method",
    "name": "run",
    "memberof": "src/backends/ibm/ibmhttpclient.js~IBMHTTPClient",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/backends/ibm/ibmhttpclient.js~IBMHTTPClient.run",
    "access": "public",
    "description": null,
    "lineNumber": 98,
    "undocument": true,
    "params": [
      {
        "name": "qasm",
        "types": [
          "*"
        ]
      },
      {
        "name": "device",
        "types": [
          "*"
        ]
      },
      {
        "name": "user_id",
        "types": [
          "*"
        ]
      },
      {
        "name": "access_token",
        "types": [
          "*"
        ]
      },
      {
        "name": "shots",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 145,
    "kind": "method",
    "name": "getResult",
    "memberof": "src/backends/ibm/ibmhttpclient.js~IBMHTTPClient",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/backends/ibm/ibmhttpclient.js~IBMHTTPClient.getResult",
    "access": "public",
    "description": null,
    "lineNumber": 117,
    "undocument": true,
    "params": [
      {
        "name": "device",
        "types": [
          "*"
        ]
      },
      {
        "name": "execution_id",
        "types": [
          "*"
        ]
      },
      {
        "name": "access_token",
        "types": [
          "*"
        ]
      },
      {
        "name": "num_retries",
        "optional": true,
        "types": [
          "number"
        ],
        "defaultRaw": 3000,
        "defaultValue": "3000"
      },
      {
        "name": "interval",
        "optional": true,
        "types": [
          "number"
        ],
        "defaultRaw": 1,
        "defaultValue": "1"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 146,
    "kind": "file",
    "name": "src/backends/printer.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/*\r\nContains a compiler engine which prints commands to stdout prior to sending\r\nthem on to the next engines (see CommandPrinter).\r\n*/\r\nimport assert from 'assert'\r\nimport {BasicEngine} from '../cengines/basics'\r\nimport {FlushGate, Measure} from '../ops/gates'\r\nimport {LogicalQubitIDTag} from '../meta/tag'\r\nimport {BasicQubit} from '../types/qubit'\r\nimport { LastEngineError } from '../meta/error'\r\n\r\n/**\r\n * @class CommandPrinter\r\n * @desc\r\n * CommandPrinter is a compiler engine which prints commands to stdout prior\r\n * to sending them on to the next compiler engine.\r\n */\r\nexport default class CommandPrinter extends BasicEngine {\r\n  /**\r\n   * @constructor\r\n  @param {boolean} acceptInput If accept_input is true, the printer queries\r\n  the user to input measurement results if the CommandPrinter is\r\n  the last engine. Otherwise, all measurements yield\r\n  @param {boolean} defaultMeasure Default measurement result (if accept_input is false).\r\n  @param {boolean} inPlace If in_place is true, all output is written on the same line of the terminal.\r\n  */\r\n  constructor(acceptInput = true, defaultMeasure = false, inPlace = false) {\r\n    super()\r\n    this._acceptInput = acceptInput\r\n    this._defaultMeasure = defaultMeasure\r\n    this._inPlace = inPlace\r\n  }\r\n\r\n  /**\r\n    Specialized implementation of isAvailable: Returns true if the\r\n    CommandPrinter is the last engine (since it can print any command).\r\n\r\n    @param {Command} cmd Command of which to check availability (all Commands can be printed).\r\n    @return {boolean} true, unless the next engine cannot handle the Command (if there is a next engine).\r\n   */\r\n  isAvailable(cmd) {\r\n    try {\r\n      return super.isAvailable(cmd)\r\n    } catch (e) {\r\n      if (e instanceof LastEngineError) {\r\n        return true\r\n      }\r\n    }\r\n    return false\r\n  }\r\n\r\n  /**\r\n    Print a command or, if the command is a measurement instruction and\r\n    the CommandPrinter is the last engine in the engine pipeline: Query\r\n    the user for the measurement result (if accept_input = true) / Set\r\n    the result to 0 (if it's false).\r\n\r\n    @param {Command} cmd Command to print.\r\n   */\r\n  printCMD(cmd) {\r\n    if (this.isLastEngine && cmd.gate.equal(Measure)) {\r\n      assert(cmd.controlCount === 0)\r\n      console.log(cmd.toString())\r\n      cmd.qubits.forEach((qureg) => {\r\n        qureg.forEach((qubit) => {\r\n          // ignore input\r\n          const m = this._defaultMeasure\r\n          let logicQubitTag\r\n          cmd.tags.forEach((tag) => {\r\n            if (tag instanceof LogicalQubitIDTag) {\r\n              logicQubitTag = tag\r\n            }\r\n          })\r\n\r\n          if (logicQubitTag) {\r\n            qubit = new BasicQubit(qubit.engine, logicQubitTag.logical_qubit_id)\r\n          }\r\n          this.main.setMeasurementResult(qubit, m)\r\n        })\r\n      })\r\n    } else if (this._inPlace) {\r\n      console.log(`\\0\\r\\t\\x1b[K${cmd.toString()}\\r`)\r\n    } else {\r\n      console.log(cmd.toString())\r\n    }\r\n  }\r\n\r\n  /**\r\n  Receive a list of commands from the previous engine, print the\r\ncommands, and then send them on to the next engine.\r\n\r\n    @param {Command[]} commandList List of Commands to print (and potentially send on to the next engine).\r\n   */\r\n  receive(commandList) {\r\n    commandList.forEach((cmd) => {\r\n      if (!(cmd.gate instanceof FlushGate)) {\r\n        this.printCMD(cmd)\r\n      }\r\n      if (!this.isLastEngine) {\r\n        this.send([cmd])\r\n      }\r\n    })\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/backends/printer.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 147,
    "kind": "class",
    "name": "CommandPrinter",
    "memberof": "src/backends/printer.js",
    "static": true,
    "longname": "src/backends/printer.js~CommandPrinter",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/backends/printer.js",
    "importStyle": "CommandPrinter",
    "description": "CommandPrinter is a compiler engine which prints commands to stdout prior\nto sending them on to the next compiler engine.",
    "lineNumber": 34,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "CommandPrinter"
      }
    ],
    "interface": false,
    "extends": [
      "src/cengines/basics.js~BasicEngine"
    ]
  },
  {
    "__docId__": 148,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/backends/printer.js~CommandPrinter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/printer.js~CommandPrinter#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 43,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "acceptInput",
        "description": "If accept_input is true, the printer queries\nthe user to input measurement results if the CommandPrinter is\nthe last engine. Otherwise, all measurements yield"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "defaultMeasure",
        "description": "Default measurement result (if accept_input is false)."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "inPlace",
        "description": "If in_place is true, all output is written on the same line of the terminal."
      }
    ]
  },
  {
    "__docId__": 149,
    "kind": "member",
    "name": "_acceptInput",
    "memberof": "src/backends/printer.js~CommandPrinter",
    "static": false,
    "longname": "src/backends/printer.js~CommandPrinter#_acceptInput",
    "access": "private",
    "description": null,
    "lineNumber": 45,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 150,
    "kind": "member",
    "name": "_defaultMeasure",
    "memberof": "src/backends/printer.js~CommandPrinter",
    "static": false,
    "longname": "src/backends/printer.js~CommandPrinter#_defaultMeasure",
    "access": "private",
    "description": null,
    "lineNumber": 46,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 151,
    "kind": "member",
    "name": "_inPlace",
    "memberof": "src/backends/printer.js~CommandPrinter",
    "static": false,
    "longname": "src/backends/printer.js~CommandPrinter#_inPlace",
    "access": "private",
    "description": null,
    "lineNumber": 47,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 152,
    "kind": "method",
    "name": "isAvailable",
    "memberof": "src/backends/printer.js~CommandPrinter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/printer.js~CommandPrinter#isAvailable",
    "access": "public",
    "description": "Specialized implementation of isAvailable: Returns true if the\nCommandPrinter is the last engine (since it can print any command).",
    "lineNumber": 57,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": "Command of which to check availability (all Commands can be printed)."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true, unless the next engine cannot handle the Command (if there is a next engine)."
    }
  },
  {
    "__docId__": 153,
    "kind": "method",
    "name": "printCMD",
    "memberof": "src/backends/printer.js~CommandPrinter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/printer.js~CommandPrinter#printCMD",
    "access": "public",
    "description": "Print a command or, if the command is a measurement instruction and\nthe CommandPrinter is the last engine in the engine pipeline: Query\nthe user for the measurement result (if accept_input = true) / Set\nthe result to 0 (if it's false).",
    "lineNumber": 76,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": "Command to print."
      }
    ],
    "return": null
  },
  {
    "__docId__": 154,
    "kind": "method",
    "name": "receive",
    "memberof": "src/backends/printer.js~CommandPrinter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/printer.js~CommandPrinter#receive",
    "access": "public",
    "description": "Receive a list of commands from the previous engine, print the\ncommands, and then send them on to the next engine.",
    "lineNumber": 110,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command[]"
        ],
        "spread": false,
        "optional": false,
        "name": "commandList",
        "description": "List of Commands to print (and potentially send on to the next engine)."
      }
    ],
    "return": null
  },
  {
    "__docId__": 155,
    "kind": "file",
    "name": "src/backends/resource.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport { BasicEngine } from '../cengines/basics'\r\nimport { LastEngineError } from '../meta/error'\r\nimport {\r\n  Allocate, Deallocate, FlushGate, Measure\r\n} from '../ops/gates'\r\nimport { LogicalQubitIDTag } from '../meta/tag'\r\nimport { BasicQubit } from '../types/qubit'\r\n\r\nimport {genString} from '../libs/util'\r\n\r\nfunction parseStringKey(key) {\r\n  return key.split(',')\r\n}\r\n\r\n/**\r\n * @class ResourceCounter\r\n * @desc\r\nResourceCounter is a compiler engine which counts the number of gates and\r\nmax. number of active qubits.\r\n\r\n  Attributes:\r\ngate_counts (dict): Dictionary of gate counts.\r\n  The keys are tuples of the form (cmd.gate, ctrl_cnt), where\r\nctrl_cnt is the number of control qubits.\r\ngate_class_counts (dict): Dictionary of gate class counts.\r\nThe keys are tuples of the form (cmd.gate.__class__, ctrl_cnt),\r\n  where ctrl_cnt is the number of control qubits.\r\nmax_width (int): Maximal width (=max. number of active qubits at any\r\ngiven point).\r\nProperties:\r\n  depth_of_dag (int): It is the longest path in the directed\r\nacyclic graph (DAG) of the program.\r\n */\r\nexport default class ResourceCounter extends BasicEngine {\r\n  /**\r\n   * @constructor\r\n   */\r\n  constructor() {\r\n    super()\r\n    this.gate_counts = {}\r\n    this.gate_class_counts = {}\r\n    this._active_qubits = 0\r\n    this.max_width = 0\r\n    // key: qubit id, depth of this qubit\r\n    this._depth_of_qubit = {}\r\n    this._previous_max_depth = 0\r\n  }\r\n\r\n  /**\r\n    Specialized implementation of isAvailable: Returns true if the\r\n    ResourceCounter is the last engine (since it can count any command).\r\n\r\n    @param {Command} cmd Command for which to check availability (all Commands can be counted).\r\n    @return {boolean} true, unless the next engine cannot handle the Command (if there is a next engine).\r\n   */\r\n  isAvailable(cmd) {\r\n    try {\r\n      return super.isAvailable(cmd)\r\n    } catch (e) {\r\n      if (e instanceof LastEngineError) {\r\n        return true\r\n      }\r\n      return false\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @return {number}\r\n   */\r\n  get depthOfDag() {\r\n    if (this._depth_of_qubit) {\r\n      const current_max = Math.max(...Object.values(this._depth_of_qubit))\r\n      return Math.max(current_max, this._previous_max_depth)\r\n    } else {\r\n      return this._previous_max_depth\r\n    }\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {Command} cmd\r\n   */\r\n  addCMD(cmd) {\r\n    const qid = cmd.qubits[0][0].id\r\n    if (cmd.gate.equal(Allocate)) {\r\n      this._active_qubits += 1\r\n      this._depth_of_qubit[qid] = 0\r\n    } else if (cmd.gate.equal(Deallocate)) {\r\n      this._active_qubits -= 1\r\n      const depth = this._depth_of_qubit[qid]\r\n      this._previous_max_depth = Math.max(this._previous_max_depth, depth)\r\n      delete this._depth_of_qubit[qid]\r\n    } else if (this.isLastEngine && cmd.gate.equal(Measure)) {\r\n      cmd.qubits.forEach((qureg) => {\r\n        qureg.forEach((qubit) => {\r\n          this._depth_of_qubit[qubit.id] += 1\r\n          //  Check if a mapper assigned a different logical id\r\n          let logical_id_tag\r\n          cmd.tags.forEach((tag) => {\r\n            if (tag instanceof LogicalQubitIDTag) {\r\n              logical_id_tag = tag\r\n            }\r\n          })\r\n          if (logical_id_tag) {\r\n            qubit = new BasicQubit(qubit.engine, logical_id_tag.logical_qubit_id)\r\n          }\r\n          this.main.setMeasurementResult(qubit, 0)\r\n        })\r\n      })\r\n    } else {\r\n      const qubit_ids = new Set()\r\n      cmd.allQubits.forEach((qureg) => {\r\n        qureg.forEach((qubit) => {\r\n          qubit_ids.add(qubit.id)\r\n        })\r\n      })\r\n      if (qubit_ids.size === 1) {\r\n        const list = [...qubit_ids]\r\n        this._depth_of_qubit[list[0]] += 1\r\n      } else {\r\n        let max_depth = 0\r\n        qubit_ids.forEach((qubit_id) => {\r\n          max_depth = Math.max(max_depth, this._depth_of_qubit[qubit_id])\r\n        })\r\n\r\n        qubit_ids.forEach(qubit_id => this._depth_of_qubit[qubit_id] = max_depth + 1)\r\n      }\r\n    }\r\n\r\n    this.max_width = Math.max(this.max_width, this._active_qubits)\r\n\r\n    const ctrl_cnt = cmd.controlCount\r\n    const gate_description = [cmd.gate, ctrl_cnt]\r\n    const gate_class_description = [cmd.gate.constructor.name, ctrl_cnt]\r\n\r\n    try {\r\n      const v = this.gate_counts[gate_description] || 0\r\n      this.gate_counts[gate_description] = v + 1\r\n    } catch (e) {\r\n      console.log(e)\r\n      this.gate_counts[gate_description] = 1\r\n    }\r\n\r\n    try {\r\n      const v = this.gate_class_counts[gate_class_description] || 0\r\n      this.gate_class_counts[gate_class_description] = v + 1\r\n    } catch (e) {\r\n      console.log(e)\r\n      this.gate_class_counts[gate_class_description] = 1\r\n    }\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {Command[]} commandList\r\n   */\r\n  receive(commandList) {\r\n    commandList.forEach((cmd) => {\r\n      if (!(cmd.gate instanceof FlushGate)) {\r\n        this.addCMD(cmd)\r\n      }\r\n      if (!this.isLastEngine) {\r\n        this.send([cmd])\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n  Return the string representation of this ResourceCounter.\r\n\r\n  @return {string}\r\n    A summary (string) of resources used, including gates, number of\r\n    calls, and max. number of qubits that were active at the same time.\r\n   */\r\n  toString() {\r\n    if (Object.keys(this.gate_counts).length > 0) {\r\n      const gate_class_list = []\r\n      Object.keys(this.gate_class_counts).forEach((gate_class_description) => {\r\n        const num = this.gate_class_counts[gate_class_description]\r\n        const [gate_class, ctrl_cnt] = parseStringKey(gate_class_description)\r\n        const name = genString('C', ctrl_cnt) + gate_class\r\n        gate_class_list.push(`${name} : ${num}`)\r\n      })\r\n\r\n      const gate_list = []\r\n      Object.keys(this.gate_counts).forEach((gate_description) => {\r\n        const num = this.gate_counts[gate_description]\r\n        const [gate, ctrl_cnt] = parseStringKey(gate_description)\r\n        const name = genString('C', ctrl_cnt) + gate.toString()\r\n        gate_list.push(`${name} : ${num}`)\r\n      })\r\n\r\n      return `Gate class counts:\\n    ${gate_class_list.join('\\n    ')}\\n\\nGate counts:\\n    ${gate_list.join('\\n    ')}\\n\\nMax. width (number of qubits) : ${this.max_width}.`\r\n    } else {\r\n      return '(No quantum resources used)'\r\n    }\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/backends/resource.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 156,
    "kind": "function",
    "name": "parseStringKey",
    "memberof": "src/backends/resource.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/backends/resource.js~parseStringKey",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/backends/resource.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 157,
    "kind": "class",
    "name": "ResourceCounter",
    "memberof": "src/backends/resource.js",
    "static": true,
    "longname": "src/backends/resource.js~ResourceCounter",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/backends/resource.js",
    "importStyle": "ResourceCounter",
    "description": "ResourceCounter is a compiler engine which counts the number of gates and\nmax. number of active qubits.\n\nAttributes:\ngate_counts (dict): Dictionary of gate counts.\nThe keys are tuples of the form (cmd.gate, ctrl_cnt), where\nctrl_cnt is the number of control qubits.\ngate_class_counts (dict): Dictionary of gate class counts.\nThe keys are tuples of the form (cmd.gate.__class__, ctrl_cnt),\nwhere ctrl_cnt is the number of control qubits.\nmax_width (int): Maximal width (=max. number of active qubits at any\ngiven point).\nProperties:\ndepth_of_dag (int): It is the longest path in the directed\nacyclic graph (DAG) of the program.",
    "lineNumber": 50,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "ResourceCounter"
      }
    ],
    "interface": false,
    "extends": [
      "src/cengines/basics.js~BasicEngine"
    ]
  },
  {
    "__docId__": 158,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/backends/resource.js~ResourceCounter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/resource.js~ResourceCounter#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 54,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ]
  },
  {
    "__docId__": 159,
    "kind": "member",
    "name": "gate_counts",
    "memberof": "src/backends/resource.js~ResourceCounter",
    "static": false,
    "longname": "src/backends/resource.js~ResourceCounter#gate_counts",
    "access": "public",
    "description": null,
    "lineNumber": 56,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 160,
    "kind": "member",
    "name": "gate_class_counts",
    "memberof": "src/backends/resource.js~ResourceCounter",
    "static": false,
    "longname": "src/backends/resource.js~ResourceCounter#gate_class_counts",
    "access": "public",
    "description": null,
    "lineNumber": 57,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 161,
    "kind": "member",
    "name": "_active_qubits",
    "memberof": "src/backends/resource.js~ResourceCounter",
    "static": false,
    "longname": "src/backends/resource.js~ResourceCounter#_active_qubits",
    "access": "private",
    "description": null,
    "lineNumber": 58,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 162,
    "kind": "member",
    "name": "max_width",
    "memberof": "src/backends/resource.js~ResourceCounter",
    "static": false,
    "longname": "src/backends/resource.js~ResourceCounter#max_width",
    "access": "public",
    "description": null,
    "lineNumber": 59,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 163,
    "kind": "member",
    "name": "_depth_of_qubit",
    "memberof": "src/backends/resource.js~ResourceCounter",
    "static": false,
    "longname": "src/backends/resource.js~ResourceCounter#_depth_of_qubit",
    "access": "private",
    "description": null,
    "lineNumber": 61,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 164,
    "kind": "member",
    "name": "_previous_max_depth",
    "memberof": "src/backends/resource.js~ResourceCounter",
    "static": false,
    "longname": "src/backends/resource.js~ResourceCounter#_previous_max_depth",
    "access": "private",
    "description": null,
    "lineNumber": 62,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 165,
    "kind": "method",
    "name": "isAvailable",
    "memberof": "src/backends/resource.js~ResourceCounter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/resource.js~ResourceCounter#isAvailable",
    "access": "public",
    "description": "Specialized implementation of isAvailable: Returns true if the\nResourceCounter is the last engine (since it can count any command).",
    "lineNumber": 72,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": "Command for which to check availability (all Commands can be counted)."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true, unless the next engine cannot handle the Command (if there is a next engine)."
    }
  },
  {
    "__docId__": 166,
    "kind": "get",
    "name": "depthOfDag",
    "memberof": "src/backends/resource.js~ResourceCounter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/resource.js~ResourceCounter#depthOfDag",
    "access": "public",
    "description": "",
    "lineNumber": 86,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 167,
    "kind": "method",
    "name": "addCMD",
    "memberof": "src/backends/resource.js~ResourceCounter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/resource.js~ResourceCounter#addCMD",
    "access": "public",
    "description": "",
    "lineNumber": 99,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 172,
    "kind": "method",
    "name": "receive",
    "memberof": "src/backends/resource.js~ResourceCounter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/resource.js~ResourceCounter#receive",
    "access": "public",
    "description": "",
    "lineNumber": 173,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command[]"
        ],
        "spread": false,
        "optional": false,
        "name": "commandList",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 173,
    "kind": "method",
    "name": "toString",
    "memberof": "src/backends/resource.js~ResourceCounter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/resource.js~ResourceCounter#toString",
    "access": "public",
    "description": "Return the string representation of this ResourceCounter.",
    "lineNumber": 191,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "A summary (string) of resources used, including gates, number of\ncalls, and max. number of qubits that were active at the same time."
    },
    "params": []
  },
  {
    "__docId__": 174,
    "kind": "file",
    "name": "src/backends/simulators/classicalsimulator.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport assert from 'assert'\r\nimport bigInt from 'big-integer'\r\nimport { BasicEngine } from '../../cengines/basics'\r\nimport { BasicQubit } from '../../types/qubit'\r\nimport {\r\n  Allocate,\r\n  AllocateQubitGate, Deallocate,\r\n  DeallocateQubitGate,\r\n  FlushGate,\r\n  Measure,\r\n  MeasureGate,\r\n  XGate\r\n} from '../../ops/gates'\r\nimport { BasicMathGate } from '../../ops/basics'\r\nimport { LogicalQubitIDTag } from '../../meta/tag'\r\nimport { instanceOf } from '../../libs/util'\r\n\r\n/**\r\n * @class ClassicalSimulator\r\n * @desc\r\nA simple introspective simulator that only permits classical operations.\r\n\r\n  Allows allocation, deallocation, measuring (no-op), flushing (no-op),\r\n  controls, NOTs, and any BasicMathGate. Supports reading/writing directly\r\nfrom/to bits and registers of bits.\r\n */\r\nexport default class ClassicalSimulator extends BasicEngine {\r\n  /**\r\n   * @constructor\r\n   */\r\n  constructor() {\r\n    super();\r\n    this._state = bigInt(0)\r\n    this._bit_positions = {}\r\n  }\r\n\r\n  /**\r\n  Converts a qubit from a logical to a mapped qubit if there is a mapper.\r\n\r\n  @param {Qubit} qubit Logical quantum bit\r\n   */\r\n  convertLogicalToMappedQubit(qubit) {\r\n    const {mapper} = this.main\r\n    if (mapper) {\r\n      const v = mapper.currentMapping[qubit.id]\r\n      if (typeof v === 'undefined') {\r\n        throw new Error('Unknown qubit id. '\r\n        + 'Please make sure you have called '\r\n        + 'eng.flush().')\r\n      }\r\n      return new BasicQubit(qubit.engine, v)\r\n    } else {\r\n      return qubit\r\n    }\r\n  }\r\n\r\n  /**\r\n  Reads a bit.\r\n\r\n  Note:\r\nIf there is a mapper present in the compiler, this function\r\nautomatically converts from logical qubits to mapped qubits for\r\n  the qureg argument.\r\n\r\n  @param {Qubit} qubit The bit to read.\r\n\r\n  @return {number} 0 if the target bit is off, 1 if it's on.\r\n   */\r\n  readBit(qubit) {\r\n    qubit = this.convertLogicalToMappedQubit(qubit)\r\n    return this.readMappedBit(qubit)\r\n  }\r\n\r\n  // Internal use only. Does not change logical to mapped qubits.\r\n  readMappedBit(mappedQubit) {\r\n    const p = this._bit_positions[mappedQubit.id]\r\n    return this._state.shiftRight(p).and(1).toJSNumber()\r\n  }\r\n\r\n  /**\r\n  Resets/sets a bit to the given value.\r\n\r\n  Note:\r\nIf there is a mapper present in the compiler, this function\r\nautomatically converts from logical qubits to mapped qubits for\r\n  the qureg argument.\r\n\r\n    @param {Qubit} qubit The bit to write.\r\n    @param {boolean|number} value Writes 1 if this value is truthy, else 0.\r\n  */\r\n  writeBit(qubit, value) {\r\n    qubit = this.convertLogicalToMappedQubit(qubit)\r\n    this.writeMappedBit(qubit, value)\r\n  }\r\n\r\n  // Internal use only. Does not change logical to mapped qubits.\r\n  writeMappedBit(mappedQubit, value) {\r\n    const p = this._bit_positions[mappedQubit.id]\r\n    if (value) {\r\n      this._state = this._state.or(bigInt(1).shiftLeft(p))\r\n    } else {\r\n      const temp = bigInt(1).shiftLeft(p).not()\r\n      this._state = this._state.and(temp)\r\n    }\r\n  }\r\n\r\n  /**\r\n  Returns a mask, to compare against the state, with bits from the\r\nregister set to 1 and other bits set to 0.\r\n\r\n@param {Qureg} qureg The bits whose positions should be set.\r\n\r\n  @return {number} The mask.\r\n   */\r\n  mask(qureg) {\r\n    let t = 0\r\n    qureg.forEach(q => t |= 1 << this._bit_positions[q.id])\r\n    return t\r\n  }\r\n\r\n  /**\r\n  Reads a group of bits as a little-endian integer.\r\n\r\n  Note:\r\nIf there is a mapper present in the compiler, this function\r\nautomatically converts from logical qubits to mapped qubits for\r\n  the qureg argument.\r\n\r\n  @param {Qureg} qureg The group of bits to read, in little-endian order.\r\n\r\n  @return {number} Little-endian register value.\r\n   */\r\n  readRegister(qureg) {\r\n    const new_qureg = []\r\n    qureg.forEach(qubit => new_qureg.push(this.convertLogicalToMappedQubit(qubit)))\r\n    return this.readMappedRegister(new_qureg)\r\n  }\r\n\r\n  readMappedRegister(mappedQureg) {\r\n    let t = 0\r\n    mappedQureg.forEach((_, i) => t |= this.readMappedBit(mappedQureg[i]) << i)\r\n    return t\r\n  }\r\n\r\n  /**\r\n  Sets a group of bits to store a little-endian integer value.\r\n\r\n  Note:\r\nIf there is a mapper present in the compiler, this function\r\nautomatically converts from logical qubits to mapped qubits for\r\n  the qureg argument.\r\n\r\n   @param {Qureg} qureg  The bits to write, in little-endian order.\r\n   @param {number} value  The integer value to store. Must fit in the register.\r\n   */\r\n  writeRegister(qureg, value) {\r\n    const new_qureg = []\r\n    qureg.forEach(qubit => new_qureg.push(this.convertLogicalToMappedQubit(qubit)))\r\n    this.writeMappedRegister(new_qureg, value)\r\n  }\r\n\r\n  writeMappedRegister(mappedQureg, value) {\r\n    if (value < 0 || value >= (2 ** mappedQureg.length)) {\r\n      throw new Error(\"Value won't fit in register.\")\r\n    }\r\n    mappedQureg.forEach((_, i) => this.writeMappedBit(mappedQureg[i], (value >> i) & 1))\r\n  }\r\n\r\n  isAvailable(cmd) {\r\n    return instanceOf(cmd.gate, [MeasureGate, AllocateQubitGate, DeallocateQubitGate, BasicMathGate, FlushGate, XGate])\r\n  }\r\n\r\n  receive(commandList) {\r\n    commandList.forEach((cmd) => {\r\n      this.handle(cmd)\r\n    })\r\n    if (!this.isLastEngine) {\r\n      this.send(commandList)\r\n    }\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {Command} cmd\r\n   */\r\n  handle(cmd) {\r\n    if (cmd.gate instanceof FlushGate) {\r\n      return\r\n    }\r\n\r\n    if (cmd.gate.equal(Measure)) {\r\n      cmd.qubits.forEach(qr => qr.forEach((qb) => {\r\n        // Check if a mapper assigned a different logical id\r\n        let logical_id_tag\r\n        cmd.tags.forEach((tag) => {\r\n          if (tag instanceof LogicalQubitIDTag) {\r\n            logical_id_tag = tag\r\n          }\r\n        })\r\n        let log_qb = qb\r\n        if (logical_id_tag) {\r\n          log_qb = new BasicQubit(qb.engine, logical_id_tag.logical_qubit_id)\r\n        }\r\n        this.main.setMeasurementResult(log_qb, this.readMappedBit(qb))\r\n      }))\r\n      return\r\n    }\r\n\r\n    if (cmd.gate.equal(Allocate)) {\r\n      const newID = cmd.qubits[0][0].id\r\n      this._bit_positions[newID] = Object.keys(this._bit_positions).length\r\n      return\r\n    }\r\n    if (cmd.gate.equal(Deallocate)) {\r\n      const old_id = cmd.qubits[0][0].id\r\n      const pos = this._bit_positions[old_id]\r\n      const low = (1 << pos) - 1\r\n      this._state = this._state.and(low).or(this._state.shiftRight(1).and(~low))\r\n      const newpos = {}\r\n      Object.keys(this._bit_positions).forEach((k) => {\r\n        const b = this._bit_positions[k]\r\n        if (b < pos) {\r\n          newpos[k] = b\r\n        } else {\r\n          newpos[k] = b - 1\r\n        }\r\n      })\r\n      this._bit_positions = newpos\r\n      return\r\n    }\r\n\r\n    const controls_mask = this.mask(cmd.controlQubits)\r\n    const meets_controls = this._state.and(controls_mask).eq(bigInt(controls_mask))\r\n\r\n    if (cmd.gate instanceof XGate) {\r\n      assert(cmd.qubits.length === 1 && cmd.qubits[0].length === 1)\r\n      const target = cmd.qubits[0][0]\r\n      if (meets_controls) {\r\n        this.writeMappedBit(target, !this.readMappedBit(target))\r\n      }\r\n      return\r\n    }\r\n\r\n    if (cmd.gate instanceof BasicMathGate) {\r\n      if (meets_controls) {\r\n        const ins = cmd.qubits.map(reg => this.readMappedRegister(reg))\r\n        const outs = cmd.gate.getMathFunction(cmd.qubits)(ins)\r\n        cmd.qubits.forEach((reg, index) => {\r\n          const out = outs[index]\r\n          this.writeMappedRegister(reg, out & ((1 << reg.length) - 1))\r\n        })\r\n      }\r\n      return\r\n    }\r\n    throw new Error('Only support alloc/dealloc/measure/not/math ops.')\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/backends/simulators/classicalsimulator.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 175,
    "kind": "class",
    "name": "ClassicalSimulator",
    "memberof": "src/backends/simulators/classicalsimulator.js",
    "static": true,
    "longname": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/backends/simulators/classicalsimulator.js",
    "importStyle": "ClassicalSimulator",
    "description": "A simple introspective simulator that only permits classical operations.\n\nAllows allocation, deallocation, measuring (no-op), flushing (no-op),\ncontrols, NOTs, and any BasicMathGate. Supports reading/writing directly\nfrom/to bits and registers of bits.",
    "lineNumber": 43,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "ClassicalSimulator"
      }
    ],
    "interface": false,
    "extends": [
      "src/cengines/basics.js~BasicEngine"
    ]
  },
  {
    "__docId__": 176,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 47,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ]
  },
  {
    "__docId__": 177,
    "kind": "member",
    "name": "_state",
    "memberof": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator",
    "static": false,
    "longname": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator#_state",
    "access": "private",
    "description": null,
    "lineNumber": 49,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 178,
    "kind": "member",
    "name": "_bit_positions",
    "memberof": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator",
    "static": false,
    "longname": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator#_bit_positions",
    "access": "private",
    "description": null,
    "lineNumber": 50,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 179,
    "kind": "method",
    "name": "convertLogicalToMappedQubit",
    "memberof": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator#convertLogicalToMappedQubit",
    "access": "public",
    "description": "Converts a qubit from a logical to a mapped qubit if there is a mapper.",
    "lineNumber": 58,
    "params": [
      {
        "nullable": null,
        "types": [
          "Qubit"
        ],
        "spread": false,
        "optional": false,
        "name": "qubit",
        "description": "Logical quantum bit"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 180,
    "kind": "method",
    "name": "readBit",
    "memberof": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator#readBit",
    "access": "public",
    "description": "Reads a bit.\n\nNote:\nIf there is a mapper present in the compiler, this function\nautomatically converts from logical qubits to mapped qubits for\nthe qureg argument.",
    "lineNumber": 85,
    "params": [
      {
        "nullable": null,
        "types": [
          "Qubit"
        ],
        "spread": false,
        "optional": false,
        "name": "qubit",
        "description": "The bit to read."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "0 if the target bit is off, 1 if it's on."
    }
  },
  {
    "__docId__": 181,
    "kind": "method",
    "name": "readMappedBit",
    "memberof": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator#readMappedBit",
    "access": "public",
    "description": null,
    "lineNumber": 91,
    "undocument": true,
    "params": [
      {
        "name": "mappedQubit",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 182,
    "kind": "method",
    "name": "writeBit",
    "memberof": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator#writeBit",
    "access": "public",
    "description": "Resets/sets a bit to the given value.\n\nNote:\nIf there is a mapper present in the compiler, this function\nautomatically converts from logical qubits to mapped qubits for\nthe qureg argument.",
    "lineNumber": 107,
    "params": [
      {
        "nullable": null,
        "types": [
          "Qubit"
        ],
        "spread": false,
        "optional": false,
        "name": "qubit",
        "description": "The bit to write."
      },
      {
        "nullable": null,
        "types": [
          "boolean",
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "Writes 1 if this value is truthy, else 0."
      }
    ],
    "return": null
  },
  {
    "__docId__": 183,
    "kind": "method",
    "name": "writeMappedBit",
    "memberof": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator#writeMappedBit",
    "access": "public",
    "description": null,
    "lineNumber": 113,
    "undocument": true,
    "params": [
      {
        "name": "mappedQubit",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 186,
    "kind": "method",
    "name": "mask",
    "memberof": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator#mask",
    "access": "public",
    "description": "Returns a mask, to compare against the state, with bits from the\nregister set to 1 and other bits set to 0.",
    "lineNumber": 131,
    "params": [
      {
        "nullable": null,
        "types": [
          "Qureg"
        ],
        "spread": false,
        "optional": false,
        "name": "qureg",
        "description": "The bits whose positions should be set."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "The mask."
    }
  },
  {
    "__docId__": 187,
    "kind": "method",
    "name": "readRegister",
    "memberof": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator#readRegister",
    "access": "public",
    "description": "Reads a group of bits as a little-endian integer.\n\nNote:\nIf there is a mapper present in the compiler, this function\nautomatically converts from logical qubits to mapped qubits for\nthe qureg argument.",
    "lineNumber": 149,
    "params": [
      {
        "nullable": null,
        "types": [
          "Qureg"
        ],
        "spread": false,
        "optional": false,
        "name": "qureg",
        "description": "The group of bits to read, in little-endian order."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Little-endian register value."
    }
  },
  {
    "__docId__": 188,
    "kind": "method",
    "name": "readMappedRegister",
    "memberof": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator#readMappedRegister",
    "access": "public",
    "description": null,
    "lineNumber": 155,
    "undocument": true,
    "params": [
      {
        "name": "mappedQureg",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 189,
    "kind": "method",
    "name": "writeRegister",
    "memberof": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator#writeRegister",
    "access": "public",
    "description": "Sets a group of bits to store a little-endian integer value.\n\nNote:\nIf there is a mapper present in the compiler, this function\nautomatically converts from logical qubits to mapped qubits for\nthe qureg argument.",
    "lineNumber": 172,
    "params": [
      {
        "nullable": null,
        "types": [
          "Qureg"
        ],
        "spread": false,
        "optional": false,
        "name": "qureg",
        "description": "The bits to write, in little-endian order."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "The integer value to store. Must fit in the register."
      }
    ],
    "return": null
  },
  {
    "__docId__": 190,
    "kind": "method",
    "name": "writeMappedRegister",
    "memberof": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator#writeMappedRegister",
    "access": "public",
    "description": null,
    "lineNumber": 178,
    "undocument": true,
    "params": [
      {
        "name": "mappedQureg",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 191,
    "kind": "method",
    "name": "isAvailable",
    "memberof": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator#isAvailable",
    "access": "public",
    "description": null,
    "lineNumber": 185,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 192,
    "kind": "method",
    "name": "receive",
    "memberof": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator#receive",
    "access": "public",
    "description": null,
    "lineNumber": 189,
    "undocument": true,
    "params": [
      {
        "name": "commandList",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 193,
    "kind": "method",
    "name": "handle",
    "memberof": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator#handle",
    "access": "public",
    "description": "",
    "lineNumber": 202,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 196,
    "kind": "file",
    "name": "src/backends/simulators/cppsim.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nconst ext = require('../../../scripts/extensions')\r\nconst path = ext.getBinaryPath()\r\n\r\nconst All = require(path)\r\n\r\n/**\r\n * @ignore\r\n */\r\nexport default All\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/backends/simulators/cppsim.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 197,
    "kind": "variable",
    "name": "ext",
    "memberof": "src/backends/simulators/cppsim.js",
    "static": true,
    "longname": "src/backends/simulators/cppsim.js~ext",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/backends/simulators/cppsim.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 198,
    "kind": "variable",
    "name": "path",
    "memberof": "src/backends/simulators/cppsim.js",
    "static": true,
    "longname": "src/backends/simulators/cppsim.js~path",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/backends/simulators/cppsim.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 199,
    "kind": "variable",
    "name": "All",
    "memberof": "src/backends/simulators/cppsim.js",
    "static": true,
    "longname": "src/backends/simulators/cppsim.js~All",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/backends/simulators/cppsim.js",
    "importStyle": "All",
    "description": "",
    "lineNumber": 20,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 200,
    "kind": "file",
    "name": "src/backends/simulators/jssim.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/*\r\nContains a (slow) JavaScript simulator.\r\n\r\n    Please compile the c++ simulator for large-scale simulations.\r\n*/\r\nimport assert from 'assert'\r\nimport math from 'mathjs'\r\nimport {\r\n  matrixDot,\r\n  matrixRangeAssign,\r\n  matrixRangeIndicesAssign,\r\n  zeros\r\n} from '../../libs/util'\r\nimport {\r\n  len, setEqual, complexVectorDot\r\n} from '../../libs/polyfill'\r\nimport { stringToArray } from '../../ops/qubitoperator'\r\n\r\n/**\r\n * @class JSSimulator\r\n * @desc\r\nNodeJS implementation of a quantum computer simulator.\r\n\r\n    This Simulator can be used as a backup if compiling the c++ simulator is\r\nnot an option (for some reason). It has the same features but is much\r\nslower, so please consider building the c++ version for larger experiments.\r\n */\r\nexport default class Simulator {\r\n  /**\r\n   * @constructor\r\n   */\r\n  constructor() {\r\n    // ignore seed\r\n    this._state = math.ones(1)\r\n    this._map = {}\r\n    this._numQubits = 0\r\n  }\r\n\r\n  /**\r\n  Return the qubit index to bit location map and the corresponding state\r\nvector.\r\n\r\n    This function can be used to measure expectation values more efficiently (emulation).\r\n\r\n    @return {Array}\r\nA tuple where the first entry is a dictionary mapping qubit indices\r\nto bit-locations and the second entry is the corresponding state\r\nvector\r\n   */\r\n  cheat() {\r\n    return [this._map, this._state._data.slice(0)]\r\n  }\r\n\r\n  /**\r\n  Measure the qubits with IDs ids and return a list of measurement\r\noutcomes (true/false).\r\n\r\n    @param {number[]} ids List of qubit IDs to measure.\r\n\r\n    @return {boolean[]} List of measurement results (containing either true or false).\r\n   */\r\n  measureQubits(ids) {\r\n    const P = Math.random()\r\n    let val = 0.0\r\n    let i_picked = 0\r\n    while (val < P && i_picked < len(this._state)) {\r\n      val = math.add(val, math.abs(this._getState(i_picked) || math.complex(0, 0)) ** 2)\r\n      i_picked += 1\r\n    }\r\n\r\n    i_picked -= 1\r\n\r\n    const res = []\r\n    const pos = ids.map((ID) => {\r\n      res.push(false)\r\n      return this._map[ID]\r\n    })\r\n\r\n    let mask = 0\r\n    val = 0\r\n\r\n    pos.forEach((looper, i) => {\r\n      res[i] = ((i_picked >> looper) & 1) === 1\r\n      mask |= (1 << looper)\r\n      val |= ((res[i] & 1) << looper)\r\n    })\r\n\r\n    let nrm = 0.0\r\n    this._state.forEach((looper, _i) => {\r\n      const i = _i[0]\r\n      if ((mask & i) !== val) {\r\n        this._setState(i, 0.0)\r\n      } else {\r\n        const tmp = math.abs(looper)\r\n        nrm = math.add(nrm, math.multiply(tmp, tmp))\r\n      }\r\n    })\r\n    // normalize\r\n    const scale = 1.0 / Math.sqrt(nrm)\r\n    this._state = math.multiply(this._state, scale)\r\n    return res\r\n  }\r\n\r\n  /**\r\n  Allocate a qubit.\r\n\r\n    @param {number} ID ID of the qubit which is being allocated.\r\n   */\r\n  allocateQubit(ID) {\r\n    this._map[ID] = this._numQubits\r\n    this._numQubits += 1\r\n    this._state.resize([1 << this._numQubits], 0)\r\n  }\r\n\r\n  /**\r\n  Return the classical value of a classical bit (i.e., a qubit which has\r\nbeen measured / uncomputed).\r\n\r\n   @param {number} ID ID of the qubit of which to get the classical value.\r\n   @param {number} tolerance Tolerance for numerical errors when determining\r\nwhether the qubit is indeed classical.\r\n\r\n    @throws {Error} If the qubit is in a superposition, i.e., has not been measured / uncomputed.\r\n*/\r\n  getClassicalValue(ID, tolerance = 1.e-10) {\r\n    const pos = this._map[ID]\r\n    let up = false\r\n    let down = false\r\n\r\n    for (let i = 0; i < len(this._state); i += (1 << (pos + 1))) {\r\n      for (let j = 0; j < (1 << pos); ++j) {\r\n        if (math.abs(this._getState(i + j)) > tolerance) {\r\n          up = true\r\n        }\r\n\r\n        if (math.abs(this._getState(i + j + (1 << pos)) || 0) > tolerance) {\r\n          down = true\r\n        }\r\n\r\n        if (up && down) {\r\n          throw new Error('Qubit has not been measured / '\r\n          + 'uncomputed. Cannot access its '\r\n          + 'classical value and/or deallocate a '\r\n          + 'qubit in superposition!')\r\n        }\r\n      }\r\n    }\r\n\r\n    return down\r\n  }\r\n\r\n  /**\r\n  Deallocate a qubit (if it has been measured / uncomputed).\r\n\r\n   @param {number} ID ID of the qubit to deallocate.\r\n\r\n   @throws {Error} If the qubit is in a superposition, i.e., has not been measured / uncomputed.\r\n   */\r\n  deallocateQubit(ID) {\r\n    const pos = this._map[ID]\r\n    const cv = this.getClassicalValue(ID)\r\n    const newstate = math.zeros(1 << (this._numQubits - 1))\r\n    let k = 0\r\n    for (let i = (1 << pos) * cv; i < len(this._state); i += 1 << (pos + 1)) {\r\n      matrixRangeIndicesAssign(newstate, k, k + (1 << pos), this._state, i)\r\n      k += (1 << pos)\r\n    }\r\n\r\n    const newmap = {}\r\n    Object.keys(this._map).forEach((key) => {\r\n      const value = this._map[key]\r\n      if (value > pos) {\r\n        newmap[key] = value - 1\r\n      } else if (parseInt(key, 10) !== ID) {\r\n        newmap[key] = value\r\n      }\r\n    })\r\n\r\n    this._map = newmap\r\n    this._state = newstate\r\n    this._numQubits -= 1\r\n  }\r\n\r\n  /**\r\n  Get control mask from list of control qubit IDs.\r\n\r\n    @return {number} A mask which represents the control qubits in binary.\r\n   */\r\n  getControlMask(ctrlids) {\r\n    let mask = 0\r\n    ctrlids.forEach((ctrlid) => {\r\n      const ctrlpos = this._map[ctrlid]\r\n      mask |= (1 << ctrlpos)\r\n    })\r\n    return mask\r\n  }\r\n\r\n  /**\r\n  Emulate a math function (e.g., BasicMathGate).\r\n\r\n    @param {function} f Function executing the operation to emulate.\r\n    @param {Array.<number[]>} qubitIDs List of lists of qubit IDs to which\r\n        the gate is being applied. Every gate is applied to a tuple of\r\n        quantum registers, which corresponds to this 'list of lists'.\r\n    @param {number[]} ctrlQubitIDs List of control qubit ids.\r\n   */\r\n  emulateMath(f, qubitIDs, ctrlQubitIDs) {\r\n    const mask = this.getControlMask(ctrlQubitIDs)\r\n    // determine qubit locations from their IDs\r\n    const qb_locs = []\r\n    qubitIDs.forEach((qureg) => {\r\n      qb_locs.push([])\r\n      qureg.forEach((qubitID) => {\r\n        qb_locs[qb_locs.length - 1].push(this._map[qubitID])\r\n      })\r\n    })\r\n\r\n    const newstate = math.zeros(len(this._state))\r\n\r\n    this._state.forEach((looper, _i) => {\r\n      const i = _i[0]\r\n      if ((mask & i) === mask) {\r\n        const argList = zeros(qb_locs.length)\r\n        qb_locs.forEach((qb, qri) => {\r\n          qb.forEach((il, qi) => {\r\n            argList[qri] |= (((i >> il) & 1) << qi)\r\n          })\r\n        })\r\n\r\n        const res = f(argList)\r\n        let newI = i\r\n\r\n        qb_locs.forEach((qb, qri) => {\r\n          qb.forEach((il, qi) => {\r\n            if (!(((newI >> il) & 1) == ((res[qri] >> qi) & 1))) {\r\n              newI ^= (1 << il)\r\n            }\r\n          })\r\n        })\r\n        newstate.subset(math.index(newI), looper)\r\n      } else {\r\n        newstate.subset(math.index(i), looper)\r\n      }\r\n    })\r\n\r\n    this._state = newstate\r\n  }\r\n\r\n  /**\r\n  Return the expectation value of a qubit operator w.r.t. qubit ids.\r\n\r\n    @param {Array.<Array>} termsArray Operator Array (see QubitOperator.terms)\r\n    @param {number[]} IDs List of qubit ids upon which the operator acts.\r\n\r\n    @return Expectation value\r\n   */\r\n  getExpectationValue(termsArray, IDs) {\r\n    let expectation = 0.0\r\n    const current_state = math.clone(this._state)\r\n    termsArray.forEach(([term, coefficient]) => {\r\n      this.applyTerm(term, IDs)\r\n      const tmp = complexVectorDot(current_state, this._state)\r\n      const delta = math.multiply(coefficient, tmp)\r\n      expectation = math.add(expectation, delta)\r\n      this._state = math.clone(current_state)\r\n    })\r\n    if (math.im(expectation) === 0) {\r\n      return math.re(expectation)\r\n    }\r\n    return expectation\r\n  }\r\n\r\n  /**\r\n  Apply a (possibly non-unitary) qubit operator to qubits.\r\n\r\n    @param {Array.<Array>} termsArray Operator array (see QubitOperator.terms)\r\n    @param {number[]} IDs List of qubit ids upon which the operator acts.\r\n  */\r\n  applyQubitOperator(termsArray, IDs) {\r\n    let new_state = math.zeros(len(this._state))\r\n    const current_state = math.clone(this._state)\r\n    termsArray.forEach(([term, coefficient]) => {\r\n      this.applyTerm(term, IDs)\r\n      const temp = math.multiply(this._state, coefficient)\r\n      new_state = math.add(new_state, temp)\r\n      this._state = math.clone(current_state)\r\n    })\r\n    this._state = new_state\r\n  }\r\n\r\n  /**\r\n  Return the probability of the outcome `bit_string` when measuring\r\nthe qubits given by the list of ids.\r\n\r\n    @param {boolean[]|number[]} bitString Measurement outcome.\r\n    @param {number[]} IDs List of qubit ids determining the ordering.\r\n\r\n    @return Probability of measuring the provided bit string.\r\n\r\n    @throws {Error} if an unknown qubit id was provided.\r\n   */\r\n  getProbability(bitString, IDs) {\r\n    const n = IDs.length\r\n    for (let i = 0; i < n; ++i) {\r\n      const id = IDs[i]\r\n      const v = this._map[id]\r\n      if (typeof v === 'undefined') {\r\n        throw new Error('get_probability(): Unknown qubit id. '\r\n        + 'Please make sure you have called '\r\n        + 'eng.flush().')\r\n      }\r\n    }\r\n    let mask = 0\r\n    let bit_str = 0\r\n    for (let i = 0; i < n; ++i) {\r\n      mask |= (1 << this._map[IDs[i]])\r\n      bit_str |= (bitString[i] << this._map[IDs[i]])\r\n    }\r\n\r\n    let probability = 0.0\r\n\r\n    this._state.forEach((val, _i) => {\r\n      const i = _i[0]\r\n      if ((i & mask) === bit_str) {\r\n        const e = val\r\n        probability += math.re(e) ** 2 + math.im(e) ** 2\r\n      }\r\n    })\r\n    return probability\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   * @param i\r\n   * @return {*}\r\n   * @private\r\n   */\r\n  _getState(i) {\r\n    return this._state.subset(math.index(i))\r\n  }\r\n\r\n  /**\r\n   * @ignore\r\n   * @param i\r\n   * @param value\r\n   * @private\r\n   */\r\n  _setState(i, value) {\r\n    this._state.subset(math.index(i), value)\r\n  }\r\n\r\n  /**\r\n  Return the probability amplitude of the supplied `bit_string`.\r\n    The ordering is given by the list of qubit ids.\r\n\r\n   @param {boolean[]|number[]} bitString Computational basis state\r\n   @param {number[]} IDs List of qubit ids determining the ordering. Must contain all allocated qubits.\r\n\r\n    @return Probability amplitude of the provided bit string.\r\n\r\n    @throws {Error} if the second argument is not a permutation of all allocated qubits.\r\n   */\r\n  getAmplitude(bitString, IDs) {\r\n    const s1 = new Set(IDs)\r\n    const s2 = new Set(Object.keys(this._map).map(k => parseInt(k, 10)))\r\n    if (!setEqual(s1, s2)) {\r\n      throw new Error('The second argument to get_amplitude() must'\r\n      + ' be a permutation of all allocated qubits. '\r\n      + 'Please make sure you have called '\r\n      + 'eng.flush().')\r\n    }\r\n    let index = 0\r\n    IDs.forEach((item, i) => {\r\n      item = parseInt(item, 10)\r\n      index |= (bitString[i] << this._map[item])\r\n    })\r\n    const ret = this._getState(index)\r\n    return ret\r\n  }\r\n\r\n  /**\r\nApplies exp(-i*time*H) to the wave function, i.e., evolves under\r\nthe Hamiltonian H for a given time. The terms in the Hamiltonian\r\nare not required to commute.\r\n\r\n    This function computes the action of the matrix exponential using\r\nideas from Al-Mohy and Higham, 2011.\r\nTODO: Implement better estimates for s.\r\n\r\n   @param {Array.<Array>} terms_dict Operator dictionary (see QubitOperator.terms) defining the Hamiltonian.\r\n   @param {number} time Time to evolve for\r\n   @param {number[]} ids A list of qubit IDs to which to apply the evolution.\r\n   @param {number[]} ctrlids A list of control qubit IDs.\r\n  */\r\n  emulateTimeEvolution(terms_dict, time, ids, ctrlids) {\r\n    // Determine the (normalized) trace, which is nonzero only for identity\r\n  // terms:\r\n    let tr = 0\r\n    let sum = 0\r\n    const newTerms = []\r\n    terms_dict.forEach(([t, c]) => {\r\n      if (t.length === 0) {\r\n        tr += c\r\n      } else {\r\n        newTerms.push([t, c])\r\n        sum += Math.abs(c)\r\n      }\r\n    })\r\n\r\n    terms_dict = newTerms\r\n    const op_nrm = math.abs(time) * sum\r\n    // rescale the operator by s:\r\n    const s = Math.floor(op_nrm + 1)\r\n    const correction = math.exp(math.complex(0, -time * tr / (s * 1.0)))\r\n    const output_state = math.clone(this._state)\r\n    const mask = this.getControlMask(ctrlids)\r\n\r\n    for (let i = 0; i < s; ++i) {\r\n      let j = 0\r\n      let nrm_change = 1.0\r\n      let update\r\n      while (nrm_change > 1.e-12) {\r\n        const coeff = math.divide(math.complex(0, -time), s * (j + 1))\r\n        const current_state = math.clone(this._state)\r\n        update = 0\r\n        terms_dict.forEach(([t, c]) => {\r\n          this.applyTerm(t, ids)\r\n          this._state = math.multiply(this._state, c)\r\n\r\n          update = math.add(this._state, update)\r\n          // update += this._state\r\n          this._state = math.clone(current_state)\r\n        })\r\n        update = math.multiply(update, coeff)\r\n        this._state = update\r\n\r\n        update.forEach((value, [m]) => {\r\n          if ((m & mask) === mask) {\r\n            const idx = math.index(m)\r\n            const v = math.add(output_state.subset(idx), value)\r\n            output_state.subset(idx, v)\r\n          }\r\n        })\r\n        nrm_change = math.norm(update)\r\n        j += 1\r\n      }\r\n\r\n      update.forEach((value, [k]) => {\r\n        if ((k & mask) === mask) {\r\n          const idx = math.index(k)\r\n          const v = math.multiply(output_state.subset(idx), correction)\r\n          output_state.subset(idx, v)\r\n        }\r\n      })\r\n      this._state = math.clone(output_state)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * leave it empty to keep same API with cpp simulator\r\n   */\r\n  run() {\r\n    //\r\n  }\r\n\r\n  /**\r\n  Applies a QubitOperator term to the state vector. (Helper function for time evolution & expectation)\r\n\r\n    @param {Array} term One term of QubitOperator.terms\r\n    @param {number[]} ids Term index to Qubit ID mapping\r\n    @param {number[]} controlIDs Control qubit IDs\r\n  */\r\n  applyTerm(term, ids, controlIDs = []) {\r\n    const X = [[0.0, 1.0], [1.0, 0.0]]\r\n    const Y = [[0.0, math.complex(0, -1)], [math.complex(0, 1), 0.0]]\r\n    const Z = [[1.0, 0.0], [0.0, -1.0]]\r\n    const gates = {X, Y, Z}\r\n    term.forEach((local_op) => {\r\n      const qb_id = ids[local_op[0]]\r\n      this.applyControlledGate(gates[local_op[1]], [qb_id], controlIDs)\r\n    })\r\n  }\r\n\r\n  /**\r\n  Applies the k-qubit gate matrix m to the qubits with indices ids,\r\n    using ctrlids as control qubits.\r\n\r\n    @param {Array.<Array.<number>>} m 2^k x 2^k complex matrix describing the k-qubit gate.\r\n    @param {number[]} ids A list containing the qubit IDs to which to apply the gate.\r\n    @param {number[]} ctrlids A list of control qubit IDs (i.e., the gate is only applied where these qubits are 1).\r\n   */\r\n  applyControlledGate(m, ids, ctrlids) {\r\n    const mask = this.getControlMask(ctrlids)\r\n    if (len(m) === 2) {\r\n      const k = ids[0]\r\n      const pos = this._map[k] || this._map[k.toString()]\r\n      this._singleQubitGate(m, pos, mask)\r\n    } else {\r\n      const pos = ids.map(ID => this._map[ID])\r\n      this._multiQubitGate(m, pos, mask)\r\n    }\r\n  }\r\n\r\n  /**\r\n  Applies the single qubit gate matrix m to the qubit at position `pos`\r\nusing `mask` to identify control qubits.\r\n\r\n   @param {Array.<Array.<number>>} m 2x2 complex matrix describing the single-qubit gate.\r\n    @param {number} pos Bit-position of the qubit.\r\n    @param {number} mask Bit-mask where set bits indicate control qubits.\r\n   */\r\n  _singleQubitGate(m, pos, mask) {\r\n    const kernel = (u, d, m) => {\r\n      const ma = math.add\r\n      const mm = math.multiply\r\n      d = d || math.complex(0, 0)\r\n      u = u || math.complex(0, 0)\r\n      const r1 = ma(mm(u, m[0][0]), mm(d, m[0][1]))\r\n      const r2 = ma(mm(u, m[1][0]), mm(d, m[1][1]))\r\n      return [r1, r2]\r\n    }\r\n\r\n    const step = 1 << (pos + 1)\r\n    for (let i = 0; i < len(this._state); i += step) {\r\n      for (let j = 0; j < (1 << pos); ++j) {\r\n        if (((i + j) & mask) === mask) {\r\n          const id1 = i + j\r\n          const id2 = id1 + (1 << pos)\r\n          const [r1, r2] = kernel(this._getState(id1), this._getState(id2), m)\r\n          this._setState(id1, r1)\r\n          this._setState(id2, r2)\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n  Applies the k-qubit gate matrix m to the qubits at `pos`\r\nusing `mask` to identify control qubits.\r\n\r\n   @param {Array.<number[]>} m 2^k x 2^k complex matrix describing the k-qubit gate.\r\n   @param {number[]} pos List of bit-positions of the qubits.\r\n   @param {number} mask Bit-mask where set bits indicate control qubits.\r\n   see follows the description in https://arxiv.org/abs/1704.01127\r\n   */\r\n  _multiQubitGate(m, pos, mask) {\r\n    const inactive = Object.keys(this._map).map(k => parseInt(k, 10)).filter(p => !pos.includes(p))\r\n\r\n    const matrix = math.matrix(m)\r\n    const subvec = zeros(1 << pos.length)\r\n    const subvec_idx = zeros(subvec.length)\r\n    for (let c = 0; c < (1 << inactive.length); ++c) {\r\n      // determine base index (state of inactive qubits)\r\n      let base = 0\r\n      for (let i = 0; i < inactive.length; ++i) {\r\n        base |= ((c >> i) & 1) << inactive[i]\r\n      }\r\n\r\n      // check the control mask\r\n      if (mask !== (base & mask)) {\r\n        continue\r\n      }\r\n      // now gather all elements involved in mat-vec mul\r\n      for (let x = 0; x < subvec_idx.length; ++x) {\r\n        let offset = 0\r\n        for (let i = 0; i < pos.length; ++i) {\r\n          offset |= ((x >> i) & 1) << pos[i]\r\n        }\r\n        subvec_idx[x] = base | offset\r\n        subvec[x] = this._getState(subvec_idx[x]) || math.complex(0, 0)\r\n      }\r\n\r\n      // perform mat-vec mul\r\n      matrixRangeAssign(this._state, subvec_idx, matrixDot(matrix, subvec))\r\n    }\r\n  }\r\n\r\n  /**\r\n  Set wavefunction and qubit ordering.\r\n\r\n    @param {Complex[]} wavefunction Array of complex amplitudes describing the wavefunction (must be normalized).\r\n    @param {Array} ordering List of ids describing the new ordering of qubits\r\n(i.e., the ordering of the provided wavefunction).\r\n   */\r\n  setWavefunction(wavefunction, ordering) {\r\n    // wavefunction contains 2^n values for n qubits\r\n    assert(wavefunction.length === (1 << ordering.length))\r\n\r\n    // all qubits must have been allocated before\r\n    const f1 = ordering.filter((Id) => {\r\n      const v = this._map[Id]\r\n      return typeof v !== 'undefined'\r\n    }).length === ordering.length\r\n    const f2 = len(this._map) === ordering.length\r\n    if (!f1 || !f2) {\r\n      throw new Error('set_wavefunction(): Invalid mapping provided.'\r\n      + ' Please make sure all qubits have been '\r\n      + 'allocated previously (call eng.flush()).')\r\n    }\r\n\r\n    this._state = math.matrix(wavefunction)\r\n    const map = {}\r\n    for (let i = 0; i < ordering.length; ++i) {\r\n      map[ordering[i]] = i\r\n    }\r\n    this._map = map\r\n  }\r\n\r\n  /**\r\n  Collapse a quantum register onto a classical basis state.\r\n\r\n    @param {number[]} ids Qubit IDs to collapse.\r\n    @param {boolean[]} values Measurement outcome for each of the qubit IDs in `ids`.\r\n    @throws {Error} If probability of outcome is ~0 or unknown qubits are provided.\r\n   */\r\n  collapseWavefunction(ids, values) {\r\n    assert(ids.length === values.length)\r\n\r\n    // all qubits must have been allocated before\r\n    const f1 = ids.filter(Id => typeof this._map[Id] !== 'undefined').length === ids.length\r\n    if (!f1) {\r\n      throw new Error('collapse_wavefunction(): Unknown qubit id(s)'\r\n        + ' provided. Try calling eng.flush() before '\r\n        + 'invoking this function.')\r\n    }\r\n\r\n    let mask = 0\r\n    let val = 0\r\n    ids.forEach((looper, i) => {\r\n      const pos = this._map[looper]\r\n      mask |= (1 << pos)\r\n      val |= (Math.floor(values[i]) << pos)\r\n    })\r\n\r\n    let nrm = 0.0\r\n    this._state.forEach((looper, _i) => {\r\n      const i = _i[0]\r\n      if ((mask & i) === val) {\r\n        nrm += math.abs(this._getState(i)) ** 2\r\n      }\r\n    })\r\n\r\n    if (nrm < 1.e-12) {\r\n      throw new Error('collapse_wavefunction(): Invalid collapse! Probability is ~0.')\r\n    }\r\n    const inv_nrm = 1.0 / math.sqrt(nrm)\r\n    this._state.forEach((looper, _i) => {\r\n      const i = _i[0]\r\n      if ((mask & i) !== val) {\r\n        this._setState(i, 0)\r\n      } else {\r\n        this._setState(i, math.multiply(looper, inv_nrm))\r\n      }\r\n    })\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/backends/simulators/jssim.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 201,
    "kind": "class",
    "name": "Simulator",
    "memberof": "src/backends/simulators/jssim.js",
    "static": true,
    "longname": "src/backends/simulators/jssim.js~Simulator",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/backends/simulators/jssim.js",
    "importStyle": "Simulator",
    "description": "NodeJS implementation of a quantum computer simulator.\n\nThis Simulator can be used as a backup if compiling the c++ simulator is\nnot an option (for some reason). It has the same features but is much\nslower, so please consider building the c++ version for larger experiments.",
    "lineNumber": 44,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "JSSimulator"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 202,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/backends/simulators/jssim.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/jssim.js~Simulator#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 48,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ]
  },
  {
    "__docId__": 203,
    "kind": "member",
    "name": "_state",
    "memberof": "src/backends/simulators/jssim.js~Simulator",
    "static": false,
    "longname": "src/backends/simulators/jssim.js~Simulator#_state",
    "access": "private",
    "description": null,
    "lineNumber": 50,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 204,
    "kind": "member",
    "name": "_map",
    "memberof": "src/backends/simulators/jssim.js~Simulator",
    "static": false,
    "longname": "src/backends/simulators/jssim.js~Simulator#_map",
    "access": "private",
    "description": null,
    "lineNumber": 51,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 205,
    "kind": "member",
    "name": "_numQubits",
    "memberof": "src/backends/simulators/jssim.js~Simulator",
    "static": false,
    "longname": "src/backends/simulators/jssim.js~Simulator#_numQubits",
    "access": "private",
    "description": null,
    "lineNumber": 52,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 206,
    "kind": "method",
    "name": "cheat",
    "memberof": "src/backends/simulators/jssim.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/jssim.js~Simulator#cheat",
    "access": "public",
    "description": "Return the qubit index to bit location map and the corresponding state\nvector.\n\nThis function can be used to measure expectation values more efficiently (emulation).",
    "lineNumber": 66,
    "return": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": "A tuple where the first entry is a dictionary mapping qubit indices\nto bit-locations and the second entry is the corresponding state\nvector"
    },
    "params": []
  },
  {
    "__docId__": 207,
    "kind": "method",
    "name": "measureQubits",
    "memberof": "src/backends/simulators/jssim.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/jssim.js~Simulator#measureQubits",
    "access": "public",
    "description": "Measure the qubits with IDs ids and return a list of measurement\noutcomes (true/false).",
    "lineNumber": 78,
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "ids",
        "description": "List of qubit IDs to measure."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean[]"
      ],
      "spread": false,
      "description": "List of measurement results (containing either true or false)."
    }
  },
  {
    "__docId__": 209,
    "kind": "method",
    "name": "allocateQubit",
    "memberof": "src/backends/simulators/jssim.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/jssim.js~Simulator#allocateQubit",
    "access": "public",
    "description": "Allocate a qubit.",
    "lineNumber": 125,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "ID",
        "description": "ID of the qubit which is being allocated."
      }
    ],
    "return": null
  },
  {
    "__docId__": 211,
    "kind": "method",
    "name": "getClassicalValue",
    "memberof": "src/backends/simulators/jssim.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/jssim.js~Simulator#getClassicalValue",
    "access": "public",
    "description": "Return the classical value of a classical bit (i.e., a qubit which has\nbeen measured / uncomputed).",
    "lineNumber": 141,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "ID",
        "description": "ID of the qubit of which to get the classical value."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "tolerance",
        "description": "Tolerance for numerical errors when determining\nwhether the qubit is indeed classical."
      }
    ],
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If the qubit is in a superposition, i.e., has not been measured / uncomputed."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 212,
    "kind": "method",
    "name": "deallocateQubit",
    "memberof": "src/backends/simulators/jssim.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/jssim.js~Simulator#deallocateQubit",
    "access": "public",
    "description": "Deallocate a qubit (if it has been measured / uncomputed).",
    "lineNumber": 175,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "ID",
        "description": "ID of the qubit to deallocate."
      }
    ],
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If the qubit is in a superposition, i.e., has not been measured / uncomputed."
      }
    ],
    "return": null
  },
  {
    "__docId__": 216,
    "kind": "method",
    "name": "getControlMask",
    "memberof": "src/backends/simulators/jssim.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/jssim.js~Simulator#getControlMask",
    "access": "public",
    "description": "Get control mask from list of control qubit IDs.",
    "lineNumber": 205,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "A mask which represents the control qubits in binary."
    },
    "params": [
      {
        "name": "ctrlids",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 217,
    "kind": "method",
    "name": "emulateMath",
    "memberof": "src/backends/simulators/jssim.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/jssim.js~Simulator#emulateMath",
    "access": "public",
    "description": "Emulate a math function (e.g., BasicMathGate).",
    "lineNumber": 223,
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "f",
        "description": "Function executing the operation to emulate."
      },
      {
        "nullable": null,
        "types": [
          "Array.<number[]>"
        ],
        "spread": false,
        "optional": false,
        "name": "qubitIDs",
        "description": "List of lists of qubit IDs to which\nthe gate is being applied. Every gate is applied to a tuple of\nquantum registers, which corresponds to this 'list of lists'."
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "ctrlQubitIDs",
        "description": "List of control qubit ids."
      }
    ],
    "return": null
  },
  {
    "__docId__": 219,
    "kind": "method",
    "name": "getExpectationValue",
    "memberof": "src/backends/simulators/jssim.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/jssim.js~Simulator#getExpectationValue",
    "access": "public",
    "description": "Return the expectation value of a qubit operator w.r.t. qubit ids.",
    "lineNumber": 273,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array.<Array>"
        ],
        "spread": false,
        "optional": false,
        "name": "termsArray",
        "description": "Operator Array (see QubitOperator.terms)"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "IDs",
        "description": "List of qubit ids upon which the operator acts."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "Expectation value"
    }
  },
  {
    "__docId__": 221,
    "kind": "method",
    "name": "applyQubitOperator",
    "memberof": "src/backends/simulators/jssim.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/jssim.js~Simulator#applyQubitOperator",
    "access": "public",
    "description": "Apply a (possibly non-unitary) qubit operator to qubits.",
    "lineNumber": 295,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array.<Array>"
        ],
        "spread": false,
        "optional": false,
        "name": "termsArray",
        "description": "Operator array (see QubitOperator.terms)"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "IDs",
        "description": "List of qubit ids upon which the operator acts."
      }
    ],
    "return": null
  },
  {
    "__docId__": 224,
    "kind": "method",
    "name": "getProbability",
    "memberof": "src/backends/simulators/jssim.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/jssim.js~Simulator#getProbability",
    "access": "public",
    "description": "Return the probability of the outcome `bit_string` when measuring\nthe qubits given by the list of ids.",
    "lineNumber": 318,
    "params": [
      {
        "nullable": null,
        "types": [
          "boolean[]",
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "bitString",
        "description": "Measurement outcome."
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "IDs",
        "description": "List of qubit ids determining the ordering."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "Probability of measuring the provided bit string."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "if an unknown qubit id was provided."
      }
    ]
  },
  {
    "__docId__": 225,
    "kind": "method",
    "name": "_getState",
    "memberof": "src/backends/simulators/jssim.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/jssim.js~Simulator#_getState",
    "access": "private",
    "description": "",
    "lineNumber": 354,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "i",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 226,
    "kind": "method",
    "name": "_setState",
    "memberof": "src/backends/simulators/jssim.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/jssim.js~Simulator#_setState",
    "access": "private",
    "description": "",
    "lineNumber": 364,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "i",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 227,
    "kind": "method",
    "name": "getAmplitude",
    "memberof": "src/backends/simulators/jssim.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/jssim.js~Simulator#getAmplitude",
    "access": "public",
    "description": "Return the probability amplitude of the supplied `bit_string`.\nThe ordering is given by the list of qubit ids.",
    "lineNumber": 379,
    "params": [
      {
        "nullable": null,
        "types": [
          "boolean[]",
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "bitString",
        "description": "Computational basis state"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "IDs",
        "description": "List of qubit ids determining the ordering. Must contain all allocated qubits."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "Probability amplitude of the provided bit string."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "if the second argument is not a permutation of all allocated qubits."
      }
    ]
  },
  {
    "__docId__": 228,
    "kind": "method",
    "name": "emulateTimeEvolution",
    "memberof": "src/backends/simulators/jssim.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/jssim.js~Simulator#emulateTimeEvolution",
    "access": "public",
    "description": "Applies exp(-i*time*H) to the wave function, i.e., evolves under\nthe Hamiltonian H for a given time. The terms in the Hamiltonian\nare not required to commute.\n\nThis function computes the action of the matrix exponential using\nideas from Al-Mohy and Higham, 2011.\nTODO: Implement better estimates for s.",
    "lineNumber": 411,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array.<Array>"
        ],
        "spread": false,
        "optional": false,
        "name": "terms_dict",
        "description": "Operator dictionary (see QubitOperator.terms) defining the Hamiltonian."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "time",
        "description": "Time to evolve for"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "ids",
        "description": "A list of qubit IDs to which to apply the evolution."
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "ctrlids",
        "description": "A list of control qubit IDs."
      }
    ],
    "return": null
  },
  {
    "__docId__": 233,
    "kind": "method",
    "name": "run",
    "memberof": "src/backends/simulators/jssim.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/jssim.js~Simulator#run",
    "access": "public",
    "description": "leave it empty to keep same API with cpp simulator",
    "lineNumber": 478,
    "params": [],
    "return": null
  },
  {
    "__docId__": 234,
    "kind": "method",
    "name": "applyTerm",
    "memberof": "src/backends/simulators/jssim.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/jssim.js~Simulator#applyTerm",
    "access": "public",
    "description": "Applies a QubitOperator term to the state vector. (Helper function for time evolution & expectation)",
    "lineNumber": 489,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "term",
        "description": "One term of QubitOperator.terms"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "ids",
        "description": "Term index to Qubit ID mapping"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "controlIDs",
        "description": "Control qubit IDs"
      }
    ],
    "return": null
  },
  {
    "__docId__": 235,
    "kind": "method",
    "name": "applyControlledGate",
    "memberof": "src/backends/simulators/jssim.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/jssim.js~Simulator#applyControlledGate",
    "access": "public",
    "description": "Applies the k-qubit gate matrix m to the qubits with indices ids,\nusing ctrlids as control qubits.",
    "lineNumber": 508,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array.<Array.<number>>"
        ],
        "spread": false,
        "optional": false,
        "name": "m",
        "description": "2^k x 2^k complex matrix describing the k-qubit gate."
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "ids",
        "description": "A list containing the qubit IDs to which to apply the gate."
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "ctrlids",
        "description": "A list of control qubit IDs (i.e., the gate is only applied where these qubits are 1)."
      }
    ],
    "return": null
  },
  {
    "__docId__": 236,
    "kind": "method",
    "name": "_singleQubitGate",
    "memberof": "src/backends/simulators/jssim.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/jssim.js~Simulator#_singleQubitGate",
    "access": "private",
    "description": "Applies the single qubit gate matrix m to the qubit at position `pos`\nusing `mask` to identify control qubits.",
    "lineNumber": 528,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array.<Array.<number>>"
        ],
        "spread": false,
        "optional": false,
        "name": "m",
        "description": "2x2 complex matrix describing the single-qubit gate."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "pos",
        "description": "Bit-position of the qubit."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "mask",
        "description": "Bit-mask where set bits indicate control qubits."
      }
    ],
    "return": null
  },
  {
    "__docId__": 237,
    "kind": "method",
    "name": "_multiQubitGate",
    "memberof": "src/backends/simulators/jssim.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/jssim.js~Simulator#_multiQubitGate",
    "access": "private",
    "description": "Applies the k-qubit gate matrix m to the qubits at `pos`\nusing `mask` to identify control qubits.",
    "lineNumber": 562,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array.<number[]>"
        ],
        "spread": false,
        "optional": false,
        "name": "m",
        "description": "2^k x 2^k complex matrix describing the k-qubit gate."
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "pos",
        "description": "List of bit-positions of the qubits."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "mask",
        "description": "Bit-mask where set bits indicate control qubits.\nsee follows the description in https://arxiv.org/abs/1704.01127"
      }
    ],
    "return": null
  },
  {
    "__docId__": 238,
    "kind": "method",
    "name": "setWavefunction",
    "memberof": "src/backends/simulators/jssim.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/jssim.js~Simulator#setWavefunction",
    "access": "public",
    "description": "Set wavefunction and qubit ordering.",
    "lineNumber": 601,
    "params": [
      {
        "nullable": null,
        "types": [
          "Complex[]"
        ],
        "spread": false,
        "optional": false,
        "name": "wavefunction",
        "description": "Array of complex amplitudes describing the wavefunction (must be normalized)."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "ordering",
        "description": "List of ids describing the new ordering of qubits\n(i.e., the ordering of the provided wavefunction)."
      }
    ],
    "return": null
  },
  {
    "__docId__": 241,
    "kind": "method",
    "name": "collapseWavefunction",
    "memberof": "src/backends/simulators/jssim.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/jssim.js~Simulator#collapseWavefunction",
    "access": "public",
    "description": "Collapse a quantum register onto a classical basis state.",
    "lineNumber": 632,
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "ids",
        "description": "Qubit IDs to collapse."
      },
      {
        "nullable": null,
        "types": [
          "boolean[]"
        ],
        "spread": false,
        "optional": false,
        "name": "values",
        "description": "Measurement outcome for each of the qubit IDs in `ids`."
      }
    ],
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If probability of outcome is ~0 or unknown qubits are provided."
      }
    ],
    "return": null
  },
  {
    "__docId__": 242,
    "kind": "file",
    "name": "src/backends/simulators/simulator.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport assert from 'assert'\r\nimport math from 'mathjs'\r\nimport {BasicEngine} from '../../cengines/basics'\r\nimport SimulatorBackend from './jssim'\r\nimport CPPSimulatorBackend from './cppsim'\r\n\r\nimport {\r\n  Allocate, AllocateQubitGate, Deallocate, DeallocateQubitGate, FlushGate, Measure, MeasureGate\r\n} from '../../ops/gates';\r\nimport {BasicMathGate} from '../../ops/basics';\r\nimport TimeEvolution from '../../ops/timeevolution';\r\nimport { BasicQubit } from '../../types/qubit'\r\nimport { stringToArray } from '../../ops/qubitoperator'\r\nimport { LogicalQubitIDTag } from '../../meta/tag'\r\nimport {instanceOf} from '../../libs/util';\r\nimport {len, stringToBitArray} from '../../libs/polyfill';\r\n\r\n/**\r\n * @class Simulator\r\n * @desc\r\nSimulator is a compiler engine which simulates a quantum computer using\r\nC++-based kernels.\r\n\r\n    OpenMP is enabled and the number of threads can be controlled using the\r\nOMP_NUM_THREADS environment variable, i.e.\r\n\r\n    @example\r\n\r\nexport OMP_NUM_THREADS=4 # use 4 threads\r\nexport OMP_PROC_BIND=spread # bind threads to processors by spreading\r\n */\r\nexport default class Simulator extends BasicEngine {\r\n  /**\r\n   * @constructor\r\n  Construct the C++/JavaScript-simulator object and initialize it with a\r\n  random seed.\r\n\r\n    @param {boolean} gate_fusion If true, gates are cached and only executed\r\nonce a certain gate-size has been reached (only has an effect\r\nfor the c++ simulator).\r\n    @param {number} rnd_seed Random seed (uses random.randint(0, 4294967295) by default). Ignored currently!!!\r\n    @param {boolean} forceSimulation if true, will force use cpp simulator\r\n\r\nExample of gate_fusion Instead of applying a Hadamard gate to 5\r\nqubits, the simulator calculates the kronecker product of the 1-qubit\r\ngate matrices and then applies one 5-qubit gate. This increases\r\noperational intensity and keeps the simulator from having to iterate\r\nthrough the state vector multiple times. Depending on the system (and,\r\n    especially, number of threads), this may or may not be beneficial.\r\n\r\n    Note:\r\nIf the C++ Simulator extension was not built or cannot be found,\r\n    the Simulator defaults to a Javascript implementation of the kernels.\r\n    While this is much slower, it is still good enough to run basic\r\nquantum algorithms.\r\n\r\n    If you need to run large simulations, check out the tutorial in\r\nthe docs which gives futher hints on how to build the C++\r\nextension.\r\n   */\r\n  constructor(gate_fusion = false, rnd_seed = null, forceSimulation = false) {\r\n    super()\r\n    if (!rnd_seed) {\r\n      rnd_seed = Math.random()\r\n    }\r\n\r\n    if (!forceSimulation && CPPSimulatorBackend) {\r\n      const S = CPPSimulatorBackend.Simulator\r\n      this._simulator = new S(rnd_seed)\r\n    } else {\r\n      this._simulator = new SimulatorBackend(rnd_seed)\r\n    }\r\n    this._gate_fusion = gate_fusion\r\n  }\r\n\r\n  /**\r\n  Specialized implementation of isAvailable: The simulator can deal\r\nwith all arbitrarily-controlled gates which provide a\r\ngate-matrix (via gate.matrix) and acts on 5 or less qubits (not\r\ncounting the control qubits).\r\n\r\n  @param {Command} cmd Command for which to check availability (single-qubit gate, arbitrary controls)\r\n\r\n  @return {boolean} true if it can be simulated and false otherwise.\r\n  */\r\n  isAvailable(cmd) {\r\n    if (instanceOf(cmd.gate, [MeasureGate, AllocateQubitGate, DeallocateQubitGate, BasicMathGate, TimeEvolution])) {\r\n      return true\r\n    }\r\n    try {\r\n      const m = cmd.gate.matrix\r\n      // Allow up to 5-qubit gates\r\n      const [row, col] = m.size()\r\n      if (row > 2 ** 5 || col > 2 ** 5) return false\r\n      return true\r\n    } catch (e) {\r\n      return false\r\n    }\r\n  }\r\n\r\n  /**\r\n    Converts a qureg from logical to mapped qubits if there is a mapper.\r\n    @param {Array.<Qubit>|Qureg} qureg Logical quantum bits\r\n  */\r\n  convertLogicalToMappedQureg(qureg) {\r\n    const {mapper} = this.main\r\n    if (mapper) {\r\n      const mapped_qureg = []\r\n      qureg.forEach((qubit) => {\r\n        const v = mapper.currentMapping[qubit.id]\r\n        if (typeof v === 'undefined') {\r\n          throw new Error('Unknown qubit id. '\r\n          + 'Please make sure you have called '\r\n          + 'eng.flush().')\r\n        }\r\n        const new_qubit = new BasicQubit(qubit.engine, mapper.currentMapping[qubit.id])\r\n        mapped_qureg.push(new_qubit)\r\n      })\r\n      return mapped_qureg\r\n    }\r\n    return qureg\r\n  }\r\n\r\n  /**\r\n  Get the expectation value of qubit_operator w.r.t. the current wave\r\nfunction represented by the supplied quantum register.\r\n\r\n    @param {QubitOperator} qubitOperator  Operator to measure.\r\n    @param {Array.<Qubit>|Qureg} qureg  Quantum bits to measure.\r\n\r\n    @return Expectation value\r\n\r\nNote:\r\n    Make sure all previous commands (especially allocations) have\r\npassed through the compilation chain (call main.flush() to\r\nmake sure).\r\n\r\nNote:\r\n    If there is a mapper present in the compiler, this function\r\nautomatically converts from logical qubits to mapped qubits for\r\n    the qureg argument.\r\n\r\n    @throws {Error} If `qubit_operator` acts on more qubits than present in the `qureg` argument.\r\n   */\r\n  getExpectationValue(qubitOperator, qureg) {\r\n    qureg = this.convertLogicalToMappedQureg(qureg)\r\n    const operator = []\r\n    const num_qubits = qureg.length\r\n    Object.keys(qubitOperator.terms).forEach((term) => {\r\n      const keys = stringToArray(term)\r\n      if (term !== '' && keys[keys.length - 1][0] >= num_qubits) {\r\n        throw new Error('qubit_operator acts on more qubits than contained in the qureg.')\r\n      }\r\n      operator.push([keys, qubitOperator.terms[term]])\r\n    })\r\n    return this._simulator.getExpectationValue(operator, qureg.map(qb => qb.id))\r\n  }\r\n\r\n  /**\r\n  Apply a (possibly non-unitary) qubit_operator to the current wave\r\nfunction represented by the supplied quantum register.\r\n\r\n    @param {QubitOperator} qubitOperator  Operator to apply.\r\n    @param {Array.<Qubit>|Qureg} qureg Quantum bits to which to apply the\r\noperator.\r\n\r\n    @throws {Error} If `qubit_operator` acts on more qubits than present in the `qureg` argument.\r\n\r\n    Warning:\r\nThis function allows applying non-unitary gates and it will not\r\nre-normalize the wave function! It is for numerical experiments\r\nonly and should not be used for other purposes.\r\n\r\n    Note:\r\nMake sure all previous commands (especially allocations) have\r\npassed through the compilation chain (call main.flush() to\r\nmake sure).\r\n\r\nNote:\r\n    If there is a mapper present in the compiler, this function\r\nautomatically converts from logical qubits to mapped qubits for\r\n    the qureg argument.\r\n   */\r\n  applyQubitOperator(qubitOperator, qureg) {\r\n    qureg = this.convertLogicalToMappedQureg(qureg)\r\n    const num_qubits = qureg.length\r\n    const operator = []\r\n    Object.keys(qubitOperator.terms).forEach((term) => {\r\n      const keys = stringToArray(term)\r\n      if (term !== '' && keys[keys.length - 1][0] >= num_qubits) {\r\n        throw new Error('qubit_operator acts on more qubits than contained in the qureg.')\r\n      }\r\n      operator.push([keys, qubitOperator.terms[term]])\r\n    })\r\n    return this._simulator.applyQubitOperator(operator, qureg.map(qb => qb.id))\r\n  }\r\n\r\n  /**\r\n  Return the probability of the outcome `bit_string` when measuring\r\nthe quantum register `qureg`.\r\n\r\n    @param {number[]|string} bitString  Measurement outcome.\r\n    @param {Qureg|Array.<Qubit>} qureg Quantum register.\r\n\r\n    @returns {number} Probability of measuring the provided bit string.\r\n\r\n    Note:\r\nMake sure all previous commands (especially allocations) have\r\npassed through the compilation chain (call main.flush() to\r\nmake sure).\r\n\r\nNote:\r\n    If there is a mapper present in the compiler, this function\r\nautomatically converts from logical qubits to mapped qubits for\r\n    the qureg argument.\r\n   */\r\n  getProbability(bitString, qureg) {\r\n    qureg = this.convertLogicalToMappedQureg(qureg)\r\n    const bit_string = stringToBitArray(bitString)\r\n    return this._simulator.getProbability(bit_string, qureg.map(qb => qb.id))\r\n  }\r\n\r\n  /**\r\n  Return the probability amplitude of the supplied `bit_string`.\r\n    The ordering is given by the quantum register `qureg`, which must\r\ncontain all allocated qubits.\r\n\r\n   @param {number[]|string} bitString Computational basis state\r\n   @param {Qureg|Array.<Qubit>} qureg Quantum register determining the\r\nordering. Must contain all allocated qubits.\r\n\r\n    @returns {number}\r\nProbability amplitude of the provided bit string.\r\n\r\n    Note:\r\nMake sure all previous commands (especially allocations) have\r\npassed through the compilation chain (call main.flush() to\r\nmake sure).\r\n\r\nNote:\r\n    If there is a mapper present in the compiler, this function\r\nautomatically converts from logical qubits to mapped qubits for\r\n    the qureg argument.\r\n   */\r\n  getAmplitude(bitString, qureg) {\r\n    qureg = this.convertLogicalToMappedQureg(qureg)\r\n    const bit_string = stringToBitArray(bitString)\r\n    return this._simulator.getAmplitude(bit_string, qureg.map(qb => qb.id))\r\n  }\r\n\r\n  /**\r\n  Set the wavefunction and the qubit ordering of the simulator.\r\n\r\n    The simulator will adopt the ordering of qureg (instead of reordering\r\nthe wavefunction).\r\n\r\n  @param {Complex[]} wavefunction  Array of complex amplitudes describing the wavefunction (must be normalized).\r\n  @param {Qureg|Array.<Qubit>} qureg  Quantum register determining the ordering. Must contain all allocated qubits.\r\n\r\n    Note:\r\nMake sure all previous commands (especially allocations) have\r\npassed through the compilation chain (call main.flush() to\r\nmake sure).\r\n\r\nNote:\r\n    If there is a mapper present in the compiler, this function\r\nautomatically converts from logical qubits to mapped qubits for\r\n    the qureg argument.\r\n   */\r\n  setWavefunction(wavefunction, qureg) {\r\n    qureg = this.convertLogicalToMappedQureg(qureg)\r\n    this._simulator.setWavefunction(wavefunction, qureg.map(qb => qb.id))\r\n  }\r\n\r\n  /**\r\n  Collapse a quantum register onto a classical basis state.\r\n\r\n    @param {Qureg|Array.<Qubit>} qureg Qubits to collapse.\r\n    @param {boolean[]} values  Measurement outcome for each of the qubits\r\nin `qureg`.\r\n\r\n    @throws {Error} If an outcome has probability (approximately) 0 or\r\nif unknown qubits are provided (see note).\r\n\r\nNote:\r\n    Make sure all previous commands have passed through the\r\ncompilation chain (call main.flush() to make sure).\r\n\r\nNote:\r\n    If there is a mapper present in the compiler, this function\r\nautomatically converts from logical qubits to mapped qubits for\r\n    the qureg argument.\r\n   */\r\n  collapseWavefunction(qureg, values) {\r\n    qureg = this.convertLogicalToMappedQureg(qureg)\r\n    return this._simulator.collapseWavefunction(qureg.map(qb => qb.id), values)\r\n  }\r\n\r\n  /**\r\n  Access the ordering of the qubits and the state vector directly.\r\n\r\n    This is a cheat function which enables, e.g., more efficient\r\nevaluation of expectation values and debugging.\r\n\r\n    @return {Array}\r\nA tuple where the first entry is a dictionary mapping qubit\r\nindices to bit-locations and the second entry is the corresponding\r\nstate vector.\r\n\r\n    Note:\r\nMake sure all previous commands have passed through the\r\ncompilation chain (call main.flush() to make sure).\r\n\r\nNote:\r\n    If there is a mapper present in the compiler, this function\r\nDOES NOT automatically convert from logical qubits to mapped\r\nqubits.\r\n   */\r\n  cheat() {\r\n    return this._simulator.cheat()\r\n  }\r\n\r\n  /**\r\n  Handle all commands, i.e., call the member functions of the C++-\r\nsimulator object corresponding to measurement, allocation/\r\ndeallocation, and (controlled) single-qubit gate.\r\n\r\n    @param {Command} cmd Command to handle.\r\n\r\n    @throws Error If a non-single-qubit gate needs to be processed (which should never happen due to isAvailable).\r\n   */\r\n  handle(cmd) {\r\n    if (cmd.gate instanceof TimeEvolution) {\r\n      const {terms} = cmd.gate.hamiltonian\r\n      const op = []\r\n      Object.keys(terms).forEach(k => {\r\n        const v = terms[k]\r\n        op.push([stringToArray(k), v])\r\n      })\r\n      const t = cmd.gate.time\r\n      const qubitids = cmd.qubits[0].map(qb => qb.id)\r\n      const ctrlids = cmd.controlQubits.map(qb => qb.id)\r\n      this._simulator.emulateTimeEvolution(op, t, qubitids, ctrlids)\r\n    } else if (cmd.gate.equal(Measure)) {\r\n      assert(cmd.controlCount === 0)\r\n      const ids = []\r\n      cmd.qubits.forEach(qr => qr.forEach(qb => ids.push(qb.id)))\r\n      const out = this._simulator.measureQubits(ids)\r\n      let i = 0\r\n      cmd.qubits.forEach((qr) => {\r\n        qr.forEach((qb) => {\r\n          // Check if a mapper assigned a different logical id\r\n          let logical_id_tag\r\n          cmd.tags.forEach((tag) => {\r\n            if (tag instanceof LogicalQubitIDTag) {\r\n              logical_id_tag = tag\r\n            }\r\n          })\r\n          if (logical_id_tag) {\r\n            qb = new BasicQubit(qb.engine, logical_id_tag.logical_qubit_id)\r\n          }\r\n          this.main.setMeasurementResult(qb, out[i])\r\n          i += 1\r\n        })\r\n      })\r\n    } else if (cmd.gate.equal(Allocate)) {\r\n      const ID = cmd.qubits[0][0].id\r\n      this._simulator.allocateQubit(ID)\r\n    } else if (cmd.gate.equal(Deallocate)) {\r\n      const ID = cmd.qubits[0][0].id\r\n      this._simulator.deallocateQubit(ID)\r\n    } else if (cmd.gate instanceof BasicMathGate) {\r\n      const qubitids = []\r\n      cmd.qubits.forEach((qr) => {\r\n        const latest = []\r\n        qubitids.push(latest)\r\n        qr.forEach((qb) => {\r\n          latest.push(qb.id)\r\n        })\r\n      })\r\n\r\n      const math_fun = cmd.gate.getMathFunction(cmd.qubits)\r\n      this._simulator.emulateMath(math_fun, qubitids, cmd.controlQubits.map(qb => qb.id))\r\n    } else if (len(cmd.gate.matrix) <= 2 ** 5) {\r\n      const matrix = cmd.gate.matrix\r\n      const ids = []\r\n      cmd.qubits.forEach(qr => qr.forEach(qb => ids.push(qb.id)))\r\n      if (2 ** ids.length !== len(matrix)) {\r\n        throw new Error(`Simulator: Error applying ${cmd.gate.toString()} gate: ${math.log(len(cmd.gate.matrix), 2)}-qubit gate applied to ${ids.length} qubits.`)\r\n      }\r\n      const m = math.clone(matrix)._data\r\n      const ctrls = cmd.controlQubits.map(qb => qb.id)\r\n      this._simulator.applyControlledGate(m, ids, ctrls)\r\n      if (!this._gate_fusion) {\r\n        this._simulator.run()\r\n      }\r\n    } else {\r\n      throw new Error('This simulator only supports controlled k-qubit'\r\n      + ' gates with k < 6!\\nPlease add an auto-replacer'\r\n      + ' engine to your list of compiler engines.')\r\n    }\r\n  }\r\n\r\n  /**\r\n  Receive a list of commands from the previous engine and handle them\r\n(simulate them classically) prior to sending them on to the next\r\nengine.\r\n\r\n    @param {Command[]} commandList List of commands to execute on the simulator.\r\n   */\r\n  receive(commandList) {\r\n    commandList.forEach((cmd) => {\r\n      if (!(cmd.gate instanceof FlushGate)) {\r\n        this.handle(cmd)\r\n      } else {\r\n        this._simulator.run()\r\n      }\r\n      if (!this.isLastEngine) {\r\n        this.send([cmd])\r\n      }\r\n    })\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/backends/simulators/simulator.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 243,
    "kind": "class",
    "name": "Simulator",
    "memberof": "src/backends/simulators/simulator.js",
    "static": true,
    "longname": "src/backends/simulators/simulator.js~Simulator",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/backends/simulators/simulator.js",
    "importStyle": "Simulator",
    "description": "Simulator is a compiler engine which simulates a quantum computer using\nC++-based kernels.\n\nOpenMP is enabled and the number of threads can be controlled using the\nOMP_NUM_THREADS environment variable, i.e.",
    "examples": [
      "\nexport OMP_NUM_THREADS=4 # use 4 threads\nexport OMP_PROC_BIND=spread # bind threads to processors by spreading"
    ],
    "lineNumber": 48,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "Simulator"
      }
    ],
    "interface": false,
    "extends": [
      "src/cengines/basics.js~BasicEngine"
    ]
  },
  {
    "__docId__": 244,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/backends/simulators/simulator.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/simulator.js~Simulator#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 77,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": "Construct the C++/JavaScript-simulator object and initialize it with a\nrandom seed."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "gate_fusion",
        "description": "If true, gates are cached and only executed\nonce a certain gate-size has been reached (only has an effect\nfor the c++ simulator)."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "rnd_seed",
        "description": "Random seed (uses random.randint(0, 4294967295) by default). Ignored currently!!!"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "forceSimulation",
        "description": "if true, will force use cpp simulator\n\nExample of gate_fusion Instead of applying a Hadamard gate to 5\nqubits, the simulator calculates the kronecker product of the 1-qubit\ngate matrices and then applies one 5-qubit gate. This increases\noperational intensity and keeps the simulator from having to iterate\nthrough the state vector multiple times. Depending on the system (and,\nespecially, number of threads), this may or may not be beneficial.\n\nNote:\nIf the C++ Simulator extension was not built or cannot be found,\nthe Simulator defaults to a Javascript implementation of the kernels.\nWhile this is much slower, it is still good enough to run basic\nquantum algorithms.\n\nIf you need to run large simulations, check out the tutorial in\nthe docs which gives futher hints on how to build the C++\nextension."
      }
    ]
  },
  {
    "__docId__": 245,
    "kind": "member",
    "name": "_simulator",
    "memberof": "src/backends/simulators/simulator.js~Simulator",
    "static": false,
    "longname": "src/backends/simulators/simulator.js~Simulator#_simulator",
    "access": "private",
    "description": null,
    "lineNumber": 85,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 247,
    "kind": "member",
    "name": "_gate_fusion",
    "memberof": "src/backends/simulators/simulator.js~Simulator",
    "static": false,
    "longname": "src/backends/simulators/simulator.js~Simulator#_gate_fusion",
    "access": "private",
    "description": null,
    "lineNumber": 89,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 248,
    "kind": "method",
    "name": "isAvailable",
    "memberof": "src/backends/simulators/simulator.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/simulator.js~Simulator#isAvailable",
    "access": "public",
    "description": "Specialized implementation of isAvailable: The simulator can deal\nwith all arbitrarily-controlled gates which provide a\ngate-matrix (via gate.matrix) and acts on 5 or less qubits (not\ncounting the control qubits).",
    "lineNumber": 102,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": "Command for which to check availability (single-qubit gate, arbitrary controls)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if it can be simulated and false otherwise."
    }
  },
  {
    "__docId__": 249,
    "kind": "method",
    "name": "convertLogicalToMappedQureg",
    "memberof": "src/backends/simulators/simulator.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/simulator.js~Simulator#convertLogicalToMappedQureg",
    "access": "public",
    "description": "Converts a qureg from logical to mapped qubits if there is a mapper.",
    "lineNumber": 121,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array.<Qubit>",
          "Qureg"
        ],
        "spread": false,
        "optional": false,
        "name": "qureg",
        "description": "Logical quantum bits"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 250,
    "kind": "method",
    "name": "getExpectationValue",
    "memberof": "src/backends/simulators/simulator.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/simulator.js~Simulator#getExpectationValue",
    "access": "public",
    "description": "Get the expectation value of qubit_operator w.r.t. the current wave\nfunction represented by the supplied quantum register.",
    "lineNumber": 161,
    "params": [
      {
        "nullable": null,
        "types": [
          "QubitOperator"
        ],
        "spread": false,
        "optional": false,
        "name": "qubitOperator",
        "description": "Operator to measure."
      },
      {
        "nullable": null,
        "types": [
          "Array.<Qubit>",
          "Qureg"
        ],
        "spread": false,
        "optional": false,
        "name": "qureg",
        "description": "Quantum bits to measure."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "Expectation value\n\nNote:\nMake sure all previous commands (especially allocations) have\npassed through the compilation chain (call main.flush() to\nmake sure).\n\nNote:\nIf there is a mapper present in the compiler, this function\nautomatically converts from logical qubits to mapped qubits for\nthe qureg argument."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If `qubit_operator` acts on more qubits than present in the `qureg` argument."
      }
    ]
  },
  {
    "__docId__": 251,
    "kind": "method",
    "name": "applyQubitOperator",
    "memberof": "src/backends/simulators/simulator.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/simulator.js~Simulator#applyQubitOperator",
    "access": "public",
    "description": "Apply a (possibly non-unitary) qubit_operator to the current wave\nfunction represented by the supplied quantum register.",
    "lineNumber": 200,
    "params": [
      {
        "nullable": null,
        "types": [
          "QubitOperator"
        ],
        "spread": false,
        "optional": false,
        "name": "qubitOperator",
        "description": "Operator to apply."
      },
      {
        "nullable": null,
        "types": [
          "Array.<Qubit>",
          "Qureg"
        ],
        "spread": false,
        "optional": false,
        "name": "qureg",
        "description": "Quantum bits to which to apply the\noperator."
      }
    ],
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If `qubit_operator` acts on more qubits than present in the `qureg` argument.\n\nWarning:\nThis function allows applying non-unitary gates and it will not\nre-normalize the wave function! It is for numerical experiments\nonly and should not be used for other purposes.\n\nNote:\nMake sure all previous commands (especially allocations) have\npassed through the compilation chain (call main.flush() to\nmake sure).\n\nNote:\nIf there is a mapper present in the compiler, this function\nautomatically converts from logical qubits to mapped qubits for\nthe qureg argument."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 252,
    "kind": "method",
    "name": "getProbability",
    "memberof": "src/backends/simulators/simulator.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/simulator.js~Simulator#getProbability",
    "access": "public",
    "description": "Return the probability of the outcome `bit_string` when measuring\nthe quantum register `qureg`.",
    "lineNumber": 233,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} Probability of measuring the provided bit string.\n\nNote:\nMake sure all previous commands (especially allocations) have\npassed through the compilation chain (call main.flush() to\nmake sure).\n\nNote:\nIf there is a mapper present in the compiler, this function\nautomatically converts from logical qubits to mapped qubits for\nthe qureg argument."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]",
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "bitString",
        "description": "Measurement outcome."
      },
      {
        "nullable": null,
        "types": [
          "Qureg",
          "Array.<Qubit>"
        ],
        "spread": false,
        "optional": false,
        "name": "qureg",
        "description": "Quantum register."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Probability of measuring the provided bit string.\n\nNote:\nMake sure all previous commands (especially allocations) have\npassed through the compilation chain (call main.flush() to\nmake sure).\n\nNote:\nIf there is a mapper present in the compiler, this function\nautomatically converts from logical qubits to mapped qubits for\nthe qureg argument."
    }
  },
  {
    "__docId__": 253,
    "kind": "method",
    "name": "getAmplitude",
    "memberof": "src/backends/simulators/simulator.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/simulator.js~Simulator#getAmplitude",
    "access": "public",
    "description": "Return the probability amplitude of the supplied `bit_string`.\nThe ordering is given by the quantum register `qureg`, which must\ncontain all allocated qubits.",
    "lineNumber": 261,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}\nProbability amplitude of the provided bit string.\n\nNote:\nMake sure all previous commands (especially allocations) have\npassed through the compilation chain (call main.flush() to\nmake sure).\n\nNote:\nIf there is a mapper present in the compiler, this function\nautomatically converts from logical qubits to mapped qubits for\nthe qureg argument."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]",
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "bitString",
        "description": "Computational basis state"
      },
      {
        "nullable": null,
        "types": [
          "Qureg",
          "Array.<Qubit>"
        ],
        "spread": false,
        "optional": false,
        "name": "qureg",
        "description": "Quantum register determining the\nordering. Must contain all allocated qubits."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Probability amplitude of the provided bit string.\n\nNote:\nMake sure all previous commands (especially allocations) have\npassed through the compilation chain (call main.flush() to\nmake sure).\n\nNote:\nIf there is a mapper present in the compiler, this function\nautomatically converts from logical qubits to mapped qubits for\nthe qureg argument."
    }
  },
  {
    "__docId__": 254,
    "kind": "method",
    "name": "setWavefunction",
    "memberof": "src/backends/simulators/simulator.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/simulator.js~Simulator#setWavefunction",
    "access": "public",
    "description": "Set the wavefunction and the qubit ordering of the simulator.\n\nThe simulator will adopt the ordering of qureg (instead of reordering\nthe wavefunction).",
    "lineNumber": 286,
    "params": [
      {
        "nullable": null,
        "types": [
          "Complex[]"
        ],
        "spread": false,
        "optional": false,
        "name": "wavefunction",
        "description": "Array of complex amplitudes describing the wavefunction (must be normalized)."
      },
      {
        "nullable": null,
        "types": [
          "Qureg",
          "Array.<Qubit>"
        ],
        "spread": false,
        "optional": false,
        "name": "qureg",
        "description": "Quantum register determining the ordering. Must contain all allocated qubits.\n\nNote:\nMake sure all previous commands (especially allocations) have\npassed through the compilation chain (call main.flush() to\nmake sure).\n\nNote:\nIf there is a mapper present in the compiler, this function\nautomatically converts from logical qubits to mapped qubits for\nthe qureg argument."
      }
    ],
    "return": null
  },
  {
    "__docId__": 255,
    "kind": "method",
    "name": "collapseWavefunction",
    "memberof": "src/backends/simulators/simulator.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/simulator.js~Simulator#collapseWavefunction",
    "access": "public",
    "description": "Collapse a quantum register onto a classical basis state.",
    "lineNumber": 310,
    "params": [
      {
        "nullable": null,
        "types": [
          "Qureg",
          "Array.<Qubit>"
        ],
        "spread": false,
        "optional": false,
        "name": "qureg",
        "description": "Qubits to collapse."
      },
      {
        "nullable": null,
        "types": [
          "boolean[]"
        ],
        "spread": false,
        "optional": false,
        "name": "values",
        "description": "Measurement outcome for each of the qubits\nin `qureg`."
      }
    ],
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If an outcome has probability (approximately) 0 or\nif unknown qubits are provided (see note).\n\nNote:\nMake sure all previous commands have passed through the\ncompilation chain (call main.flush() to make sure).\n\nNote:\nIf there is a mapper present in the compiler, this function\nautomatically converts from logical qubits to mapped qubits for\nthe qureg argument."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 256,
    "kind": "method",
    "name": "cheat",
    "memberof": "src/backends/simulators/simulator.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/simulator.js~Simulator#cheat",
    "access": "public",
    "description": "Access the ordering of the qubits and the state vector directly.\n\nThis is a cheat function which enables, e.g., more efficient\nevaluation of expectation values and debugging.",
    "lineNumber": 335,
    "return": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": "A tuple where the first entry is a dictionary mapping qubit\nindices to bit-locations and the second entry is the corresponding\nstate vector.\n\nNote:\nMake sure all previous commands have passed through the\ncompilation chain (call main.flush() to make sure).\n\nNote:\nIf there is a mapper present in the compiler, this function\nDOES NOT automatically convert from logical qubits to mapped\nqubits."
    },
    "params": []
  },
  {
    "__docId__": 257,
    "kind": "method",
    "name": "handle",
    "memberof": "src/backends/simulators/simulator.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/simulator.js~Simulator#handle",
    "access": "public",
    "description": "Handle all commands, i.e., call the member functions of the C++-\nsimulator object corresponding to measurement, allocation/\ndeallocation, and (controlled) single-qubit gate.",
    "lineNumber": 348,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": "Command to handle."
      }
    ],
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "Error If a non-single-qubit gate needs to be processed (which should never happen due to isAvailable)."
      }
    ],
    "return": null
  },
  {
    "__docId__": 258,
    "kind": "method",
    "name": "receive",
    "memberof": "src/backends/simulators/simulator.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/simulator.js~Simulator#receive",
    "access": "public",
    "description": "Receive a list of commands from the previous engine and handle them\n(simulate them classically) prior to sending them on to the next\nengine.",
    "lineNumber": 427,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command[]"
        ],
        "spread": false,
        "optional": false,
        "name": "commandList",
        "description": "List of commands to execute on the simulator."
      }
    ],
    "return": null
  },
  {
    "__docId__": 259,
    "kind": "file",
    "name": "src/cengines/basicmapper.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n\r\nimport {BasicEngine} from './basics'\r\nimport {LogicalQubitIDTag} from '../meta/tag'\r\nimport {dropEngineAfter, insertEngine} from '../meta/util'\r\nimport {MeasureGate} from '../ops/gates'\r\nimport CommandModifier from './cmdmodifier'\r\n\r\n/**\r\n * @class BasicMapperEngine\r\n * @desc\r\nDefines the parent class from which all mappers should be derived.\r\n\r\n    There is only one engine currently allowed to be derived from\r\nBasicMapperEngine. This allows the simulator to automatically translate\r\nlogical qubit ids to mapped ids.\r\n*/\r\nexport default class BasicMapperEngine extends BasicEngine {\r\n  /**\r\n   * @constructor\r\n  Parent class for all Mappers.\r\n\r\nthis.current_mapping (dict): Keys are the logical qubit ids and values\r\nare the mapped qubit ids.\r\n   */\r\n  constructor() {\r\n    super()\r\n    this._currentMapping = null\r\n  }\r\n\r\n  get currentMapping() {\r\n    return Object.assign({}, this._currentMapping)\r\n  }\r\n\r\n  set currentMapping(newMap) {\r\n    this._currentMapping = newMap\r\n  }\r\n\r\n  /**\r\n  Send this Command using the mapped qubit ids of this.current_mapping.\r\n\r\n    If it is a Measurement gate, then it adds a LogicalQubitID tag.\r\n\r\n    @param {Command} cmd Command object with logical qubit ids.\r\n   */\r\n  sendCMDWithMappedIDs(cmd) {\r\n    const newCMD = cmd.copy()\r\n    const qubits = newCMD.qubits\r\n    qubits.forEach((qureg) => {\r\n      qureg.forEach((qubit) => {\r\n        if (qubit.id !== -1) {\r\n          qubit.id = this._currentMapping[qubit.id]\r\n        }\r\n      })\r\n    })\r\n    const controlQubits = newCMD.controlQubits\r\n    controlQubits.forEach((qubit) => {\r\n      qubit.id = this._currentMapping[qubit.id]\r\n    })\r\n    if (newCMD.gate instanceof MeasureGate) {\r\n      if (!(newCMD.qubits.length === 1 && newCMD.qubits[0].length === 1)) {\r\n        throw new Error('assert error')\r\n      }\r\n      // Add LogicalQubitIDTag to MeasureGate\r\n      const add_logical_id = function (command, old_tags = cmd.tags.slice(0)) {\r\n        old_tags.push(new LogicalQubitIDTag(cmd.qubits[0][0].id))\r\n        command.tags = old_tags\r\n        return command\r\n      }\r\n\r\n      const tagger_eng = new CommandModifier(add_logical_id)\r\n      insertEngine(this, tagger_eng)\r\n      this.send([newCMD])\r\n      dropEngineAfter(this)\r\n    } else {\r\n      this.send([newCMD])\r\n    }\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/cengines/basicmapper.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 260,
    "kind": "class",
    "name": "BasicMapperEngine",
    "memberof": "src/cengines/basicmapper.js",
    "static": true,
    "longname": "src/cengines/basicmapper.js~BasicMapperEngine",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/cengines/basicmapper.js",
    "importStyle": "BasicMapperEngine",
    "description": "Defines the parent class from which all mappers should be derived.\n\nThere is only one engine currently allowed to be derived from\nBasicMapperEngine. This allows the simulator to automatically translate\nlogical qubit ids to mapped ids.",
    "lineNumber": 33,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "BasicMapperEngine"
      }
    ],
    "interface": false,
    "extends": [
      "src/cengines/basics.js~BasicEngine"
    ]
  },
  {
    "__docId__": 261,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/cengines/basicmapper.js~BasicMapperEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/basicmapper.js~BasicMapperEngine#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 41,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": "Parent class for all Mappers.\n\nthis.current_mapping (dict): Keys are the logical qubit ids and values\nare the mapped qubit ids."
      }
    ]
  },
  {
    "__docId__": 262,
    "kind": "member",
    "name": "_currentMapping",
    "memberof": "src/cengines/basicmapper.js~BasicMapperEngine",
    "static": false,
    "longname": "src/cengines/basicmapper.js~BasicMapperEngine#_currentMapping",
    "access": "private",
    "description": null,
    "lineNumber": 43,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 263,
    "kind": "get",
    "name": "currentMapping",
    "memberof": "src/cengines/basicmapper.js~BasicMapperEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/basicmapper.js~BasicMapperEngine#currentMapping",
    "access": "public",
    "description": null,
    "lineNumber": 46,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 264,
    "kind": "set",
    "name": "currentMapping",
    "memberof": "src/cengines/basicmapper.js~BasicMapperEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/basicmapper.js~BasicMapperEngine#currentMapping",
    "access": "public",
    "description": null,
    "lineNumber": 50,
    "undocument": true
  },
  {
    "__docId__": 266,
    "kind": "method",
    "name": "sendCMDWithMappedIDs",
    "memberof": "src/cengines/basicmapper.js~BasicMapperEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/basicmapper.js~BasicMapperEngine#sendCMDWithMappedIDs",
    "access": "public",
    "description": "Send this Command using the mapped qubit ids of this.current_mapping.\n\nIf it is a Measurement gate, then it adds a LogicalQubitID tag.",
    "lineNumber": 61,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": "Command object with logical qubit ids."
      }
    ],
    "return": null
  },
  {
    "__docId__": 267,
    "kind": "file",
    "name": "src/cengines/basics.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n\r\nimport {Qureg, Qubit} from '../types/qubit'\r\nimport Command from '../ops/command'\r\nimport {Allocate, Deallocate} from '../ops/gates'\r\nimport {DirtyQubitTag} from '../meta/tag'\r\nimport { LastEngineError } from '../meta/error'\r\n\r\n/**\r\n * @class BasicEngine\r\n * @abstract\r\n * @desc\r\nBasic compiler engine: All compiler engines are derived from this class.\r\nIt provides basic functionality such as qubit allocation/deallocation and\r\nfunctions that provide information about the engine's position (e.g., next\r\nengine).\r\n\r\nThis information is provided by the MainEngine, which initializes all\r\nfurther engines.\r\n\r\n    Attributes:\r\nnext_engine (BasicEngine): Next compiler engine (or the back-end).\r\nmain_engine (MainEngine): Reference to the main compiler engine.\r\nis_last_engine (bool): true for the last engine, which is the back-end.\r\n */\r\nexport class BasicEngine {\r\n  /**\r\n   * @constructor\r\n   Initialize the basic engine.\r\n\r\n    Initializes local variables such as _next_engine, _main_engine, etc. to None.\r\n  */\r\n  constructor() {\r\n    this.isLastEngine = false\r\n  }\r\n\r\n  /**\r\n    Default implementation of isAvailable:\r\n    Ask the next engine whether a command is available, i.e.,\r\n    whether it can be executed by the next engine(s).\r\n\r\n    @param {Command} cmd Command for which to check availability.\r\n    @return {boolean} true if the command can be executed.\r\n\r\n    @throws {LastEngineError} If is_last_engine is true but isAvailable is not implemented.\r\n     */\r\n  isAvailable(cmd) {\r\n    if (!this.isLastEngine) {\r\n      return this.next.isAvailable(cmd)\r\n    }\r\n    throw new LastEngineError('Should not be last!')\r\n  }\r\n\r\n  /**\r\n    Return a new qubit as a list containing 1 qubit object (quantum\r\nregister of size 1).\r\n\r\nAllocates a new qubit by getting a (new) qubit id from the MainEngine,\r\n    creating the qubit object, and then sending an AllocateQubit command\r\ndown the pipeline. If dirty=true, the fresh qubit can be replaced by\r\na pre-allocated one (in an unknown, dirty, initial state). Dirty qubits\r\nmust be returned to their initial states before they are deallocated /\r\nfreed.\r\n\r\n    All allocated qubits are added to the MainEngine's set of active\r\nqubits as weak references. This allows proper clean-up at the end of\r\nthe JavaScript program (using atexit), deallocating all qubits which are\r\nstill alive. Qubit ids of dirty qubits are registered in MainEngine's\r\ndirty_qubits set.\r\n\r\n    @param {boolean} dirty If true, indicates that the allocated qubit may be\r\n    dirty (i.e., in an arbitrary initial state).\r\n\r\n    @return {Qureg} Qureg of length 1, where the first entry is the allocated qubit.\r\n  */\r\n  allocateQubit(dirty = false) {\r\n    const new_id = this.main.getNewQubitID()\r\n    const qubit = new Qubit(this, new_id)\r\n    const qb = new Qureg(qubit)\r\n    const cmd = new Command(this, Allocate, [qb])\r\n    if (dirty) {\r\n      if (this.isMetaTagSupported(DirtyQubitTag)) {\r\n        cmd.tags.push(new DirtyQubitTag())\r\n        this.main.dirtyQubits.add(qubit.id)\r\n      }\r\n    }\r\n    this.main.activeQubits.add(qubit)\r\n    this.send([cmd])\r\n    return qb\r\n  }\r\n\r\n  /**\r\n    Allocate n qubits and return them as a quantum register, which is a\r\nlist of qubit objects.\r\n\r\n    @param {number} n Number of qubits to allocate\r\n    @return {Qureg} Qureg of length n, a list of n newly allocated qubits.\r\n  */\r\n  allocateQureg(n) {\r\n    const array = []\r\n    for (let i = 0; i < n; ++i) {\r\n      const q = this.allocateQubit()[0]\r\n      array.push(q)\r\n    }\r\n    return new Qureg(array)\r\n  }\r\n\r\n  /**\r\n    Deallocate a qubit (and sends the deallocation command down the\r\npipeline). If the qubit was allocated as a dirty qubit, add\r\nDirtyQubitTag() to Deallocate command.\r\n\r\n    @param {BasicQubit} qubit Qubit to deallocate.\r\n    @throws {Error} Qubit already deallocated. Caller likely has a bug.\r\n  */\r\n  deallocateQubit(qubit) {\r\n    if (qubit.id === -1) {\r\n      throw new Error('Already deallocated.')\r\n    }\r\n    const is_dirty = this.main.dirtyQubits.has(qubit.id)\r\n    const cmds = [new Command(this, Deallocate, [new Qureg([qubit])], [], is_dirty ? [new DirtyQubitTag()] : [])]\r\n    this.send(cmds)\r\n  }\r\n\r\n  /**\r\n    Check if there is a compiler engine handling the meta tag\r\n\r\n    @param {function} metaTag Meta tag class for which to check support\r\n\r\n    @return {boolean} true if one of the further compiler engines is a\r\nmeta tag handler, i.e., engine.is_meta_tag_handler(meta_tag)\r\nreturns true.\r\n     */\r\n  isMetaTagSupported(metaTag) {\r\n    let engine = this\r\n    try {\r\n      while (true) {\r\n        if (typeof engine.isMetaTagHandler === 'function' && engine.isMetaTagHandler(metaTag)) {\r\n          return true\r\n        }\r\n        engine = engine.next\r\n      }\r\n    } catch (e) {\r\n      return false\r\n    }\r\n  }\r\n\r\n  /**\r\n    Forward the list of commands to the next engine in the pipeline.\r\n   @param {Command[]} commandList\r\n  */\r\n  send(commandList) {\r\n    this.next.receive(commandList)\r\n  }\r\n\r\n  receive() {\r\n    // do nothing\r\n  }\r\n}\r\n\r\n/**\r\n * @class ForwarderEngine\r\n * @desc\r\n    A ForwarderEngine is a trivial engine which forwards all commands to the next engine.\r\n\r\n    It is mainly used as a substitute for the MainEngine at lower levels such\r\nthat meta operations still work (e.g., with Compute).\r\n */\r\nexport class ForwarderEngine extends BasicEngine {\r\n  /**\r\n   * @constructor\r\n\r\n    @param {BasicEngine} engine Engine to forward all commands to.\r\n    @param {function} cmdModFunc Function which is called before sending a\r\ncommand. Each command cmd is replaced by the command it\r\nreturns when getting called with cmd.\r\n     */\r\n  constructor(engine, cmdModFunc) {\r\n    super()\r\n    this.main = engine.main\r\n    this.next = engine\r\n    if (!cmdModFunc) {\r\n      cmdModFunc = x => x\r\n    }\r\n    this.cmdModFunc = cmdModFunc\r\n  }\r\n\r\n  receive(commandList) {\r\n    const newCommandList = commandList.map(cmd => this.cmdModFunc(cmd))\r\n    this.send(newCommandList)\r\n  }\r\n\r\n  /**\r\n   * internal usaged for deallocate qubits after `Uncompute`\r\n   */\r\n  autoDeallocateQubits() {\r\n    const copy = new Set(this.main.activeQubits)\r\n    copy.forEach((qb) => {\r\n      if (qb.engine === this) {\r\n        // need to\r\n        qb.deallocate()\r\n      }\r\n    })\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/cengines/basics.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 268,
    "kind": "class",
    "name": "BasicEngine",
    "memberof": "src/cengines/basics.js",
    "static": true,
    "longname": "src/cengines/basics.js~BasicEngine",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/cengines/basics.js",
    "importStyle": "{BasicEngine}",
    "description": "Basic compiler engine: All compiler engines are derived from this class.\nIt provides basic functionality such as qubit allocation/deallocation and\nfunctions that provide information about the engine's position (e.g., next\nengine).\n\nThis information is provided by the MainEngine, which initializes all\nfurther engines.\n\nAttributes:\nnext_engine (BasicEngine): Next compiler engine (or the back-end).\nmain_engine (MainEngine): Reference to the main compiler engine.\nis_last_engine (bool): true for the last engine, which is the back-end.",
    "lineNumber": 41,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "BasicEngine"
      }
    ],
    "abstract": true,
    "interface": false
  },
  {
    "__docId__": 269,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/cengines/basics.js~BasicEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/basics.js~BasicEngine#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 48,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": "Initialize the basic engine.\n\nInitializes local variables such as _next_engine, _main_engine, etc. to None."
      }
    ]
  },
  {
    "__docId__": 270,
    "kind": "member",
    "name": "isLastEngine",
    "memberof": "src/cengines/basics.js~BasicEngine",
    "static": false,
    "longname": "src/cengines/basics.js~BasicEngine#isLastEngine",
    "access": "public",
    "description": null,
    "lineNumber": 49,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 271,
    "kind": "method",
    "name": "isAvailable",
    "memberof": "src/cengines/basics.js~BasicEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/basics.js~BasicEngine#isAvailable",
    "access": "public",
    "description": "Default implementation of isAvailable:\nAsk the next engine whether a command is available, i.e.,\nwhether it can be executed by the next engine(s).",
    "lineNumber": 62,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": "Command for which to check availability."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the command can be executed."
    },
    "throws": [
      {
        "types": [
          "LastEngineError"
        ],
        "description": "If is_last_engine is true but isAvailable is not implemented."
      }
    ]
  },
  {
    "__docId__": 272,
    "kind": "method",
    "name": "allocateQubit",
    "memberof": "src/cengines/basics.js~BasicEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/basics.js~BasicEngine#allocateQubit",
    "access": "public",
    "description": "Return a new qubit as a list containing 1 qubit object (quantum\nregister of size 1).\n\nAllocates a new qubit by getting a (new) qubit id from the MainEngine,\ncreating the qubit object, and then sending an AllocateQubit command\ndown the pipeline. If dirty=true, the fresh qubit can be replaced by\na pre-allocated one (in an unknown, dirty, initial state). Dirty qubits\nmust be returned to their initial states before they are deallocated /\nfreed.\n\nAll allocated qubits are added to the MainEngine's set of active\nqubits as weak references. This allows proper clean-up at the end of\nthe JavaScript program (using atexit), deallocating all qubits which are\nstill alive. Qubit ids of dirty qubits are registered in MainEngine's\ndirty_qubits set.",
    "lineNumber": 91,
    "params": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "dirty",
        "description": "If true, indicates that the allocated qubit may be\ndirty (i.e., in an arbitrary initial state)."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Qureg"
      ],
      "spread": false,
      "description": "Qureg of length 1, where the first entry is the allocated qubit."
    }
  },
  {
    "__docId__": 273,
    "kind": "method",
    "name": "allocateQureg",
    "memberof": "src/cengines/basics.js~BasicEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/basics.js~BasicEngine#allocateQureg",
    "access": "public",
    "description": "Allocate n qubits and return them as a quantum register, which is a\nlist of qubit objects.",
    "lineNumber": 114,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "n",
        "description": "Number of qubits to allocate"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Qureg"
      ],
      "spread": false,
      "description": "Qureg of length n, a list of n newly allocated qubits."
    }
  },
  {
    "__docId__": 274,
    "kind": "method",
    "name": "deallocateQubit",
    "memberof": "src/cengines/basics.js~BasicEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/basics.js~BasicEngine#deallocateQubit",
    "access": "public",
    "description": "Deallocate a qubit (and sends the deallocation command down the\npipeline). If the qubit was allocated as a dirty qubit, add\nDirtyQubitTag() to Deallocate command.",
    "lineNumber": 131,
    "params": [
      {
        "nullable": null,
        "types": [
          "BasicQubit"
        ],
        "spread": false,
        "optional": false,
        "name": "qubit",
        "description": "Qubit to deallocate."
      }
    ],
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Qubit already deallocated. Caller likely has a bug."
      }
    ],
    "return": null
  },
  {
    "__docId__": 275,
    "kind": "method",
    "name": "isMetaTagSupported",
    "memberof": "src/cengines/basics.js~BasicEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/basics.js~BasicEngine#isMetaTagSupported",
    "access": "public",
    "description": "Check if there is a compiler engine handling the meta tag",
    "lineNumber": 149,
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "metaTag",
        "description": "Meta tag class for which to check support"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if one of the further compiler engines is a\nmeta tag handler, i.e., engine.is_meta_tag_handler(meta_tag)\nreturns true."
    }
  },
  {
    "__docId__": 276,
    "kind": "method",
    "name": "send",
    "memberof": "src/cengines/basics.js~BasicEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/basics.js~BasicEngine#send",
    "access": "public",
    "description": "Forward the list of commands to the next engine in the pipeline.",
    "lineNumber": 167,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command[]"
        ],
        "spread": false,
        "optional": false,
        "name": "commandList",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 277,
    "kind": "method",
    "name": "receive",
    "memberof": "src/cengines/basics.js~BasicEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/basics.js~BasicEngine#receive",
    "access": "public",
    "description": null,
    "lineNumber": 171,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 278,
    "kind": "class",
    "name": "ForwarderEngine",
    "memberof": "src/cengines/basics.js",
    "static": true,
    "longname": "src/cengines/basics.js~ForwarderEngine",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/cengines/basics.js",
    "importStyle": "{ForwarderEngine}",
    "description": "A ForwarderEngine is a trivial engine which forwards all commands to the next engine.\n\nIt is mainly used as a substitute for the MainEngine at lower levels such\nthat meta operations still work (e.g., with Compute).",
    "lineNumber": 184,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "ForwarderEngine"
      }
    ],
    "interface": false,
    "extends": [
      "BasicEngine"
    ]
  },
  {
    "__docId__": 279,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/cengines/basics.js~ForwarderEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/basics.js~ForwarderEngine#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 193,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "BasicEngine"
        ],
        "spread": false,
        "optional": false,
        "name": "engine",
        "description": "Engine to forward all commands to."
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "cmdModFunc",
        "description": "Function which is called before sending a\ncommand. Each command cmd is replaced by the command it\nreturns when getting called with cmd."
      }
    ]
  },
  {
    "__docId__": 280,
    "kind": "member",
    "name": "main",
    "memberof": "src/cengines/basics.js~ForwarderEngine",
    "static": false,
    "longname": "src/cengines/basics.js~ForwarderEngine#main",
    "access": "public",
    "description": null,
    "lineNumber": 195,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 281,
    "kind": "member",
    "name": "next",
    "memberof": "src/cengines/basics.js~ForwarderEngine",
    "static": false,
    "longname": "src/cengines/basics.js~ForwarderEngine#next",
    "access": "public",
    "description": null,
    "lineNumber": 196,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 282,
    "kind": "member",
    "name": "cmdModFunc",
    "memberof": "src/cengines/basics.js~ForwarderEngine",
    "static": false,
    "longname": "src/cengines/basics.js~ForwarderEngine#cmdModFunc",
    "access": "public",
    "description": null,
    "lineNumber": 200,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 283,
    "kind": "method",
    "name": "receive",
    "memberof": "src/cengines/basics.js~ForwarderEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/basics.js~ForwarderEngine#receive",
    "access": "public",
    "description": null,
    "lineNumber": 203,
    "undocument": true,
    "params": [
      {
        "name": "commandList",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 284,
    "kind": "method",
    "name": "autoDeallocateQubits",
    "memberof": "src/cengines/basics.js~ForwarderEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/basics.js~ForwarderEngine#autoDeallocateQubits",
    "access": "public",
    "description": "internal usaged for deallocate qubits after `Uncompute`",
    "lineNumber": 211,
    "params": [],
    "return": null
  },
  {
    "__docId__": 285,
    "kind": "file",
    "name": "src/cengines/cmdmodifier.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/**\r\nContains a CommandModifier engine, which can be used to, e.g., modify the tags\r\nof all commands which pass by (see the AutoReplacer for an example).\r\n*/\r\n\r\nimport {BasicEngine} from './basics'\r\n\r\n/**\r\n * @class CommandModifier\r\n * @desc\r\nCommandModifier is a compiler engine which applies a function to all\r\nincoming commands, sending on the resulting command instead of the original one.\r\n */\r\nexport default class CommandModifier extends BasicEngine {\r\n  /**\r\n   * @constructor\r\n  Initialize the CommandModifier.\r\n\r\n    @param {function} cmdModFunc Function which, given a command cmd,\r\n    returns the command it should send instead.\r\n\r\n    @example\r\n\r\nfunction cmd_mod_fun(cmd)\r\ncmd.tags += [new MyOwnTag()]\r\ncompiler_engine = new CommandModifier(cmd_mod_fun)\r\n   */\r\n  constructor(cmdModFunc) {\r\n    super()\r\n    this._cmdModFunc = cmdModFunc\r\n  }\r\n\r\n  /**\r\n  Receive a list of commands from the previous engine, modify all\r\n   commands, and send them on to the next engine.\r\n\r\n    @param {Command[]} cmdList List of commands to receive and then (after modification) send on.\r\n   */\r\n  receive(cmdList) {\r\n    const newList = cmdList.map(cmd => this._cmdModFunc(cmd))\r\n    this.send(newList)\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/cengines/cmdmodifier.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 286,
    "kind": "class",
    "name": "CommandModifier",
    "memberof": "src/cengines/cmdmodifier.js",
    "static": true,
    "longname": "src/cengines/cmdmodifier.js~CommandModifier",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/cengines/cmdmodifier.js",
    "importStyle": "CommandModifier",
    "description": "CommandModifier is a compiler engine which applies a function to all\nincoming commands, sending on the resulting command instead of the original one.",
    "lineNumber": 30,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "CommandModifier"
      }
    ],
    "interface": false,
    "extends": [
      "src/cengines/basics.js~BasicEngine"
    ]
  },
  {
    "__docId__": 287,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/cengines/cmdmodifier.js~CommandModifier",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/cmdmodifier.js~CommandModifier#constructor",
    "access": "public",
    "description": "",
    "examples": [
      "\nfunction cmd_mod_fun(cmd)\ncmd.tags += [new MyOwnTag()]\ncompiler_engine = new CommandModifier(cmd_mod_fun)"
    ],
    "lineNumber": 44,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": "Initialize the CommandModifier."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "cmdModFunc",
        "description": "Function which, given a command cmd,\nreturns the command it should send instead."
      }
    ]
  },
  {
    "__docId__": 288,
    "kind": "member",
    "name": "_cmdModFunc",
    "memberof": "src/cengines/cmdmodifier.js~CommandModifier",
    "static": false,
    "longname": "src/cengines/cmdmodifier.js~CommandModifier#_cmdModFunc",
    "access": "private",
    "description": null,
    "lineNumber": 46,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 289,
    "kind": "method",
    "name": "receive",
    "memberof": "src/cengines/cmdmodifier.js~CommandModifier",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/cmdmodifier.js~CommandModifier#receive",
    "access": "public",
    "description": "Receive a list of commands from the previous engine, modify all\ncommands, and send them on to the next engine.",
    "lineNumber": 55,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command[]"
        ],
        "spread": false,
        "optional": false,
        "name": "cmdList",
        "description": "List of commands to receive and then (after modification) send on."
      }
    ],
    "return": null
  },
  {
    "__docId__": 290,
    "kind": "file",
    "name": "src/cengines/ibm5qubitmapper.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport {permutations} from 'itertools'\r\nimport BasicMapperEngine from './basicmapper'\r\nimport { Allocate, FlushGate, NOT } from '../ops/gates'\r\n\r\nimport IBMBackend from '../backends/ibm/ibm'\r\n\r\nfunction stringKeyToIntArray(key) {\r\n  return key.split(',').map(i => parseInt(i, 10))\r\n}\r\n\r\n// export const ibmqx4_connections = new Set([2, 1], [4, 2], [2, 0], [3, 2], [3, 4], [1, 0])\r\n/**\r\n * @type {Set<string>}\r\n */\r\nexport const ibmqx4_connections = new Set(['2,1', '4,2', '2,0', '3,2', '3,4', '1,0'])\r\n\r\n/**\r\n * @class IBM5QubitMapper\r\n * @desc\r\nMapper for the 5-qubit IBM backend.\r\n\r\n  Maps a given circuit to the IBM Quantum Experience chip.\r\n\r\n  Note:\r\nThe mapper has to be run once on the entire circuit.\r\n\r\n  Warning:\r\nIf the provided circuit cannot be mapped to the hardware layout\r\nwithout performing Swaps, the mapping procedure\r\n**raises an Exception**.\r\n */\r\nexport default class IBM5QubitMapper extends BasicMapperEngine {\r\n  /**\r\n   * @constructor\r\nInitialize an IBM 5-qubit mapper compiler engine.\r\n\r\n  Resets the mapping.\r\n   */\r\n  constructor() {\r\n    super();\r\n    this.currentMapping = {}\r\n    this._reset()\r\n  }\r\n\r\n  /**\r\n  Check if the IBM backend can perform the Command cmd and return true\r\nif so.\r\n\r\n  @param {Command} cmd The command to check\r\n   */\r\n  isAvailable(cmd) {\r\n    return new IBMBackend().isAvailable(cmd)\r\n  }\r\n\r\n  // Reset the mapping parameters so the next circuit can be mapped.\r\n  _reset() {\r\n    this._cmds = []\r\n    this._interactions = {}\r\n  }\r\n\r\n  /**\r\n  Check if the command corresponds to a CNOT (controlled NOT gate).\r\n\r\n  @param {Command} cmd Command to check whether it is a controlled NOT gate.\r\n  */\r\n  _isCNOT(cmd) {\r\n    return (cmd.gate instanceof NOT.constructor && cmd.controlCount === 1)\r\n  }\r\n\r\n  /**\r\n  Determines the cost of the circuit with the given mapping.\r\n\r\n  @param {Object} mapping Dictionary with key, value pairs where keys are\r\n    logical qubit ids and the corresponding value is the physical\r\n    location on the IBM Q chip.\r\n  @return {number} Cost measure taking into account CNOT directionality or None\r\n    if the circuit cannot be executed given the mapping.\r\n  */\r\n  determineCost(mapping) {\r\n    let cost = 0\r\n    const connections = ibmqx4_connections\r\n    const keys = Object.keys(this._interactions)\r\n    for (let i = 0; i < keys.length; ++i) {\r\n      const tpl = stringKeyToIntArray(keys[i])\r\n      const ctrl_id = tpl[0]\r\n      const target_id = tpl[1]\r\n      const ctrl_pos = mapping[ctrl_id]\r\n      const target_pos = mapping[target_id]\r\n      let k = `${ctrl_pos},${target_pos}`\r\n      let v = connections.has(k)\r\n      if (!v) {\r\n        k = `${target_pos},${ctrl_pos}`\r\n        v = connections.has(k)\r\n        if (v) {\r\n          cost += this._interactions[tpl]\r\n        } else {\r\n          return undefined\r\n        }\r\n      }\r\n    }\r\n    return cost\r\n  }\r\n\r\n  /**\r\n  Runs all stored gates.\r\n\r\n  @throws {Error}\r\n  If the mapping to the IBM backend cannot be performed or if\r\n  the mapping was already determined but more CNOTs get sent\r\ndown the pipeline.\r\n   */\r\n  run() {\r\n    if (Object.keys(this._currentMapping).length > 0 && Math.max(...Object.values(this._currentMapping)) > 4) {\r\n      throw new Error('Too many qubits allocated. The IBM Q '\r\n      + 'device supports at most 5 qubits and no '\r\n      + 'intermediate measurements / '\r\n      + 'reallocations.')\r\n    }\r\n    if (Object.keys(this._interactions).length > 0) {\r\n      const logical_ids = Object.keys(this._currentMapping).map(k => parseInt(k, 10))\r\n      let best_mapping = this._currentMapping\r\n      let best_cost\r\n\r\n      for (const physical_ids of permutations([0, 1, 2, 3, 4], logical_ids.length)) {\r\n        const mapping = {}\r\n        physical_ids.forEach((looper, i) => mapping[logical_ids[i]] = looper)\r\n        const new_cost = this.determineCost(mapping)\r\n        if (new_cost) {\r\n          if (!best_cost || new_cost < best_cost) {\r\n            best_cost = new_cost\r\n            best_mapping = mapping\r\n          }\r\n        }\r\n      }\r\n\r\n      if (!best_cost) {\r\n        throw new Error('Circuit cannot be mapped without using Swaps. Mapping failed.')\r\n      }\r\n      this._interactions = {}\r\n      this.currentMapping = best_mapping\r\n    }\r\n\r\n    this._cmds.forEach(cmd => this.sendCMDWithMappedIDs(cmd))\r\n\r\n    this._cmds = []\r\n  }\r\n\r\n  /**\r\n  Store a command and handle CNOTs.\r\n\r\n  @param {Command} cmd A command to store\r\n   */\r\n  _store(cmd) {\r\n    let target\r\n    if (!(cmd.gate instanceof FlushGate)) {\r\n      target = cmd.qubits[0][0].id\r\n    }\r\n\r\n    if (this._isCNOT(cmd)) {\r\n      // CNOT encountered\r\n      const ctrl = cmd.controlQubits[0].id\r\n      const key = [ctrl, target]\r\n      const v = this._interactions[key]\r\n      if (typeof v === 'undefined') {\r\n        this._interactions[key] = 0\r\n      }\r\n      this._interactions[key] += 1\r\n    } else if (cmd.gate.equal(Allocate)) {\r\n      const v = this._currentMapping[target]\r\n      if (typeof v === 'undefined') {\r\n        let newMax = 0\r\n        if (Object.keys(this._currentMapping).length > 0) {\r\n          newMax = Math.max(...Object.values(this._currentMapping)) + 1\r\n        }\r\n        this._currentMapping[target] = newMax\r\n      }\r\n    }\r\n    this._cmds.push(cmd)\r\n  }\r\n\r\n  /**\r\n  Receives a command list and, for each command, stores it until\r\ncompletion.\r\n\r\n  @param {Command[]} commandList list of commands to receive.\r\n\r\n  @throws {Error} If mapping the CNOT gates to 1 qubit would require\r\nSwaps. The current version only supports remapping of CNOT\r\ngates without performing any Swaps due to the large costs\r\nassociated with Swapping given the CNOT constraints.\r\n   */\r\n  receive(commandList) {\r\n    commandList.forEach((cmd) => {\r\n      this._store(cmd)\r\n      if (cmd.gate instanceof FlushGate) {\r\n        this.run()\r\n        this._reset()\r\n      }\r\n    })\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/cengines/ibm5qubitmapper.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 291,
    "kind": "function",
    "name": "stringKeyToIntArray",
    "memberof": "src/cengines/ibm5qubitmapper.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/cengines/ibm5qubitmapper.js~stringKeyToIntArray",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/cengines/ibm5qubitmapper.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 292,
    "kind": "variable",
    "name": "ibmqx4_connections",
    "memberof": "src/cengines/ibm5qubitmapper.js",
    "static": true,
    "longname": "src/cengines/ibm5qubitmapper.js~ibmqx4_connections",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/cengines/ibm5qubitmapper.js",
    "importStyle": "{ibmqx4_connections}",
    "description": "",
    "lineNumber": 31,
    "type": {
      "nullable": null,
      "types": [
        "Set<string>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 293,
    "kind": "class",
    "name": "IBM5QubitMapper",
    "memberof": "src/cengines/ibm5qubitmapper.js",
    "static": true,
    "longname": "src/cengines/ibm5qubitmapper.js~IBM5QubitMapper",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/cengines/ibm5qubitmapper.js",
    "importStyle": "IBM5QubitMapper",
    "description": "Mapper for the 5-qubit IBM backend.\n\nMaps a given circuit to the IBM Quantum Experience chip.\n\nNote:\nThe mapper has to be run once on the entire circuit.\n\nWarning:\nIf the provided circuit cannot be mapped to the hardware layout\nwithout performing Swaps, the mapping procedure\n*raises an Exception**.",
    "lineNumber": 48,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "IBM5QubitMapper"
      }
    ],
    "interface": false,
    "extends": [
      "src/cengines/basicmapper.js~BasicMapperEngine"
    ]
  },
  {
    "__docId__": 294,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/cengines/ibm5qubitmapper.js~IBM5QubitMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/ibm5qubitmapper.js~IBM5QubitMapper#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 55,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": "Initialize an IBM 5-qubit mapper compiler engine.\n\nResets the mapping."
      }
    ]
  },
  {
    "__docId__": 295,
    "kind": "member",
    "name": "currentMapping",
    "memberof": "src/cengines/ibm5qubitmapper.js~IBM5QubitMapper",
    "static": false,
    "longname": "src/cengines/ibm5qubitmapper.js~IBM5QubitMapper#currentMapping",
    "access": "public",
    "description": null,
    "lineNumber": 57,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 296,
    "kind": "method",
    "name": "isAvailable",
    "memberof": "src/cengines/ibm5qubitmapper.js~IBM5QubitMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/ibm5qubitmapper.js~IBM5QubitMapper#isAvailable",
    "access": "public",
    "description": "Check if the IBM backend can perform the Command cmd and return true\nif so.",
    "lineNumber": 67,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": "The command to check"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 297,
    "kind": "method",
    "name": "_reset",
    "memberof": "src/cengines/ibm5qubitmapper.js~IBM5QubitMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/ibm5qubitmapper.js~IBM5QubitMapper#_reset",
    "access": "private",
    "description": null,
    "lineNumber": 72,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 298,
    "kind": "member",
    "name": "_cmds",
    "memberof": "src/cengines/ibm5qubitmapper.js~IBM5QubitMapper",
    "static": false,
    "longname": "src/cengines/ibm5qubitmapper.js~IBM5QubitMapper#_cmds",
    "access": "private",
    "description": null,
    "lineNumber": 73,
    "undocument": true,
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 299,
    "kind": "member",
    "name": "_interactions",
    "memberof": "src/cengines/ibm5qubitmapper.js~IBM5QubitMapper",
    "static": false,
    "longname": "src/cengines/ibm5qubitmapper.js~IBM5QubitMapper#_interactions",
    "access": "private",
    "description": null,
    "lineNumber": 74,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 300,
    "kind": "method",
    "name": "_isCNOT",
    "memberof": "src/cengines/ibm5qubitmapper.js~IBM5QubitMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/ibm5qubitmapper.js~IBM5QubitMapper#_isCNOT",
    "access": "private",
    "description": "Check if the command corresponds to a CNOT (controlled NOT gate).",
    "lineNumber": 82,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": "Command to check whether it is a controlled NOT gate."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 301,
    "kind": "method",
    "name": "determineCost",
    "memberof": "src/cengines/ibm5qubitmapper.js~IBM5QubitMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/ibm5qubitmapper.js~IBM5QubitMapper#determineCost",
    "access": "public",
    "description": "Determines the cost of the circuit with the given mapping.",
    "lineNumber": 95,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "mapping",
        "description": "Dictionary with key, value pairs where keys are\nlogical qubit ids and the corresponding value is the physical\nlocation on the IBM Q chip."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Cost measure taking into account CNOT directionality or None\nif the circuit cannot be executed given the mapping."
    }
  },
  {
    "__docId__": 302,
    "kind": "method",
    "name": "run",
    "memberof": "src/cengines/ibm5qubitmapper.js~IBM5QubitMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/ibm5qubitmapper.js~IBM5QubitMapper#run",
    "access": "public",
    "description": "Runs all stored gates.",
    "lineNumber": 128,
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If the mapping to the IBM backend cannot be performed or if\nthe mapping was already determined but more CNOTs get sent\ndown the pipeline."
      }
    ],
    "params": [],
    "return": null
  },
  {
    "__docId__": 306,
    "kind": "method",
    "name": "_store",
    "memberof": "src/cengines/ibm5qubitmapper.js~IBM5QubitMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/ibm5qubitmapper.js~IBM5QubitMapper#_store",
    "access": "private",
    "description": "Store a command and handle CNOTs.",
    "lineNumber": 169,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": "A command to store"
      }
    ],
    "return": null
  },
  {
    "__docId__": 307,
    "kind": "method",
    "name": "receive",
    "memberof": "src/cengines/ibm5qubitmapper.js~IBM5QubitMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/ibm5qubitmapper.js~IBM5QubitMapper#receive",
    "access": "public",
    "description": "Receives a command list and, for each command, stores it until\ncompletion.",
    "lineNumber": 208,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command[]"
        ],
        "spread": false,
        "optional": false,
        "name": "commandList",
        "description": "list of commands to receive."
      }
    ],
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If mapping the CNOT gates to 1 qubit would require\nSwaps. The current version only supports remapping of CNOT\ngates without performing any Swaps due to the large costs\nassociated with Swapping given the CNOT constraints."
      }
    ],
    "return": null
  },
  {
    "__docId__": 308,
    "kind": "file",
    "name": "src/cengines/linearmapper.js",
    "content": "\r\n/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/*\r\nMapper for a quantum circuit to a linear chain of qubits.\r\n\r\n    Input: Quantum circuit with 1 and 2 qubit gates on n qubits. Gates are assumed\r\nto be applied in parallel if they act on disjoint qubit(s) and any pair\r\nof qubits can perform a 2 qubit gate (all-to-all connectivity)\r\nOutput: Quantum circuit in which qubits are placed in 1-D chain in which only\r\nnearest neighbour qubits can perform a 2 qubit gate. The mapper uses\r\nSwap gates in order to move qubits next to each other.\r\n*/\r\n\r\n\r\nimport assert from 'assert'\r\nimport BasicMapperEngine from './basicmapper'\r\nimport {\r\n  intersection, len, setDifference, setFromRange\r\n} from '../libs/polyfill'\r\nimport {\r\n  Allocate,\r\n  AllocateQubitGate, Deallocate, DeallocateQubitGate, FlushGate, Swap\r\n} from '../ops/gates'\r\nimport {BasicQubit} from '../types/qubit'\r\nimport {tuple} from '../libs/util'\r\nimport Command from '../ops/command'\r\nimport {LogicalQubitIDTag} from '../meta'\r\n\r\n/**\r\n * @ignore\r\n Returns the circuit depth to execute these swaps.\r\n @param {Array.<Array>} swaps Each tuple contains two integers representing the two IDs of the qubits involved in the\r\n    Swap operation\r\n @returns {number} Circuit depth to execute these swaps.\r\n */\r\nexport function return_swap_depth(swaps) {\r\n  const depth_of_qubits = {}\r\n  swaps.forEach(([qb0_id, qb1_id]) => {\r\n    if (!(qb0_id in depth_of_qubits)) {\r\n      depth_of_qubits[qb0_id] = 0\r\n    }\r\n    if (!(qb1_id in depth_of_qubits)) {\r\n      depth_of_qubits[qb1_id] = 0\r\n    }\r\n    const max_depth = Math.max(depth_of_qubits[qb0_id], depth_of_qubits[qb1_id])\r\n    depth_of_qubits[qb0_id] = max_depth + 1\r\n    depth_of_qubits[qb1_id] = max_depth + 1\r\n  })\r\n  const values = Object.values(depth_of_qubits)\r\n  values.push(0)\r\n  return Math.max(...values)\r\n}\r\n\r\n/**\r\n * @class LinearMapper\r\n * @desc\r\nMaps a quantum circuit to a linear chain of nearest neighbour interactions.\r\n\r\n    Maps a quantum circuit to a linear chain of qubits with nearest neighbour\r\ninteractions using Swap gates. It supports open or cyclic boundary\r\nconditions.\r\n\r\n    Attributes:\r\ncurrent_mapping:  Stores the mapping: key is logical qubit id, value\r\nis mapped qubit id from 0,...,this.num_qubits\r\ncyclic (Bool): If chain is cyclic or not\r\nstorage (int): Number of gate it caches before mapping.\r\nnum_mappings (int): Number of times the mapper changed the mapping\r\ndepth_of_swaps (dict): Key are circuit depth of swaps, value is the\r\nnumber of such mappings which have been\r\napplied\r\nnum_of_swaps_per_mapping (dict): Key are the number of swaps per\r\nmapping, value is the number of such\r\nmappings which have been applied\r\n\r\nNote:\r\n    1) Gates are cached and only mapped from time to time. A\r\nFastForwarding gate doesn't empty the cache, only a FlushGate does.\r\n2) Only 1 and two qubit gates allowed.\r\n3) Does not optimize for dirty qubits.\r\n */\r\nexport default class LinearMapper extends BasicMapperEngine {\r\n  /**\r\n   * @constructor\r\n  Initialize a LinearMapper compiler engine.\r\n\r\n    @param {number} num_qubits Number of physical qubits in the linear chain\r\n    @param {boolean} cyclic If 1D chain is a cycle. Default is false.\r\n    @param {number} storage Number of gates to temporarily store, default is 1000\r\n  */\r\n  constructor(num_qubits, cyclic = false, storage = 1000) {\r\n    super()\r\n\r\n    this.num_qubits = num_qubits\r\n    this.cyclic = cyclic\r\n    this.storage = storage\r\n    // Storing commands\r\n    this._stored_commands = []\r\n    // Logical qubit ids for which the Allocate gate has already been\r\n    // processed and sent to the next engine but which are not yet\r\n    // deallocated:\r\n    this._currently_allocated_ids = new Set()\r\n    // Statistics:\r\n    this.num_mappings = 0\r\n    this.depth_of_swaps = {}\r\n    this.num_of_swaps_per_mapping = {}\r\n  }\r\n\r\n  // Only allows 1 or two qubit gates.\r\n  isAvailable(cmd) {\r\n    let num_qubits = 0\r\n    cmd.allQubits.forEach(qureg => num_qubits += len(qureg))\r\n    return num_qubits <= 2\r\n  }\r\n\r\n  /**\r\n   * @static\r\n  Builds a mapping of qubits to a linear chain.\r\n\r\n    It goes through stored_commands and tries to find a mapping to apply these gates\r\n    on a first come first served basis. More compilicated scheme could try to optimize to apply\r\n   as many gates as possible between the Swaps.\r\n\r\n    @param {number} num_qubits Total number of qubits in the linear chain\r\n    @param {boolean} cyclic If linear chain is a cycle.\r\n    @param {Set<Number>} currently_allocated_ids Logical qubit ids for which\r\n      the Allocate gate has already been processed and sent to the next engine but which are\r\n      not yet deallocated and hence need to be included in the new mapping.\r\n    @param {Command[]} stored_commands Future commands which should be applied next.\r\n    @param {Object} current_mapping A current mapping as a dict. key is logical qubit id, value is placement id.\r\n      If there are different possible maps, this current mapping is used to minimize the swaps\r\n      to go to the new mapping by a heuristic.\r\n\r\n    @return {Object} A new mapping as a dict. key is logical qubit id, value is placement id\r\n   */\r\n  static returnNewMapping(num_qubits, cyclic, currently_allocated_ids, stored_commands, current_mapping) {\r\n    // allocated_qubits is used as this mapper currently does not reassign\r\n    // a qubit placement to a new qubit if the previous qubit at that\r\n    // location has been deallocated. This is done after the next swaps.\r\n    const allocated_qubits = new Set(currently_allocated_ids)\r\n    const active_qubits = new Set(currently_allocated_ids)\r\n    // Segments contains a list of segments. A segment is a list of\r\n    // neighouring qubit ids\r\n    const segments = []\r\n    // neighbour_ids only used to speedup the lookup process if qubits\r\n    // are already connected. key: qubit_id, value: set of neighbour ids\r\n    const neighbour_ids = {}\r\n    active_qubits.forEach(qubit_id => neighbour_ids[qubit_id] = new Set())\r\n\r\n    for (let i = 0; i < stored_commands.length; ++i) {\r\n      const cmd = stored_commands[i]\r\n      if (len(allocated_qubits) === num_qubits && len(active_qubits) === 0) {\r\n        break\r\n      }\r\n\r\n      const qubit_ids = []\r\n      cmd.allQubits.forEach(qureg => qureg.forEach(qubit => qubit_ids.push(qubit.id)))\r\n\r\n      if (len(qubit_ids) > 2 || len(qubit_ids) === 0) {\r\n        throw new Error(`Invalid command (number of qubits): ${cmd.toString()}`)\r\n      } else if (cmd.gate instanceof AllocateQubitGate) {\r\n        const qubit_id = cmd.qubits[0][0].id\r\n        if (len(allocated_qubits) < num_qubits) {\r\n          allocated_qubits.add(qubit_id)\r\n          active_qubits.add(qubit_id)\r\n          neighbour_ids[qubit_id] = new Set()\r\n        }\r\n      } else if (cmd.gate instanceof DeallocateQubitGate) {\r\n        const qubit_id = cmd.qubits[0][0].id\r\n        if (active_qubits.has(qubit_id)) {\r\n          active_qubits.delete(qubit_id)\r\n        }\r\n        // Do not remove from allocated_qubits as this would\r\n        // allow the mapper to add a new qubit to this location\r\n        // before the next swaps which is currently not supported\r\n      } else if (len(qubit_ids) === 1) {\r\n        continue\r\n      } else {\r\n        // Process a two qubit gate:\r\n\r\n        LinearMapper._processTwoQubitGate(\r\n          num_qubits,\r\n          cyclic,\r\n          qubit_ids[0],\r\n          qubit_ids[1],\r\n          active_qubits,\r\n          segments,\r\n          neighbour_ids\r\n        )\r\n      }\r\n    }\r\n\r\n    return LinearMapper._returnNewMappingFromSegments(\r\n      num_qubits,\r\n      segments,\r\n      allocated_qubits,\r\n      current_mapping\r\n    )\r\n  }\r\n\r\n  /**\r\n  Processes a two qubit gate.\r\n\r\n    It either removes the two qubits from active_qubits if the gate is not\r\npossible or updates the segements such that the gate is possible.\r\n\r\n   @param {number} num_qubits Total number of qubits in the chain\r\n   @param {boolean} cyclic If linear chain is a cycle\r\n   @param {number} qubit0 qubit.id of one of the qubits\r\n   @param {number} qubit1 qubit.id of the other qubit\r\n   @param {Set<Number>} active_qubits contains all qubit ids which for which gates can be applied in this cycle before the swaps\r\n   @param {Array} segments List of segments. A segment is a list of neighbouring qubits.\r\n   @param {Object} neighbour_ids Key: qubit.id Value: qubit.id of neighbours\r\n   */\r\n  static _processTwoQubitGate(num_qubits, cyclic, qubit0, qubit1, active_qubits, segments, neighbour_ids) {\r\n    // already connected\r\n    if (qubit1 in neighbour_ids && neighbour_ids[qubit1].has(qubit0)) {\r\n      // do nothing\r\n\r\n    }\r\n    // at least one qubit is not an active qubit:\r\n    else if (!active_qubits.has(qubit0) || !active_qubits.has(qubit1)) {\r\n      active_qubits.delete(qubit0)\r\n      active_qubits.delete(qubit1)\r\n    }\r\n    // at least one qubit is in the inside of a segment:\r\n    else if (len(neighbour_ids[qubit0]) > 1 || len(neighbour_ids[qubit1]) > 1) {\r\n      active_qubits.delete(qubit0)\r\n      active_qubits.delete(qubit1)\r\n    }\r\n    // qubits are both active and either not yet in a segment or at\r\n    // the end of segement:\r\n    else {\r\n      let segment_index_qb0\r\n      let qb0_is_left_end\r\n      let segment_index_qb1\r\n      let qb1_is_left_end\r\n\r\n      segments.forEach((segment, index) => {\r\n        if (qubit0 === segment[0]) {\r\n          segment_index_qb0 = index\r\n          qb0_is_left_end = true\r\n        } else if (qubit0 === segment[segment.length - 1]) {\r\n          segment_index_qb0 = index\r\n          qb0_is_left_end = false\r\n        }\r\n        if (qubit1 === segment[0]) {\r\n          segment_index_qb1 = index\r\n          qb1_is_left_end = true\r\n        } else if (qubit1 === segment[segment.length - 1]) {\r\n          segment_index_qb1 = index\r\n          qb1_is_left_end = false\r\n        }\r\n      })\r\n      // Both qubits are not yet assigned to a segment:\r\n      if (typeof segment_index_qb0 === 'undefined' && typeof segment_index_qb1 === 'undefined') {\r\n        segments.push([qubit0, qubit1])\r\n        neighbour_ids[qubit0].add(qubit1)\r\n        neighbour_ids[qubit1].add(qubit0)\r\n      }\r\n      // if qubits are in the same segment, then the gate is not\r\n      // possible. Note that if this.cyclic==true, we have\r\n      // added that connection already to neighbour_ids and wouldn't be\r\n      // in this branch.\r\n      else if (segment_index_qb0 === segment_index_qb1) {\r\n        active_qubits.delete(qubit0)\r\n        active_qubits.delete(qubit1)\r\n        // qubit0 not yet assigned to a segment:\r\n      } else if (typeof segment_index_qb0 === 'undefined') {\r\n        if (qb1_is_left_end) {\r\n          segments[segment_index_qb1].splice(0, 0, qubit0)\r\n        } else {\r\n          segments[segment_index_qb1].push(qubit0)\r\n        }\r\n        neighbour_ids[qubit0].add(qubit1)\r\n        neighbour_ids[qubit1].add(qubit0)\r\n        if (cyclic && len(segments[0]) === num_qubits) {\r\n          const tmp = segments[0]\r\n          neighbour_ids[tmp[0]].add(tmp[tmp.length - 1])\r\n          neighbour_ids[tmp[tmp.length - 1]].add(tmp[0])\r\n        }\r\n      }\r\n      // qubit1 not yet assigned to a segment:\r\n      else if (typeof segment_index_qb1 === 'undefined') {\r\n        if (qb0_is_left_end) {\r\n          segments[segment_index_qb0].splice(0, 0, qubit1)\r\n        } else {\r\n          segments[segment_index_qb0].push(qubit1)\r\n        }\r\n        neighbour_ids[qubit0].add(qubit1)\r\n        neighbour_ids[qubit1].add(qubit0)\r\n        if (cyclic && len(segments[0]) === num_qubits) {\r\n          const tmp = segments[0]\r\n          neighbour_ids[tmp[0]].add(tmp[tmp.length - 1])\r\n          neighbour_ids[tmp[tmp.length - 1]].add(tmp[0])\r\n        }\r\n      }\r\n      // both qubits are at the end of different segments -> combine them\r\n      else {\r\n        if (!qb0_is_left_end && qb1_is_left_end) {\r\n          segments[segment_index_qb0] = segments[segment_index_qb0].concat(segments[segment_index_qb1])\r\n          segments.splice(segment_index_qb1, 1)\r\n        } else if (!qb0_is_left_end && !qb1_is_left_end) {\r\n          const rev = segments[segment_index_qb1].slice(0).reverse()\r\n          segments[segment_index_qb0] = segments[segment_index_qb0].concat(rev)\r\n          segments.splice(segment_index_qb1, 1)\r\n        } else if (qb0_is_left_end && qb1_is_left_end) {\r\n          segments[segment_index_qb0].reverse()\r\n          segments[segment_index_qb0] = segments[segment_index_qb0].concat(segments[segment_index_qb1])\r\n          segments.splice(segment_index_qb1, 1)\r\n        } else {\r\n          segments[segment_index_qb1] = segments[segment_index_qb1].concat(segments[segment_index_qb0])\r\n          segments.splice(segment_index_qb0, 1)\r\n        }\r\n\r\n        // Add new neighbour ids && make sure to check cyclic\r\n        neighbour_ids[qubit0].add(qubit1)\r\n        neighbour_ids[qubit1].add(qubit0)\r\n        if (cyclic && len(segments[0]) === num_qubits) {\r\n          const tmp = segments[0]\r\n          neighbour_ids[tmp[0]].add(tmp[tmp.length - 1])\r\n          neighbour_ids[tmp[tmp.length - 1]].add(tmp[0])\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n  Returns the swap operation for an odd-even transposition sort.\r\n\r\n  @see https://en.wikipedia.org/wiki/Odd-even_sort\r\n\r\n  @param {Object} old_mapping keys are logical ids and values are mapped qubit ids\r\n  @param {Object} new_mapping dict: keys are logical ids and values are mapped qubit ids\r\n  @return {Array} List of tuples. Each tuple is a swap operation which needs to be\r\n  applied. Tuple contains the two MappedQubit ids for the Swap.\r\n  */\r\n  _oddEvenTranspositionSortSwaps(old_mapping, new_mapping) {\r\n    const final_positions = new Array(this.num_qubits)\r\n    // move qubits which are in both mappings\r\n    Object.keys(old_mapping).forEach((logical_id) => {\r\n      if (logical_id in new_mapping) {\r\n        final_positions[old_mapping[logical_id]] = new_mapping[logical_id]\r\n      }\r\n    })\r\n    // exchange all remaining None with the not yet used mapped ids\r\n    const used_mapped_ids = new Set(final_positions)\r\n    used_mapped_ids.delete(undefined)\r\n    const all_ids = setFromRange(this.num_qubits)\r\n    let not_used_mapped_ids = Array.from(setDifference(all_ids, used_mapped_ids))\r\n    not_used_mapped_ids = not_used_mapped_ids.sort().reverse()\r\n    for (let i = 0; i < final_positions.length; ++i) {\r\n      const looper = final_positions[i]\r\n      if (typeof looper === 'undefined') {\r\n        final_positions[i] = not_used_mapped_ids.pop()\r\n      }\r\n    }\r\n    assert(len(not_used_mapped_ids) === 0)\r\n    // Start sorting:\r\n    const swap_operations = []\r\n    let finished_sorting = false\r\n    while (!finished_sorting) {\r\n      finished_sorting = true\r\n      for (let i = 1; i < len(final_positions); i += 2) {\r\n        if (final_positions[i] > final_positions[i + 1]) {\r\n          swap_operations.push(tuple(i, i + 1))\r\n          const tmp = final_positions[i]\r\n          final_positions[i] = final_positions[i + 1]\r\n          final_positions[i + 1] = tmp\r\n          finished_sorting = false\r\n        }\r\n      }\r\n      for (let i = 0; i < len(final_positions) - 1; i += 2) {\r\n        if (final_positions[i] > final_positions[i + 1]) {\r\n          swap_operations.push(tuple(i, i + 1))\r\n          const tmp = final_positions[i]\r\n          final_positions[i] = final_positions[i + 1]\r\n          final_positions[i + 1] = tmp\r\n          finished_sorting = false\r\n        }\r\n      }\r\n    }\r\n    return swap_operations\r\n  }\r\n\r\n\r\n  /**\r\n  Sends the stored commands possible without changing the mapping.\r\n\r\n  Note: this.currentMapping must exist already\r\n   */\r\n  _sendPossibleCommands() {\r\n    const active_ids = new Set(this._currently_allocated_ids)\r\n    Object.keys(this._currentMapping).forEach(logical_id => active_ids.add(parseInt(logical_id, 10)))\r\n\r\n    let new_stored_commands = []\r\n    for (let i = 0; i < this._stored_commands.length; ++i) {\r\n      const cmd = this._stored_commands[i]\r\n      if (len(active_ids) === 0) {\r\n        new_stored_commands = new_stored_commands.concat(this._stored_commands.slice(i))\r\n        break\r\n      }\r\n      if (cmd.gate instanceof AllocateQubitGate) {\r\n        const qid = cmd.qubits[0][0].id\r\n        if (qid in this._currentMapping) {\r\n          this._currently_allocated_ids.add(qid)\r\n          const qb = new BasicQubit(this, this._currentMapping[qid])\r\n          const new_cmd = new Command(this, new AllocateQubitGate(), tuple([qb]), [], [new LogicalQubitIDTag(qid)])\r\n          this.send([new_cmd])\r\n        } else {\r\n          new_stored_commands.push(cmd)\r\n        }\r\n      } else if (cmd.gate instanceof DeallocateQubitGate) {\r\n        const qid = cmd.qubits[0][0].id\r\n        if (active_ids.has(qid)) {\r\n          const qb = new BasicQubit(this, this._currentMapping[qid])\r\n          const new_cmd = new Command(this, new DeallocateQubitGate(), tuple([qb]), [], [new LogicalQubitIDTag(qid)])\r\n          this._currently_allocated_ids.delete(qid)\r\n          active_ids.delete(qid)\r\n          delete this._currentMapping[qid]\r\n          this.send([new_cmd])\r\n        } else {\r\n          new_stored_commands.push(cmd)\r\n        }\r\n      } else {\r\n        let send_gate = true\r\n        let mapped_ids = new Set()\r\n        for (let i = 0; i < cmd.allQubits.length; ++i) {\r\n          const qureg = cmd.allQubits[i]\r\n          for (let j = 0; j < qureg.length; ++j) {\r\n            const qubit = qureg[j]\r\n            if (!(active_ids.has(qubit.id))) {\r\n              send_gate = false\r\n              break\r\n            }\r\n            mapped_ids.add(this._currentMapping[qubit.id])\r\n          }\r\n        }\r\n\r\n        // Check that mapped ids are nearest neighbour\r\n        if (len(mapped_ids) === 2) {\r\n          mapped_ids = Array.from(mapped_ids)\r\n          const diff = Math.abs(mapped_ids[0] - mapped_ids[1])\r\n          if (this.cyclic) {\r\n            if (diff !== 1 && diff !== this.num_qubits - 1) {\r\n              send_gate = false\r\n            }\r\n          } else if (diff !== 1) {\r\n            send_gate = false\r\n          }\r\n        }\r\n        if (send_gate) {\r\n          this.sendCMDWithMappedIDs(cmd)\r\n        } else {\r\n          cmd.allQubits.forEach(qureg => qureg.forEach(qubit => active_ids.delete(qubit.id)))\r\n          new_stored_commands.push(cmd)\r\n        }\r\n      }\r\n    }\r\n    this._stored_commands = new_stored_commands\r\n  }\r\n\r\n  /**\r\n    Creates a new mapping and executes possible gates.\r\n\r\n  It first allocates all 0, ..., this.num_qubits-1 mapped qubit ids, if\r\n  they are not already used because we might need them all for the\r\n  swaps. Then it creates a new map, swaps all the qubits to the new map,\r\n  executes all possible gates, and finally deallocates mapped qubit ids\r\n  which don't store any information.\r\n   */\r\n  _run() {\r\n    const num_of_stored_commands_before = len(this._stored_commands)\r\n    if (!this._currentMapping) {\r\n      this.currentMapping = {}\r\n    } else {\r\n      this._sendPossibleCommands()\r\n      if (len(this._stored_commands) === 0) {\r\n        return\r\n      }\r\n    }\r\n    const new_mapping = LinearMapper.returnNewMapping(this.num_qubits,\r\n      this.cyclic,\r\n      this._currently_allocated_ids,\r\n      this._stored_commands,\r\n      this.currentMapping)\r\n    const swaps = this._oddEvenTranspositionSortSwaps(this._currentMapping, new_mapping)\r\n    if (swaps.length > 0) { // first mapping requires no swaps\r\n      // Allocate all mapped qubit ids (which are not already allocated,\r\n      // i.e., contained in this._currently_allocated_ids)\r\n      let mapped_ids_used = new Set()\r\n      for (const logical_id of this._currently_allocated_ids) {\r\n        mapped_ids_used.add(this._currentMapping[logical_id])\r\n      }\r\n      const tmpSet = setFromRange(this.num_qubits)\r\n      const not_allocated_ids = setDifference(tmpSet, mapped_ids_used)\r\n      for (const mapped_id of not_allocated_ids) {\r\n        const qb = new BasicQubit(this, mapped_id)\r\n        const cmd = new Command(this, Allocate, tuple([qb]))\r\n        this.send([cmd])\r\n      }\r\n      // Send swap operations to arrive at new_mapping:\r\n      swaps.forEach(([qubit_id0, qubit_id1]) => {\r\n        const q0 = new BasicQubit(this, qubit_id0)\r\n        const q1 = new BasicQubit(this, qubit_id1)\r\n        const cmd = new Command(this, Swap, tuple([q0], [q1]))\r\n        this.send([cmd])\r\n      })\r\n      // Register statistics:\r\n      this.num_mappings += 1\r\n      const depth = return_swap_depth(swaps)\r\n      if (!(depth in this.depth_of_swaps)) {\r\n        this.depth_of_swaps[depth] = 1\r\n      } else {\r\n        this.depth_of_swaps[depth] += 1\r\n      }\r\n      if (!(len(swaps) in this.num_of_swaps_per_mapping)) {\r\n        this.num_of_swaps_per_mapping[len(swaps)] = 1\r\n      } else {\r\n        this.num_of_swaps_per_mapping[len(swaps)] += 1\r\n      }\r\n      // Deallocate all previously mapped ids which we only needed for the\r\n      // swaps:\r\n      mapped_ids_used = new Set()\r\n      for (const logical_id of this._currently_allocated_ids) {\r\n        mapped_ids_used.add(new_mapping[logical_id])\r\n      }\r\n      const not_needed_anymore = setDifference(setFromRange(this.num_qubits), mapped_ids_used)\r\n      for (const mapped_id of not_needed_anymore) {\r\n        const qb = new BasicQubit(this, mapped_id)\r\n        const cmd = new Command(this, Deallocate, tuple([qb]))\r\n        this.send([cmd])\r\n      }\r\n    }\r\n\r\n    // Change to new map:\r\n    this.currentMapping = new_mapping\r\n    // Send possible gates:\r\n    this._sendPossibleCommands()\r\n    // Check that mapper actually made progress\r\n    if (len(this._stored_commands) === num_of_stored_commands_before) {\r\n      throw new Error('Mapper is potentially in an infinite loop. '\r\n      + 'It is likely that the algorithm requires '\r\n      + 'too many qubits. Increase the number of '\r\n      + 'qubits for this mapper.')\r\n    }\r\n  }\r\n\r\n  /**\r\n  Receives a command list and, for each command, stores it until\r\n  we do a mapping (FlushGate or Cache of stored commands is full).\r\n\r\n  @param {Command[]} command_list list of commands to receive.\r\n  */\r\n  receive(command_list) {\r\n    command_list.forEach((cmd) => {\r\n      if (cmd.gate instanceof FlushGate) {\r\n        while (this._stored_commands.length > 0) {\r\n          this._run()\r\n        }\r\n        this.send([cmd])\r\n      } else {\r\n        this._stored_commands.push(cmd)\r\n      }\r\n    })\r\n\r\n    // Storage is full: Create new map and send some gates away:\r\n    if (this._stored_commands.length >= this.storage) {\r\n      this._run()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @static\r\n  Combines the individual segments into a new mapping.\r\n\r\n  It tries to minimize the number of swaps to go from the old mapping\r\n  in this.currentMapping to the new mapping which it returns. The\r\n  strategy is to map a segment to the same region where most of the\r\n  qubits are already. Note that this is not a global optimal strategy\r\n  but helps if currently the qubits can be divided into independent\r\n  groups without interactions between the groups.\r\n\r\n   @param {number} num_qubits Total number of qubits in the linear chain\r\n   @param {Array} segments List of segments. A segment is a list of qubit ids which\r\n    should be nearest neighbour in the new map. Individual qubits are in allocated_qubits\r\n    but not in any segment\r\n   @param {Object} allocated_qubits A set of all qubit ids which need to be present in the new map\r\n   @param {Object} current_mapping A current mapping as a dict. key is logical qubit\r\n  id, value is placement id. If there are different possible maps, this current mapping is used to\r\n  minimize the swaps to go to the new mapping by a heuristic.\r\n  @returns\r\n      A new mapping as a dict. key is logical qubit id, value is placement id\r\n   */\r\n  static _returnNewMappingFromSegments(num_qubits, segments, allocated_qubits, current_mapping) {\r\n    const remaining_segments = segments.slice(0)\r\n    const individual_qubits = new Set(allocated_qubits)\r\n    let num_unused_qubits = num_qubits - len(allocated_qubits)\r\n    // Create a segment out of individual qubits and add to segments\r\n    segments.forEach((segment) => {\r\n      segment.forEach((qubit_id) => {\r\n        individual_qubits.delete(qubit_id)\r\n      })\r\n    })\r\n\r\n    for (const individual_qubit_id of individual_qubits) {\r\n      remaining_segments.push([individual_qubit_id])\r\n    }\r\n\r\n    const previous_chain = new Array(num_qubits)\r\n    if (current_mapping) {\r\n      Object.keys(current_mapping).forEach(key => previous_chain[current_mapping[key]] = parseInt(key, 10))\r\n    }\r\n\r\n    // Note: previous_chain potentially has some None elements\r\n    const new_chain = new Array(num_qubits)\r\n\r\n    let current_position_to_fill = 0\r\n    while (len(remaining_segments)) {\r\n      let best_segment = []\r\n      let best_padding = num_qubits\r\n      let highest_overlap_fraction = 0\r\n      remaining_segments.forEach((segment) => {\r\n        for (let padding = 0; padding < num_unused_qubits + 1; ++padding) {\r\n          const idx0 = current_position_to_fill + padding\r\n          const idx1 = idx0 + len(segment)\r\n\r\n          const previous_chain_ids = new Set(previous_chain.slice(idx0, idx1))\r\n          previous_chain_ids.delete(undefined)\r\n          const segment_ids = new Set(segment)\r\n          segment_ids.delete(undefined)\r\n\r\n          const overlap = len(intersection(previous_chain_ids, segment_ids)) + previous_chain.slice(idx0, idx1).count(undefined)\r\n          let overlap_fraction\r\n          if (overlap === 0) {\r\n            overlap_fraction = 0\r\n          } else if (overlap === len(segment)) {\r\n            overlap_fraction = 1\r\n          } else {\r\n            overlap_fraction = overlap / (len(segment) * 1.0)\r\n          }\r\n          if ((overlap_fraction === 1 && padding < best_padding)\r\n          || overlap_fraction > highest_overlap_fraction\r\n          || highest_overlap_fraction === 0) {\r\n            best_segment = segment\r\n            best_padding = padding\r\n            highest_overlap_fraction = overlap_fraction\r\n          }\r\n        }\r\n      })\r\n\r\n      // Add best segment and padding to new_chain\r\n      const start = current_position_to_fill + best_padding\r\n      for (let i = 0; i < len(best_segment); ++i) {\r\n        new_chain[start + i] = best_segment[i]\r\n      }\r\n\r\n      remaining_segments.remove(best_segment)\r\n      current_position_to_fill += best_padding + len(best_segment)\r\n      num_unused_qubits -= best_padding\r\n    }\r\n    // Create mapping\r\n    const new_mapping = {}\r\n    Object.keys(new_chain).forEach((pos) => {\r\n      const logical_id = new_chain[pos]\r\n      if (typeof logical_id !== 'undefined') {\r\n        new_mapping[logical_id] = parseInt(pos, 10)\r\n      }\r\n    })\r\n    return new_mapping\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/cengines/linearmapper.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 309,
    "kind": "function",
    "name": "return_swap_depth",
    "memberof": "src/cengines/linearmapper.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/cengines/linearmapper.js~return_swap_depth",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/cengines/linearmapper.js",
    "importStyle": "{return_swap_depth}",
    "description": "",
    "lineNumber": 51,
    "ignore": true,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} Circuit depth to execute these swaps."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Array.<Array>"
        ],
        "spread": false,
        "optional": false,
        "name": "swaps",
        "description": "Each tuple contains two integers representing the two IDs of the qubits involved in the\nSwap operation"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Circuit depth to execute these swaps."
    }
  },
  {
    "__docId__": 310,
    "kind": "class",
    "name": "LinearMapper",
    "memberof": "src/cengines/linearmapper.js",
    "static": true,
    "longname": "src/cengines/linearmapper.js~LinearMapper",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/cengines/linearmapper.js",
    "importStyle": "LinearMapper",
    "description": "Maps a quantum circuit to a linear chain of nearest neighbour interactions.\n\nMaps a quantum circuit to a linear chain of qubits with nearest neighbour\ninteractions using Swap gates. It supports open or cyclic boundary\nconditions.\n\nAttributes:\ncurrent_mapping:  Stores the mapping: key is logical qubit id, value\nis mapped qubit id from 0,...,this.num_qubits\ncyclic (Bool): If chain is cyclic or not\nstorage (int): Number of gate it caches before mapping.\nnum_mappings (int): Number of times the mapper changed the mapping\ndepth_of_swaps (dict): Key are circuit depth of swaps, value is the\nnumber of such mappings which have been\napplied\nnum_of_swaps_per_mapping (dict): Key are the number of swaps per\nmapping, value is the number of such\nmappings which have been applied\n\nNote:\n1) Gates are cached and only mapped from time to time. A\nFastForwarding gate doesn't empty the cache, only a FlushGate does.\n2) Only 1 and two qubit gates allowed.\n3) Does not optimize for dirty qubits.",
    "lineNumber": 97,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "LinearMapper"
      }
    ],
    "interface": false,
    "extends": [
      "src/cengines/basicmapper.js~BasicMapperEngine"
    ]
  },
  {
    "__docId__": 311,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/cengines/linearmapper.js~LinearMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/linearmapper.js~LinearMapper#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 106,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": "Initialize a LinearMapper compiler engine."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "num_qubits",
        "description": "Number of physical qubits in the linear chain"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "cyclic",
        "description": "If 1D chain is a cycle. Default is false."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "storage",
        "description": "Number of gates to temporarily store, default is 1000"
      }
    ]
  },
  {
    "__docId__": 312,
    "kind": "member",
    "name": "num_qubits",
    "memberof": "src/cengines/linearmapper.js~LinearMapper",
    "static": false,
    "longname": "src/cengines/linearmapper.js~LinearMapper#num_qubits",
    "access": "public",
    "description": null,
    "lineNumber": 109,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 313,
    "kind": "member",
    "name": "cyclic",
    "memberof": "src/cengines/linearmapper.js~LinearMapper",
    "static": false,
    "longname": "src/cengines/linearmapper.js~LinearMapper#cyclic",
    "access": "public",
    "description": null,
    "lineNumber": 110,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 314,
    "kind": "member",
    "name": "storage",
    "memberof": "src/cengines/linearmapper.js~LinearMapper",
    "static": false,
    "longname": "src/cengines/linearmapper.js~LinearMapper#storage",
    "access": "public",
    "description": null,
    "lineNumber": 111,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 315,
    "kind": "member",
    "name": "_stored_commands",
    "memberof": "src/cengines/linearmapper.js~LinearMapper",
    "static": false,
    "longname": "src/cengines/linearmapper.js~LinearMapper#_stored_commands",
    "access": "private",
    "description": null,
    "lineNumber": 113,
    "undocument": true,
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 316,
    "kind": "member",
    "name": "_currently_allocated_ids",
    "memberof": "src/cengines/linearmapper.js~LinearMapper",
    "static": false,
    "longname": "src/cengines/linearmapper.js~LinearMapper#_currently_allocated_ids",
    "access": "private",
    "description": null,
    "lineNumber": 117,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 317,
    "kind": "member",
    "name": "num_mappings",
    "memberof": "src/cengines/linearmapper.js~LinearMapper",
    "static": false,
    "longname": "src/cengines/linearmapper.js~LinearMapper#num_mappings",
    "access": "public",
    "description": null,
    "lineNumber": 119,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 318,
    "kind": "member",
    "name": "depth_of_swaps",
    "memberof": "src/cengines/linearmapper.js~LinearMapper",
    "static": false,
    "longname": "src/cengines/linearmapper.js~LinearMapper#depth_of_swaps",
    "access": "public",
    "description": null,
    "lineNumber": 120,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 319,
    "kind": "member",
    "name": "num_of_swaps_per_mapping",
    "memberof": "src/cengines/linearmapper.js~LinearMapper",
    "static": false,
    "longname": "src/cengines/linearmapper.js~LinearMapper#num_of_swaps_per_mapping",
    "access": "public",
    "description": null,
    "lineNumber": 121,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 320,
    "kind": "method",
    "name": "isAvailable",
    "memberof": "src/cengines/linearmapper.js~LinearMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/linearmapper.js~LinearMapper#isAvailable",
    "access": "public",
    "description": null,
    "lineNumber": 125,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 321,
    "kind": "method",
    "name": "returnNewMapping",
    "memberof": "src/cengines/linearmapper.js~LinearMapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/cengines/linearmapper.js~LinearMapper.returnNewMapping",
    "access": "public",
    "description": "",
    "lineNumber": 151,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "num_qubits",
        "description": "Total number of qubits in the linear chain"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "cyclic",
        "description": "If linear chain is a cycle."
      },
      {
        "nullable": null,
        "types": [
          "Set<Number>"
        ],
        "spread": false,
        "optional": false,
        "name": "currently_allocated_ids",
        "description": "Logical qubit ids for which\nthe Allocate gate has already been processed and sent to the next engine but which are\nnot yet deallocated and hence need to be included in the new mapping."
      },
      {
        "nullable": null,
        "types": [
          "Command[]"
        ],
        "spread": false,
        "optional": false,
        "name": "stored_commands",
        "description": "Future commands which should be applied next."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "current_mapping",
        "description": "A current mapping as a dict. key is logical qubit id, value is placement id.\nIf there are different possible maps, this current mapping is used to minimize the swaps\nto go to the new mapping by a heuristic."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "A new mapping as a dict. key is logical qubit id, value is placement id"
    }
  },
  {
    "__docId__": 322,
    "kind": "method",
    "name": "_processTwoQubitGate",
    "memberof": "src/cengines/linearmapper.js~LinearMapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/cengines/linearmapper.js~LinearMapper._processTwoQubitGate",
    "access": "private",
    "description": "Processes a two qubit gate.\n\nIt either removes the two qubits from active_qubits if the gate is not\npossible or updates the segements such that the gate is possible.",
    "lineNumber": 230,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "num_qubits",
        "description": "Total number of qubits in the chain"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "cyclic",
        "description": "If linear chain is a cycle"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "qubit0",
        "description": "qubit.id of one of the qubits"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "qubit1",
        "description": "qubit.id of the other qubit"
      },
      {
        "nullable": null,
        "types": [
          "Set<Number>"
        ],
        "spread": false,
        "optional": false,
        "name": "active_qubits",
        "description": "contains all qubit ids which for which gates can be applied in this cycle before the swaps"
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "segments",
        "description": "List of segments. A segment is a list of neighbouring qubits."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "neighbour_ids",
        "description": "Key: qubit.id Value: qubit.id of neighbours"
      }
    ],
    "return": null
  },
  {
    "__docId__": 323,
    "kind": "method",
    "name": "_oddEvenTranspositionSortSwaps",
    "memberof": "src/cengines/linearmapper.js~LinearMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/linearmapper.js~LinearMapper#_oddEvenTranspositionSortSwaps",
    "access": "private",
    "description": "Returns the swap operation for an odd-even transposition sort.",
    "see": [
      "https://en.wikipedia.org/wiki/Odd-even_sort"
    ],
    "lineNumber": 353,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "old_mapping",
        "description": "keys are logical ids and values are mapped qubit ids"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "new_mapping",
        "description": "dict: keys are logical ids and values are mapped qubit ids"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": "List of tuples. Each tuple is a swap operation which needs to be\napplied. Tuple contains the two MappedQubit ids for the Swap."
    }
  },
  {
    "__docId__": 324,
    "kind": "method",
    "name": "_sendPossibleCommands",
    "memberof": "src/cengines/linearmapper.js~LinearMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/linearmapper.js~LinearMapper#_sendPossibleCommands",
    "access": "private",
    "description": "Sends the stored commands possible without changing the mapping.\n\nNote: this.currentMapping must exist already",
    "lineNumber": 407,
    "params": [],
    "return": null
  },
  {
    "__docId__": 326,
    "kind": "method",
    "name": "_run",
    "memberof": "src/cengines/linearmapper.js~LinearMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/linearmapper.js~LinearMapper#_run",
    "access": "private",
    "description": "Creates a new mapping and executes possible gates.\n\nIt first allocates all 0, ..., this.num_qubits-1 mapped qubit ids, if\nthey are not already used because we might need them all for the\nswaps. Then it creates a new map, swaps all the qubits to the new map,\nexecutes all possible gates, and finally deallocates mapped qubit ids\nwhich don't store any information.",
    "lineNumber": 487,
    "params": [],
    "return": null
  },
  {
    "__docId__": 327,
    "kind": "member",
    "name": "currentMapping",
    "memberof": "src/cengines/linearmapper.js~LinearMapper",
    "static": false,
    "longname": "src/cengines/linearmapper.js~LinearMapper#currentMapping",
    "access": "public",
    "description": null,
    "lineNumber": 490,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 330,
    "kind": "method",
    "name": "receive",
    "memberof": "src/cengines/linearmapper.js~LinearMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/linearmapper.js~LinearMapper#receive",
    "access": "public",
    "description": "Receives a command list and, for each command, stores it until\nwe do a mapping (FlushGate or Cache of stored commands is full).",
    "lineNumber": 570,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command[]"
        ],
        "spread": false,
        "optional": false,
        "name": "command_list",
        "description": "list of commands to receive."
      }
    ],
    "return": null
  },
  {
    "__docId__": 331,
    "kind": "method",
    "name": "_returnNewMappingFromSegments",
    "memberof": "src/cengines/linearmapper.js~LinearMapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/cengines/linearmapper.js~LinearMapper._returnNewMappingFromSegments",
    "access": "private",
    "description": "",
    "lineNumber": 610,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "A new mapping as a dict. key is logical qubit id, value is placement id"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "num_qubits",
        "description": "Total number of qubits in the linear chain"
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "segments",
        "description": "List of segments. A segment is a list of qubit ids which\nshould be nearest neighbour in the new map. Individual qubits are in allocated_qubits\nbut not in any segment"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "allocated_qubits",
        "description": "A set of all qubit ids which need to be present in the new map"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "current_mapping",
        "description": "A current mapping as a dict. key is logical qubit\nid, value is placement id. If there are different possible maps, this current mapping is used to\nminimize the swaps to go to the new mapping by a heuristic."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "A new mapping as a dict. key is logical qubit id, value is placement id"
    }
  },
  {
    "__docId__": 332,
    "kind": "file",
    "name": "src/cengines/main.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n// Contains the main engine of every compiler engine pipeline, called MainEngine.\r\nimport {BasicEngine} from './basics'\r\nimport {FlushGate} from '../ops/gates'\r\nimport BasicMapperEngine from './basicmapper'\r\nimport Command from '../ops/command'\r\nimport {BasicQubit} from '../types/qubit';\r\nimport {NotYetMeasuredError} from '../meta/error'\r\nimport {getEngineList} from '../setups'\r\nimport Simulator from '../backends/simulators/simulator'\r\n\r\n/**\r\n * @class MainEngine\r\n * @desc\r\nThe MainEngine class provides all functionality of the main compiler\r\nengine.\r\n\r\n    It initializes all further compiler engines (calls, e.g.,\r\n    .next_engine=...) and keeps track of measurement results and active\r\nqubits (and their IDs).\r\n\r\nAttributes:\r\n    next_engine (BasicEngine): Next compiler engine (or the back-end).\r\nmain_engine (MainEngine): Self.\r\nactive_qubits (WeakSet): WeakSet containing all active qubits\r\ndirty_qubits (Set): Containing all dirty qubit ids\r\nbackend (BasicEngine): Access the back-end.\r\nmapper (BasicMapperEngine): Access to the mapper if there is one.\r\n */\r\nexport default class MainEngine extends BasicEngine {\r\n  /**\r\n   * @constructor\r\n  Initialize the main compiler engine and all compiler engines.\r\n\r\n    Sets 'next_engine'- and 'main_engine'-attributes of all compiler\r\nengines and adds the back-end as the last engine.\r\n\r\n    @param {BasicEngine} backend Backend to send the compiled circuit to.\r\n    @param {Array.<BasicEngine>} engineList List of engines / backends to use\r\n            as compiler engines. Note: The engine list must not contain\r\n            multiple mappers (instances of BasicMapperEngine).\r\n            Default: getEngineList()\r\n   @param {boolean} verbose Either print full or compact error messages.\r\n    Default: false (i.e. compact error messages).\r\n\r\n    @example\r\n      const eng = new MainEngine() // uses default engine_list and the Simulator\r\n\r\nInstead of the default `engine_list` one can use, e.g., one of the IBM\r\nsetups which defines a custom `engine_list` useful for one of the IBM\r\nchips\r\n\r\n    @example\r\n      const eng = new MainEngine(new Simulator, getEngineList())\r\n      // eng uses the default Simulator backend\r\n\r\nAlternatively, one can specify all compiler engines explicitly, e.g.,\r\n\r\n    @example\r\n      const rule_set = new DecompositionRuleSet()\r\n      const engines = [new AutoReplacer(rule_set), new TagRemover(), new LocalOptimizer(3)]\r\n      const eng = new MainEngine(new Simulator(), engines)\r\n  */\r\n  constructor(backend, engineList, verbose = false) {\r\n    super()\r\n    if (!backend) {\r\n      backend = new Simulator()\r\n    } else if (!(backend instanceof BasicEngine)) {\r\n      throw new Error('\\nYou supplied a backend which is not supported,\\n'\r\n      + 'i.e. not an instance of BasicEngine.\\n'\r\n      + 'Did you forget the brackets to create an instance?\\n'\r\n      + 'E.g. MainEngine(backend=Simulator) instead of \\n'\r\n      + '     MainEngine(backend=Simulator())')\r\n    }\r\n\r\n    if (!engineList) {\r\n      engineList = getEngineList()\r\n    }\r\n\r\n    this.mapper = null\r\n    if (Array.isArray(engineList)) {\r\n      engineList.forEach((looper) => {\r\n        if (!(looper instanceof BasicEngine)) {\r\n          throw new Error('\\nYou supplied an unsupported engine in engine_list,'\r\n          + '\\ni.e. not an instance of BasicEngine.\\n'\r\n          + 'Did you forget the brackets to create an instance?\\n'\r\n          + 'E.g. MainEngine(engine_list=[AutoReplacer]) instead '\r\n          + 'of\\n     MainEngine(engine_list=[AutoReplacer()])')\r\n        }\r\n        if (looper instanceof BasicMapperEngine) {\r\n          if (!this.mapper) {\r\n            this.mapper = looper\r\n          } else {\r\n            throw new Error('More than one mapper engine is not supported.')\r\n          }\r\n        }\r\n      })\r\n    } else {\r\n      throw new Error('The provided list of engines is not a list!')\r\n    }\r\n\r\n    engineList = [...engineList, backend]\r\n\r\n    this.backend = backend\r\n\r\n    // Test that user did not supply twice the same engine instance\r\n    const num_different_engines = new Set(engineList).size\r\n    if (engineList.length !== num_different_engines) {\r\n      throw new Error('\\nError:\\n You supplied twice the same engine as backend'\r\n      + \" or item in engine_list. This doesn't work. Create two \\n\"\r\n      + ' separate instances of a compiler engine if it is needed\\n'\r\n      + ' twice.\\n')\r\n    }\r\n\r\n    this._qubitIdx = 0\r\n    for (let i = 0; i < engineList.length - 1; ++i) {\r\n      engineList[i].next = engineList[i + 1]\r\n      engineList[i].main = this\r\n    }\r\n\r\n    backend.main = this\r\n    backend.isLastEngine = true\r\n\r\n    this.next = engineList[0]\r\n    this.main = this\r\n    this.activeQubits = new Set()\r\n    this._measurements = {}\r\n    this.dirtyQubits = new Set()\r\n    this.verbose = verbose\r\n  }\r\n\r\n  /**\r\n  Register a measurement result\r\n\r\nThe engine being responsible for measurement results needs to register\r\nthese results with the master engine such that they are available when\r\nthe user calls an int() or bool() conversion operator on a measured\r\nqubit.\r\n\r\n    @param {BasicQubit} qubit Qubit for which to register the measurement result.\r\n    @param {boolean} value Boolean value of the measurement outcome (true / false = 1 / 0 respectively).\r\n   */\r\n  setMeasurementResult(qubit, value) {\r\n    this._measurements[qubit.id] = !!value\r\n  }\r\n\r\n  /**\r\n  Return the classical value of a measured qubit, given that an engine\r\nregistered this result previously (see setMeasurementResult).\r\n\r\n  @param {BasicQubit} qubit Qubit of which to get the measurement result.\r\n\r\n    @example\r\n\r\nconst eng = new MainEngine()\r\nconst qubit = eng.allocateQubit() // quantum register of size 1\r\nH.or(qubit)\r\nMeasure.or(qubit)\r\neng.getMeasurementResult(qubit[0]) == qubit.toNumber()\r\n   */\r\n  getMeasurementResult(qubit) {\r\n    const v = this._measurements[qubit.id]\r\n    if (typeof v === 'undefined') {\r\n      throw new NotYetMeasuredError(`${\"\\nError: Can't access measurement result for \"\r\n      + 'qubit #'}${qubit.id}. The problem may `\r\n      + 'be:\\n\\t1. Your '\r\n      + 'code lacks a measurement statement\\n\\t'\r\n      + '2. You have not yet called engine.flush() to '\r\n      + 'force execution of your code\\n\\t3. The '\r\n      + 'underlying backend failed to register '\r\n      + 'the measurement result\\n')\r\n    } else {\r\n      return v\r\n    }\r\n  }\r\n\r\n  /**\r\n    Returns a unique qubit id to be used for the next qubit allocation.\r\n\r\n    @return {number} New unique qubit id.\r\n  */\r\n  getNewQubitID() {\r\n    this._qubitIdx += 1\r\n    return this._qubitIdx - 1\r\n  }\r\n\r\n  /**\r\n  Forward the list of commands to the first engine.\r\n    @param {Command[]} commandList List of commands to receive (and then send on)\r\n   */\r\n  receive(commandList) {\r\n    this.send(commandList)\r\n  }\r\n\r\n  /**\r\n  Forward the list of commands to the next engine in the pipeline.\r\n    It also shortens exception stack traces if this.verbose is false.\r\n   */\r\n  send(commandList) {\r\n    try {\r\n      this.next.receive(commandList)\r\n    } catch (e) {\r\n      if (this.verbose) {\r\n        console.log(e)\r\n      }\r\n      throw e\r\n    }\r\n  }\r\n\r\n  /**\r\n    Destroy the main engine.\r\n   Flushes the entire circuit down the pipeline, clearing all temporary buffers (in, e.g., optimizers).\r\n */\r\n  deallocate() {\r\n    this.flush(true)\r\n  }\r\n\r\n  /**\r\n    Flush the entire circuit down the pipeline, clearing potential buffers (of, e.g., optimizers).\r\n\r\n    @param {boolean} deallocateQubits If true, deallocates all qubits that are\r\n    still alive (invalidating references to them by setting their id to -1).\r\n  */\r\n  flush(deallocateQubits = false) {\r\n    if (deallocateQubits) {\r\n      this.activeQubits.forEach(qb => qb.deallocate())\r\n      this.activeQubits = new Set()\r\n    }\r\n\r\n    this.receive([new Command(this, new FlushGate(), [[new BasicQubit(this, -1)]])])\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/cengines/main.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 333,
    "kind": "class",
    "name": "MainEngine",
    "memberof": "src/cengines/main.js",
    "static": true,
    "longname": "src/cengines/main.js~MainEngine",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/cengines/main.js",
    "importStyle": "MainEngine",
    "description": "The MainEngine class provides all functionality of the main compiler\nengine.\n\nIt initializes all further compiler engines (calls, e.g.,\n.next_engine=...) and keeps track of measurement results and active\nqubits (and their IDs).\n\nAttributes:\nnext_engine (BasicEngine): Next compiler engine (or the back-end).\nmain_engine (MainEngine): Self.\nactive_qubits (WeakSet): WeakSet containing all active qubits\ndirty_qubits (Set): Containing all dirty qubit ids\nbackend (BasicEngine): Access the back-end.\nmapper (BasicMapperEngine): Access to the mapper if there is one.",
    "lineNumber": 45,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "MainEngine"
      }
    ],
    "interface": false,
    "extends": [
      "src/cengines/basics.js~BasicEngine"
    ]
  },
  {
    "__docId__": 334,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/cengines/main.js~MainEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/main.js~MainEngine#constructor",
    "access": "public",
    "description": "",
    "examples": [
      "const eng = new MainEngine() // uses default engine_list and the Simulator\n\nInstead of the default `engine_list` one can use, e.g., one of the IBM\nsetups which defines a custom `engine_list` useful for one of the IBM\nchips",
      "const eng = new MainEngine(new Simulator, getEngineList())\n// eng uses the default Simulator backend\n\nAlternatively, one can specify all compiler engines explicitly, e.g.,",
      "const rule_set = new DecompositionRuleSet()\nconst engines = [new AutoReplacer(rule_set), new TagRemover(), new LocalOptimizer(3)]\nconst eng = new MainEngine(new Simulator(), engines)"
    ],
    "lineNumber": 79,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": "Initialize the main compiler engine and all compiler engines.\n\nSets 'next_engine'- and 'main_engine'-attributes of all compiler\nengines and adds the back-end as the last engine."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "BasicEngine"
        ],
        "spread": false,
        "optional": false,
        "name": "backend",
        "description": "Backend to send the compiled circuit to."
      },
      {
        "nullable": null,
        "types": [
          "Array.<BasicEngine>"
        ],
        "spread": false,
        "optional": false,
        "name": "engineList",
        "description": "List of engines / backends to use\nas compiler engines. Note: The engine list must not contain\nmultiple mappers (instances of BasicMapperEngine).\nDefault: getEngineList()"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "verbose",
        "description": "Either print full or compact error messages.\nDefault: false (i.e. compact error messages)."
      }
    ]
  },
  {
    "__docId__": 335,
    "kind": "member",
    "name": "mapper",
    "memberof": "src/cengines/main.js~MainEngine",
    "static": false,
    "longname": "src/cengines/main.js~MainEngine#mapper",
    "access": "public",
    "description": null,
    "lineNumber": 95,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 337,
    "kind": "member",
    "name": "backend",
    "memberof": "src/cengines/main.js~MainEngine",
    "static": false,
    "longname": "src/cengines/main.js~MainEngine#backend",
    "access": "public",
    "description": null,
    "lineNumber": 119,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 338,
    "kind": "member",
    "name": "_qubitIdx",
    "memberof": "src/cengines/main.js~MainEngine",
    "static": false,
    "longname": "src/cengines/main.js~MainEngine#_qubitIdx",
    "access": "private",
    "description": null,
    "lineNumber": 130,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 339,
    "kind": "member",
    "name": "next",
    "memberof": "src/cengines/main.js~MainEngine",
    "static": false,
    "longname": "src/cengines/main.js~MainEngine#next",
    "access": "public",
    "description": null,
    "lineNumber": 139,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 340,
    "kind": "member",
    "name": "main",
    "memberof": "src/cengines/main.js~MainEngine",
    "static": false,
    "longname": "src/cengines/main.js~MainEngine#main",
    "access": "public",
    "description": null,
    "lineNumber": 140,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 341,
    "kind": "member",
    "name": "activeQubits",
    "memberof": "src/cengines/main.js~MainEngine",
    "static": false,
    "longname": "src/cengines/main.js~MainEngine#activeQubits",
    "access": "public",
    "description": null,
    "lineNumber": 141,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 342,
    "kind": "member",
    "name": "_measurements",
    "memberof": "src/cengines/main.js~MainEngine",
    "static": false,
    "longname": "src/cengines/main.js~MainEngine#_measurements",
    "access": "private",
    "description": null,
    "lineNumber": 142,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 343,
    "kind": "member",
    "name": "dirtyQubits",
    "memberof": "src/cengines/main.js~MainEngine",
    "static": false,
    "longname": "src/cengines/main.js~MainEngine#dirtyQubits",
    "access": "public",
    "description": null,
    "lineNumber": 143,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 344,
    "kind": "member",
    "name": "verbose",
    "memberof": "src/cengines/main.js~MainEngine",
    "static": false,
    "longname": "src/cengines/main.js~MainEngine#verbose",
    "access": "public",
    "description": null,
    "lineNumber": 144,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 345,
    "kind": "method",
    "name": "setMeasurementResult",
    "memberof": "src/cengines/main.js~MainEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/main.js~MainEngine#setMeasurementResult",
    "access": "public",
    "description": "Register a measurement result\n\nThe engine being responsible for measurement results needs to register\nthese results with the master engine such that they are available when\nthe user calls an int() or bool() conversion operator on a measured\nqubit.",
    "lineNumber": 158,
    "params": [
      {
        "nullable": null,
        "types": [
          "BasicQubit"
        ],
        "spread": false,
        "optional": false,
        "name": "qubit",
        "description": "Qubit for which to register the measurement result."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "Boolean value of the measurement outcome (true / false = 1 / 0 respectively)."
      }
    ],
    "return": null
  },
  {
    "__docId__": 346,
    "kind": "method",
    "name": "getMeasurementResult",
    "memberof": "src/cengines/main.js~MainEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/main.js~MainEngine#getMeasurementResult",
    "access": "public",
    "description": "Return the classical value of a measured qubit, given that an engine\nregistered this result previously (see setMeasurementResult).",
    "examples": [
      "\nconst eng = new MainEngine()\nconst qubit = eng.allocateQubit() // quantum register of size 1\nH.or(qubit)\nMeasure.or(qubit)\neng.getMeasurementResult(qubit[0]) == qubit.toNumber()"
    ],
    "lineNumber": 176,
    "params": [
      {
        "nullable": null,
        "types": [
          "BasicQubit"
        ],
        "spread": false,
        "optional": false,
        "name": "qubit",
        "description": "Qubit of which to get the measurement result."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 347,
    "kind": "method",
    "name": "getNewQubitID",
    "memberof": "src/cengines/main.js~MainEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/main.js~MainEngine#getNewQubitID",
    "access": "public",
    "description": "Returns a unique qubit id to be used for the next qubit allocation.",
    "lineNumber": 197,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "New unique qubit id."
    },
    "params": []
  },
  {
    "__docId__": 349,
    "kind": "method",
    "name": "receive",
    "memberof": "src/cengines/main.js~MainEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/main.js~MainEngine#receive",
    "access": "public",
    "description": "Forward the list of commands to the first engine.",
    "lineNumber": 206,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command[]"
        ],
        "spread": false,
        "optional": false,
        "name": "commandList",
        "description": "List of commands to receive (and then send on)"
      }
    ],
    "return": null
  },
  {
    "__docId__": 350,
    "kind": "method",
    "name": "send",
    "memberof": "src/cengines/main.js~MainEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/main.js~MainEngine#send",
    "access": "public",
    "description": "Forward the list of commands to the next engine in the pipeline.\nIt also shortens exception stack traces if this.verbose is false.",
    "lineNumber": 214,
    "params": [
      {
        "name": "commandList",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 351,
    "kind": "method",
    "name": "deallocate",
    "memberof": "src/cengines/main.js~MainEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/main.js~MainEngine#deallocate",
    "access": "public",
    "description": "Destroy the main engine.\nFlushes the entire circuit down the pipeline, clearing all temporary buffers (in, e.g., optimizers).",
    "lineNumber": 229,
    "params": [],
    "return": null
  },
  {
    "__docId__": 352,
    "kind": "method",
    "name": "flush",
    "memberof": "src/cengines/main.js~MainEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/main.js~MainEngine#flush",
    "access": "public",
    "description": "Flush the entire circuit down the pipeline, clearing potential buffers (of, e.g., optimizers).",
    "lineNumber": 239,
    "params": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "deallocateQubits",
        "description": "If true, deallocates all qubits that are\nstill alive (invalidating references to them by setting their id to -1)."
      }
    ],
    "return": null
  },
  {
    "__docId__": 354,
    "kind": "file",
    "name": "src/cengines/manualmapper.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport BasicMapperEngine from './basicmapper'\r\n\r\n/**\r\n * @class ManualMapper\r\n * @desc\r\nManual Mapper which adds QubitPlacementTags to Allocate gate commands\r\naccording to a user-specified mapping.\r\n    @property {function} map The function which maps a given qubit id to its\r\n    location. It gets set when initializing the mapper.\r\n */\r\nexport default class ManualMapper extends BasicMapperEngine {\r\n  /**\r\n   * @constructor\r\n    Initialize the mapper to a given mapping. If no mapping function is\r\nprovided, the qubit id is used as the location.\r\n\r\n    @param {function} mapFunc Function which, given the qubit id, returns\r\nan integer describing the physical location (must be constant).\r\n     */\r\n  constructor(mapFunc = x => x) {\r\n    super()\r\n    this.map = mapFunc\r\n    this.currentMapping = {}\r\n  }\r\n\r\n  /**\r\n    Receives a command list and passes it to the next engine, adding\r\n    qubit placement tags to allocate gates.\r\n\r\n    @param {Command[]} command_list list of commands to receive.\r\n  */\r\n  receive(command_list) {\r\n    command_list.forEach((cmd) => {\r\n      const ids = []\r\n      cmd.qubits.forEach((qr) => {\r\n        qr.forEach(qb => ids.push(qb.id))\r\n      })\r\n      ids.forEach((id) => {\r\n        const v = this._currentMapping[id]\r\n        if (typeof v === 'undefined') {\r\n          this._currentMapping[id] = this.map(id)\r\n        }\r\n      })\r\n      this.sendCMDWithMappedIDs(cmd)\r\n    })\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/cengines/manualmapper.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 355,
    "kind": "class",
    "name": "ManualMapper",
    "memberof": "src/cengines/manualmapper.js",
    "static": true,
    "longname": "src/cengines/manualmapper.js~ManualMapper",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/cengines/manualmapper.js",
    "importStyle": "ManualMapper",
    "description": "Manual Mapper which adds QubitPlacementTags to Allocate gate commands\naccording to a user-specified mapping.",
    "lineNumber": 27,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "ManualMapper"
      }
    ],
    "properties": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "map",
        "description": "The function which maps a given qubit id to its\nlocation. It gets set when initializing the mapper."
      }
    ],
    "interface": false,
    "extends": [
      "src/cengines/basicmapper.js~BasicMapperEngine"
    ]
  },
  {
    "__docId__": 356,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/cengines/manualmapper.js~ManualMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/manualmapper.js~ManualMapper#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 36,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": "Initialize the mapper to a given mapping. If no mapping function is\nprovided, the qubit id is used as the location."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "mapFunc",
        "description": "Function which, given the qubit id, returns\nan integer describing the physical location (must be constant)."
      }
    ]
  },
  {
    "__docId__": 357,
    "kind": "member",
    "name": "map",
    "memberof": "src/cengines/manualmapper.js~ManualMapper",
    "static": false,
    "longname": "src/cengines/manualmapper.js~ManualMapper#map",
    "access": "public",
    "description": null,
    "lineNumber": 38,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 358,
    "kind": "member",
    "name": "currentMapping",
    "memberof": "src/cengines/manualmapper.js~ManualMapper",
    "static": false,
    "longname": "src/cengines/manualmapper.js~ManualMapper#currentMapping",
    "access": "public",
    "description": null,
    "lineNumber": 39,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 359,
    "kind": "method",
    "name": "receive",
    "memberof": "src/cengines/manualmapper.js~ManualMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/manualmapper.js~ManualMapper#receive",
    "access": "public",
    "description": "Receives a command list and passes it to the next engine, adding\nqubit placement tags to allocate gates.",
    "lineNumber": 48,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command[]"
        ],
        "spread": false,
        "optional": false,
        "name": "command_list",
        "description": "list of commands to receive."
      }
    ],
    "return": null
  },
  {
    "__docId__": 360,
    "kind": "file",
    "name": "src/cengines/optimize.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport assert from 'assert'\r\nimport {BasicEngine} from './basics'\r\nimport {FastForwardingGate} from '../ops/basics';\r\nimport {FlushGate} from '../ops/gates'\r\nimport {instanceOf} from '../libs/util'\r\nimport {NotMergeable} from '../meta/error';\r\n\r\n\r\n/**\r\n * @class LocalOptimizer\r\n * @desc is a compiler engine which optimizes locally (merging\r\nrotations, cancelling gates with their inverse) in a local window of user-\r\ndefined size.\r\n\r\n    It stores all commands in a dict of lists, where each qubit has its own\r\ngate pipeline. After adding a gate, it tries to merge / cancel successive\r\ngates using the get_merged and getInverse functions of the gate (if\r\n    available). For examples, see BasicRotationGate. Once a list corresponding\r\nto a qubit contains >=m gates, the pipeline is sent on to the next engine.\r\n */\r\nexport default class LocalOptimizer extends BasicEngine {\r\n  /**\r\n   * @constructor\r\n   * @param {number} m Number of gates to cache per qubit, before sending on the first gate.\r\n   */\r\n  constructor(m = 5) {\r\n    super()\r\n    this._l = {} // dict of lists containing operations for each qubit\r\n    this._m = m // wait for m gates before sending on\r\n  }\r\n\r\n  /**\r\n   * Send n gate operations of the qubit with index idx to the next engine.\r\n   * @param {number} idx qubit index\r\n   * @param {number} n command position in qubit idx's command list\r\n   */\r\n  sendQubitPipeline(idx, n) {\r\n    if (typeof idx !== 'number') {\r\n      idx = parseInt(idx, 10)\r\n    }\r\n    // temporary label for readability\r\n    const il = this._l[idx]\r\n    const count = Math.min(n, il.length)\r\n\r\n    // loop over first n operations\r\n    // send all gates before n-qubit gate for other qubits involved\r\n    // --> recursively call send_helper\r\n    for (let i = 0; i < count; ++i) {\r\n      const other_involved_qubits = []\r\n      il[i].allQubits.forEach(qreg => qreg.forEach((qb) => {\r\n        if (qb.id !== idx) {\r\n          other_involved_qubits.push(qb)\r\n        }\r\n      }))\r\n\r\n      other_involved_qubits.forEach((qb) => {\r\n        const idLooper = qb.id\r\n        try {\r\n          let gateloc = 0\r\n          // find location of this gate within its list\r\n          while (!this._l[idLooper][gateloc].equal(il[i])) {\r\n            gateloc += 1\r\n          }\r\n\r\n          gateloc = this.optimize(idLooper, gateloc)\r\n          // flush the gates before the n-qubit gate\r\n          this.sendQubitPipeline(idLooper, gateloc)\r\n          // delete the n-qubit gate, we're taking care of it\r\n          // and don't want the other qubit to do so\r\n          this._l[idLooper] = this._l[idLooper].slice(1)\r\n        } catch (e) {\r\n          console.log(e)\r\n          console.log('Invalid qubit pipeline encountered (in the  process of shutting down?).')\r\n        }\r\n      })\r\n      // all qubits that need to be flushed have been flushed\r\n      // --> send on the n-qubit gate\r\n      this.send([il[i]])\r\n    }\r\n    // n operations have been sent on --> resize our gate list\r\n    this._l[idx] = this._l[idx].slice(n)\r\n  }\r\n\r\n  /**\r\n    Return all indices of a command, each index corresponding to the\r\n    command's index in one of the qubits' command lists.\r\n\r\n    @param {number} idx qubit index\r\n    @param {number} i command position in qubit idx's command list\r\n    @param {number[]} IDs IDs of all qubits involved in the command\r\n    @return {number[]}\r\n  */\r\n  getGateIndices(idx, i, IDs) {\r\n    if (typeof idx !== 'number') {\r\n      idx = parseInt(idx, 10)\r\n    }\r\n    const N = IDs.length\r\n    // 1-qubit gate: only gate at index i in list #idx is involved\r\n    if (N === 1) {\r\n      return [i]\r\n    }\r\n\r\n    // When the same gate appears multiple time, we need to make sure not to\r\n    // match earlier instances of the gate applied to the same qubits. So we\r\n    // count how many there are, and skip over them when looking in the\r\n    // other lists.\r\n    const cmd = this._l[idx][i]\r\n    let num_identical_to_skip = 0\r\n    this._l[idx].slice(0, i).forEach((prev_cmd) => {\r\n      if (prev_cmd.equal(cmd)) {\r\n        num_identical_to_skip += 1\r\n      }\r\n    })\r\n\r\n    const indices = []\r\n    IDs.forEach((Id) => {\r\n      const identical_indices = []\r\n      this._l[Id].forEach((c, j) => {\r\n        if (c.equal(cmd)) {\r\n          identical_indices.push(j)\r\n        }\r\n      })\r\n      indices.push(identical_indices[num_identical_to_skip])\r\n    })\r\n    return indices\r\n  }\r\n\r\n  /**\r\n  Try to merge or even cancel successive gates using the get_merged and\r\ngetInverse functions of the gate (see, e.g., BasicRotationGate).\r\n\r\n    It does so for all qubit command lists.\r\n   @param {number} idx\r\n   @param {number} lim\r\n   */\r\n  optimize(idx, lim) {\r\n    if (typeof idx !== 'number') {\r\n      idx = parseInt(idx, 10)\r\n    }\r\n    // loop over all qubit indices\r\n    let i = 0\r\n    let new_gateloc = 0\r\n    let limit = this._l[idx].length\r\n    if (typeof lim !== 'undefined') {\r\n      limit = lim\r\n      new_gateloc = limit\r\n    }\r\n\r\n    while (i < limit - 1) {\r\n    // can be dropped if two in a row are self-inverses\r\n      const cmd = this._l[idx][i]\r\n      const inv = cmd.getInverse()\r\n\r\n      if (inv.equal(this._l[idx][i + 1])) {\r\n      // determine index of this gate on all qubits\r\n        const qubitids = []\r\n        cmd.allQubits.forEach(sublist => sublist.forEach(qb => qubitids.push(qb.id)))\r\n        const gid = this.getGateIndices(idx, i, qubitids)\r\n        // check that there are no other gates between this and its\r\n        // inverse on any of the other qubits involved\r\n        let erase = true\r\n        qubitids.forEach((looper, j) => {\r\n          erase = inv.equal(this._l[looper][gid[j] + 1])\r\n        })\r\n\r\n        // drop these two gates if possible and goto next iteration\r\n        if (erase) {\r\n          let new_list = []\r\n          qubitids.forEach((looper, j) => {\r\n            new_list = this._l[looper].slice(0, gid[j]).concat(this._l[looper].slice(gid[j] + 2))\r\n            this._l[looper] = new_list\r\n          })\r\n          i = 0\r\n          limit -= 2\r\n          continue\r\n        }\r\n      }\r\n      // gates are not each other's inverses --> check if they're\r\n      // mergeable\r\n      try {\r\n        const merged_command = this._l[idx][i].getMerged(this._l[idx][i + 1])\r\n        // determine index of this gate on all qubits\r\n        const qubitids = []\r\n        const c = this._l[idx][i]\r\n        c.allQubits.forEach(sublist => sublist.forEach(qb => qubitids.push(qb.id)))\r\n\r\n        const gid = this.getGateIndices(idx, i, qubitids)\r\n\r\n        let merge = true\r\n        qubitids.forEach((looper, j) => {\r\n          const m = this._l[looper][gid[j]].getMerged(this._l[looper][gid[j] + 1])\r\n          merge = m.equal(merged_command)\r\n        })\r\n        if (merge) {\r\n          qubitids.forEach((looper, j) => {\r\n            this._l[looper][gid[j]] = merged_command\r\n            const new_list = this._l[looper].slice(0, gid[j] + 1).concat(this._l[looper].slice(gid[j] + 2))\r\n            this._l[looper] = new_list\r\n          })\r\n          i = 0\r\n          limit -= 1\r\n          continue\r\n        }\r\n      } catch (e) {\r\n        if (!(e instanceof NotMergeable)) {\r\n          throw e\r\n        }\r\n      }\r\n      i += 1 // next iteration: look at next gate\r\n    }\r\n    return limit\r\n  }\r\n\r\n\r\n  /**\r\n  Check whether a qubit pipeline must be sent on and, if so,\r\n    optimize the pipeline and then send it on.\r\n   */\r\n  checkAndSend() {\r\n    Object.keys(this._l).forEach((i) => {\r\n      let v = this._l[i]\r\n      let lastCMD = v.length > 0 ? v[v.length - 1] : {}\r\n      let gateFlag = instanceOf(lastCMD.gate, FastForwardingGate)\r\n      if (v.length >= this._m || (v.length > 0 && gateFlag)) {\r\n        this.optimize(i)\r\n        v = this._l[i]\r\n        lastCMD = v.length > 0 ? v[v.length - 1] : {}\r\n        gateFlag = instanceOf(lastCMD.gate, FastForwardingGate)\r\n\r\n        if (v.length >= this._m && !gateFlag) {\r\n          this.sendQubitPipeline(i, v.length - this._m + 1)\r\n        } else if (v.length > 0 && gateFlag) {\r\n          this.sendQubitPipeline(i, v.length)\r\n        }\r\n      }\r\n    })\r\n    const newDict = {}\r\n    Object.keys(this._l).forEach((key) => {\r\n      const v = this._l[key]\r\n      if (v.length > 0) {\r\n        newDict[key] = v\r\n      }\r\n    })\r\n\r\n    this._l = newDict\r\n  }\r\n\r\n  /**\r\n    Cache a command, i.e., inserts it into the command lists of all qubits involved.\r\n    @param {Command} cmd\r\n  */\r\n  cacheCMD(cmd) {\r\n    // are there qubit ids that haven't been added to the list?\r\n    const ids = []\r\n    cmd.allQubits.forEach(sublist => sublist.forEach(qubit => ids.push(qubit.id)))\r\n\r\n    // add gate command to each of the qubits involved\r\n    ids.forEach((ID) => {\r\n      const v = this._l[ID]\r\n      if (typeof v === 'undefined') {\r\n        this._l[ID] = []\r\n      }\r\n      this._l[ID].push(cmd)\r\n    })\r\n    this.checkAndSend()\r\n  }\r\n\r\n  /**\r\n    Receive commands from the previous engine and cache them.\r\n    If a flush gate arrives, the entire buffer is sent on.\r\n  */\r\n  receive(commandList) {\r\n    commandList.forEach((cmd) => {\r\n      if (instanceOf(cmd.gate, FlushGate)) {\r\n        Object.keys(this._l).forEach((idx) => {\r\n          const v = this._l[idx]\r\n          this.optimize(idx)\r\n          this.sendQubitPipeline(idx, v.length)\r\n        })\r\n\r\n        const newDict = {}\r\n        Object.keys(this._l).forEach((idx) => {\r\n          const v = this._l[idx]\r\n          if (v.length > 0) {\r\n            newDict[idx] = v\r\n          }\r\n        })\r\n        this._l = newDict\r\n        assert(Object.keys(this._l).length === 0)\r\n        this.send([cmd])\r\n      } else {\r\n        this.cacheCMD(cmd)\r\n      }\r\n    })\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/cengines/optimize.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 361,
    "kind": "class",
    "name": "LocalOptimizer",
    "memberof": "src/cengines/optimize.js",
    "static": true,
    "longname": "src/cengines/optimize.js~LocalOptimizer",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/cengines/optimize.js",
    "importStyle": "LocalOptimizer",
    "description": "is a compiler engine which optimizes locally (merging\nrotations, cancelling gates with their inverse) in a local window of user-\ndefined size.\n\nIt stores all commands in a dict of lists, where each qubit has its own\ngate pipeline. After adding a gate, it tries to merge / cancel successive\ngates using the get_merged and getInverse functions of the gate (if\navailable). For examples, see BasicRotationGate. Once a list corresponding\nto a qubit contains >=m gates, the pipeline is sent on to the next engine.",
    "lineNumber": 37,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "LocalOptimizer"
      }
    ],
    "interface": false,
    "extends": [
      "src/cengines/basics.js~BasicEngine"
    ]
  },
  {
    "__docId__": 362,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/cengines/optimize.js~LocalOptimizer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/optimize.js~LocalOptimizer#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 42,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "m",
        "description": "Number of gates to cache per qubit, before sending on the first gate."
      }
    ]
  },
  {
    "__docId__": 363,
    "kind": "member",
    "name": "_l",
    "memberof": "src/cengines/optimize.js~LocalOptimizer",
    "static": false,
    "longname": "src/cengines/optimize.js~LocalOptimizer#_l",
    "access": "private",
    "description": null,
    "lineNumber": 44,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 364,
    "kind": "member",
    "name": "_m",
    "memberof": "src/cengines/optimize.js~LocalOptimizer",
    "static": false,
    "longname": "src/cengines/optimize.js~LocalOptimizer#_m",
    "access": "private",
    "description": null,
    "lineNumber": 45,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 365,
    "kind": "method",
    "name": "sendQubitPipeline",
    "memberof": "src/cengines/optimize.js~LocalOptimizer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/optimize.js~LocalOptimizer#sendQubitPipeline",
    "access": "public",
    "description": "Send n gate operations of the qubit with index idx to the next engine.",
    "lineNumber": 53,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "idx",
        "description": "qubit index"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "n",
        "description": "command position in qubit idx's command list"
      }
    ],
    "return": null
  },
  {
    "__docId__": 366,
    "kind": "method",
    "name": "getGateIndices",
    "memberof": "src/cengines/optimize.js~LocalOptimizer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/optimize.js~LocalOptimizer#getGateIndices",
    "access": "public",
    "description": "Return all indices of a command, each index corresponding to the\ncommand's index in one of the qubits' command lists.",
    "lineNumber": 109,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "idx",
        "description": "qubit index"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "i",
        "description": "command position in qubit idx's command list"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "IDs",
        "description": "IDs of all qubits involved in the command"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number[]"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 367,
    "kind": "method",
    "name": "optimize",
    "memberof": "src/cengines/optimize.js~LocalOptimizer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/optimize.js~LocalOptimizer#optimize",
    "access": "public",
    "description": "Try to merge or even cancel successive gates using the get_merged and\ngetInverse functions of the gate (see, e.g., BasicRotationGate).\n\nIt does so for all qubit command lists.",
    "lineNumber": 152,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "idx",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "lim",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 368,
    "kind": "method",
    "name": "checkAndSend",
    "memberof": "src/cengines/optimize.js~LocalOptimizer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/optimize.js~LocalOptimizer#checkAndSend",
    "access": "public",
    "description": "Check whether a qubit pipeline must be sent on and, if so,\noptimize the pipeline and then send it on.",
    "lineNumber": 235,
    "params": [],
    "return": null
  },
  {
    "__docId__": 370,
    "kind": "method",
    "name": "cacheCMD",
    "memberof": "src/cengines/optimize.js~LocalOptimizer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/optimize.js~LocalOptimizer#cacheCMD",
    "access": "public",
    "description": "Cache a command, i.e., inserts it into the command lists of all qubits involved.",
    "lineNumber": 268,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 371,
    "kind": "method",
    "name": "receive",
    "memberof": "src/cengines/optimize.js~LocalOptimizer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/optimize.js~LocalOptimizer#receive",
    "access": "public",
    "description": "Receive commands from the previous engine and cache them.\nIf a flush gate arrives, the entire buffer is sent on.",
    "lineNumber": 288,
    "params": [
      {
        "name": "commandList",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 373,
    "kind": "file",
    "name": "src/cengines/replacer/decompositionrule.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport {BasicGate} from '../../ops/basics'\r\nimport { isKindclassOf } from '../../libs/util'\r\n\r\n/**\r\n * @class DecompositionRule\r\n * @desc A rule for breaking down specific gates into sequences of simpler gates.\r\n */\r\nexport default class DecompositionRule {\r\n  /**\r\n   * @constructor\r\n    @param {function} gateClass The type of gate that this rule decomposes.\r\n\r\n    The gate class is redundant information used to make lookups\r\nfaster when iterating over a circuit and deciding \"which rules\r\napply to this gate?\" again and again.\r\n\r\n    Note that this parameter is a gate type, not a gate instance.\r\n    You supply gate_class=MyGate or gate_class=MyGate().__class__,\r\n    not gate_class=MyGate().\r\n\r\n   @param {function} gateDecomposer Function which,\r\n    given the command to decompose, applies a sequence of gates\r\ncorresponding to the high-level function of a gate of type\r\ngate_class.\r\n\r\n   @param {function} gateRecognizer A\r\npredicate that determines if the decomposition applies to the\r\ngiven command (on top of the filtering by gate_class).\r\n\r\nFor example, a decomposition rule may only to apply rotation\r\ngates that rotate by a specific angle.\r\n\r\n    If no gate_recognizer is given, the decomposition applies to\r\nall gates matching the gate_class.\r\n     */\r\n  constructor(gateClass, gateDecomposer, gateRecognizer = () => true) {\r\n    // Check for common gate_class type mistakes.\r\n    if (gateClass instanceof BasicGate) {\r\n      throw new Error('gate_class is a gate instance instead of a type of BasicGate.'\r\n            + '\\nDid you pass in someGate instead of someGate.__class__?')\r\n    }\r\n\r\n    if (!isKindclassOf(gateClass, BasicGate)) {\r\n      throw new Error('Invalid class type, you should pass a subclass of BasicGate!')\r\n    }\r\n\r\n    this.gateClass = gateClass\r\n    this.gateDecomposer = gateDecomposer\r\n    this.gateRecognizer = gateRecognizer\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/cengines/replacer/decompositionrule.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 374,
    "kind": "class",
    "name": "DecompositionRule",
    "memberof": "src/cengines/replacer/decompositionrule.js",
    "static": true,
    "longname": "src/cengines/replacer/decompositionrule.js~DecompositionRule",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/cengines/replacer/decompositionrule.js",
    "importStyle": "DecompositionRule",
    "description": "A rule for breaking down specific gates into sequences of simpler gates.",
    "lineNumber": 24,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "DecompositionRule"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 375,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/cengines/replacer/decompositionrule.js~DecompositionRule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/replacer/decompositionrule.js~DecompositionRule#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 52,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "gateClass",
        "description": "The type of gate that this rule decomposes.\n\nThe gate class is redundant information used to make lookups\nfaster when iterating over a circuit and deciding \"which rules\napply to this gate?\" again and again.\n\nNote that this parameter is a gate type, not a gate instance.\nYou supply gate_class=MyGate or gate_class=MyGate().__class__,\nnot gate_class=MyGate()."
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "gateDecomposer",
        "description": "Function which,\ngiven the command to decompose, applies a sequence of gates\ncorresponding to the high-level function of a gate of type\ngate_class."
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "gateRecognizer",
        "description": "A\npredicate that determines if the decomposition applies to the\ngiven command (on top of the filtering by gate_class).\n\nFor example, a decomposition rule may only to apply rotation\ngates that rotate by a specific angle.\n\nIf no gate_recognizer is given, the decomposition applies to\nall gates matching the gate_class."
      }
    ]
  },
  {
    "__docId__": 376,
    "kind": "member",
    "name": "gateClass",
    "memberof": "src/cengines/replacer/decompositionrule.js~DecompositionRule",
    "static": false,
    "longname": "src/cengines/replacer/decompositionrule.js~DecompositionRule#gateClass",
    "access": "public",
    "description": null,
    "lineNumber": 63,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 377,
    "kind": "member",
    "name": "gateDecomposer",
    "memberof": "src/cengines/replacer/decompositionrule.js~DecompositionRule",
    "static": false,
    "longname": "src/cengines/replacer/decompositionrule.js~DecompositionRule#gateDecomposer",
    "access": "public",
    "description": null,
    "lineNumber": 64,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 378,
    "kind": "member",
    "name": "gateRecognizer",
    "memberof": "src/cengines/replacer/decompositionrule.js~DecompositionRule",
    "static": false,
    "longname": "src/cengines/replacer/decompositionrule.js~DecompositionRule#gateRecognizer",
    "access": "public",
    "description": null,
    "lineNumber": 65,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 379,
    "kind": "file",
    "name": "src/cengines/replacer/decompositionruleset.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport {Dagger} from '../../meta/dagger'\r\n\r\n/**\r\n * @class DecompositionRuleSet\r\n * A collection of indexed decomposition rules.\r\n */\r\nexport default class DecompositionRuleSet {\r\n  /**\r\n    @param {Array.<DecompositionRule>} rules Initial decomposition rules.\r\n    @param {?Array} modules A list of things with an \"all_defined_decomposition_rules\" property\r\n      containing decomposition rules to add to the rule set.\r\n  */\r\n  constructor(rules, modules = null) {\r\n    this.decompositions = {}\r\n    if (rules) {\r\n      this.addDecompositionRules(rules)\r\n    }\r\n    if (modules) {\r\n      modules.forEach((module) => {\r\n        this.addDecompositionRules(module.allDefinedDecompositionRules)\r\n      })\r\n    }\r\n  }\r\n\r\n  addDecompositionRules(rules) {\r\n    rules.forEach(rule => this.addDecompositionRule(rule))\r\n  }\r\n\r\n  /**\r\n    Add a decomposition rule to the rule set.\r\n\r\n    @param {DecompositionRule} rule The decomposition rule to add.\r\n     */\r\n  addDecompositionRule(rule) {\r\n    const decomp_obj = new _Decomposition(rule.gateDecomposer, rule.gateRecognizer)\r\n    const cls = rule.gateClass.name\r\n    if (!(cls in this.decompositions)) {\r\n      this.decompositions[cls] = []\r\n    }\r\n    this.decompositions[cls].push(decomp_obj)\r\n  }\r\n}\r\n\r\n/**\r\n * @class ModuleWithDecompositionRuleSet\r\n * Interface type for explaining one of the parameters that can be given to DecompositionRuleSet.\r\n */\r\nclass ModuleWithDecompositionRuleSet {\r\n  constructor(allDefinedDecompositionRules) {\r\n    this.allDefinedDecompositionRules = allDefinedDecompositionRules\r\n  }\r\n}\r\n\r\n/**\r\n * @private\r\n * @class _Decomposition\r\n * @desc\r\nThe Decomposition class can be used to register a decomposition rule (by calling register_decomposition)\r\n */\r\nclass _Decomposition {\r\n  /**\r\n   * @constructor\r\n    Construct the Decomposition object.\r\n\r\n    @param {function} replacementFunc when called with a `Command` object, decomposes this command.\r\n    @param {function(cmd: Command): boolean} recognizerFunc when called with a `Command` object,\r\n      returns true if and only if the replacement rule can handle this command.\r\n\r\n    Every Decomposition is registered with the gate class. The\r\nDecomposition rule is then potentially valid for all objects which are\r\nan instance of that same class\r\n(i.e., instance of gate_object.constructor). All other parameters have\r\nto be checked by the recogn_fun, i.e., it has to decide whether the\r\ndecomposition rule can indeed be applied to replace the given Command.\r\n\r\n    As an example, consider recognizing the Toffoli gate, which is a\r\nPauli-X gate with 2 control qubits. The recognizer function would then\r\nbe:\r\n\r\n    @example\r\n    function recogn_toffoli(cmd) {\r\n    // can be applied if the gate is an X-gate with 2 controls\r\n        return len(cmd.control_qubits) == 2\r\n    }\r\n\r\nand, given a replacement function `replace_toffoli`, the decomposition\r\nrule can be registered as\r\n\r\n   @example\r\n    register_decomposition(X.constructor, decompose_toffoli, recogn_toffoli)\r\n\r\nNote:\r\n    See projectq.setups.decompositions for more example codes.\r\n     */\r\n  constructor(replacementFunc, recognizerFunc) {\r\n    this.decompose = replacementFunc\r\n    this.check = recognizerFunc\r\n  }\r\n\r\n  /**\r\n    Return the Decomposition object which handles the inverse of the original command.\r\n\r\n    This simulates the user having added a decomposition rule for the\r\n    inverse as well. Since decomposing the inverse of a command can be\r\nachieved by running the original decomposition inside a\r\n    `Dagger(engine)` statement, this is not necessary\r\n(and will be done automatically by the framework).\r\n\r\n  @return {_Decomposition} Decomposition handling the inverse of the original command.\r\n  */\r\n  getInverseDecomposition() {\r\n    const decomp = (cmd) => {\r\n      Dagger(cmd.engine, () => this.decompose(cmd.getInverse()))\r\n    }\r\n    const recogn = (cmd) => {\r\n      return this.check(cmd.getInverse())\r\n    }\r\n    return new _Decomposition(decomp, recogn)\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/cengines/replacer/decompositionruleset.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 380,
    "kind": "class",
    "name": "DecompositionRuleSet",
    "memberof": "src/cengines/replacer/decompositionruleset.js",
    "static": true,
    "longname": "src/cengines/replacer/decompositionruleset.js~DecompositionRuleSet",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/cengines/replacer/decompositionruleset.js",
    "importStyle": "DecompositionRuleSet",
    "description": "",
    "lineNumber": 23,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "DecompositionRuleSet\nA collection of indexed decomposition rules."
      }
    ],
    "interface": false
  },
  {
    "__docId__": 381,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/cengines/replacer/decompositionruleset.js~DecompositionRuleSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/replacer/decompositionruleset.js~DecompositionRuleSet#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 29,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array.<DecompositionRule>"
        ],
        "spread": false,
        "optional": false,
        "name": "rules",
        "description": "Initial decomposition rules."
      },
      {
        "nullable": true,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "modules",
        "description": "A list of things with an \"all_defined_decomposition_rules\" property\ncontaining decomposition rules to add to the rule set."
      }
    ]
  },
  {
    "__docId__": 382,
    "kind": "member",
    "name": "decompositions",
    "memberof": "src/cengines/replacer/decompositionruleset.js~DecompositionRuleSet",
    "static": false,
    "longname": "src/cengines/replacer/decompositionruleset.js~DecompositionRuleSet#decompositions",
    "access": "public",
    "description": null,
    "lineNumber": 30,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 383,
    "kind": "method",
    "name": "addDecompositionRules",
    "memberof": "src/cengines/replacer/decompositionruleset.js~DecompositionRuleSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/replacer/decompositionruleset.js~DecompositionRuleSet#addDecompositionRules",
    "access": "public",
    "description": null,
    "lineNumber": 41,
    "undocument": true,
    "params": [
      {
        "name": "rules",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 384,
    "kind": "method",
    "name": "addDecompositionRule",
    "memberof": "src/cengines/replacer/decompositionruleset.js~DecompositionRuleSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/replacer/decompositionruleset.js~DecompositionRuleSet#addDecompositionRule",
    "access": "public",
    "description": "Add a decomposition rule to the rule set.",
    "lineNumber": 50,
    "params": [
      {
        "nullable": null,
        "types": [
          "DecompositionRule"
        ],
        "spread": false,
        "optional": false,
        "name": "rule",
        "description": "The decomposition rule to add."
      }
    ],
    "return": null
  },
  {
    "__docId__": 385,
    "kind": "class",
    "name": "ModuleWithDecompositionRuleSet",
    "memberof": "src/cengines/replacer/decompositionruleset.js",
    "static": true,
    "longname": "src/cengines/replacer/decompositionruleset.js~ModuleWithDecompositionRuleSet",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/cengines/replacer/decompositionruleset.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 64,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "ModuleWithDecompositionRuleSet\nInterface type for explaining one of the parameters that can be given to DecompositionRuleSet."
      }
    ],
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 386,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/cengines/replacer/decompositionruleset.js~ModuleWithDecompositionRuleSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/replacer/decompositionruleset.js~ModuleWithDecompositionRuleSet#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 65,
    "undocument": true
  },
  {
    "__docId__": 387,
    "kind": "member",
    "name": "allDefinedDecompositionRules",
    "memberof": "src/cengines/replacer/decompositionruleset.js~ModuleWithDecompositionRuleSet",
    "static": false,
    "longname": "src/cengines/replacer/decompositionruleset.js~ModuleWithDecompositionRuleSet#allDefinedDecompositionRules",
    "access": "public",
    "description": null,
    "lineNumber": 66,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 388,
    "kind": "class",
    "name": "_Decomposition",
    "memberof": "src/cengines/replacer/decompositionruleset.js",
    "static": true,
    "longname": "src/cengines/replacer/decompositionruleset.js~_Decomposition",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/cengines/replacer/decompositionruleset.js",
    "importStyle": null,
    "description": "The Decomposition class can be used to register a decomposition rule (by calling register_decomposition)",
    "lineNumber": 76,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "_Decomposition"
      }
    ],
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 389,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/cengines/replacer/decompositionruleset.js~_Decomposition",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/replacer/decompositionruleset.js~_Decomposition#constructor",
    "access": "public",
    "description": "",
    "examples": [
      "function recogn_toffoli(cmd) {\n// can be applied if the gate is an X-gate with 2 controls\nreturn len(cmd.control_qubits) == 2\n}\n\nand, given a replacement function `replace_toffoli`, the decomposition\nrule can be registered as",
      "register_decomposition(X.constructor, decompose_toffoli, recogn_toffoli)\n\nNote:\nSee projectq.setups.decompositions for more example codes."
    ],
    "lineNumber": 111,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": "Construct the Decomposition object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "replacementFunc",
        "description": "when called with a `Command` object, decomposes this command."
      },
      {
        "nullable": null,
        "types": [
          "function(cmd: Command): boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "recognizerFunc",
        "description": "when called with a `Command` object,\nreturns true if and only if the replacement rule can handle this command.\n\nEvery Decomposition is registered with the gate class. The\nDecomposition rule is then potentially valid for all objects which are\nan instance of that same class\n(i.e., instance of gate_object.constructor). All other parameters have\nto be checked by the recogn_fun, i.e., it has to decide whether the\ndecomposition rule can indeed be applied to replace the given Command.\n\nAs an example, consider recognizing the Toffoli gate, which is a\nPauli-X gate with 2 control qubits. The recognizer function would then\nbe:"
      }
    ]
  },
  {
    "__docId__": 390,
    "kind": "member",
    "name": "decompose",
    "memberof": "src/cengines/replacer/decompositionruleset.js~_Decomposition",
    "static": false,
    "longname": "src/cengines/replacer/decompositionruleset.js~_Decomposition#decompose",
    "access": "public",
    "description": null,
    "lineNumber": 112,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 391,
    "kind": "member",
    "name": "check",
    "memberof": "src/cengines/replacer/decompositionruleset.js~_Decomposition",
    "static": false,
    "longname": "src/cengines/replacer/decompositionruleset.js~_Decomposition#check",
    "access": "public",
    "description": null,
    "lineNumber": 113,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 392,
    "kind": "method",
    "name": "getInverseDecomposition",
    "memberof": "src/cengines/replacer/decompositionruleset.js~_Decomposition",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/replacer/decompositionruleset.js~_Decomposition#getInverseDecomposition",
    "access": "public",
    "description": "Return the Decomposition object which handles the inverse of the original command.\n\nThis simulates the user having added a decomposition rule for the\ninverse as well. Since decomposing the inverse of a command can be\nachieved by running the original decomposition inside a\n`Dagger(engine)` statement, this is not necessary\n(and will be done automatically by the framework).",
    "lineNumber": 127,
    "return": {
      "nullable": null,
      "types": [
        "_Decomposition"
      ],
      "spread": false,
      "description": "Decomposition handling the inverse of the original command."
    },
    "params": []
  },
  {
    "__docId__": 393,
    "kind": "file",
    "name": "src/cengines/replacer/replacer.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport {BasicEngine, ForwarderEngine} from '../basics'\r\nimport {FlushGate} from '../../ops/gates'\r\nimport CommandModifier from '../cmdmodifier'\r\nimport {classHierachy} from '../../libs/util';\r\nimport {getInverse} from '../../ops/_cycle';\r\nimport {NoGateDecompositionError} from '../../meta/error';\r\n\r\n/**\r\n * @class InstructionFilter\r\n * @desc\r\nThe InstructionFilter is a compiler engine which changes the behavior of\r\nisAvailable according to a filter function. All commands are passed to\r\nthis function, which then returns whether this command can be executed\r\n(true) or needs replacement (false).\r\n */\r\nexport class InstructionFilter extends BasicEngine {\r\n  /**\r\n   * @constructor\r\n  Initializer: The provided filterfun returns true for all commands\r\nwhich do not need replacement and false for commands that do.\r\n\r\n    @param {function} filterFunc Filter function which returns true for\r\n    available commands, and false otherwise. filterfun will be\r\n    called as filterfun(self, cmd).\r\n  */\r\n  constructor(filterFunc) {\r\n    super()\r\n\r\n    this._filterFunc = filterFunc\r\n  }\r\n\r\n  /**\r\n  Specialized implementation of BasicBackend.isAvailable: Forwards this\r\ncall to the filter function given to the constructor.\r\n\r\n    @param {Command} cmd Command for which to check availability.\r\n   */\r\n  isAvailable(cmd) {\r\n    return this._filterFunc(this, cmd)\r\n  }\r\n\r\n  /**\r\n  Forward all commands to the next engine.\r\n\r\n    @param {Command[]} commandList List of commands to receive.\r\n   */\r\n  receive(commandList) {\r\n    this.next.receive(commandList)\r\n  }\r\n}\r\n\r\n/**\r\n * @class AutoReplacer\r\n * @desc\r\nThe AutoReplacer is a compiler engine which uses engine.isAvailable in\r\norder to determine which commands need to be replaced/decomposed/compiled\r\nfurther. The loaded setup is used to find decomposition rules appropriate\r\nfor each command (e.g., setups.default).\r\n */\r\nexport class AutoReplacer extends BasicEngine {\r\n  /**\r\n   * @constructor\r\n    @param {DecompositionRuleSet} decompositionRuleSet\r\n    @param {?function} decomposition_chooser A function which, given the\r\nCommand to decompose and a list of potential Decomposition\r\nobjects, determines (and then returns) the 'best'\r\ndecomposition.\r\n\r\n    The default decomposition chooser simply returns the first list\r\nelement, i.e., calling\r\n\r\n   @example\r\n\r\nrepl = new AutoReplacer()\r\n\r\nAmounts to\r\n\r\n   @example\r\n\r\n  function decomposition_chooser(cmd, decomp_list) {\r\n    return decomp_list[0]\r\n  }\r\n  const repl = new AutoReplacer(decomposition_chooser)\r\n  */\r\n  constructor(decompositionRuleSet, decomposition_chooser) {\r\n    if (!decomposition_chooser) {\r\n      decomposition_chooser = (cmd, decomposition_list) => decomposition_list[0]\r\n    }\r\n\r\n    super()\r\n    this._decomp_chooser = decomposition_chooser\r\n    this.decompositionRuleSet = decompositionRuleSet\r\n  }\r\n\r\n  /**\r\n  Check whether a command cmd can be handled by further engines and,\r\nif not, replace it using the decomposition rules loaded with the setup\r\n(e.g., setups.default).\r\n\r\n    @param {Command} cmd Command to process.\r\n\r\n    @throws Exception if no replacement is available in the loaded setup.\r\n   */\r\n  _processCommand(cmd) {\r\n    if (this.isAvailable(cmd)) {\r\n      this.send([cmd])\r\n    } else {\r\n    // check for decomposition rules\r\n      const decomp_list = []\r\n      let potential_decomps = []\r\n\r\n      // First check for a decomposition rules of the gate class, then\r\n      // the gate class of the inverse gate. If nothing is found, do the\r\n      // same for the first parent class, etc.\r\n      const gate_mro = classHierachy(cmd.gate.constructor)\r\n      // If gate does not have an inverse it's parent classes are\r\n      // DaggeredGate, BasicGate, object. Hence don't check the last two\r\n      const inverse_mro = classHierachy(getInverse(cmd.gate).constructor)\r\n      const rules = this.decompositionRuleSet.decompositions\r\n      const total = Math.max(gate_mro.length, inverse_mro.length)\r\n      for (let level = 0; level < total; ++level) {\r\n        // Check for forward rules\r\n        if (level < gate_mro.length) {\r\n          const class_name = gate_mro[level].name\r\n          try {\r\n            potential_decomps = rules[class_name] || []\r\n          } catch (e) {\r\n            console.log(e)\r\n          }\r\n\r\n          potential_decomps.forEach(d => d.check(cmd) && decomp_list.push(d))\r\n          if (decomp_list.length > 0) {\r\n            break\r\n          }\r\n        }\r\n        // Check for rules implementing the inverse gate\r\n        // and run them in reverse\r\n\r\n        if (level < inverse_mro.length) {\r\n          const inv_class_name = inverse_mro[level].name\r\n          try {\r\n            let list = rules[inv_class_name] || []\r\n            list = list.map(d => d.getInverseDecomposition())\r\n            potential_decomps = potential_decomps.concat(list)\r\n          } catch (e) {\r\n            console.log(e)\r\n          }\r\n\r\n          // throw out the ones which don't recognize the command\r\n          potential_decomps.forEach(d => d.check(cmd) && decomp_list.push(d))\r\n          if (decomp_list.length > 0) {\r\n            break\r\n          }\r\n        }\r\n      }\r\n\r\n      if (decomp_list.length === 0) {\r\n        throw new NoGateDecompositionError(`\\nNo replacement found for ${cmd.toString()}!`)\r\n      }\r\n\r\n      // use decomposition chooser to determine the best decomposition\r\n      const chosen_decomp = this._decomp_chooser(cmd, decomp_list)\r\n\r\n      // the decomposed command must have the same tags\r\n      // (plus the ones it gets from meta-statements inside the\r\n      // decomposition rule).\r\n      // --> use a CommandModifier with a ForwarderEngine to achieve this.\r\n      const old_tags = cmd.tags.slice(0)\r\n\r\n      /*\r\n      Receive a list of commands from the previous compiler engine and, if\r\n            necessary, replace/decompose the gates according to the decomposition\r\n        rules in the loaded setup.\r\n\r\n            @param {Command} command List of commands to handle.\r\n       */\r\n      const cmd_mod_fun = (command) => { // Adds the tags\r\n        command.tags = [...old_tags, ...command.tags]\r\n        command.engine = this.main\r\n        return command\r\n      }\r\n      // the CommandModifier calls cmd_mod_fun for each command\r\n      // --> commands get the right tags.\r\n      const cmod_eng = new CommandModifier(cmd_mod_fun)\r\n      cmod_eng.next = this // send modified commands back here\r\n      cmod_eng.main = this.main\r\n      // forward everything to cmod_eng using the ForwarderEngine\r\n      // which behaves just like MainEngine\r\n      // (--> meta functions still work)\r\n      const forwarder_eng = new ForwarderEngine(cmod_eng)\r\n      cmd.engine = forwarder_eng // send gates directly to forwarder\r\n      // (and not to main engine, which would screw up the ordering).\r\n\r\n      chosen_decomp.decompose(cmd) // run the decomposition\r\n    }\r\n  }\r\n\r\n  receive(commandList) {\r\n    commandList.forEach((cmd) => {\r\n      if (!(cmd.gate instanceof FlushGate)) {\r\n        this._processCommand(cmd)\r\n      } else {\r\n        this.send([cmd])\r\n      }\r\n    })\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/cengines/replacer/replacer.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 394,
    "kind": "class",
    "name": "InstructionFilter",
    "memberof": "src/cengines/replacer/replacer.js",
    "static": true,
    "longname": "src/cengines/replacer/replacer.js~InstructionFilter",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/cengines/replacer/replacer.js",
    "importStyle": "{InstructionFilter}",
    "description": "The InstructionFilter is a compiler engine which changes the behavior of\nisAvailable according to a filter function. All commands are passed to\nthis function, which then returns whether this command can be executed\n(true) or needs replacement (false).",
    "lineNumber": 32,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "InstructionFilter"
      }
    ],
    "interface": false,
    "extends": [
      "src/cengines/basics.js~BasicEngine"
    ]
  },
  {
    "__docId__": 395,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/cengines/replacer/replacer.js~InstructionFilter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/replacer/replacer.js~InstructionFilter#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 42,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": "Initializer: The provided filterfun returns true for all commands\nwhich do not need replacement and false for commands that do."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "filterFunc",
        "description": "Filter function which returns true for\navailable commands, and false otherwise. filterfun will be\ncalled as filterfun(self, cmd)."
      }
    ]
  },
  {
    "__docId__": 396,
    "kind": "member",
    "name": "_filterFunc",
    "memberof": "src/cengines/replacer/replacer.js~InstructionFilter",
    "static": false,
    "longname": "src/cengines/replacer/replacer.js~InstructionFilter#_filterFunc",
    "access": "private",
    "description": null,
    "lineNumber": 45,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 397,
    "kind": "method",
    "name": "isAvailable",
    "memberof": "src/cengines/replacer/replacer.js~InstructionFilter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/replacer/replacer.js~InstructionFilter#isAvailable",
    "access": "public",
    "description": "Specialized implementation of BasicBackend.isAvailable: Forwards this\ncall to the filter function given to the constructor.",
    "lineNumber": 54,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": "Command for which to check availability."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 398,
    "kind": "method",
    "name": "receive",
    "memberof": "src/cengines/replacer/replacer.js~InstructionFilter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/replacer/replacer.js~InstructionFilter#receive",
    "access": "public",
    "description": "Forward all commands to the next engine.",
    "lineNumber": 63,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command[]"
        ],
        "spread": false,
        "optional": false,
        "name": "commandList",
        "description": "List of commands to receive."
      }
    ],
    "return": null
  },
  {
    "__docId__": 399,
    "kind": "class",
    "name": "AutoReplacer",
    "memberof": "src/cengines/replacer/replacer.js",
    "static": true,
    "longname": "src/cengines/replacer/replacer.js~AutoReplacer",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/cengines/replacer/replacer.js",
    "importStyle": "{AutoReplacer}",
    "description": "The AutoReplacer is a compiler engine which uses engine.isAvailable in\norder to determine which commands need to be replaced/decomposed/compiled\nfurther. The loaded setup is used to find decomposition rules appropriate\nfor each command (e.g., setups.default).",
    "lineNumber": 76,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "AutoReplacer"
      }
    ],
    "interface": false,
    "extends": [
      "src/cengines/basics.js~BasicEngine"
    ]
  },
  {
    "__docId__": 400,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/cengines/replacer/replacer.js~AutoReplacer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/replacer/replacer.js~AutoReplacer#constructor",
    "access": "public",
    "description": "",
    "examples": [
      "\nrepl = new AutoReplacer()\n\nAmounts to",
      "\nfunction decomposition_chooser(cmd, decomp_list) {\nreturn decomp_list[0]\n}\nconst repl = new AutoReplacer(decomposition_chooser)"
    ],
    "lineNumber": 101,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "DecompositionRuleSet"
        ],
        "spread": false,
        "optional": false,
        "name": "decompositionRuleSet",
        "description": ""
      },
      {
        "nullable": true,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "decomposition_chooser",
        "description": "A function which, given the\nCommand to decompose and a list of potential Decomposition\nobjects, determines (and then returns) the 'best'\ndecomposition.\n\nThe default decomposition chooser simply returns the first list\nelement, i.e., calling"
      }
    ]
  },
  {
    "__docId__": 401,
    "kind": "member",
    "name": "_decomp_chooser",
    "memberof": "src/cengines/replacer/replacer.js~AutoReplacer",
    "static": false,
    "longname": "src/cengines/replacer/replacer.js~AutoReplacer#_decomp_chooser",
    "access": "private",
    "description": null,
    "lineNumber": 107,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 402,
    "kind": "member",
    "name": "decompositionRuleSet",
    "memberof": "src/cengines/replacer/replacer.js~AutoReplacer",
    "static": false,
    "longname": "src/cengines/replacer/replacer.js~AutoReplacer#decompositionRuleSet",
    "access": "public",
    "description": null,
    "lineNumber": 108,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 403,
    "kind": "method",
    "name": "_processCommand",
    "memberof": "src/cengines/replacer/replacer.js~AutoReplacer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/replacer/replacer.js~AutoReplacer#_processCommand",
    "access": "private",
    "description": "Check whether a command cmd can be handled by further engines and,\nif not, replace it using the decomposition rules loaded with the setup\n(e.g., setups.default).",
    "lineNumber": 120,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": "Command to process."
      }
    ],
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "Exception if no replacement is available in the loaded setup."
      }
    ],
    "return": null
  },
  {
    "__docId__": 404,
    "kind": "method",
    "name": "receive",
    "memberof": "src/cengines/replacer/replacer.js~AutoReplacer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/replacer/replacer.js~AutoReplacer#receive",
    "access": "public",
    "description": null,
    "lineNumber": 214,
    "undocument": true,
    "params": [
      {
        "name": "commandList",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 405,
    "kind": "file",
    "name": "src/cengines/swapandcnotflipper.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport assert from 'assert'\r\nimport {BasicEngine, ForwarderEngine} from './basics'\r\nimport {NOT, H, Swap} from '../ops/gates'\r\nimport {All} from '../ops/metagates'\r\nimport {instanceOf, tuple} from '../libs/util';\r\nimport {CNOT} from '../ops/shortcuts'\r\nimport CommandModifier from './cmdmodifier'\r\n\r\n/**\r\n * @class SwapAndCNOTFlipper\r\n * @desc\r\nFlips CNOTs and translates Swaps to CNOTs where necessary.\r\n\r\n    Warning:\r\nThis engine assumes that CNOT and Hadamard gates are supported by\r\nthe following engines.\r\n\r\n    Warning:\r\nThis engine cannot be used as a backend.\r\n */\r\nexport default class SwapAndCNOTFlipper extends BasicEngine {\r\n  /**\r\n   * @constructor\r\n   * @param {Set<string> | Set<Array.<number>>} connectivity Set of tuples (c, t) where if (c, t) is an\r\n   *   element of the set means that a CNOT can be performed between the physical ids (c, t)\r\n   *   with c being the control and t being the target qubit.\r\n   */\r\n  constructor(connectivity) {\r\n    super()\r\n    if (connectivity instanceof Set) {\r\n      const newMap = {}\r\n      connectivity.forEach(v => newMap[v] = 1)\r\n      connectivity = newMap\r\n    }\r\n    this.connectivity = connectivity\r\n  }\r\n\r\n  /**\r\n   * Check if the IBM backend can perform the Command cmd and return true if so.\r\n   * @param {Command} cmd The command to check\r\n   */\r\n  isAvailable(cmd) {\r\n    return this.isSwap(cmd) || this.next.isAvailable(cmd)\r\n  }\r\n\r\n  isCNOT(cmd) {\r\n    return instanceOf(cmd.gate, NOT.constructor) && cmd.controlCount === 1\r\n  }\r\n\r\n  isSwap(cmd) {\r\n    const n = cmd.controlCount\r\n    const f = cmd.gate.equal(Swap)\r\n    return n === 0 && f\r\n  }\r\n\r\n  needsFlipping(cmd) {\r\n    if (!this.isCNOT(cmd)) {\r\n      return false\r\n    }\r\n\r\n    const target = cmd.qubits[0][0].id\r\n    const control = cmd.controlQubits[0].id\r\n    const key = [control, target]\r\n    const rkey = [target, control]\r\n    const v = this.connectivity[key]\r\n    const rv = this.connectivity[rkey]\r\n    const is_possible = typeof v !== 'undefined'\r\n    if (!is_possible && typeof rv === 'undefined') {\r\n      throw new Error(`The provided connectivity does not allow to execute the CNOT gate ${cmd.toString()}.`)\r\n    }\r\n    return !is_possible\r\n  }\r\n\r\n  sendCNOT(cmd, control, target, flip = false) {\r\n    const cmd_mod = (command) => {\r\n      command.tags = cmd.tags.slice(0).concat(command.tags)\r\n      command.engine = this.main\r\n      return command\r\n    }\r\n\r\n    // We'll have to add all meta tags before sending on\r\n    const cmd_mod_eng = new CommandModifier(cmd_mod)\r\n    cmd_mod_eng.next = this.next\r\n    cmd_mod_eng.main = this.main\r\n    // forward everything to the command modifier\r\n    const forwarder_eng = new ForwarderEngine(cmd_mod_eng)\r\n    target[0].engine = forwarder_eng\r\n    control[0].engine = forwarder_eng\r\n    if (flip) {\r\n      // flip the CNOT using Hadamard gates:\r\n      new All(H).or(control.concat(target))\r\n      CNOT.or(tuple(target, control))\r\n      new All(H).or(control.concat(target))\r\n    } else {\r\n      CNOT.or(tuple(control, target))\r\n    }\r\n  }\r\n\r\n  /**\r\n     Receives a command list and if the command is a CNOT gate, it flips\r\n    it using Hadamard gates if necessary; if it is a Swap gate, it\r\n    decomposes it using 3 CNOTs. All other gates are simply sent to the next engine.\r\n    @param {Command[]} commandList list of commands to receive.\r\n   */\r\n  receive(commandList) {\r\n    commandList.forEach((cmd) => {\r\n      if (this.needsFlipping(cmd)) {\r\n        this.sendCNOT(cmd, cmd.controlQubits, cmd.qubits[0], true)\r\n      } else if (this.isSwap(cmd)) {\r\n        const qubits = []\r\n        cmd.qubits.forEach(qr => qr.forEach(qb => qubits.push(qb)))\r\n        const ids = qubits.map(qb => qb.id)\r\n        assert(ids.length === 2)\r\n        let key = ids\r\n        let v = this.connectivity[key]\r\n        let control\r\n        let target\r\n        if (typeof v !== 'undefined') {\r\n          control = [qubits[0]]\r\n          target = [qubits[1]]\r\n        } else {\r\n          key = key.slice(0).reverse()\r\n          v = this.connectivity[key]\r\n          if (typeof v !== 'undefined') {\r\n            control = [qubits[1]]\r\n            target = [qubits[0]]\r\n          } else {\r\n            throw new Error(`The provided connectivity does not allow to execute the Swap gate ${cmd.toString()}.`)\r\n          }\r\n        }\r\n\r\n        this.sendCNOT(cmd, control, target)\r\n        this.sendCNOT(cmd, target, control, true)\r\n        this.sendCNOT(cmd, control, target)\r\n      } else {\r\n        this.next.receive([cmd])\r\n      }\r\n    })\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/cengines/swapandcnotflipper.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 406,
    "kind": "class",
    "name": "SwapAndCNOTFlipper",
    "memberof": "src/cengines/swapandcnotflipper.js",
    "static": true,
    "longname": "src/cengines/swapandcnotflipper.js~SwapAndCNOTFlipper",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/cengines/swapandcnotflipper.js",
    "importStyle": "SwapAndCNOTFlipper",
    "description": "Flips CNOTs and translates Swaps to CNOTs where necessary.\n\nWarning:\nThis engine assumes that CNOT and Hadamard gates are supported by\nthe following engines.\n\nWarning:\nThis engine cannot be used as a backend.",
    "lineNumber": 37,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "SwapAndCNOTFlipper"
      }
    ],
    "interface": false,
    "extends": [
      "src/cengines/basics.js~BasicEngine"
    ]
  },
  {
    "__docId__": 407,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/cengines/swapandcnotflipper.js~SwapAndCNOTFlipper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/swapandcnotflipper.js~SwapAndCNOTFlipper#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 44,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Set<string> | Set<Array.<number>>"
        ],
        "spread": false,
        "optional": false,
        "name": "connectivity",
        "description": "Set of tuples (c, t) where if (c, t) is an\n  element of the set means that a CNOT can be performed between the physical ids (c, t)\n  with c being the control and t being the target qubit."
      }
    ]
  },
  {
    "__docId__": 408,
    "kind": "member",
    "name": "connectivity",
    "memberof": "src/cengines/swapandcnotflipper.js~SwapAndCNOTFlipper",
    "static": false,
    "longname": "src/cengines/swapandcnotflipper.js~SwapAndCNOTFlipper#connectivity",
    "access": "public",
    "description": null,
    "lineNumber": 51,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 409,
    "kind": "method",
    "name": "isAvailable",
    "memberof": "src/cengines/swapandcnotflipper.js~SwapAndCNOTFlipper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/swapandcnotflipper.js~SwapAndCNOTFlipper#isAvailable",
    "access": "public",
    "description": "Check if the IBM backend can perform the Command cmd and return true if so.",
    "lineNumber": 58,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": "The command to check"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 410,
    "kind": "method",
    "name": "isCNOT",
    "memberof": "src/cengines/swapandcnotflipper.js~SwapAndCNOTFlipper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/swapandcnotflipper.js~SwapAndCNOTFlipper#isCNOT",
    "access": "public",
    "description": null,
    "lineNumber": 62,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 411,
    "kind": "method",
    "name": "isSwap",
    "memberof": "src/cengines/swapandcnotflipper.js~SwapAndCNOTFlipper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/swapandcnotflipper.js~SwapAndCNOTFlipper#isSwap",
    "access": "public",
    "description": null,
    "lineNumber": 66,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 412,
    "kind": "method",
    "name": "needsFlipping",
    "memberof": "src/cengines/swapandcnotflipper.js~SwapAndCNOTFlipper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/swapandcnotflipper.js~SwapAndCNOTFlipper#needsFlipping",
    "access": "public",
    "description": null,
    "lineNumber": 72,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 413,
    "kind": "method",
    "name": "sendCNOT",
    "memberof": "src/cengines/swapandcnotflipper.js~SwapAndCNOTFlipper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/swapandcnotflipper.js~SwapAndCNOTFlipper#sendCNOT",
    "access": "public",
    "description": null,
    "lineNumber": 90,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      },
      {
        "name": "control",
        "types": [
          "*"
        ]
      },
      {
        "name": "target",
        "types": [
          "*"
        ]
      },
      {
        "name": "flip",
        "optional": true,
        "types": [
          "boolean"
        ],
        "defaultRaw": false,
        "defaultValue": "false"
      }
    ],
    "return": null
  },
  {
    "__docId__": 414,
    "kind": "method",
    "name": "receive",
    "memberof": "src/cengines/swapandcnotflipper.js~SwapAndCNOTFlipper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/swapandcnotflipper.js~SwapAndCNOTFlipper#receive",
    "access": "public",
    "description": "Receives a command list and if the command is a CNOT gate, it flips\nit using Hadamard gates if necessary; if it is a Swap gate, it\ndecomposes it using 3 CNOTs. All other gates are simply sent to the next engine.",
    "lineNumber": 121,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command[]"
        ],
        "spread": false,
        "optional": false,
        "name": "commandList",
        "description": "list of commands to receive."
      }
    ],
    "return": null
  },
  {
    "__docId__": 415,
    "kind": "file",
    "name": "src/cengines/tagremover.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport assert from 'assert'\r\nimport {BasicEngine} from './basics'\r\nimport {ComputeTag, UncomputeTag} from '../meta/tag'\r\nimport {instanceOf} from '../libs/util'\r\n\r\n/**\r\n *  @class TagRemover\r\n *  @desc is a compiler engine which removes temporary command tags (see the tag classes such as LoopTag in `loop`).\r\n\r\nRemoving tags is important (after having handled them if necessary) in\r\norder to enable optimizations across meta-function boundaries (compute/\r\naction/uncompute or loops after unrolling)\r\n */\r\nexport default class TagRemover extends BasicEngine {\r\n  /**\r\n    @constructor\r\n    @param {Array.<function>} tags A list of meta tag classes (e.g., [ComputeTag, UncomputeTag])\r\n    denoting the tags to remove\r\n  */\r\n  constructor(tags = [ComputeTag, UncomputeTag]) {\r\n    super()\r\n    assert(Array.isArray(tags))\r\n    this._tags = tags\r\n  }\r\n\r\n  /**\r\n   * @param {function} tag\r\n   */\r\n  _isTagIn(tag) {\r\n    return instanceOf(tag, this._tags)\r\n  }\r\n\r\n  /**\r\n    Receive a list of commands from the previous engine, remove all tags\r\nwhich are an instance of at least one of the meta tags provided in the\r\nconstructor, and then send them on to the next compiler engine.\r\n\r\n    @param {Command[]} commandList List of commands to receive and then (after removing tags) send on.\r\n  */\r\n  receive(commandList) {\r\n    commandList.forEach((cmd) => {\r\n      cmd.tags = cmd.tags.filter(t => !this._isTagIn(t))\r\n      this.send([cmd])\r\n    })\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/cengines/tagremover.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 416,
    "kind": "class",
    "name": "TagRemover",
    "memberof": "src/cengines/tagremover.js",
    "static": true,
    "longname": "src/cengines/tagremover.js~TagRemover",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/cengines/tagremover.js",
    "importStyle": "TagRemover",
    "description": "is a compiler engine which removes temporary command tags (see the tag classes such as LoopTag in `loop`).\n\nRemoving tags is important (after having handled them if necessary) in\norder to enable optimizations across meta-function boundaries (compute/\naction/uncompute or loops after unrolling)",
    "lineNumber": 30,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "TagRemover"
      }
    ],
    "interface": false,
    "extends": [
      "src/cengines/basics.js~BasicEngine"
    ]
  },
  {
    "__docId__": 417,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/cengines/tagremover.js~TagRemover",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/tagremover.js~TagRemover#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 36,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Array.<function>"
        ],
        "spread": false,
        "optional": false,
        "name": "tags",
        "description": "A list of meta tag classes (e.g., [ComputeTag, UncomputeTag])\ndenoting the tags to remove"
      }
    ]
  },
  {
    "__docId__": 418,
    "kind": "member",
    "name": "_tags",
    "memberof": "src/cengines/tagremover.js~TagRemover",
    "static": false,
    "longname": "src/cengines/tagremover.js~TagRemover#_tags",
    "access": "private",
    "description": null,
    "lineNumber": 39,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 419,
    "kind": "method",
    "name": "_isTagIn",
    "memberof": "src/cengines/tagremover.js~TagRemover",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/tagremover.js~TagRemover#_isTagIn",
    "access": "private",
    "description": "",
    "lineNumber": 45,
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "tag",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 420,
    "kind": "method",
    "name": "receive",
    "memberof": "src/cengines/tagremover.js~TagRemover",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/tagremover.js~TagRemover#receive",
    "access": "public",
    "description": "Receive a list of commands from the previous engine, remove all tags\nwhich are an instance of at least one of the meta tags provided in the\nconstructor, and then send them on to the next compiler engine.",
    "lineNumber": 56,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command[]"
        ],
        "spread": false,
        "optional": false,
        "name": "commandList",
        "description": "List of commands to receive and then (after removing tags) send on."
      }
    ],
    "return": null
  },
  {
    "__docId__": 421,
    "kind": "file",
    "name": "src/cengines/testengine.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport {BasicEngine} from './basics'\r\nimport {FlushGate} from '../ops/gates'\r\n\r\n/**\r\n * @class CompareEngine\r\n * @desc CompareEngine is an engine which saves all commands. It is only intended\r\n * for testing purposes. Two CompareEngine backends can be compared and\r\n * return true if they contain the same commmands.\r\n */\r\nexport class CompareEngine extends BasicEngine {\r\n  /**\r\n   * @constructor\r\n   */\r\n  constructor() {\r\n    super()\r\n    this._l = [[]]\r\n  }\r\n\r\n  /**\r\n   * @return {boolean}\r\n   */\r\n  isAvailable() {\r\n    return true\r\n  }\r\n\r\n  /**\r\n   * @param {Command} cmd\r\n   */\r\n  cacheCMD(cmd) {\r\n    // are there qubit ids that haven't been added to the list?\r\n    const allQubitIDList = []\r\n    cmd.allQubits.forEach((qureg) => {\r\n      qureg.forEach(qubit => allQubitIDList.push(qubit.id))\r\n    })\r\n    let maxidx = 0\r\n    allQubitIDList.forEach(qid => maxidx = Math.max(maxidx, qid))\r\n\r\n    // if so, increase size of list to account for these qubits\r\n    const add = maxidx + 1 - this._l.length\r\n    if (add > 0) {\r\n      for (let i = 0; i < add; ++i) {\r\n        this._l.push([])\r\n      }\r\n    }\r\n    // add gate command to each of the qubits involved\r\n    allQubitIDList.forEach(qid => this._l[qid].push(cmd))\r\n  }\r\n\r\n  receive(commandList) {\r\n    const f = new FlushGate()\r\n    commandList.forEach((cmd) => {\r\n      if (!cmd.gate.equal(f)) {\r\n        this.cacheCMD(cmd)\r\n      }\r\n    })\r\n\r\n    if (!this.isLastEngine) {\r\n      this.send(commandList)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * test if c1 & c2 are equal\r\n   * @param c1 {Command}\r\n   * @param c2 {Command}\r\n   * @return {boolean}\r\n   */\r\n  compareCMDs(c1, c2) {\r\n    const item = c2.copy()\r\n    item.engine = c1.engine\r\n    return c1.equal(item)\r\n  }\r\n\r\n  equal(engine) {\r\n    const len = this._l.length\r\n    if (!(engine instanceof CompareEngine) || len !== engine._l.length) {\r\n      return false\r\n    }\r\n\r\n    for (let i = 0; i < len; ++i) {\r\n      const item1 = this._l[i]\r\n      const item2 = engine._l[i]\r\n      if (item1.length !== item2.length) {\r\n        return false\r\n      }\r\n      const total = item1.length\r\n      for (let j = 0; j < total; ++j) {\r\n        if (!this.compareCMDs(item1[j], item2[j])) {\r\n          return false\r\n        }\r\n      }\r\n    }\r\n    return true\r\n  }\r\n\r\n  /**\r\n   * string description\r\n   * @return {string}\r\n   */\r\n  toString() {\r\n    let string = ''\r\n    this._l.forEach((cmds, qubit_id) => {\r\n      string += `Qubit ${qubit_id} : `\r\n      cmds.forEach((command) => {\r\n        string += `${command.toString()}, `\r\n      })\r\n      string = `${string.substring(0, string.length - 2)}\\n`\r\n    })\r\n    return string\r\n  }\r\n}\r\n\r\n/**\r\n * @class DummyEngine\r\n   @desc DummyEngine used for testing.\r\n    The DummyEngine forwards all commands directly to next engine.\r\n    If this.is_last_engine == true it just discards all gates.\r\n    By setting save_commands == true all commands get saved as a\r\n    list in this.received_commands. Elements are appended to this\r\n    list so they are ordered according to when they are received.\r\n */\r\nexport class DummyEngine extends BasicEngine {\r\n  /**\r\n   * @constructor\r\n   * @param {boolean} saveCommands default is false\r\n   */\r\n  constructor(saveCommands = false) {\r\n    super()\r\n    this.saveCommands = saveCommands\r\n    this.receivedCommands = []\r\n  }\r\n\r\n  isAvailable() {\r\n    return true\r\n  }\r\n\r\n  receive(commandList) {\r\n    if (this.saveCommands) {\r\n      this.receivedCommands = this.receivedCommands.concat(commandList)\r\n    }\r\n\r\n    if (!this.isLastEngine) {\r\n      this.send(commandList)\r\n    }\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/cengines/testengine.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 422,
    "kind": "class",
    "name": "CompareEngine",
    "memberof": "src/cengines/testengine.js",
    "static": true,
    "longname": "src/cengines/testengine.js~CompareEngine",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/cengines/testengine.js",
    "importStyle": "{CompareEngine}",
    "description": "CompareEngine is an engine which saves all commands. It is only intended\nfor testing purposes. Two CompareEngine backends can be compared and\nreturn true if they contain the same commmands.",
    "lineNumber": 26,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "CompareEngine"
      }
    ],
    "interface": false,
    "extends": [
      "src/cengines/basics.js~BasicEngine"
    ]
  },
  {
    "__docId__": 423,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/cengines/testengine.js~CompareEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/testengine.js~CompareEngine#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 30,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ]
  },
  {
    "__docId__": 424,
    "kind": "member",
    "name": "_l",
    "memberof": "src/cengines/testengine.js~CompareEngine",
    "static": false,
    "longname": "src/cengines/testengine.js~CompareEngine#_l",
    "access": "private",
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "type": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 425,
    "kind": "method",
    "name": "isAvailable",
    "memberof": "src/cengines/testengine.js~CompareEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/testengine.js~CompareEngine#isAvailable",
    "access": "public",
    "description": "",
    "lineNumber": 38,
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 426,
    "kind": "method",
    "name": "cacheCMD",
    "memberof": "src/cengines/testengine.js~CompareEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/testengine.js~CompareEngine#cacheCMD",
    "access": "public",
    "description": "",
    "lineNumber": 45,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 427,
    "kind": "method",
    "name": "receive",
    "memberof": "src/cengines/testengine.js~CompareEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/testengine.js~CompareEngine#receive",
    "access": "public",
    "description": null,
    "lineNumber": 65,
    "undocument": true,
    "params": [
      {
        "name": "commandList",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 428,
    "kind": "method",
    "name": "compareCMDs",
    "memberof": "src/cengines/testengine.js~CompareEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/testengine.js~CompareEngine#compareCMDs",
    "access": "public",
    "description": "test if c1 & c2 are equal",
    "lineNumber": 84,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "c1",
        "description": "{Command}"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "c2",
        "description": "{Command}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 429,
    "kind": "method",
    "name": "equal",
    "memberof": "src/cengines/testengine.js~CompareEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/testengine.js~CompareEngine#equal",
    "access": "public",
    "description": null,
    "lineNumber": 90,
    "undocument": true,
    "params": [
      {
        "name": "engine",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 430,
    "kind": "method",
    "name": "toString",
    "memberof": "src/cengines/testengine.js~CompareEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/testengine.js~CompareEngine#toString",
    "access": "public",
    "description": "string description",
    "lineNumber": 116,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 431,
    "kind": "class",
    "name": "DummyEngine",
    "memberof": "src/cengines/testengine.js",
    "static": true,
    "longname": "src/cengines/testengine.js~DummyEngine",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/cengines/testengine.js",
    "importStyle": "{DummyEngine}",
    "description": "DummyEngine used for testing.\nThe DummyEngine forwards all commands directly to next engine.\nIf this.is_last_engine == true it just discards all gates.\nBy setting save_commands == true all commands get saved as a\nlist in this.received_commands. Elements are appended to this\nlist so they are ordered according to when they are received.",
    "lineNumber": 138,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "DummyEngine"
      }
    ],
    "interface": false,
    "extends": [
      "src/cengines/basics.js~BasicEngine"
    ]
  },
  {
    "__docId__": 432,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/cengines/testengine.js~DummyEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/testengine.js~DummyEngine#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 143,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "saveCommands",
        "description": "default is false"
      }
    ]
  },
  {
    "__docId__": 433,
    "kind": "member",
    "name": "saveCommands",
    "memberof": "src/cengines/testengine.js~DummyEngine",
    "static": false,
    "longname": "src/cengines/testengine.js~DummyEngine#saveCommands",
    "access": "public",
    "description": null,
    "lineNumber": 145,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 434,
    "kind": "member",
    "name": "receivedCommands",
    "memberof": "src/cengines/testengine.js~DummyEngine",
    "static": false,
    "longname": "src/cengines/testengine.js~DummyEngine#receivedCommands",
    "access": "public",
    "description": null,
    "lineNumber": 146,
    "undocument": true,
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 435,
    "kind": "method",
    "name": "isAvailable",
    "memberof": "src/cengines/testengine.js~DummyEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/testengine.js~DummyEngine#isAvailable",
    "access": "public",
    "description": null,
    "lineNumber": 149,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 436,
    "kind": "method",
    "name": "receive",
    "memberof": "src/cengines/testengine.js~DummyEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/testengine.js~DummyEngine#receive",
    "access": "public",
    "description": null,
    "lineNumber": 153,
    "undocument": true,
    "params": [
      {
        "name": "commandList",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 438,
    "kind": "file",
    "name": "src/cengines/twodmapper.js",
    "content": "/*\r\nMapper for a quantum circuit to a 2D square grid.\r\n\r\n    Input: Quantum circuit with 1 and 2 qubit gates on n qubits. Gates are assumed\r\nto be applied in parallel if they act on disjoint qubit(s) and any pair\r\nof qubits can perform a 2 qubit gate (all-to-all connectivity)\r\nOutput: Quantum circuit in which qubits are placed in 2-D square grid in which\r\nonly nearest neighbour qubits can perform a 2 qubit gate. The mapper\r\nuses Swap gates in order to move qubits next to each other.\r\n*/\r\nimport assert from 'assert'\r\nimport math from 'mathjs'\r\nimport {permutations} from 'itertools'\r\nimport BasicMapperEngine from './basicmapper';\r\nimport {return_swap_depth} from './linearmapper'\r\nimport NativeImpl from '../backends/simulators/cppsim'\r\nimport {\r\n  arrayFromRange, len, randomSample, setDifference, setEqual, setFromRange\r\n} from '../libs/polyfill';\r\nimport LinearMapper from './linearmapper';\r\nimport {\r\n  AllocateQubitGate, DeallocateQubitGate, FlushGate, Swap\r\n} from '../ops';\r\nimport {tuple} from '../libs/util';\r\nimport Command from '../ops/command';\r\nimport {BasicQubit} from '../types/qubit';\r\nimport {LogicalQubitIDTag} from '../meta';\r\n\r\n/**\r\n * @class Position\r\n */\r\nexport class Position {\r\n  /**\r\n   * @constructor\r\n   * @param {number} current_row\r\n   * @param {number} current_column\r\n   * @param {number} final_row\r\n   * @param {number} final_column\r\n   * @param {number} row_after_step_1\r\n   */\r\n  constructor(current_row, current_column, final_row, final_column, row_after_step_1) {\r\n    this.current_row = current_row\r\n    this.current_column = current_column\r\n    this.final_row = final_row\r\n    this.final_column = final_column\r\n    this.row_after_step_1 = row_after_step_1\r\n  }\r\n}\r\n\r\n/**\r\n * @class GridMapper\r\n * @desc\r\nMapper to a 2-D grid graph.\r\n\r\n    Mapped qubits on the grid are numbered in row-major order. E.g. for\r\n3 rows and 2 columns:\r\n  ```js\r\n    0 - 1\r\n    |   |\r\n    2 - 3\r\n    |   |\r\n    4 - 5\r\n  ```\r\nThe numbers are the mapped qubit ids. The backend might number\r\nthe qubits on the grid differently (e.g. not row-major), we call these\r\nbackend qubit ids. If the backend qubit ids are not row-major, one can\r\npass a dictionary translating from our row-major mapped ids to these\r\nbackend ids.\r\n\r\n    Note: The algorithm sorts twice inside each column and once inside each\r\nrow.\r\n\r\n @property current_mapping Stores the mapping: key is logical qubit id, value is backend qubit id.\r\nstorage(int): Number of gate it caches before mapping.\r\nnum_rows(int): Number of rows in the grid\r\nnum_columns(int): Number of columns in the grid\r\nnum_qubits(int): num_rows x num_columns = number of qubits\r\nnum_mappings (int): Number of times the mapper changed the mapping\r\ndepth_of_swaps (dict): Key are circuit depth of swaps, value is the\r\nnumber of such mappings which have been\r\napplied\r\nnum_of_swaps_per_mapping (dict): Key are the number of swaps per\r\nmapping, value is the number of such\r\nmappings which have been applied\r\n */\r\nexport default class GridMapper extends BasicMapperEngine {\r\n  /**\r\n   * @constructor\r\n  Initialize a GridMapper compiler engine.\r\n\r\n    @param {{num_rows: number, num_columns: number, mapped_ids_to_backend_ids: ?Object, storage: ?number, optimization_function: ?function, num_optimization_steps: ?number}} args\r\n    @throws {Error} if incorrect `mapped_ids_to_backend_ids` parameter\r\n   */\r\n  constructor(args) {\r\n    super()\r\n    /**\r\n     * @type {Object}\r\n     * @property {number} args.num_rows\r\n     */\r\n    const {\r\n      num_rows, num_columns, mapped_ids_to_backend_ids,\r\n      storage = 1000,\r\n      optimization_function = x => return_swap_depth(x),\r\n      num_optimization_steps = 50\r\n    } = args\r\n\r\n    /**\r\n     * @property {number} this.num_rows Number of rows in the grid\r\n     * @property {number} this.num_columns Number of columns in the grid.\r\n     * @property {number} this.num_qubits\r\n     * @property {Object<number, number>} this._mapped_ids_to_backend_ids\r\n     * @property {Object<number, number>} this._backend_ids_to_mapped_ids\r\n     *      Stores a mapping from mapped ids which are 0,...,this.num_qubits-1 in row-major order\r\n     *      on the grid to the corresponding qubit ids of the backend. Key: mapped id. Value: corresponding backend id.\r\n     *      Default is None which means backend ids are identical to mapped ids.\r\n     * @property {Object<number, number>} this._current_row_major_mapping\r\n     * @property {number} this.storage Number of gates to temporarily store\r\n     * @property {function} this.optimization_function\r\n     *      Function which takes a list of swaps and returns a cost value. Mapper chooses a permutation\r\n     *      which minimizes this cost. Default optimizes for circuit depth.\r\n     * @property {number} this.num_optimization_steps\r\n     *      Number of different permutations to of the matching to try and minimize the cost.\r\n     * @property {number} this.num_mappings\r\n     * @property {Object<number, number>} this.depth_of_swaps\r\n     * @property {Object<number, number>} this.num_of_swaps_per_mapping\r\n     */\r\n    this.num_rows = num_rows\r\n    this.num_columns = num_columns\r\n    this.num_qubits = num_rows * num_columns\r\n    // Internally we use the mapped ids until sending a command.\r\n    // Before sending we use this map to translate to backend ids:\r\n    this._mapped_ids_to_backend_ids = mapped_ids_to_backend_ids\r\n    if (typeof this._mapped_ids_to_backend_ids === 'undefined' || this._mapped_ids_to_backend_ids === null) {\r\n      this._mapped_ids_to_backend_ids = {}\r\n      for (let i = 0; i < this.num_qubits; ++i) {\r\n        this._mapped_ids_to_backend_ids[i] = i\r\n      }\r\n    }\r\n\r\n    const f1 = setEqual(new Set(Object.keys(this._mapped_ids_to_backend_ids).map(k => parseInt(k, 10))), setFromRange(this.num_qubits))\r\n    const f2 = new Set(Object.values(this._mapped_ids_to_backend_ids)).size === this.num_qubits\r\n    if (!f1 || !f2) {\r\n      throw new Error('Incorrect mapped_ids_to_backend_ids parameter')\r\n    }\r\n    this._backend_ids_to_mapped_ids = {}\r\n\r\n    Object.keys(this._mapped_ids_to_backend_ids).forEach((mapped_id) => {\r\n      const backend_id = this._mapped_ids_to_backend_ids[mapped_id]\r\n      this._backend_ids_to_mapped_ids[backend_id] = mapped_id\r\n    })\r\n    // As we use internally the mapped ids which are in row-major order,\r\n    // we have an internal current mapping which maps from logical ids to\r\n    // these mapped ids:\r\n    this._current_row_major_mapping = Object.assign({}, this._currentMapping)\r\n    this.storage = storage\r\n    this.optimization_function = optimization_function\r\n    this.num_optimization_steps = num_optimization_steps\r\n    // Randomness to pick permutations if there are too many.\r\n    // This creates an own instance of Random in order to not influence\r\n    // the bound methods of the random module which might be used in other\r\n    // places.\r\n    // TODO\r\n    // this._rng = random.Random(11)\r\n    /**\r\n     * Storing commands\r\n     * @property {Command[]} this._stored_commands\r\n     */\r\n    this._stored_commands = []\r\n    /** Logical qubit ids for which the Allocate gate has already been\r\n      processed and sent to the next engine but which are not yet deallocated:\r\n      @property {Set<number>} this._currently_allocated_ids\r\n     */\r\n    this._currently_allocated_ids = new Set()\r\n    /**\r\n     * Change between 2D and 1D mappings (2D is a snake like 1D chain)\r\n        Note it translates to our mapped ids in row major order and not\r\n        backend ids which might be different.\r\n     * @property {Object<number, number>} this._map_2d_to_1d\r\n     * @property {Object<number, number>} this._map_1d_to_2d\r\n    */\r\n    this._map_2d_to_1d = {}\r\n    this._map_1d_to_2d = {}\r\n    for (let row_index = 0; row_index < this.num_rows; ++row_index) {\r\n      for (let column_index = 0; column_index < this.num_columns; ++column_index) {\r\n        if (row_index % 2 === 0) {\r\n          const mapped_id = row_index * this.num_columns + column_index\r\n          this._map_2d_to_1d[mapped_id] = mapped_id\r\n          this._map_1d_to_2d[mapped_id] = mapped_id\r\n        } else {\r\n          const mapped_id_2d = row_index * this.num_columns + column_index\r\n          const mapped_id_1d = ((row_index + 1) * this.num_columns - column_index - 1)\r\n          this._map_2d_to_1d[mapped_id_2d] = mapped_id_1d\r\n          this._map_1d_to_2d[mapped_id_1d] = mapped_id_2d\r\n        }\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Statistics\r\n      */\r\n    this.num_mappings = 0\r\n    this.depth_of_swaps = {}\r\n    this.num_of_swaps_per_mapping = {}\r\n  }\r\n\r\n  get currentMapping() {\r\n    return super.currentMapping\r\n  }\r\n\r\n  set currentMapping(newMapping) {\r\n    this._currentMapping = newMapping\r\n    if (typeof newMapping === 'undefined' || newMapping === null) {\r\n      this._current_row_major_mapping = newMapping\r\n    } else {\r\n      this._current_row_major_mapping = {}\r\n\r\n      Object.keys(newMapping).forEach((logical_id) => {\r\n        const backend_id = newMapping[logical_id]\r\n        const value = this._backend_ids_to_mapped_ids[backend_id]\r\n        this._current_row_major_mapping[logical_id] = parseInt(value, 10)\r\n      })\r\n    }\r\n  }\r\n\r\n  // Only allows 1 || two qubit gates.\r\n  isAvailable(cmd) {\r\n    let num_qubits = 0\r\n    cmd.allQubits.forEach(qureg => num_qubits += qureg.length)\r\n    return num_qubits <= 2\r\n  }\r\n\r\n  /**\r\n  Returns a new mapping of the qubits.\r\n\r\n    It goes through this._saved_commands and tries to find a\r\nmapping to apply these gates on a first come first served basis.\r\n    It reuses the function of a 1D mapper and creates a mapping for a\r\n  1D linear chain and then wraps it like a snake onto the square grid.\r\n\r\n    One might create better mappings by specializing this function for a\r\n  square grid.\r\n\r\n    @return {Object} A new mapping as a dict. key is logical qubit id, value is mapped id\r\n   */\r\n  returnNewMapping() {\r\n    // Change old mapping to 1D in order to use LinearChain heuristic\r\n    let old_mapping_1d\r\n    if (this._current_row_major_mapping) {\r\n      old_mapping_1d = {}\r\n      Object.keys(this._current_row_major_mapping).forEach((logical_id) => {\r\n        const mapped_id = this._current_row_major_mapping[logical_id]\r\n        old_mapping_1d[logical_id] = this._map_2d_to_1d[mapped_id]\r\n      })\r\n    } else {\r\n      old_mapping_1d = this._current_row_major_mapping\r\n    }\r\n\r\n    const new_mapping_1d = LinearMapper.returnNewMapping(\r\n      this.num_qubits,\r\n      false,\r\n      this._currently_allocated_ids,\r\n      this._stored_commands,\r\n      old_mapping_1d\r\n    )\r\n\r\n    const new_mapping_2d = {}\r\n    Object.keys(new_mapping_1d).forEach((logical_id) => {\r\n      const mapped_id = new_mapping_1d[logical_id]\r\n      new_mapping_2d[logical_id] = this._map_1d_to_2d[mapped_id]\r\n    })\r\n\r\n    return new_mapping_2d\r\n  }\r\n\r\n  /**\r\n   * If swapped (inplace), then return swap operation so that `key(element0) < key(element1)`\r\n   @param {Position} element0\r\n   @param {Position} element1\r\n   @param {function(arg: Position): number} key\r\n   @return {Array<number>|undefined}\r\n   */\r\n  _compareAndSwap(element0, element1, key) {\r\n    if (key(element0) > key(element1)) {\r\n      const mapped_id0 = (element0.current_column + element0.current_row * this.num_columns)\r\n      const mapped_id1 = (element1.current_column + element1.current_row * this.num_columns)\r\n      const swap_operation = [mapped_id0, mapped_id1]\r\n      // swap elements but update also current position:\r\n      const tmp_0 = element0.final_row\r\n      const tmp_1 = element0.final_column\r\n      const tmp_2 = element0.row_after_step_1\r\n      element0.final_row = element1.final_row\r\n      element0.final_column = element1.final_column\r\n      element0.row_after_step_1 = element1.row_after_step_1\r\n      element1.final_row = tmp_0\r\n      element1.final_column = tmp_1\r\n      element1.row_after_step_1 = tmp_2\r\n      return swap_operation\r\n    }\r\n    return undefined\r\n  }\r\n\r\n  /**\r\n   * @param {Array<Position[]>} final_positions\r\n   * @param {function(arg: Position): number} key\r\n   * @return {Array<number[]>}\r\n   * @private\r\n   */\r\n  _sortWithinRows(final_positions, key) {\r\n    const swap_operations = []\r\n    for (let row = 0; row < this.num_rows; ++row) {\r\n      let finished_sorting = false\r\n      while (!finished_sorting) {\r\n        finished_sorting = true\r\n        for (let column = 1; column < this.num_columns - 1; column += 2) {\r\n          const element0 = final_positions[row][column]\r\n          const element1 = final_positions[row][column + 1]\r\n          const swap = this._compareAndSwap(element0, element1, key)\r\n          if (typeof swap !== 'undefined') {\r\n            finished_sorting = false\r\n            swap_operations.push(swap)\r\n          }\r\n        }\r\n\r\n        for (let column = 0; column < this.num_columns - 1; column += 2) {\r\n          const element0 = final_positions[row][column]\r\n          const element1 = final_positions[row][column + 1]\r\n          const swap = this._compareAndSwap(element0, element1, key)\r\n          if (typeof swap !== 'undefined') {\r\n            finished_sorting = false\r\n            swap_operations.push(swap)\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return swap_operations\r\n  }\r\n\r\n  /**\r\n   * @param {Array<Position[]>} final_positions\r\n   * @param {function(arg: Position): number} key\r\n   * @return {Array<number[]>}\r\n   * @private\r\n   */\r\n  _sortWithinColumns(final_positions, key) {\r\n    const swap_operations = []\r\n    for (let column = 0; column < this.num_columns; ++column) {\r\n      let finished_sorting = false\r\n      while (!finished_sorting) {\r\n        finished_sorting = true\r\n        for (let row = 1; row < this.num_rows - 1; row += 2) {\r\n          const element0 = final_positions[row][column]\r\n          const element1 = final_positions[row + 1][column]\r\n          const swap = this._compareAndSwap(element0, element1, key)\r\n          if (typeof swap !== 'undefined') {\r\n            finished_sorting = false\r\n            swap_operations.push(swap)\r\n          }\r\n        }\r\n\r\n        for (let row = 0; row < this.num_rows - 1; row += 2) {\r\n          const element0 = final_positions[row][column]\r\n          const element1 = final_positions[row + 1][column]\r\n          const swap = this._compareAndSwap(element0, element1, key)\r\n          if (typeof swap !== 'undefined') {\r\n            finished_sorting = false\r\n            swap_operations.push(swap)\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return swap_operations\r\n  }\r\n\r\n  /**\r\n  Creates a new mapping and executes possible gates.\r\n\r\n    It first allocates all 0, ..., this.num_qubits-1 mapped qubit ids, if\r\n    they are not already used because we might need them all for the\r\n  swaps. Then it creates a new map, swaps all the qubits to the new map,\r\n    executes all possible gates, and finally deallocates mapped qubit ids\r\nwhich don't store any information.\r\n   */\r\n  _run() {\r\n    const num_of_stored_commands_before = len(this._stored_commands)\r\n    if (!this._currentMapping) {\r\n      this.currentMapping = {}\r\n    } else {\r\n      this._sendPossibleCommands()\r\n      if (len(this._stored_commands) === 0) {\r\n        return\r\n      }\r\n    }\r\n\r\n    const new_row_major_mapping = this.returnNewMapping()\r\n    // Find permutation of matchings with lowest cost\r\n    let swaps\r\n    let lowest_cost\r\n    const matchings_numbers = arrayFromRange(this.num_rows)\r\n    const ps = []\r\n    if (this.num_optimization_steps <= math.factorial(this.num_rows)) {\r\n      for (const looper of permutations(matchings_numbers, this.num_rows)) {\r\n        ps.push(looper)\r\n      }\r\n    } else {\r\n      for (let i = 0; i < this.num_optimization_steps; ++i) {\r\n        ps.push(randomSample(matchings_numbers, this.num_rows))\r\n      }\r\n    }\r\n\r\n    ps.forEach((permutation) => {\r\n      const trial_swaps = this.returnSwaps(\r\n        this._current_row_major_mapping,\r\n        new_row_major_mapping,\r\n        permutation\r\n      )\r\n      if (typeof swaps === 'undefined') {\r\n        swaps = trial_swaps\r\n        lowest_cost = this.optimization_function(trial_swaps)\r\n      } else if (lowest_cost > this.optimization_function(trial_swaps)) {\r\n        swaps = trial_swaps\r\n        lowest_cost = this.optimization_function(trial_swaps)\r\n      }\r\n    })\r\n    if (swaps.length > 0) { // first mapping requires no swaps\r\n      // Allocate all mapped qubit ids (which are not already allocated,\r\n      // i.e., contained in this._currently_allocated_ids)\r\n      let mapped_ids_used = new Set()\r\n      for (const logical_id of this._currently_allocated_ids) {\r\n        mapped_ids_used.add(this._current_row_major_mapping[logical_id])\r\n      }\r\n      const not_allocated_ids = setDifference(setFromRange(this.num_qubits), mapped_ids_used)\r\n      for (const mapped_id of not_allocated_ids) {\r\n        const qb = new BasicQubit(this, this._mapped_ids_to_backend_ids[mapped_id])\r\n        const cmd = new Command(this, new AllocateQubitGate(), tuple([qb]))\r\n        this.send([cmd])\r\n      }\r\n\r\n\r\n      // Send swap operations to arrive at new_mapping:\r\n      swaps.forEach(([qubit_id0, qubit_id1]) => {\r\n        const q0 = new BasicQubit(this, this._mapped_ids_to_backend_ids[qubit_id0])\r\n        const q1 = new BasicQubit(this, this._mapped_ids_to_backend_ids[qubit_id1])\r\n        const cmd = new Command(this, Swap, tuple([q0], [q1]))\r\n        this.send([cmd])\r\n      })\r\n      // Register statistics:\r\n      this.num_mappings += 1\r\n      const depth = return_swap_depth(swaps)\r\n      if (!(depth in this.depth_of_swaps)) {\r\n        this.depth_of_swaps[depth] = 1\r\n      } else {\r\n        this.depth_of_swaps[depth] += 1\r\n      }\r\n      if (!(len(swaps) in this.num_of_swaps_per_mapping)) {\r\n        this.num_of_swaps_per_mapping[len(swaps)] = 1\r\n      } else {\r\n        this.num_of_swaps_per_mapping[len(swaps)] += 1\r\n      }\r\n      // Deallocate all previously mapped ids which we only needed for the\r\n      // swaps:\r\n      mapped_ids_used = new Set()\r\n      for (const logical_id of this._currently_allocated_ids) {\r\n        mapped_ids_used.add(new_row_major_mapping[logical_id])\r\n      }\r\n      const not_needed_anymore = setDifference(setFromRange(this.num_qubits), mapped_ids_used)\r\n      for (const mapped_id of not_needed_anymore) {\r\n        const qb = new BasicQubit(this, this._mapped_ids_to_backend_ids[mapped_id])\r\n        const cmd = new Command(this, new DeallocateQubitGate(), tuple([qb]))\r\n        this.send([cmd])\r\n      }\r\n    }\r\n\r\n    // Change to new map:\r\n    this._current_row_major_mapping = new_row_major_mapping\r\n    const new_mapping = {}\r\n    Object.keys(new_row_major_mapping).forEach((logical_id) => {\r\n      const mapped_id = new_row_major_mapping[logical_id]\r\n      new_mapping[logical_id] = this._mapped_ids_to_backend_ids[mapped_id]\r\n    })\r\n\r\n    this.currentMapping = new_mapping\r\n    // Send possible gates\r\n    this._sendPossibleCommands()\r\n    // Check that mapper actually made progress\r\n    if (len(this._stored_commands) === num_of_stored_commands_before) {\r\n      throw new Error('Mapper is potentially in an infinite loop. '\r\n          + 'It is likely that the algorithm requires '\r\n          + 'too many qubits. Increase the number of '\r\n          + 'qubits for this mapper.')\r\n    }\r\n  }\r\n\r\n  /**\r\n  Sends the stored commands possible without changing the mapping.\r\n    Note: this._current_row_major_mapping (hence also this.currentMapping) must exist already\r\n   */\r\n  _sendPossibleCommands() {\r\n    const active_ids = new Set(Array.from(this._currently_allocated_ids).map(k => parseInt(k, 10)))\r\n    Object.keys(this._current_row_major_mapping).forEach(logical_id => active_ids.add(parseInt(logical_id, 10)))\r\n\r\n    let new_stored_commands = []\r\n    for (let i = 0; i < this._stored_commands.length; ++i) {\r\n      const cmd = this._stored_commands[i]\r\n      if (len(active_ids) === 0) {\r\n        new_stored_commands = new_stored_commands.concat(this._stored_commands.slice(i))\r\n        break\r\n      }\r\n      if (cmd.gate instanceof AllocateQubitGate) {\r\n        const qid = cmd.qubits[0][0].id\r\n        if (qid in this._current_row_major_mapping) {\r\n          this._currently_allocated_ids.add(qid)\r\n          const mapped_id = this._current_row_major_mapping[qid]\r\n          const qb = new BasicQubit(this, this._mapped_ids_to_backend_ids[mapped_id])\r\n          const new_cmd = new Command(this, new AllocateQubitGate(), tuple([qb]), [], [new LogicalQubitIDTag(qid)])\r\n          this.send([new_cmd])\r\n        } else {\r\n          new_stored_commands.push(cmd)\r\n        }\r\n      } else if (cmd.gate instanceof DeallocateQubitGate) {\r\n        const qid = cmd.qubits[0][0].id\r\n        if (active_ids.has(qid)) {\r\n          const mapped_id = this._current_row_major_mapping[qid]\r\n          const qb = new BasicQubit(this, this._mapped_ids_to_backend_ids[mapped_id])\r\n          const new_cmd = new Command(this, new DeallocateQubitGate(), tuple([qb]), [], [new LogicalQubitIDTag(qid)])\r\n          this._currently_allocated_ids.delete(qid)\r\n          active_ids.delete(qid)\r\n          delete this._current_row_major_mapping[qid]\r\n          delete this._currentMapping[qid]\r\n          this.send([new_cmd])\r\n        } else {\r\n          new_stored_commands.push(cmd)\r\n        }\r\n      } else {\r\n        let send_gate = true\r\n        const mapped_ids = new Set()\r\n\r\n        for (let k = 0; k < cmd.allQubits.length; ++k) {\r\n          const qureg = cmd.allQubits[k]\r\n          for (let j = 0; j < qureg.length; ++j) {\r\n            const qubit = qureg[j]\r\n            if (!active_ids.has(qubit.id)) {\r\n              send_gate = false\r\n              break\r\n            }\r\n            mapped_ids.add(this._current_row_major_mapping[qubit.id])\r\n          }\r\n        }\r\n\r\n\r\n        // Check that mapped ids are nearest neighbour on 2D grid\r\n        if (len(mapped_ids) === 2) {\r\n          const [qb0, qb1] = Array.from(mapped_ids).sort((a, b) => a - b)\r\n          send_gate = false\r\n          if (qb1 - qb0 === this.num_columns) {\r\n            send_gate = true\r\n          } else if (qb1 - qb0 === 1 && (qb1 % this.num_columns !== 0)) {\r\n            send_gate = true\r\n          }\r\n        }\r\n        if (send_gate) {\r\n          // Note: This sends the cmd correctly with the backend ids\r\n          //       as it looks up the mapping in this.currentMapping\r\n          //       and not our internal mapping\r\n          //       this._current_row_major_mapping\r\n          this.sendCMDWithMappedIDs(cmd)\r\n        } else {\r\n          cmd.allQubits.forEach(qureg => qureg.forEach(qubit => active_ids.delete(qubit.id)))\r\n          new_stored_commands.push(cmd)\r\n        }\r\n      }\r\n    }\r\n\r\n    this._stored_commands = new_stored_commands\r\n  }\r\n\r\n  /**\r\n  Receives a command list and, for each command, stores it until\r\n  we do a mapping (FlushGate || Cache of stored commands is full).\r\n   @param {Command[]} command_list  list of commands to receive.\r\n  */\r\n  receive(command_list) {\r\n    command_list.forEach((cmd) => {\r\n      if (cmd.gate instanceof FlushGate) {\r\n        while (this._stored_commands.length > 0) {\r\n          this._run()\r\n        }\r\n        this.send([cmd])\r\n      } else {\r\n        this._stored_commands.push(cmd)\r\n      }\r\n\r\n      if (this._stored_commands.length >= this.storage) {\r\n        this._run()\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n  Returns the swap operation to change mapping\r\n\r\n    @param {Object} old_mapping dict keys are logical ids and values are mapped qubit ids\r\n    @param {Object} new_mapping dict keys are logical ids and values are mapped qubit ids\r\n    @param {Array.<number[]>} permutation list of int from 0, 1, ..., this.num_rows-1. It is\r\n      used to permute the found perfect matchings. Default is None which keeps the original order.\r\n    @return {Array.<number[]>} List of tuples. Each tuple is a swap operation which needs to be\r\n      applied. Tuple contains the two mapped qubit ids for the Swap.\r\n   */\r\n  returnSwaps(old_mapping, new_mapping, permutation) {\r\n    if (typeof permutation === 'undefined') {\r\n      permutation = arrayFromRange(this.num_rows)\r\n    }\r\n    let swap_operations = []\r\n\r\n    // final_positions contains info containers\r\n    // final_position[i][j] contains info container with\r\n    // current_row == i and current_column == j\r\n    const final_positions = new Array(this.num_rows)\r\n    for (let i = 0; i < this.num_rows; ++i) {\r\n      final_positions[i] = new Array(this.num_columns)\r\n    }\r\n\r\n    // move qubits which are in both mappings\r\n    const used_mapped_ids = new Set()\r\n\r\n    Object.keys(old_mapping).forEach((logical_id) => {\r\n      if (logical_id in new_mapping) {\r\n        used_mapped_ids.add(new_mapping[logical_id])\r\n        const old_column = old_mapping[logical_id] % this.num_columns\r\n        const old_row = Math.floor(old_mapping[logical_id] / this.num_columns)\r\n        const new_column = new_mapping[logical_id] % this.num_columns\r\n        const new_row = Math.floor(new_mapping[logical_id] / this.num_columns)\r\n        const info_container = new Position(old_row,\r\n          old_column,\r\n          new_row,\r\n          new_column)\r\n        final_positions[old_row][old_column] = info_container\r\n      }\r\n    })\r\n    // exchange all remaining None with the not yet used mapped ids\r\n    const all_ids = setFromRange(this.num_qubits)\r\n    let not_used_mapped_ids = Array.from(setDifference(all_ids, used_mapped_ids))\r\n    not_used_mapped_ids = not_used_mapped_ids.sort((a, b) => b - a)\r\n\r\n    for (let row = 0; row < this.num_rows; ++row) {\r\n      for (let column = 0; column < this.num_columns; ++column) {\r\n        if (typeof final_positions[row][column] === 'undefined') {\r\n          const mapped_id = not_used_mapped_ids.pop()\r\n          const new_column = mapped_id % this.num_columns\r\n          const new_row = Math.floor(mapped_id / this.num_columns)\r\n          const info_container = new Position(row, column, new_row, new_column)\r\n          final_positions[row][column] = info_container\r\n        }\r\n      }\r\n    }\r\n\r\n    assert(len(not_used_mapped_ids) === 0)\r\n    const positions = []\r\n    final_positions.forEach(row => positions.push(row.map(item => item.final_column)))\r\n    const matchings = NativeImpl.returnNewSwap(this.num_rows, this.num_columns, positions)\r\n    const offset = this.num_columns\r\n    // permute the matchings\r\n    const tmp = matchings.map(looper => Object.assign({}, looper))\r\n    for (let i = 0; i < this.num_rows; ++i) {\r\n      matchings[i] = tmp[permutation[i]]\r\n    }\r\n    // Assign row_after_step_1\r\n    for (let column = 0; column < this.num_columns; ++column) {\r\n      for (let row_after_step_1 = 0; row_after_step_1 < this.num_rows; ++row_after_step_1) {\r\n        const dest_column = matchings[row_after_step_1][column] - offset\r\n        let best_element\r\n        for (let row = 0; row < this.num_rows; ++row) {\r\n          const element = final_positions[row][column]\r\n          if (typeof element.row_after_step_1 !== 'undefined') {\r\n            continue\r\n          } else if (element.final_column === dest_column) {\r\n            if (typeof best_element === 'undefined') {\r\n              best_element = element\r\n            } else if (best_element.final_row > element.final_row) {\r\n              best_element = element\r\n            }\r\n          }\r\n        }\r\n        best_element.row_after_step_1 = row_after_step_1\r\n      }\r\n    }\r\n\r\n    // 2. Sort inside all the rows\r\n    let swaps = this._sortWithinColumns(final_positions, x => x.row_after_step_1)\r\n    swap_operations = swap_operations.concat(swaps)\r\n    // 3. Sort inside all the columns\r\n    swaps = this._sortWithinRows(final_positions, x => x.final_column)\r\n    swap_operations = swap_operations.concat(swaps)\r\n    // 4. Sort inside all the rows\r\n    swaps = this._sortWithinColumns(final_positions, x => x.final_row)\r\n    swap_operations = swap_operations.concat(swaps)\r\n    return swap_operations\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/cengines/twodmapper.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 439,
    "kind": "class",
    "name": "Position",
    "memberof": "src/cengines/twodmapper.js",
    "static": true,
    "longname": "src/cengines/twodmapper.js~Position",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/cengines/twodmapper.js",
    "importStyle": "{Position}",
    "description": "",
    "lineNumber": 32,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "Position"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 440,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/cengines/twodmapper.js~Position",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/twodmapper.js~Position#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 41,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "current_row",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "current_column",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "final_row",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "final_column",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "row_after_step_1",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 441,
    "kind": "member",
    "name": "current_row",
    "memberof": "src/cengines/twodmapper.js~Position",
    "static": false,
    "longname": "src/cengines/twodmapper.js~Position#current_row",
    "access": "public",
    "description": null,
    "lineNumber": 42,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 442,
    "kind": "member",
    "name": "current_column",
    "memberof": "src/cengines/twodmapper.js~Position",
    "static": false,
    "longname": "src/cengines/twodmapper.js~Position#current_column",
    "access": "public",
    "description": null,
    "lineNumber": 43,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 443,
    "kind": "member",
    "name": "final_row",
    "memberof": "src/cengines/twodmapper.js~Position",
    "static": false,
    "longname": "src/cengines/twodmapper.js~Position#final_row",
    "access": "public",
    "description": null,
    "lineNumber": 44,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 444,
    "kind": "member",
    "name": "final_column",
    "memberof": "src/cengines/twodmapper.js~Position",
    "static": false,
    "longname": "src/cengines/twodmapper.js~Position#final_column",
    "access": "public",
    "description": null,
    "lineNumber": 45,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 445,
    "kind": "member",
    "name": "row_after_step_1",
    "memberof": "src/cengines/twodmapper.js~Position",
    "static": false,
    "longname": "src/cengines/twodmapper.js~Position#row_after_step_1",
    "access": "public",
    "description": null,
    "lineNumber": 46,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 446,
    "kind": "class",
    "name": "GridMapper",
    "memberof": "src/cengines/twodmapper.js",
    "static": true,
    "longname": "src/cengines/twodmapper.js~GridMapper",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/cengines/twodmapper.js",
    "importStyle": "GridMapper",
    "description": "Mapper to a 2-D grid graph.\n\nMapped qubits on the grid are numbered in row-major order. E.g. for\n3 rows and 2 columns:\n```js\n0 - 1\n|   |\n2 - 3\n|   |\n4 - 5\n```\nThe numbers are the mapped qubit ids. The backend might number\nthe qubits on the grid differently (e.g. not row-major), we call these\nbackend qubit ids. If the backend qubit ids are not row-major, one can\npass a dictionary translating from our row-major mapped ids to these\nbackend ids.\n\nNote: The algorithm sorts twice inside each column and once inside each\nrow.",
    "lineNumber": 86,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "GridMapper"
      }
    ],
    "properties": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "current_mapping",
        "description": "Stores the mapping: key is logical qubit id, value is backend qubit id.\nstorage(int): Number of gate it caches before mapping.\nnum_rows(int): Number of rows in the grid\nnum_columns(int): Number of columns in the grid\nnum_qubits(int): num_rows x num_columns = number of qubits\nnum_mappings (int): Number of times the mapper changed the mapping\ndepth_of_swaps (dict): Key are circuit depth of swaps, value is the\nnumber of such mappings which have been\napplied\nnum_of_swaps_per_mapping (dict): Key are the number of swaps per\nmapping, value is the number of such\nmappings which have been applied"
      }
    ],
    "interface": false,
    "extends": [
      "src/cengines/basicmapper.js~BasicMapperEngine"
    ]
  },
  {
    "__docId__": 447,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 94,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": "Initialize a GridMapper compiler engine."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "{num_rows: number, num_columns: number, mapped_ids_to_backend_ids: ?Object, storage: ?number, optimization_function: ?function, num_optimization_steps: ?number}"
        ],
        "spread": false,
        "optional": false,
        "name": "args",
        "description": ""
      }
    ],
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "if incorrect `mapped_ids_to_backend_ids` parameter"
      }
    ]
  },
  {
    "__docId__": 448,
    "kind": "member",
    "name": "num_rows",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#num_rows",
    "access": "public",
    "description": "",
    "lineNumber": 127,
    "properties": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "this.num_rows",
        "description": "Number of rows in the grid"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "this.num_columns",
        "description": "Number of columns in the grid."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "this.num_qubits",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Object<number, number>"
        ],
        "spread": false,
        "optional": false,
        "name": "this._mapped_ids_to_backend_ids",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Object<number, number>"
        ],
        "spread": false,
        "optional": false,
        "name": "this._backend_ids_to_mapped_ids",
        "description": "Stores a mapping from mapped ids which are 0,...,this.num_qubits-1 in row-major order\n     on the grid to the corresponding qubit ids of the backend. Key: mapped id. Value: corresponding backend id.\n     Default is None which means backend ids are identical to mapped ids."
      },
      {
        "nullable": null,
        "types": [
          "Object<number, number>"
        ],
        "spread": false,
        "optional": false,
        "name": "this._current_row_major_mapping",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "this.storage",
        "description": "Number of gates to temporarily store"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "this.optimization_function",
        "description": "Function which takes a list of swaps and returns a cost value. Mapper chooses a permutation\n     which minimizes this cost. Default optimizes for circuit depth."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "this.num_optimization_steps",
        "description": "Number of different permutations to of the matching to try and minimize the cost."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "this.num_mappings",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Object<number, number>"
        ],
        "spread": false,
        "optional": false,
        "name": "this.depth_of_swaps",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Object<number, number>"
        ],
        "spread": false,
        "optional": false,
        "name": "this.num_of_swaps_per_mapping",
        "description": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 449,
    "kind": "member",
    "name": "num_columns",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#num_columns",
    "access": "public",
    "description": null,
    "lineNumber": 128,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 450,
    "kind": "member",
    "name": "num_qubits",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#num_qubits",
    "access": "public",
    "description": null,
    "lineNumber": 129,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 451,
    "kind": "member",
    "name": "_mapped_ids_to_backend_ids",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#_mapped_ids_to_backend_ids",
    "access": "private",
    "description": null,
    "lineNumber": 132,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 453,
    "kind": "member",
    "name": "_backend_ids_to_mapped_ids",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#_backend_ids_to_mapped_ids",
    "access": "private",
    "description": null,
    "lineNumber": 145,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 454,
    "kind": "member",
    "name": "_current_row_major_mapping",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#_current_row_major_mapping",
    "access": "private",
    "description": null,
    "lineNumber": 154,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 455,
    "kind": "member",
    "name": "storage",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#storage",
    "access": "public",
    "description": null,
    "lineNumber": 155,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 456,
    "kind": "member",
    "name": "optimization_function",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#optimization_function",
    "access": "public",
    "description": null,
    "lineNumber": 156,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 457,
    "kind": "member",
    "name": "num_optimization_steps",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#num_optimization_steps",
    "access": "public",
    "description": null,
    "lineNumber": 157,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 458,
    "kind": "member",
    "name": "_stored_commands",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#_stored_commands",
    "access": "private",
    "description": "Storing commands",
    "lineNumber": 168,
    "properties": [
      {
        "nullable": null,
        "types": [
          "Command[]"
        ],
        "spread": false,
        "optional": false,
        "name": "this._stored_commands",
        "description": ""
      }
    ],
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 459,
    "kind": "member",
    "name": "_currently_allocated_ids",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#_currently_allocated_ids",
    "access": "private",
    "description": "Logical qubit ids for which the Allocate gate has already been\nprocessed and sent to the next engine but which are not yet deallocated:",
    "lineNumber": 173,
    "properties": [
      {
        "nullable": null,
        "types": [
          "Set<number>"
        ],
        "spread": false,
        "optional": false,
        "name": "this._currently_allocated_ids",
        "description": ""
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 460,
    "kind": "member",
    "name": "_map_2d_to_1d",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#_map_2d_to_1d",
    "access": "private",
    "description": "Change between 2D and 1D mappings (2D is a snake like 1D chain)\nNote it translates to our mapped ids in row major order and not\nbackend ids which might be different.",
    "lineNumber": 181,
    "properties": [
      {
        "nullable": null,
        "types": [
          "Object<number, number>"
        ],
        "spread": false,
        "optional": false,
        "name": "this._map_2d_to_1d",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Object<number, number>"
        ],
        "spread": false,
        "optional": false,
        "name": "this._map_1d_to_2d",
        "description": ""
      }
    ],
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 461,
    "kind": "member",
    "name": "_map_1d_to_2d",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#_map_1d_to_2d",
    "access": "private",
    "description": null,
    "lineNumber": 182,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 462,
    "kind": "member",
    "name": "num_mappings",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#num_mappings",
    "access": "public",
    "description": "Statistics",
    "lineNumber": 201,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 463,
    "kind": "member",
    "name": "depth_of_swaps",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#depth_of_swaps",
    "access": "public",
    "description": null,
    "lineNumber": 202,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 464,
    "kind": "member",
    "name": "num_of_swaps_per_mapping",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#num_of_swaps_per_mapping",
    "access": "public",
    "description": null,
    "lineNumber": 203,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 465,
    "kind": "get",
    "name": "currentMapping",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#currentMapping",
    "access": "public",
    "description": null,
    "lineNumber": 206,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 466,
    "kind": "set",
    "name": "currentMapping",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#currentMapping",
    "access": "public",
    "description": null,
    "lineNumber": 210,
    "undocument": true
  },
  {
    "__docId__": 467,
    "kind": "member",
    "name": "_currentMapping",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#_currentMapping",
    "access": "private",
    "description": null,
    "lineNumber": 211,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 470,
    "kind": "method",
    "name": "isAvailable",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#isAvailable",
    "access": "public",
    "description": null,
    "lineNumber": 226,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 471,
    "kind": "method",
    "name": "returnNewMapping",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#returnNewMapping",
    "access": "public",
    "description": "Returns a new mapping of the qubits.\n\nIt goes through this._saved_commands and tries to find a\nmapping to apply these gates on a first come first served basis.\nIt reuses the function of a 1D mapper and creates a mapping for a\n1D linear chain and then wraps it like a snake onto the square grid.\n\nOne might create better mappings by specializing this function for a\nsquare grid.",
    "lineNumber": 245,
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "A new mapping as a dict. key is logical qubit id, value is mapped id"
    },
    "params": []
  },
  {
    "__docId__": 472,
    "kind": "method",
    "name": "_compareAndSwap",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#_compareAndSwap",
    "access": "private",
    "description": "If swapped (inplace), then return swap operation so that `key(element0) < key(element1)`",
    "lineNumber": 282,
    "params": [
      {
        "nullable": null,
        "types": [
          "Position"
        ],
        "spread": false,
        "optional": false,
        "name": "element0",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Position"
        ],
        "spread": false,
        "optional": false,
        "name": "element1",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "function(arg: Position): number"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<number>",
        "undefined"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 473,
    "kind": "method",
    "name": "_sortWithinRows",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#_sortWithinRows",
    "access": "private",
    "description": "",
    "lineNumber": 308,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array<Position[]>"
        ],
        "spread": false,
        "optional": false,
        "name": "final_positions",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "function(arg: Position): number"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<number[]>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 474,
    "kind": "method",
    "name": "_sortWithinColumns",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#_sortWithinColumns",
    "access": "private",
    "description": "",
    "lineNumber": 344,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array<Position[]>"
        ],
        "spread": false,
        "optional": false,
        "name": "final_positions",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "function(arg: Position): number"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<number[]>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 475,
    "kind": "method",
    "name": "_run",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#_run",
    "access": "private",
    "description": "Creates a new mapping and executes possible gates.\n\nIt first allocates all 0, ..., this.num_qubits-1 mapped qubit ids, if\nthey are not already used because we might need them all for the\nswaps. Then it creates a new map, swaps all the qubits to the new map,\nexecutes all possible gates, and finally deallocates mapped qubit ids\nwhich don't store any information.",
    "lineNumber": 383,
    "params": [],
    "return": null
  },
  {
    "__docId__": 480,
    "kind": "method",
    "name": "_sendPossibleCommands",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#_sendPossibleCommands",
    "access": "private",
    "description": "Sends the stored commands possible without changing the mapping.\nNote: this._current_row_major_mapping (hence also this.currentMapping) must exist already",
    "lineNumber": 497,
    "params": [],
    "return": null
  },
  {
    "__docId__": 482,
    "kind": "method",
    "name": "receive",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#receive",
    "access": "public",
    "description": "Receives a command list and, for each command, stores it until\nwe do a mapping (FlushGate || Cache of stored commands is full).",
    "lineNumber": 581,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command[]"
        ],
        "spread": false,
        "optional": false,
        "name": "command_list",
        "description": "list of commands to receive."
      }
    ],
    "return": null
  },
  {
    "__docId__": 483,
    "kind": "method",
    "name": "returnSwaps",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#returnSwaps",
    "access": "public",
    "description": "Returns the swap operation to change mapping",
    "lineNumber": 608,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "old_mapping",
        "description": "dict keys are logical ids and values are mapped qubit ids"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "new_mapping",
        "description": "dict keys are logical ids and values are mapped qubit ids"
      },
      {
        "nullable": null,
        "types": [
          "Array.<number[]>"
        ],
        "spread": false,
        "optional": false,
        "name": "permutation",
        "description": "list of int from 0, 1, ..., this.num_rows-1. It is\nused to permute the found perfect matchings. Default is None which keeps the original order."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array.<number[]>"
      ],
      "spread": false,
      "description": "List of tuples. Each tuple is a swap operation which needs to be\napplied. Tuple contains the two mapped qubit ids for the Swap."
    }
  },
  {
    "__docId__": 484,
    "kind": "file",
    "name": "src/libs/math/constantmath.js",
    "content": "\r\n/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport assert from 'assert'\r\nimport math from 'mathjs'\r\nimport {Compute, CustomUncompute, Uncompute} from '../../meta/compute'\r\nimport {QFT} from '../../ops/qftgate'\r\nimport {R, Swap, X} from '../../ops/gates'\r\nimport {\r\n  AddConstant, AddConstantModN, SubConstant, SubConstantModN\r\n} from './gates';\r\nimport {tuple} from '../util';\r\nimport {CNOT} from '../../ops/shortcuts';\r\nimport {Control} from '../../meta/control';\r\nimport {len} from '../polyfill';\r\n\r\n/**\r\n * @ignore\r\n * Adds a classical constant c to the quantum integer (qureg) quint using Draper addition.\r\n * Note: Uses the Fourier-transform adder\r\n * see https://arxiv.org/abs/quant-ph/0008033\r\n * @param {BasicEngine} eng\r\n * @param {number} c\r\n * @param {Array<Qubit>|Qureg} quint\r\n */\r\nexport function add_constant(eng, c, quint) {\r\n  Compute(eng, () => QFT.or(quint))\r\n\r\n  for (let i = 0; i < quint.length; ++i) {\r\n    for (let j = i; j > -1; j -= 1) {\r\n      if ((c >> j) & 1) {\r\n        new R(math.pi / (1 << (i - j))).or(quint[i])\r\n      }\r\n    }\r\n  }\r\n\r\n  Uncompute(eng)\r\n}\r\n\r\n/**\r\n * @ignore\r\n * Modular adder by Beauregard\r\n * see https://arxiv.org/abs/quant-ph/0205095\r\nAdds a classical constant c to a quantum integer (qureg) quint modulo N\r\nusing Draper addition and the construction\r\n * @param {BasicEngine} eng\r\n * @param {number} c\r\n * @param {number} N\r\n * @param {Array<Qubit>|Qureg} quint\r\n */\r\nexport function add_constant_modN(eng, c, N, quint) {\r\n  assert(c < N && c >= 0)\r\n\r\n  new AddConstant(c).or(quint)\r\n\r\n  let ancilla\r\n\r\n  Compute(eng, () => {\r\n    SubConstant(N).or(quint)\r\n    ancilla = eng.allocateQubit()\r\n    CNOT.or(tuple(quint[quint.length - 1], ancilla))\r\n    Control(eng, ancilla, () => new AddConstant(N).or(quint))\r\n  })\r\n\r\n  SubConstant(c).or(quint)\r\n\r\n  CustomUncompute(eng, () => {\r\n    X.or(quint[quint.length - 1])\r\n    CNOT.or(tuple(quint[quint.length - 1], ancilla))\r\n    X.or(quint[quint.length - 1])\r\n    ancilla.deallocate()\r\n  })\r\n\r\n  new AddConstant(c).or(quint)\r\n}\r\n\r\n\r\n// calculates the inverse of a modulo N\r\nfunction inv_mod_N(a, N) {\r\n  let s = 0\r\n  let old_s = 1\r\n  let r = N\r\n  let old_r = a\r\n  while (r !== 0) {\r\n    const q = Math.floor(old_r / r)\r\n    let tmp = r\r\n    r = old_r - q * r\r\n    old_r = tmp\r\n    tmp = s\r\n    s = old_s - q * s\r\n    old_s = tmp\r\n  }\r\n  return (old_s + N) % N\r\n}\r\n\r\n/**\r\n * @ignore\r\n * Modular multiplication by modular addition & shift, followed by uncompute\r\n https://arxiv.org/abs/quant-ph/0205095\r\nMultiplies a quantum integer by a classical number a modulo N, i.e.,\r\n ```\r\n  |x> -> |a*x mod N>\r\n ```\r\n(only works if a and N are relative primes, otherwise the modular inverse does not exist).\r\n */\r\nexport function mul_by_constant_modN(eng, c, N, quint_in) {\r\n  assert(c < N && c >= 0)\r\n  assert(math.gcd(c, N) === 1)\r\n\r\n  const n = len(quint_in)\r\n  const quint_out = eng.allocateQureg(n + 1)\r\n\r\n  for (let i = 0; i < n; ++i) {\r\n    Control(eng, quint_in[i], () => new AddConstantModN((c << i) % N, N).or(quint_out))\r\n  }\r\n\r\n  for (let i = 0; i < n; ++i) {\r\n    Swap.or(tuple(quint_out[i], quint_in[i]))\r\n  }\r\n\r\n  const cinv = inv_mod_N(c, N)\r\n\r\n  for (let i = 0; i < n; ++i) {\r\n    Control(eng, quint_in[i], () => SubConstantModN((cinv << i) % N, N).or(quint_out))\r\n  }\r\n\r\n  quint_out.deallocate()\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/libs/math/constantmath.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 485,
    "kind": "function",
    "name": "add_constant",
    "memberof": "src/libs/math/constantmath.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/math/constantmath.js~add_constant",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/math/constantmath.js",
    "importStyle": "{add_constant}",
    "description": "",
    "lineNumber": 40,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "BasicEngine"
        ],
        "spread": false,
        "optional": false,
        "name": "eng",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "c",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Array<Qubit>",
          "Qureg"
        ],
        "spread": false,
        "optional": false,
        "name": "quint",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 486,
    "kind": "function",
    "name": "add_constant_modN",
    "memberof": "src/libs/math/constantmath.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/math/constantmath.js~add_constant_modN",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/math/constantmath.js",
    "importStyle": "{add_constant_modN}",
    "description": "",
    "lineNumber": 65,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "BasicEngine"
        ],
        "spread": false,
        "optional": false,
        "name": "eng",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "c",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "N",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Array<Qubit>",
          "Qureg"
        ],
        "spread": false,
        "optional": false,
        "name": "quint",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 487,
    "kind": "function",
    "name": "inv_mod_N",
    "memberof": "src/libs/math/constantmath.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/math/constantmath.js~inv_mod_N",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/libs/math/constantmath.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 93,
    "undocument": true,
    "params": [
      {
        "name": "a",
        "types": [
          "*"
        ]
      },
      {
        "name": "N",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 488,
    "kind": "function",
    "name": "mul_by_constant_modN",
    "memberof": "src/libs/math/constantmath.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/math/constantmath.js~mul_by_constant_modN",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/math/constantmath.js",
    "importStyle": "{mul_by_constant_modN}",
    "description": "",
    "lineNumber": 120,
    "ignore": true,
    "params": [
      {
        "name": "eng",
        "types": [
          "*"
        ]
      },
      {
        "name": "c",
        "types": [
          "*"
        ]
      },
      {
        "name": "N",
        "types": [
          "*"
        ]
      },
      {
        "name": "quint_in",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 489,
    "kind": "file",
    "name": "src/libs/math/defaultrules.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport {add_constant, add_constant_modN, mul_by_constant_modN} from './constantmath';\r\nimport {Control} from '../../meta/control';\r\nimport DecompositionRule from '../../cengines/replacer/decompositionrule';\r\nimport {AddConstant, AddConstantModN, MultiplyByConstantModN} from './gates';\r\n\r\nfunction _replace_addconstant(cmd) {\r\n  const eng = cmd.engine\r\n  const c = cmd.gate.a\r\n  const quint = cmd.qubits[0]\r\n\r\n  Control(eng, cmd.controlQubits, () => add_constant(eng, c, quint))\r\n}\r\n\r\n\r\nfunction _replace_addconstmodN(cmd) {\r\n  const eng = cmd.engine\r\n  const c = cmd.gate.a\r\n  const N = cmd.gate.N\r\n  const quint = cmd.qubits[0]\r\n\r\n  Control(eng, cmd.controlQubits, () => add_constant_modN(eng, c, N, quint))\r\n}\r\n\r\n\r\nfunction _replace_multiplybyconstantmodN(cmd) {\r\n  const eng = cmd.engine\r\n  const c = cmd.gate.a\r\n  const N = cmd.gate.N\r\n  const quint = cmd.qubits[0]\r\n\r\n  Control(eng, cmd.controlQubits, () => mul_by_constant_modN(eng, c, N, quint))\r\n}\r\n\r\nexport default [\r\n  new DecompositionRule(AddConstant, _replace_addconstant),\r\n  new DecompositionRule(AddConstantModN, _replace_addconstmodN),\r\n  new DecompositionRule(MultiplyByConstantModN, _replace_multiplybyconstantmodN),\r\n]\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/libs/math/defaultrules.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 490,
    "kind": "function",
    "name": "_replace_addconstant",
    "memberof": "src/libs/math/defaultrules.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/math/defaultrules.js~_replace_addconstant",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/libs/math/defaultrules.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 491,
    "kind": "function",
    "name": "_replace_addconstmodN",
    "memberof": "src/libs/math/defaultrules.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/math/defaultrules.js~_replace_addconstmodN",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/libs/math/defaultrules.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 492,
    "kind": "function",
    "name": "_replace_multiplybyconstantmodN",
    "memberof": "src/libs/math/defaultrules.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/math/defaultrules.js~_replace_multiplybyconstantmodN",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/libs/math/defaultrules.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 41,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 493,
    "kind": "file",
    "name": "src/libs/math/gates.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nimport math from 'mathjs'\r\nimport {BasicMathGate} from '../../ops/basics'\r\n\r\n/**\r\n * @class AddConstant\r\n * @desc\r\nAdd a constant to a quantum number represented by a quantum register,\r\n    stored from low- to high-bit.\r\n\r\n    @example\r\n\r\nqunum = eng.allocateQureg(5) # 5-qubit number\r\nX | qunum[1] # qunum is now equal to 2\r\nAddConstant(3) | qunum # qunum is now equal to 5\r\n */\r\nexport class AddConstant extends BasicMathGate {\r\n  /**\r\n  Initializes the gate to the number to add.\r\n\r\n    @param {number} a Number to add to a quantum register.\r\n\r\n    It also initializes its base class, BasicMathGate, with the\r\n  corresponding function, so it can be emulated efficiently.\r\n   */\r\n  constructor(a) {\r\n    super(x => [x + a])\r\n    this.a = a\r\n  }\r\n\r\n  getInverse() {\r\n    return SubConstant(this.a)\r\n  }\r\n\r\n  toString() {\r\n    return `AddConstant(${this.a})`\r\n  }\r\n\r\n  equal(other) {\r\n    return other instanceof AddConstant && other.a === this.a\r\n  }\r\n}\r\n\r\n/**\r\nSubtract a constant from a quantum number represented by a quantum\r\nregister, stored from low- to high-bit.\r\n\r\n    @param {number} a Constant to subtract\r\n\r\n    @example\r\n\r\nqunum = eng.allocateQureg(5) # 5-qubit number\r\nX | qunum[2] # qunum is now equal to 4\r\nSubConstant(3) | qunum # qunum is now equal to 1\r\n */\r\nexport function SubConstant(a) {\r\n  return new AddConstant(-a)\r\n}\r\n\r\n/**\r\n * @class AddConstantModN\r\n * @desc\r\nAdd a constant to a quantum number represented by a quantum register\r\nmodulo N.\r\n\r\n    The number is stored from low- to high-bit, i.e., qunum[0] is the LSB.\r\n\r\n    @example\r\n\r\nqunum = eng.allocateQureg(5) # 5-qubit number\r\nX | qunum[1] # qunum is now equal to 2\r\nAddConstantModN(3, 4) | qunum # qunum is now equal to 1\r\n */\r\nexport class AddConstantModN extends BasicMathGate {\r\n  /**\r\n   * @constructor\r\n  Initializes the gate to the number to add modulo N.\r\n\r\n    @param {number} a Number to add to a quantum register (0 <= a < N).\r\n    @param {number} N Number modulo which the addition is carried out.\r\n\r\n    It also initializes its base class, BasicMathGate, with the\r\n  corresponding function, so it can be emulated efficiently.\r\n   */\r\n  constructor(a, N) {\r\n    super(x => [math.mod(x + a, N)])\r\n    this.a = a\r\n    this.N = N\r\n  }\r\n\r\n  toString() {\r\n    return `AddConstantModN(${this.a}, ${this.N})`\r\n  }\r\n\r\n  getInverse() {\r\n    return SubConstantModN(this.a, this.N)\r\n  }\r\n\r\n  equal(other) {\r\n    return other instanceof AddConstantModN && other.a === this.a && other.N === this.N\r\n  }\r\n}\r\n\r\n/**\r\nSubtract a constant from a quantum number represented by a quantum\r\nregister modulo N.\r\n\r\n    The number is stored from low- to high-bit, i.e., qunum[0] is the LSB.\r\n\r\n @param {number} a Constant to add\r\n @param {number} N Constant modulo which the addition of a should be carried out.\r\n\r\n    @example\r\n\r\nqunum = eng.allocateQureg(3) # 3-qubit number\r\nX | qunum[1] # qunum is now equal to 2\r\nSubConstantModN(4,5) | qunum # qunum is now -2 = 6 = 1 (mod 5)\r\n */\r\nexport function SubConstantModN(a, N) {\r\n  return new AddConstantModN(N - a, N)\r\n}\r\n\r\n/**\r\n * @class MultiplyByConstantModN\r\n * @desc\r\nMultiply a quantum number represented by a quantum register by a constant\r\nmodulo N.\r\n\r\n    The number is stored from low- to high-bit, i.e., qunum[0] is the LSB.\r\n\r\n    @example\r\nqunum = eng.allocateQureg(5) # 5-qubit number\r\nX | qunum[2] # qunum is now equal to 4\r\nMultiplyByConstantModN(3,5) | qunum # qunum is now 2.\r\n */\r\nexport class MultiplyByConstantModN extends BasicMathGate {\r\n  /**\r\n   * @constructor\r\n  Initializes the gate to the number to multiply with modulo N.\r\n\r\n   @param {number} a Number by which to multiply a quantum register (0 <= a < N).\r\n   @param {number} N Number modulo which the multiplication is carried out.\r\n\r\n    It also initializes its base class, BasicMathGate, with the\r\n  corresponding function, so it can be emulated efficiently.\r\n   */\r\n  constructor(a, N) {\r\n    super(x => [(a * x) % N])\r\n    this.a = a\r\n    this.N = N\r\n  }\r\n\r\n  toString() {\r\n    return `MultiplyByConstantModN(${this.a}, ${this.N})`\r\n  }\r\n\r\n  equal(other) {\r\n    return other instanceof MultiplyByConstantModN && other.a === this.a && other.N === this.N\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/libs/math/gates.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 494,
    "kind": "class",
    "name": "AddConstant",
    "memberof": "src/libs/math/gates.js",
    "static": true,
    "longname": "src/libs/math/gates.js~AddConstant",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/math/gates.js",
    "importStyle": "{AddConstant}",
    "description": "Add a constant to a quantum number represented by a quantum register,\nstored from low- to high-bit.",
    "examples": [
      "\nqunum = eng.allocateQureg(5) # 5-qubit number\nX | qunum[1] # qunum is now equal to 2\nAddConstant(3) | qunum # qunum is now equal to 5"
    ],
    "lineNumber": 31,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "AddConstant"
      }
    ],
    "interface": false,
    "extends": [
      "src/ops/basics.js~BasicMathGate"
    ]
  },
  {
    "__docId__": 495,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/libs/math/gates.js~AddConstant",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/libs/math/gates.js~AddConstant#constructor",
    "access": "public",
    "description": "Initializes the gate to the number to add.",
    "lineNumber": 40,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "a",
        "description": "Number to add to a quantum register.\n\nIt also initializes its base class, BasicMathGate, with the\ncorresponding function, so it can be emulated efficiently."
      }
    ]
  },
  {
    "__docId__": 496,
    "kind": "member",
    "name": "a",
    "memberof": "src/libs/math/gates.js~AddConstant",
    "static": false,
    "longname": "src/libs/math/gates.js~AddConstant#a",
    "access": "public",
    "description": null,
    "lineNumber": 42,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 497,
    "kind": "method",
    "name": "getInverse",
    "memberof": "src/libs/math/gates.js~AddConstant",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/libs/math/gates.js~AddConstant#getInverse",
    "access": "public",
    "description": null,
    "lineNumber": 45,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 498,
    "kind": "method",
    "name": "toString",
    "memberof": "src/libs/math/gates.js~AddConstant",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/libs/math/gates.js~AddConstant#toString",
    "access": "public",
    "description": null,
    "lineNumber": 49,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 499,
    "kind": "method",
    "name": "equal",
    "memberof": "src/libs/math/gates.js~AddConstant",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/libs/math/gates.js~AddConstant#equal",
    "access": "public",
    "description": null,
    "lineNumber": 53,
    "undocument": true,
    "params": [
      {
        "name": "other",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 500,
    "kind": "function",
    "name": "SubConstant",
    "memberof": "src/libs/math/gates.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/math/gates.js~SubConstant",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/math/gates.js",
    "importStyle": "{SubConstant}",
    "description": "Subtract a constant from a quantum number represented by a quantum\nregister, stored from low- to high-bit.",
    "examples": [
      "\nqunum = eng.allocateQureg(5) # 5-qubit number\nX | qunum[2] # qunum is now equal to 4\nSubConstant(3) | qunum # qunum is now equal to 1"
    ],
    "lineNumber": 70,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "a",
        "description": "Constant to subtract"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 501,
    "kind": "class",
    "name": "AddConstantModN",
    "memberof": "src/libs/math/gates.js",
    "static": true,
    "longname": "src/libs/math/gates.js~AddConstantModN",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/math/gates.js",
    "importStyle": "{AddConstantModN}",
    "description": "Add a constant to a quantum number represented by a quantum register\nmodulo N.\n\nThe number is stored from low- to high-bit, i.e., qunum[0] is the LSB.",
    "examples": [
      "\nqunum = eng.allocateQureg(5) # 5-qubit number\nX | qunum[1] # qunum is now equal to 2\nAddConstantModN(3, 4) | qunum # qunum is now equal to 1"
    ],
    "lineNumber": 88,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "AddConstantModN"
      }
    ],
    "interface": false,
    "extends": [
      "src/ops/basics.js~BasicMathGate"
    ]
  },
  {
    "__docId__": 502,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/libs/math/gates.js~AddConstantModN",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/libs/math/gates.js~AddConstantModN#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 99,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": "Initializes the gate to the number to add modulo N."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "a",
        "description": "Number to add to a quantum register (0 <= a < N)."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "N",
        "description": "Number modulo which the addition is carried out.\n\nIt also initializes its base class, BasicMathGate, with the\ncorresponding function, so it can be emulated efficiently."
      }
    ]
  },
  {
    "__docId__": 503,
    "kind": "member",
    "name": "a",
    "memberof": "src/libs/math/gates.js~AddConstantModN",
    "static": false,
    "longname": "src/libs/math/gates.js~AddConstantModN#a",
    "access": "public",
    "description": null,
    "lineNumber": 101,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 504,
    "kind": "member",
    "name": "N",
    "memberof": "src/libs/math/gates.js~AddConstantModN",
    "static": false,
    "longname": "src/libs/math/gates.js~AddConstantModN#N",
    "access": "public",
    "description": null,
    "lineNumber": 102,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 505,
    "kind": "method",
    "name": "toString",
    "memberof": "src/libs/math/gates.js~AddConstantModN",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/libs/math/gates.js~AddConstantModN#toString",
    "access": "public",
    "description": null,
    "lineNumber": 105,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 506,
    "kind": "method",
    "name": "getInverse",
    "memberof": "src/libs/math/gates.js~AddConstantModN",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/libs/math/gates.js~AddConstantModN#getInverse",
    "access": "public",
    "description": null,
    "lineNumber": 109,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 507,
    "kind": "method",
    "name": "equal",
    "memberof": "src/libs/math/gates.js~AddConstantModN",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/libs/math/gates.js~AddConstantModN#equal",
    "access": "public",
    "description": null,
    "lineNumber": 113,
    "undocument": true,
    "params": [
      {
        "name": "other",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 508,
    "kind": "function",
    "name": "SubConstantModN",
    "memberof": "src/libs/math/gates.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/math/gates.js~SubConstantModN",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/math/gates.js",
    "importStyle": "{SubConstantModN}",
    "description": "Subtract a constant from a quantum number represented by a quantum\nregister modulo N.\n\nThe number is stored from low- to high-bit, i.e., qunum[0] is the LSB.",
    "examples": [
      "\nqunum = eng.allocateQureg(3) # 3-qubit number\nX | qunum[1] # qunum is now equal to 2\nSubConstantModN(4,5) | qunum # qunum is now -2 = 6 = 1 (mod 5)"
    ],
    "lineNumber": 133,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "a",
        "description": "Constant to add"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "N",
        "description": "Constant modulo which the addition of a should be carried out."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 509,
    "kind": "class",
    "name": "MultiplyByConstantModN",
    "memberof": "src/libs/math/gates.js",
    "static": true,
    "longname": "src/libs/math/gates.js~MultiplyByConstantModN",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/math/gates.js",
    "importStyle": "{MultiplyByConstantModN}",
    "description": "Multiply a quantum number represented by a quantum register by a constant\nmodulo N.\n\nThe number is stored from low- to high-bit, i.e., qunum[0] is the LSB.",
    "examples": [
      "qunum = eng.allocateQureg(5) # 5-qubit number\nX | qunum[2] # qunum is now equal to 4\nMultiplyByConstantModN(3,5) | qunum # qunum is now 2."
    ],
    "lineNumber": 150,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "MultiplyByConstantModN"
      }
    ],
    "interface": false,
    "extends": [
      "src/ops/basics.js~BasicMathGate"
    ]
  },
  {
    "__docId__": 510,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/libs/math/gates.js~MultiplyByConstantModN",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/libs/math/gates.js~MultiplyByConstantModN#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 161,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": "Initializes the gate to the number to multiply with modulo N."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "a",
        "description": "Number by which to multiply a quantum register (0 <= a < N)."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "N",
        "description": "Number modulo which the multiplication is carried out.\n\nIt also initializes its base class, BasicMathGate, with the\ncorresponding function, so it can be emulated efficiently."
      }
    ]
  },
  {
    "__docId__": 511,
    "kind": "member",
    "name": "a",
    "memberof": "src/libs/math/gates.js~MultiplyByConstantModN",
    "static": false,
    "longname": "src/libs/math/gates.js~MultiplyByConstantModN#a",
    "access": "public",
    "description": null,
    "lineNumber": 163,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 512,
    "kind": "member",
    "name": "N",
    "memberof": "src/libs/math/gates.js~MultiplyByConstantModN",
    "static": false,
    "longname": "src/libs/math/gates.js~MultiplyByConstantModN#N",
    "access": "public",
    "description": null,
    "lineNumber": 164,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 513,
    "kind": "method",
    "name": "toString",
    "memberof": "src/libs/math/gates.js~MultiplyByConstantModN",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/libs/math/gates.js~MultiplyByConstantModN#toString",
    "access": "public",
    "description": null,
    "lineNumber": 167,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 514,
    "kind": "method",
    "name": "equal",
    "memberof": "src/libs/math/gates.js~MultiplyByConstantModN",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/libs/math/gates.js~MultiplyByConstantModN#equal",
    "access": "public",
    "description": null,
    "lineNumber": 171,
    "undocument": true,
    "params": [
      {
        "name": "other",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 515,
    "kind": "file",
    "name": "src/libs/polyfill.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport math from 'mathjs'\r\nimport {instanceOf} from './util';\r\n\r\nconst Complex = math.complex().constructor\r\nconst Matrix = math.matrix().constructor\r\n\r\n/**\r\n * @ignore\r\n * check if value is complex number\r\n * @param {Object} value\r\n * @return {boolean}\r\n */\r\nexport function isComplex(value) {\r\n  return value instanceof Complex\r\n}\r\n\r\n/**\r\n * @ignore\r\n * check if value is number or complex number\r\n * @param {Object} value\r\n * @return {boolean}\r\n */\r\nexport function isNumeric(value) {\r\n  return (typeof value === 'number' || value instanceof Complex)\r\n}\r\n\r\n/**\r\n * @ignore\r\n * return intersection of s1 & s2\r\n * @param {Set} s1\r\n * @param {Set} s2\r\n * @return {Set}\r\n */\r\nexport function intersection(s1, s2) {\r\n  return new Set([...s1].filter(x => s2.has(x)))\r\n}\r\n\r\n/**\r\n * @ignore\r\n * return union set of s1 & s2\r\n * @param {Set} s1\r\n * @param {Set} s2\r\n * @return {Set<any>}\r\n */\r\nexport function unionSet(s1, s2) {\r\n  const s = [...s2].filter(x => !s1.has(x))\r\n  const result = new Set(s1)\r\n  s.forEach(x => result.add(x))\r\n  return result\r\n}\r\n\r\n/**\r\n * @ignore\r\n * return symmetric difference of s1 & s2\r\n * @param {Set} s1\r\n * @param {Set} s2\r\n * @return {Set<*>}\r\n */\r\nexport function symmetricDifference(s1, s2) {\r\n  const inset = intersection(s1, s2)\r\n  const a = [...s1].filter(x => !inset.has(x))\r\n  const b = [...s2].filter(x => !inset.has(x))\r\n  return new Set([...a, ...b])\r\n}\r\n\r\n/**\r\n * @ignore\r\n * check if s1 is equal to s2\r\n * @param {Set} s1\r\n * @param {Set} s2\r\n * @return {boolean}\r\n */\r\nexport function setEqual(s1, s2) {\r\n  return symmetricDifference(s1, s2).size === 0\r\n}\r\n\r\n/**\r\n * @ignore\r\n * check if `superset` is the super set of `s`\r\n * @param {Set} superset\r\n * @param {Set} s\r\n * @return {boolean}\r\n */\r\nexport function setIsSuperSet(superset, s) {\r\n  const result = [...s].filter(x => !superset.has(x))\r\n  return result.length === 0\r\n}\r\n\r\n/**\r\n * @ignore\r\n * @param {Set<*>} s1\r\n * @param {Set<*>} s2\r\n * @return {Set<*>}\r\n */\r\nexport function setDifference(s1, s2) {\r\n  return new Set([...s1].filter(x => !s2.has(x)))\r\n}\r\n\r\n/**\r\n * @ignore\r\n * create a Set contains numbers in range from 0 to n\r\n * @param {number} n\r\n * @return {Set<number>}\r\n */\r\nexport function setFromRange(n) {\r\n  const result = new Set()\r\n  for (let i = 0; i < n; i++) {\r\n    result.add(i)\r\n  }\r\n  return result\r\n}\r\n\r\n/**\r\n * @ignore\r\n * create an array filled by number in range, active like python does\r\n * @param {number} start\r\n * @param {number} end\r\n * @param {number} step\r\n * @return {number[]}\r\n */\r\nexport function arrayFromRange(start, end, step) {\r\n  if (typeof end === 'undefined') {\r\n    end = start\r\n    start = 0\r\n  }\r\n  if (typeof step === 'undefined') {\r\n    step = 1\r\n  }\r\n  const n = end - start\r\n  const result = new Array(n)\r\n  for (let i = 0; i < n; i += step) {\r\n    result[i] = i + start\r\n  }\r\n  return result\r\n}\r\n\r\n/**\r\n * @ignore\r\n * return a random sample from `array` which length is `count`\r\n * @param {any[]} array\r\n * @param {number} count\r\n * @return {any[]}\r\n */\r\nexport function randomSample(array, count) {\r\n  const result = []\r\n  const {length} = array\r\n  if (length >= count) {\r\n    const copy = array.slice(0)\r\n    while (result.length < count) {\r\n      const idx = Math.floor(Math.random() * copy.length)\r\n      result.push(copy[idx])\r\n      copy.splice(idx, 1)\r\n    }\r\n  }\r\n  return result\r\n}\r\n\r\n/**\r\n * @ignore\r\n * test if two array(a1, a2) are equal, support instance of classes in this library\r\n * @param {Array} a1\r\n * @param {Array} a2\r\n * @param {function} itemCompareFunc\r\n * @return {boolean}\r\n */\r\nexport function arrayEqual(a1, a2, itemCompareFunc) {\r\n  if (a1 === a2) {\r\n    return true\r\n  }\r\n\r\n  if (Array.isArray(a1) && Array.isArray(a2)) {\r\n    const l1 = a1.length\r\n    const l2 = a2.length\r\n    if (l1 === l2) {\r\n      for (let i = 0; i < l1; ++i) {\r\n        const c = a1[i]\r\n        const d = a2[i]\r\n        let func = itemCompareFunc\r\n        if (!func && c.__proto__.equal) {\r\n          func = (x, y) => Reflect.apply(c.__proto__.equal, x, [y])\r\n        }\r\n        if (Array.isArray(c) && Array.isArray(d)) {\r\n          func = arrayEqual\r\n        }\r\n        if (!func) {\r\n          func = (x, y) => x === y\r\n        }\r\n        const f = func(c, d)\r\n        if (!f) {\r\n          return false\r\n        }\r\n      }\r\n      return true\r\n    }\r\n  }\r\n  return false\r\n}\r\n\r\n/**\r\n * @ignore\r\n * @function\r\n * reverse version of `forEach`\r\n * @param {function} callbackFunc\r\n */\r\nArray.prototype.rforEach = function (callbackFunc) {\r\n  if (typeof callbackFunc === 'function') {\r\n    const count = this.length\r\n    for (let i = count - 1; i >= 0; --i) {\r\n      callbackFunc(this[i])\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @ignore\r\n * @function\r\n * reverse version of `map`\r\n * @param {function} callbackFunc\r\n * @return {any[]}\r\n */\r\nArray.prototype.rmap = function (callbackFunc) {\r\n  const result = []\r\n  if (typeof callbackFunc === 'function') {\r\n    const count = this.length\r\n    for (let i = count - 1; i >= 0; --i) {\r\n      result.push(callbackFunc(this[i]))\r\n    }\r\n  }\r\n  return result\r\n}\r\n\r\n/**\r\n * @ignore\r\n * @function\r\n * return total exist count of `item` in array\r\n * @param {any} item\r\n */\r\nArray.prototype.count = function (item) {\r\n  let count = 0\r\n  for (let i = 0; i < this.length; ++i) {\r\n    if (this[i] === item) {\r\n      ++count\r\n    }\r\n  }\r\n  return count\r\n}\r\n\r\n/**\r\n * @ignore\r\n * remove all existance of `target` from array\r\n * @param {any} target\r\n */\r\nArray.prototype.remove = function (target) {\r\n  let idx = -1\r\n  for (let i = 0; i < this.length; ++i) {\r\n    if (arrayEqual(this[i], target)) {\r\n      idx = i\r\n      break\r\n    }\r\n  }\r\n  if (idx !== -1) {\r\n    this.splice(idx, 1)\r\n  }\r\n}\r\n\r\n/**\r\n * @ignore\r\n * return all regular expression match count of `substring` in string\r\n * @param {string} substring\r\n * @return {number}\r\n */\r\nString.prototype.count = function (substring) {\r\n  const exp = new RegExp(substring, 'g')\r\n  const result = this.match(exp)\r\n  if (result) return result.length\r\n  return 0\r\n}\r\n\r\n/**\r\n * return `length` of v, act like python\r\n * @param {any} v\r\n * @return {number}\r\n */\r\nexport function len(v) {\r\n  if (typeof v === 'undefined' || v === null) {\r\n    return 0\r\n  }\r\n  if (Array.isArray(v)) {\r\n    return v.length\r\n  }\r\n  if (v instanceof Set) {\r\n    return v.size\r\n  }\r\n  if (v instanceof Matrix) {\r\n    return v.size()[0]\r\n  }\r\n  if (instanceOf(v, String)) {\r\n    return v.length\r\n  }\r\n  if (typeof v.length !== 'undefined') {\r\n    if (typeof v.length === 'function') {\r\n      return v.length()\r\n    } else {\r\n      return v.length\r\n    }\r\n  }\r\n  if (typeof v === 'object') {\r\n    return Object.keys(v).length\r\n  }\r\n  return 0\r\n}\r\n\r\n/**\r\n * @ignore\r\n * parse string contains 1/0 into bit array\r\n * @param {string} str\r\n * @return {boolean[]}\r\n */\r\nexport function stringToBitArray(str) {\r\n  if (Array.isArray(str)) {\r\n    return str\r\n  }\r\n  const result = []\r\n  if (instanceOf(str, String)) {\r\n    for (let i = 0; i < str.length; ++i) {\r\n      result.push(str.charAt(i) !== '0')\r\n    }\r\n  }\r\n  return result\r\n}\r\n\r\n/**\r\n * @ignore\r\n * return dot product of two complex vector(a1, a2)\r\n * @param {Complex[]} a1\r\n * @param {Complex[]} a2\r\n * @return {Complex}\r\n */\r\nexport function complexVectorDot(a1, a2) {\r\n  let real = 0\r\n  let image = 0\r\n  a1.forEach((c1, [i]) => {\r\n    const c2 = a2.subset(math.index(i))\r\n    const r1 = math.re(c1)\r\n    const i1 = math.im(c1)\r\n    const r2 = math.re(c2)\r\n    const i2 = math.im(c2)\r\n    real += r1 * r2 - (-i1 * i2)\r\n    image += r1 * i2 - r2 * i1\r\n  })\r\n  return math.complex(real, image)\r\n}\r\n\r\n/**\r\n * @ignore\r\n * return n-length Array filled by item\r\n * @param {Function|any} item\r\n * @param {number} count\r\n * @return {Array}\r\n */\r\nexport function narray(item, count) {\r\n  const result = []\r\n  if (typeof item === 'function') {\r\n    for (let i = 0; i < count; ++i) {\r\n      result.push(item())\r\n    }\r\n  } else {\r\n    for (let i = 0; i < count; ++i) {\r\n      result.push(item)\r\n    }\r\n  }\r\n  return result\r\n}\r\n\r\n/**\r\n * @ignore\r\n * product loop on two Arrays p1 & p2\r\n * @param {Array} p1\r\n * @param {Array} p2\r\n * @param {function} func\r\n */\r\nexport function productLoop(p1, p2, func) {\r\n  for (let i = 0; i < p1.length; ++i) {\r\n    for (let j = 0; j < p2.length; ++j) {\r\n      const stop = func(p1[i], p2[j])\r\n      if (stop) {\r\n        return\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @ignore\r\n * product loop on three Arrays p1 & p2 & p3\r\n * @param {Array} p1\r\n * @param {Array} p2\r\n * @param {Array} p3\r\n * @param {function} func\r\n */\r\nexport function productLoop3(p1, p2, p3, func) {\r\n  for (let i = 0; i < p1.length; ++i) {\r\n    for (let j = 0; j < p2.length; ++j) {\r\n      for (let k = 0; k < p3.length; ++k) {\r\n        const stop = func(p1[i], p2[j], p3[k])\r\n        if (stop) {\r\n          return\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @ignore\r\n * return (base ^ exp) % mod, it's fast and support big number\r\n * @param {number} base\r\n * @param {number}  exp\r\n * @param  {number} mod\r\n * @return {number}\r\n */\r\nexport function expmod(base, exp, mod) {\r\n  if (exp === 0) return 1\r\n  if (exp % 2 === 0) {\r\n    return Math.pow(expmod(base, (exp / 2), mod), 2) % mod\r\n  } else {\r\n    return (base * expmod(base, (exp - 1), mod)) % mod\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/libs/polyfill.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 516,
    "kind": "variable",
    "name": "Complex",
    "memberof": "src/libs/polyfill.js",
    "static": true,
    "longname": "src/libs/polyfill.js~Complex",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/libs/polyfill.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 517,
    "kind": "variable",
    "name": "Matrix",
    "memberof": "src/libs/polyfill.js",
    "static": true,
    "longname": "src/libs/polyfill.js~Matrix",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/libs/polyfill.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 518,
    "kind": "function",
    "name": "isComplex",
    "memberof": "src/libs/polyfill.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/polyfill.js~isComplex",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/polyfill.js",
    "importStyle": "{isComplex}",
    "description": "",
    "lineNumber": 29,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 519,
    "kind": "function",
    "name": "isNumeric",
    "memberof": "src/libs/polyfill.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/polyfill.js~isNumeric",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/polyfill.js",
    "importStyle": "{isNumeric}",
    "description": "",
    "lineNumber": 39,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 520,
    "kind": "function",
    "name": "intersection",
    "memberof": "src/libs/polyfill.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/polyfill.js~intersection",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/polyfill.js",
    "importStyle": "{intersection}",
    "description": "",
    "lineNumber": 50,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "Set"
        ],
        "spread": false,
        "optional": false,
        "name": "s1",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Set"
        ],
        "spread": false,
        "optional": false,
        "name": "s2",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Set"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 521,
    "kind": "function",
    "name": "unionSet",
    "memberof": "src/libs/polyfill.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/polyfill.js~unionSet",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/polyfill.js",
    "importStyle": "{unionSet}",
    "description": "",
    "lineNumber": 61,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "Set"
        ],
        "spread": false,
        "optional": false,
        "name": "s1",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Set"
        ],
        "spread": false,
        "optional": false,
        "name": "s2",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Set<any>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 522,
    "kind": "function",
    "name": "symmetricDifference",
    "memberof": "src/libs/polyfill.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/polyfill.js~symmetricDifference",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/polyfill.js",
    "importStyle": "{symmetricDifference}",
    "description": "",
    "lineNumber": 75,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "Set"
        ],
        "spread": false,
        "optional": false,
        "name": "s1",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Set"
        ],
        "spread": false,
        "optional": false,
        "name": "s2",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Set<*>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 523,
    "kind": "function",
    "name": "setEqual",
    "memberof": "src/libs/polyfill.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/polyfill.js~setEqual",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/polyfill.js",
    "importStyle": "{setEqual}",
    "description": "",
    "lineNumber": 89,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "Set"
        ],
        "spread": false,
        "optional": false,
        "name": "s1",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Set"
        ],
        "spread": false,
        "optional": false,
        "name": "s2",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 524,
    "kind": "function",
    "name": "setIsSuperSet",
    "memberof": "src/libs/polyfill.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/polyfill.js~setIsSuperSet",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/polyfill.js",
    "importStyle": "{setIsSuperSet}",
    "description": "",
    "lineNumber": 100,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "Set"
        ],
        "spread": false,
        "optional": false,
        "name": "superset",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Set"
        ],
        "spread": false,
        "optional": false,
        "name": "s",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 525,
    "kind": "function",
    "name": "setDifference",
    "memberof": "src/libs/polyfill.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/polyfill.js~setDifference",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/polyfill.js",
    "importStyle": "{setDifference}",
    "description": "",
    "lineNumber": 111,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "Set<*>"
        ],
        "spread": false,
        "optional": false,
        "name": "s1",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Set<*>"
        ],
        "spread": false,
        "optional": false,
        "name": "s2",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Set<*>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 526,
    "kind": "function",
    "name": "setFromRange",
    "memberof": "src/libs/polyfill.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/polyfill.js~setFromRange",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/polyfill.js",
    "importStyle": "{setFromRange}",
    "description": "",
    "lineNumber": 121,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "n",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Set<number>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 527,
    "kind": "function",
    "name": "arrayFromRange",
    "memberof": "src/libs/polyfill.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/polyfill.js~arrayFromRange",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/polyfill.js",
    "importStyle": "{arrayFromRange}",
    "description": "",
    "lineNumber": 137,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "start",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "end",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "step",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number[]"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 528,
    "kind": "function",
    "name": "randomSample",
    "memberof": "src/libs/polyfill.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/polyfill.js~randomSample",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/polyfill.js",
    "importStyle": "{randomSample}",
    "description": "",
    "lineNumber": 160,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "any[]"
        ],
        "spread": false,
        "optional": false,
        "name": "array",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "count",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "any[]"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 529,
    "kind": "function",
    "name": "arrayEqual",
    "memberof": "src/libs/polyfill.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/polyfill.js~arrayEqual",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/polyfill.js",
    "importStyle": "{arrayEqual}",
    "description": "",
    "lineNumber": 182,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "a1",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "a2",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "itemCompareFunc",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 530,
    "kind": "function",
    "name": "rforEach",
    "memberof": "src/libs/polyfill.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/polyfill.js~rforEach",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/libs/polyfill.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 221,
    "ignore": true,
    "unknown": [
      {
        "tagName": "@function",
        "tagValue": "reverse version of `forEach`"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "callbackFunc",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 531,
    "kind": "function",
    "name": "rmap",
    "memberof": "src/libs/polyfill.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/polyfill.js~rmap",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/libs/polyfill.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 237,
    "ignore": true,
    "unknown": [
      {
        "tagName": "@function",
        "tagValue": "reverse version of `map`"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "callbackFunc",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "any[]"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 532,
    "kind": "function",
    "name": "count",
    "memberof": "src/libs/polyfill.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/polyfill.js~count",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/libs/polyfill.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 254,
    "ignore": true,
    "unknown": [
      {
        "tagName": "@function",
        "tagValue": "return total exist count of `item` in array"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "any"
        ],
        "spread": false,
        "optional": false,
        "name": "item",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 533,
    "kind": "function",
    "name": "remove",
    "memberof": "src/libs/polyfill.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/polyfill.js~remove",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/libs/polyfill.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 269,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "any"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 534,
    "kind": "function",
    "name": "count",
    "memberof": "src/libs/polyfill.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/polyfill.js~count",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/libs/polyfill.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 288,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "substring",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 535,
    "kind": "function",
    "name": "len",
    "memberof": "src/libs/polyfill.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/polyfill.js~len",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/polyfill.js",
    "importStyle": "{len}",
    "description": "return `length` of v, act like python",
    "lineNumber": 300,
    "params": [
      {
        "nullable": null,
        "types": [
          "any"
        ],
        "spread": false,
        "optional": false,
        "name": "v",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 536,
    "kind": "function",
    "name": "stringToBitArray",
    "memberof": "src/libs/polyfill.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/polyfill.js~stringToBitArray",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/polyfill.js",
    "importStyle": "{stringToBitArray}",
    "description": "",
    "lineNumber": 335,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "str",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean[]"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 537,
    "kind": "function",
    "name": "complexVectorDot",
    "memberof": "src/libs/polyfill.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/polyfill.js~complexVectorDot",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/polyfill.js",
    "importStyle": "{complexVectorDot}",
    "description": "",
    "lineNumber": 355,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "Complex[]"
        ],
        "spread": false,
        "optional": false,
        "name": "a1",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Complex[]"
        ],
        "spread": false,
        "optional": false,
        "name": "a2",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Complex"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 538,
    "kind": "function",
    "name": "narray",
    "memberof": "src/libs/polyfill.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/polyfill.js~narray",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/polyfill.js",
    "importStyle": "{narray}",
    "description": "",
    "lineNumber": 377,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "Function",
          "any"
        ],
        "spread": false,
        "optional": false,
        "name": "item",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "count",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 539,
    "kind": "function",
    "name": "productLoop",
    "memberof": "src/libs/polyfill.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/polyfill.js~productLoop",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/polyfill.js",
    "importStyle": "{productLoop}",
    "description": "",
    "lineNumber": 398,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "p1",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "p2",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "func",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 540,
    "kind": "function",
    "name": "productLoop3",
    "memberof": "src/libs/polyfill.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/polyfill.js~productLoop3",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/polyfill.js",
    "importStyle": "{productLoop3}",
    "description": "",
    "lineNumber": 417,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "p1",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "p2",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "p3",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "func",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 541,
    "kind": "function",
    "name": "expmod",
    "memberof": "src/libs/polyfill.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/polyfill.js~expmod",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/polyfill.js",
    "importStyle": "{expmod}",
    "description": "",
    "lineNumber": 438,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "base",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "exp",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "mod",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 542,
    "kind": "file",
    "name": "src/libs/util.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nimport math from 'mathjs'\r\n\r\n/**\r\n * @ignore\r\n * generate a n-Length Array filled by `0`\r\n * @param {number} n\r\n * @return {number[]}\r\n */\r\nexport function zeros(n) {\r\n  const array = new Array(n)\r\n  for (let i = 0; i < n; ++i) {\r\n    array[i] = 0\r\n  }\r\n  return array\r\n}\r\n\r\n/**\r\n * @ignore\r\n * check if an array is `tuple`\r\n * @param {Array} value\r\n * @return {boolean}\r\n */\r\nexport function arrayIsTuple(value) {\r\n  let isTuple = false\r\n  if (typeof value.$$__tuple !== 'undefined') {\r\n    isTuple = value.$$__tuple\r\n    return isTuple\r\n  }\r\n  if (Array.isArray(value)) {\r\n    isTuple = value.some(item => item instanceof Array)\r\n  }\r\n  return isTuple\r\n}\r\n\r\n/**\r\n * @ignore\r\n * force mark a value as `tuple`, internal usage only\r\n * @param value\r\n */\r\nexport function markTuple(value) {\r\n  value.$$__tuple = true\r\n}\r\n\r\n/**\r\n * create `tuple` from arguments\r\n * @param args\r\n * @return {Array}\r\n */\r\nexport function tuple(...args) {\r\n  const result = new Array(...args)\r\n  markTuple(result)\r\n  return result\r\n}\r\n\r\n/**\r\n * @ignore\r\n * create copy of object, with same `class`\r\n * @param {Object} obj\r\n * @return {Object}\r\n */\r\nexport function ObjectCopy(obj) {\r\n  const copy = Object.create(obj.__proto__)\r\n  Object.assign(copy, obj)\r\n  return copy\r\n}\r\n\r\n/**\r\n * return class hierachy of `cls`\r\n * @param {function} cls\r\n * @return {function[]}\r\n */\r\nexport function classHierachy(cls) {\r\n  const result = []\r\n  if (typeof cls === 'function') {\r\n    let {name} = cls\r\n    while (name.length > 0) {\r\n      result.push({name, class: cls})\r\n      cls = cls.__proto__\r\n      name = cls.name\r\n    }\r\n  }\r\n  return result\r\n}\r\n\r\n/**\r\n * check if `cls` is subclass of `superClass`, will return false if cls is superClass\r\n * @param {function} cls\r\n * @param {function} superClass\r\n * @return {boolean}\r\n */\r\nexport function isSubclassOf(cls, superClass) {\r\n  if (typeof cls === 'function' && typeof superClass === 'function') {\r\n    const targetName = superClass.name\r\n    let {name} = cls\r\n    let level = 0\r\n    while (name.length > 0) {\r\n      if (name === targetName && level > 0) {\r\n        return true\r\n      }\r\n      cls = cls.__proto__\r\n      name = cls.name\r\n      ++level\r\n    }\r\n  }\r\n  return false\r\n}\r\n\r\n/**\r\n * check if `cls` is kind of `superClass`, will return true if cls is superClass\r\n * @param {function} cls\r\n * @param {function} superClass\r\n * @return {boolean}\r\n */\r\nexport function isKindclassOf(cls, superClass) {\r\n  if (typeof cls === 'function' && typeof superClass === 'function') {\r\n    const targetName = superClass.name\r\n    let {name} = cls\r\n    while (name.length > 0) {\r\n      if (name === targetName) {\r\n        return true\r\n      }\r\n      cls = cls.__proto__\r\n      name = cls.name\r\n    }\r\n  }\r\n  return false\r\n}\r\n\r\n/**\r\n * check if `inst` is instance of `cls`, specialized for some class\r\n * @param {any} inst\r\n * @param {function} cls\r\n * @return {boolean}\r\n */\r\nexport function instanceOf(inst, cls) {\r\n  if (Array.isArray(cls)) {\r\n    return cls.some(looper => instanceOf(inst, looper))\r\n  }\r\n  switch (cls.name) {\r\n    case 'String': {\r\n      return typeof inst === 'string' || inst instanceof cls\r\n    }\r\n    case 'Number': {\r\n      return typeof inst === 'number' || inst instanceof cls\r\n    }\r\n    default: {\r\n      return inst instanceof cls\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @ignore\r\n * return item * n string like python does.\r\n * @param {string} item\r\n * @param {number} n\r\n * @return {string}\r\n */\r\nexport function genString(item, n) {\r\n  let str = ''\r\n  for (let i = 0; i < n; ++i) {\r\n    str += item\r\n  }\r\n  return str\r\n}\r\n\r\n/**\r\n * @ignore\r\n * assign value in `vector` into `matrix` by index in `indices`\r\n * @param {math.matrix} matrix\r\n * @param {number[]} indices\r\n * @param {number[]} vector\r\n */\r\nexport function matrixRangeAssign(matrix, indices, vector) {\r\n  if (Array.isArray(vector)) {\r\n    indices.forEach(idx => matrix.subset(math.index(idx), vector[idx]))\r\n  } else {\r\n    indices.forEach((idx, i) => matrix.subset(math.index(idx), vector.subset(math.index(i))))\r\n  }\r\n}\r\n\r\n/**\r\n * @ignore\r\n * @param matrix\r\n * @param mstart\r\n * @param mend\r\n * @param vector\r\n * @param vstart\r\n */\r\nexport function matrixRangeIndicesAssign(matrix, mstart, mend, vector, vstart) {\r\n  if (Array.isArray(vector)) {\r\n    for (let i = 0; i + mstart < mend; ++i) {\r\n      matrix.subset(math.index(i + mstart), vector[vstart + i])\r\n    }\r\n  } else {\r\n    for (let i = 0; i + mstart < mend; ++i) {\r\n      matrix.subset(math.index(i + mstart), vector.subset(math.index(vstart + i)))\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @ignore\r\n * return a row of matrix\r\n * @param {math.matrix} matrix\r\n * @param {number} index\r\n * @return {number[]}\r\n */\r\nexport function matrixGetRow(matrix, index) {\r\n  const rows = math.size(matrix).valueOf()[1];\r\n  return math.flatten(math.subset(matrix, math.index(index, math.range(0, rows))));\r\n}\r\n\r\n/**\r\n * @ignore\r\n * dot product of matrix & vector\r\n * @param {math.matrix} matrix\r\n * @param {number[]} vector\r\n * @return {math.matrix}\r\n */\r\nexport function matrixDot(matrix, vector) {\r\n  const [rows] = matrix.size()\r\n  const result = []\r\n  for (let i = 0; i < rows; ++i) {\r\n    const row = matrixGetRow(matrix, i)\r\n    result.push(math.dot(row, vector))\r\n  }\r\n  return math.matrix(result)\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/libs/util.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 543,
    "kind": "function",
    "name": "zeros",
    "memberof": "src/libs/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/util.js~zeros",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/util.js",
    "importStyle": "{zeros}",
    "description": "",
    "lineNumber": 24,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "n",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number[]"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 544,
    "kind": "function",
    "name": "arrayIsTuple",
    "memberof": "src/libs/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/util.js~arrayIsTuple",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/util.js",
    "importStyle": "{arrayIsTuple}",
    "description": "",
    "lineNumber": 38,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 545,
    "kind": "function",
    "name": "markTuple",
    "memberof": "src/libs/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/util.js~markTuple",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/util.js",
    "importStyle": "{markTuple}",
    "description": "",
    "lineNumber": 55,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 546,
    "kind": "function",
    "name": "tuple",
    "memberof": "src/libs/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/util.js~tuple",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/util.js",
    "importStyle": "{tuple}",
    "description": "create `tuple` from arguments",
    "lineNumber": 64,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "args",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 547,
    "kind": "function",
    "name": "ObjectCopy",
    "memberof": "src/libs/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/util.js~ObjectCopy",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/util.js",
    "importStyle": "{ObjectCopy}",
    "description": "",
    "lineNumber": 76,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "obj",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 548,
    "kind": "function",
    "name": "classHierachy",
    "memberof": "src/libs/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/util.js~classHierachy",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/util.js",
    "importStyle": "{classHierachy}",
    "description": "return class hierachy of `cls`",
    "lineNumber": 87,
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "cls",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "function[]"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 549,
    "kind": "function",
    "name": "isSubclassOf",
    "memberof": "src/libs/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/util.js~isSubclassOf",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/util.js",
    "importStyle": "{isSubclassOf}",
    "description": "check if `cls` is subclass of `superClass`, will return false if cls is superClass",
    "lineNumber": 106,
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "cls",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "superClass",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 550,
    "kind": "function",
    "name": "isKindclassOf",
    "memberof": "src/libs/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/util.js~isKindclassOf",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/util.js",
    "importStyle": "{isKindclassOf}",
    "description": "check if `cls` is kind of `superClass`, will return true if cls is superClass",
    "lineNumber": 129,
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "cls",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "superClass",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 551,
    "kind": "function",
    "name": "instanceOf",
    "memberof": "src/libs/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/util.js~instanceOf",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/util.js",
    "importStyle": "{instanceOf}",
    "description": "check if `inst` is instance of `cls`, specialized for some class",
    "lineNumber": 150,
    "params": [
      {
        "nullable": null,
        "types": [
          "any"
        ],
        "spread": false,
        "optional": false,
        "name": "inst",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "cls",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 552,
    "kind": "function",
    "name": "genString",
    "memberof": "src/libs/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/util.js~genString",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/util.js",
    "importStyle": "{genString}",
    "description": "",
    "lineNumber": 174,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "item",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "n",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 553,
    "kind": "function",
    "name": "matrixRangeAssign",
    "memberof": "src/libs/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/util.js~matrixRangeAssign",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/util.js",
    "importStyle": "{matrixRangeAssign}",
    "description": "",
    "lineNumber": 189,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "math.matrix"
        ],
        "spread": false,
        "optional": false,
        "name": "matrix",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "indices",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "vector",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 554,
    "kind": "function",
    "name": "matrixRangeIndicesAssign",
    "memberof": "src/libs/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/util.js~matrixRangeIndicesAssign",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/util.js",
    "importStyle": "{matrixRangeIndicesAssign}",
    "description": "",
    "lineNumber": 205,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "matrix",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "mstart",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "mend",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "vector",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "vstart",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 555,
    "kind": "function",
    "name": "matrixGetRow",
    "memberof": "src/libs/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/util.js~matrixGetRow",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/util.js",
    "importStyle": "{matrixGetRow}",
    "description": "",
    "lineNumber": 224,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "math.matrix"
        ],
        "spread": false,
        "optional": false,
        "name": "matrix",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "index",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number[]"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 556,
    "kind": "function",
    "name": "matrixDot",
    "memberof": "src/libs/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/util.js~matrixDot",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/util.js",
    "importStyle": "{matrixDot}",
    "description": "",
    "lineNumber": 236,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "math.matrix"
        ],
        "spread": false,
        "optional": false,
        "name": "matrix",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "vector",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "math.matrix"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 557,
    "kind": "file",
    "name": "src/meta/compute.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/* Compute, Uncompute, CustomUncompute.\r\n\r\n    Contains Compute, Uncompute, and CustomUncompute classes which can be used to\r\nannotate Compute / Action / Uncompute sections, facilitating the conditioning\r\nof the entire operation on the value of a qubit / register (only Action needs\r\ncontrols). This file also defines the corresponding meta tags.\r\n*/\r\nimport assert from 'assert'\r\nimport {BasicEngine} from '../cengines/basics'\r\nimport CommandModifier from '../cengines/cmdmodifier'\r\nimport {ComputeTag, UncomputeTag} from './tag'\r\nimport {dropEngineAfter, insertEngine} from './util'\r\nimport {Allocate, Deallocate} from '../ops/gates'\r\nimport {\r\n  unionSet, setEqual, setIsSuperSet, intersection\r\n} from '../libs/polyfill'\r\nimport {QubitManagementError} from './error'\r\n\r\n/**\r\n * @class ComputeEngine\r\n * @desc Adds Compute-tags to all commands and stores them (to later uncompute them automatically)\r\n */\r\nexport class ComputeEngine extends BasicEngine {\r\n  /**\r\n   * @constructor\r\n   */\r\n  constructor() {\r\n    super()\r\n    this._l = []\r\n    this._compute = true\r\n    // Save all qubit ids from qubits which are created or destroyed.\r\n    this.allocatedQubitIDs = new Set()\r\n    this.deallocatedQubitIDs = new Set()\r\n  }\r\n\r\n  /**\r\n    Modify the command tags, inserting an UncomputeTag.\r\n    @param {Command} cmd Command to modify.\r\n     */\r\n  addUnComputeTag(cmd) {\r\n    cmd.tags.push(new UncomputeTag())\r\n    return cmd\r\n  }\r\n\r\n  /**\r\n    Send uncomputing gates.\r\n\r\n    Sends the inverse of the stored commands in reverse order down to the\r\nnext engine. And also deals with allocated qubits in Compute section.\r\n    If a qubit has been allocated during compute, it will be deallocated\r\nduring uncompute. If a qubit has been allocated and deallocated during\r\ncompute, then a new qubit is allocated and deallocated during\r\nuncompute.\r\n     */\r\n  runUnCompute() {\r\n    // No qubits allocated during Compute section -> do standard uncompute\r\n    if (this.allocatedQubitIDs.size === 0) {\r\n      const cmds = this._l.rmap(cmd => this.addUnComputeTag(cmd.getInverse()))\r\n      this.send(cmds)\r\n      return\r\n    }\r\n\r\n\r\n    // qubits ids which were allocated and deallocated in Compute section\r\n    const ids_local_to_compute = intersection(this.allocatedQubitIDs, this.deallocatedQubitIDs)\r\n    // qubit ids which were allocated but not yet deallocated in\r\n    // Compute section\r\n    // TODO: why need to calculate this???\r\n    // const ids_still_alive = symmetricDifference(this.allocatedQubitIDs, this.deallocatedQubitIDs)\r\n\r\n    // No qubits allocated and already deallocated during compute.\r\n    // Don't inspect each command as below -> faster uncompute\r\n    // Just find qubits which have been allocated and deallocate them\r\n    if (ids_local_to_compute.size === 0) {\r\n      this._l.rforEach((cmd) => {\r\n        if (cmd.gate.equal(Allocate)) {\r\n          const qubit_id = cmd.qubits[0][0].id\r\n          // Remove this qubit from MainEngine.active_qubits and\r\n          // set qubit.id to = -1 in Qubit object such that it won't\r\n          // send another deallocate when it goes out of scope\r\n          let qubit_found = false\r\n          for (const active_qubit of this.main.activeQubits) {\r\n            if (active_qubit.id === qubit_id) {\r\n              active_qubit.id = -1\r\n              active_qubit.deallocate()\r\n              qubit_found = true\r\n              break\r\n            }\r\n          }\r\n\r\n          if (!qubit_found) {\r\n            throw new QubitManagementError('\\nQubit was not found in '\r\n                + 'MainEngine.active_qubits.\\n')\r\n          }\r\n          this.send([this.addUnComputeTag(cmd.getInverse())])\r\n        } else {\r\n          this.send([this.addUnComputeTag(cmd.getInverse())])\r\n        }\r\n      })\r\n      return\r\n    }\r\n\r\n    // There was at least one qubit allocated and deallocated within\r\n    // compute section. Handle uncompute in most general case\r\n    const new_local_id = {}\r\n    this._l.slice(0).rforEach((cmd) => {\r\n      if (cmd.gate.equal(Deallocate)) {\r\n        assert(ids_local_to_compute.has(cmd.qubits[0][0].id))\r\n        // Create new local qubit which lives within uncompute section\r\n\r\n        // Allocate needs to have old tags + uncompute tag\r\n        const add_uncompute = (command, old_tags = cmd.tags.slice(0)) => {\r\n          command.tags = old_tags.concat([new UncomputeTag()])\r\n          return command\r\n        }\r\n        const tagger_eng = new CommandModifier(add_uncompute)\r\n        insertEngine(this, tagger_eng)\r\n        const new_local_qb = this.allocateQubit()\r\n        dropEngineAfter(this)\r\n\r\n        new_local_id[cmd.qubits[0][0].id] = new_local_qb[0].id\r\n        // Set id of new_local_qb to -1 such that it doesn't send a\r\n        // deallocate gate\r\n        new_local_qb[0].id = -1\r\n      } else if (cmd.gate.equal(Allocate)) {\r\n        // Deallocate qubit\r\n        if (ids_local_to_compute.has(cmd.qubits[0][0].id)) {\r\n          // Deallocate local qubit and remove id from new_local_id\r\n          const old_id = cmd.qubits[0][0].id\r\n          cmd.qubits[0][0].id = new_local_id[cmd.qubits[0][0].id]\r\n          delete new_local_id[old_id]\r\n          this.send([this.addUnComputeTag(cmd.getInverse())])\r\n        } else {\r\n          // Deallocate qubit which was allocated in compute section:\r\n          const qubit_id = cmd.qubits[0][0].id\r\n          // Remove this qubit from MainEngine.active_qubits and\r\n          // set qubit.id to = -1 in Qubit object such that it won't\r\n          // send another deallocate when it goes out of scope\r\n          let qubit_found = false\r\n          for (const active_qubit of this.main.activeQubits) {\r\n            if (active_qubit.id === qubit_id) {\r\n              active_qubit.id = -1\r\n              active_qubit.deallocate()\r\n              qubit_found = true\r\n              break\r\n            }\r\n          }\r\n          if (!qubit_found) {\r\n            throw new QubitManagementError(\r\n              '\\nQubit was not found in '\r\n            + 'MainEngine.active_qubits.\\n'\r\n            )\r\n          }\r\n          this.send([this.addUnComputeTag(cmd.getInverse())])\r\n        }\r\n      } else {\r\n        // Process commands by replacing each local qubit from\r\n        // compute section with new local qubit from the uncompute\r\n        // section\r\n        if (Object.keys(new_local_id).length > 0) { // Only if we still have local qubits\r\n          cmd.allQubits.forEach((qureg) => {\r\n            qureg.forEach((qubit) => {\r\n              if (new_local_id[qubit.id]) {\r\n                qubit.id = new_local_id[qubit.id]\r\n              }\r\n            })\r\n          })\r\n        }\r\n        this.send([this.addUnComputeTag(cmd.getInverse())])\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\nEnd the compute step (exit the Compute() - statement).\r\n\r\nWill tell the Compute-engine to stop caching. It then waits for the\r\n    uncompute instruction, which is when it sends all cached commands\r\ninverted and in reverse order down to the next compiler engine.\r\n\r\n    @throws {QubitManagementError} If qubit has been deallocated in Compute\r\nsection which has not been allocated in Compute section\r\n*/\r\n  endCompute() {\r\n    this._compute = false\r\n    if (!setIsSuperSet(this.allocatedQubitIDs, this.deallocatedQubitIDs)) {\r\n      throw new QubitManagementError(\r\n        '\\nQubit has been deallocated in with Compute(eng) context \\n'\r\n    + 'which has not been allocated within this Compute section'\r\n      )\r\n    }\r\n  }\r\n\r\n  /**\r\n  If in compute-mode: Receive commands and store deepcopy of each cmd.\r\n    Add ComputeTag to received cmd and send it on.\r\n    Otherwise: send all received commands directly to next_engine.\r\n\r\n    @param {Command[]} commandList List of commands to receive.\r\n   */\r\n  receive(commandList) {\r\n    if (this._compute) {\r\n      commandList.forEach((cmd) => {\r\n        if (cmd.gate.equal(Allocate)) {\r\n          this.allocatedQubitIDs.add(cmd.qubits[0][0].id)\r\n        } else if (cmd.gate.equal(Deallocate)) {\r\n          this.deallocatedQubitIDs.add(cmd.qubits[0][0].id)\r\n        }\r\n        this._l.push(cmd.copy())\r\n        cmd.tags.push(new ComputeTag())\r\n      })\r\n    }\r\n    this.send(commandList)\r\n  }\r\n}\r\n\r\n/**\r\n * @class Uncompute\r\n */\r\nexport class UncomputeEngine extends BasicEngine {\r\n  /**\r\n   * @constructor\r\n   */\r\n  constructor() {\r\n    super()\r\n    // Save all qubit ids from qubits which are created or destroyed.\r\n    this.allocatedQubitIDs = new Set()\r\n    this.deallocatedQubitIDs = new Set()\r\n  }\r\n\r\n  /**\r\n  Receive commands and add an UncomputeTag to their tags.\r\n\r\n    @param {Command[]} commandList List of commands to handle.\r\n   */\r\n  receive(commandList) {\r\n    commandList.forEach((cmd) => {\r\n      if (cmd.gate.equal(Allocate)) {\r\n        this.allocatedQubitIDs.add(cmd.qubits[0][0].id)\r\n      } else if (cmd.gate.equal(Deallocate)) {\r\n        this.deallocatedQubitIDs.add(cmd.qubits[0][0].id)\r\n      }\r\n      cmd.tags.push(new UncomputeTag())\r\n      this.send([cmd])\r\n    })\r\n  }\r\n}\r\n\r\n/**\r\nStart a compute-section.\r\n\r\n    @example\r\n\r\nCompute(eng, () => {\r\n  do_something(qubits)\r\n  action(qubits)\r\n})\r\nUncompute(eng) // runs inverse of the compute section\r\n\r\nWarning:\r\n    If qubits are allocated within the compute section, they must either be\r\nuncomputed and deallocated within that section or, alternatively,\r\n    uncomputed and deallocated in the following uncompute section.\r\n\r\n    This means that the following examples are valid:\r\n\r\n @example\r\n\r\nCompute(eng, () => {\r\n  anc = eng.allocateQubit()\r\n  do_something_with_ancilla(anc)\r\n})\r\n ...\r\nuncompute_ancilla(anc)\r\nanc.deallocate()\r\n\r\ndo_something_else(qubits)\r\n\r\nUncompute(eng)  // will allocate a new ancilla (with a different id)\r\n// and then deallocate it again\r\n\r\n @example\r\n\r\nCompute(eng, () => {\r\nanc = eng.allocateQubit()\r\ndo_something_with_ancilla(anc)\r\n...\r\n})\r\ndo_something_else(qubits)\r\n\r\nUncompute(eng)  // will deallocate the ancilla!\r\n\r\n    After the uncompute section, ancilla qubits allocated within the\r\ncompute section will be invalid (and deallocated). The same holds when\r\nusing CustomUncompute.\r\n\r\n    Failure to comply with these rules results in an exception being thrown.\r\n */\r\nexport function Compute(engine, func) {\r\n  let computeEngine = null\r\n  const enter = () => {\r\n    computeEngine = new ComputeEngine()\r\n    insertEngine(engine, computeEngine)\r\n  }\r\n\r\n  const exit = () => {\r\n    computeEngine.endCompute()\r\n    computeEngine = null\r\n  }\r\n\r\n  if (typeof func === 'function') {\r\n    enter()\r\n    try {\r\n      func()\r\n    } catch (e) {\r\n      throw e\r\n    } finally {\r\n      exit()\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\nStart a custom uncompute-section.\r\n\r\n    @example\r\n\r\nCompute(eng, () => {\r\n  do_something(qubits)\r\n})\r\n\r\n action(qubits)\r\n\r\n CustomUncompute(eng, () => {\r\n  do_something_inverse(qubits)\r\n})\r\n\r\n@throws {QubitManagementError} If qubits are allocated within Compute or within\r\nCustomUncompute context but are not deallocated.\r\n */\r\nexport function CustomUncompute(engine, func) {\r\n  let allocatedQubitIDs = new Set()\r\n  let deallocatedQubitIDs = new Set()\r\n  let uncomputeEngine = null\r\n\r\n  const enter = () => {\r\n    // first, remove the compute engine\r\n    const compute_eng = engine.next\r\n    if (!(compute_eng instanceof ComputeEngine)) {\r\n      throw new QubitManagementError('Invalid call to CustomUncompute: No corresponding \"Compute\" statement found.')\r\n    }\r\n    // Make copy so there is not reference to compute_eng anymore\r\n    // after __enter__\r\n    allocatedQubitIDs = new Set(compute_eng.allocatedQubitIDs)\r\n    deallocatedQubitIDs = new Set(compute_eng.deallocatedQubitIDs)\r\n    dropEngineAfter(engine)\r\n    // Now add uncompute engine\r\n    uncomputeEngine = new UncomputeEngine()\r\n    insertEngine(engine, uncomputeEngine)\r\n  }\r\n\r\n  const exit = () => {\r\n    // If an error happens in this context, qubits might not have been\r\n    // deallocated because that code section was not yet executed,\r\n    // so don't check and raise an additional error.\r\n\r\n    // Check that all qubits allocated within Compute or within\r\n    // CustomUncompute have been deallocated.\r\n    const all_allocated_qubits = unionSet(allocatedQubitIDs, uncomputeEngine.allocatedQubitIDs)\r\n    const all_deallocated_qubits = unionSet(deallocatedQubitIDs, uncomputeEngine.deallocatedQubitIDs)\r\n    if (!setEqual(all_allocated_qubits, all_deallocated_qubits)) {\r\n      throw new QubitManagementError('\\nError. Not all qubits have been deallocated which have \\n'\r\n               + 'been allocated in the Compute(eng) or with '\r\n               + 'CustomUncompute(eng) context.')\r\n    }\r\n    // remove uncompute engine\r\n    dropEngineAfter(engine)\r\n  }\r\n\r\n  if (typeof func === 'function') {\r\n    enter()\r\n    try {\r\n      func()\r\n    } catch (e) {\r\n      throw e\r\n    } finally {\r\n      exit()\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\nUncompute automatically.\r\n\r\n    @example\r\n Compute(eng, () => {\r\n  do_something(qubits)\r\n})\r\n  action(qubits)\r\n  Uncompute(eng) // runs inverse of the compute section\r\n */\r\nexport function Uncompute(engine) {\r\n  const compute_eng = engine.next\r\n  if (!(compute_eng instanceof ComputeEngine)) {\r\n    throw new Error('Invalid call to Uncompute: No corresponding \"Compute\" statement found.')\r\n  }\r\n  compute_eng.runUnCompute()\r\n  dropEngineAfter(engine)\r\n\r\n  if (engine.autoDeallocateQubits) {\r\n    engine.autoDeallocateQubits()\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/meta/compute.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 558,
    "kind": "class",
    "name": "ComputeEngine",
    "memberof": "src/meta/compute.js",
    "static": true,
    "longname": "src/meta/compute.js~ComputeEngine",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/meta/compute.js",
    "importStyle": "{ComputeEngine}",
    "description": "Adds Compute-tags to all commands and stores them (to later uncompute them automatically)",
    "lineNumber": 39,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "ComputeEngine"
      }
    ],
    "interface": false,
    "extends": [
      "src/cengines/basics.js~BasicEngine"
    ]
  },
  {
    "__docId__": 559,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/meta/compute.js~ComputeEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/compute.js~ComputeEngine#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 43,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ]
  },
  {
    "__docId__": 560,
    "kind": "member",
    "name": "_l",
    "memberof": "src/meta/compute.js~ComputeEngine",
    "static": false,
    "longname": "src/meta/compute.js~ComputeEngine#_l",
    "access": "private",
    "description": null,
    "lineNumber": 45,
    "undocument": true,
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 561,
    "kind": "member",
    "name": "_compute",
    "memberof": "src/meta/compute.js~ComputeEngine",
    "static": false,
    "longname": "src/meta/compute.js~ComputeEngine#_compute",
    "access": "private",
    "description": null,
    "lineNumber": 46,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 562,
    "kind": "member",
    "name": "allocatedQubitIDs",
    "memberof": "src/meta/compute.js~ComputeEngine",
    "static": false,
    "longname": "src/meta/compute.js~ComputeEngine#allocatedQubitIDs",
    "access": "public",
    "description": null,
    "lineNumber": 48,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 563,
    "kind": "member",
    "name": "deallocatedQubitIDs",
    "memberof": "src/meta/compute.js~ComputeEngine",
    "static": false,
    "longname": "src/meta/compute.js~ComputeEngine#deallocatedQubitIDs",
    "access": "public",
    "description": null,
    "lineNumber": 49,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 564,
    "kind": "method",
    "name": "addUnComputeTag",
    "memberof": "src/meta/compute.js~ComputeEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/compute.js~ComputeEngine#addUnComputeTag",
    "access": "public",
    "description": "Modify the command tags, inserting an UncomputeTag.",
    "lineNumber": 56,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": "Command to modify."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 565,
    "kind": "method",
    "name": "runUnCompute",
    "memberof": "src/meta/compute.js~ComputeEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/compute.js~ComputeEngine#runUnCompute",
    "access": "public",
    "description": "Send uncomputing gates.\n\nSends the inverse of the stored commands in reverse order down to the\nnext engine. And also deals with allocated qubits in Compute section.\nIf a qubit has been allocated during compute, it will be deallocated\nduring uncompute. If a qubit has been allocated and deallocated during\ncompute, then a new qubit is allocated and deallocated during\nuncompute.",
    "lineNumber": 71,
    "params": [],
    "return": null
  },
  {
    "__docId__": 566,
    "kind": "method",
    "name": "endCompute",
    "memberof": "src/meta/compute.js~ComputeEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/compute.js~ComputeEngine#endCompute",
    "access": "public",
    "description": "End the compute step (exit the Compute() - statement).\n\nWill tell the Compute-engine to stop caching. It then waits for the\nuncompute instruction, which is when it sends all cached commands\ninverted and in reverse order down to the next compiler engine.",
    "lineNumber": 200,
    "throws": [
      {
        "types": [
          "QubitManagementError"
        ],
        "description": "If qubit has been deallocated in Compute\nsection which has not been allocated in Compute section"
      }
    ],
    "params": [],
    "return": null
  },
  {
    "__docId__": 568,
    "kind": "method",
    "name": "receive",
    "memberof": "src/meta/compute.js~ComputeEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/compute.js~ComputeEngine#receive",
    "access": "public",
    "description": "If in compute-mode: Receive commands and store deepcopy of each cmd.\nAdd ComputeTag to received cmd and send it on.\nOtherwise: send all received commands directly to next_engine.",
    "lineNumber": 217,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command[]"
        ],
        "spread": false,
        "optional": false,
        "name": "commandList",
        "description": "List of commands to receive."
      }
    ],
    "return": null
  },
  {
    "__docId__": 569,
    "kind": "class",
    "name": "UncomputeEngine",
    "memberof": "src/meta/compute.js",
    "static": true,
    "longname": "src/meta/compute.js~UncomputeEngine",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/meta/compute.js",
    "importStyle": "{UncomputeEngine}",
    "description": "",
    "lineNumber": 236,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "Uncompute"
      }
    ],
    "interface": false,
    "extends": [
      "src/cengines/basics.js~BasicEngine"
    ]
  },
  {
    "__docId__": 570,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/meta/compute.js~UncomputeEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/compute.js~UncomputeEngine#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 240,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ]
  },
  {
    "__docId__": 571,
    "kind": "member",
    "name": "allocatedQubitIDs",
    "memberof": "src/meta/compute.js~UncomputeEngine",
    "static": false,
    "longname": "src/meta/compute.js~UncomputeEngine#allocatedQubitIDs",
    "access": "public",
    "description": null,
    "lineNumber": 243,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 572,
    "kind": "member",
    "name": "deallocatedQubitIDs",
    "memberof": "src/meta/compute.js~UncomputeEngine",
    "static": false,
    "longname": "src/meta/compute.js~UncomputeEngine#deallocatedQubitIDs",
    "access": "public",
    "description": null,
    "lineNumber": 244,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 573,
    "kind": "method",
    "name": "receive",
    "memberof": "src/meta/compute.js~UncomputeEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/compute.js~UncomputeEngine#receive",
    "access": "public",
    "description": "Receive commands and add an UncomputeTag to their tags.",
    "lineNumber": 252,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command[]"
        ],
        "spread": false,
        "optional": false,
        "name": "commandList",
        "description": "List of commands to handle."
      }
    ],
    "return": null
  },
  {
    "__docId__": 574,
    "kind": "function",
    "name": "Compute",
    "memberof": "src/meta/compute.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/meta/compute.js~Compute",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/meta/compute.js",
    "importStyle": "{Compute}",
    "description": "Start a compute-section.",
    "examples": [
      "\nCompute(eng, () => {\ndo_something(qubits)\naction(qubits)\n})\nUncompute(eng) // runs inverse of the compute section\n\nWarning:\nIf qubits are allocated within the compute section, they must either be\nuncomputed and deallocated within that section or, alternatively,\nuncomputed and deallocated in the following uncompute section.\n\nThis means that the following examples are valid:",
      "\nCompute(eng, () => {\nanc = eng.allocateQubit()\ndo_something_with_ancilla(anc)\n})\n...\nuncompute_ancilla(anc)\nanc.deallocate()\n\ndo_something_else(qubits)\n\nUncompute(eng)  // will allocate a new ancilla (with a different id)\n// and then deallocate it again",
      "\nCompute(eng, () => {\nanc = eng.allocateQubit()\ndo_something_with_ancilla(anc)\n...\n})\ndo_something_else(qubits)\n\nUncompute(eng)  // will deallocate the ancilla!\n\nAfter the uncompute section, ancilla qubits allocated within the\ncompute section will be invalid (and deallocated). The same holds when\nusing CustomUncompute.\n\nFailure to comply with these rules results in an exception being thrown."
    ],
    "lineNumber": 315,
    "params": [
      {
        "name": "engine",
        "types": [
          "*"
        ]
      },
      {
        "name": "func",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 575,
    "kind": "function",
    "name": "CustomUncompute",
    "memberof": "src/meta/compute.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/meta/compute.js~CustomUncompute",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/meta/compute.js",
    "importStyle": "{CustomUncompute}",
    "description": "Start a custom uncompute-section.",
    "examples": [
      "\nCompute(eng, () => {\ndo_something(qubits)\n})\n\naction(qubits)\n\nCustomUncompute(eng, () => {\ndo_something_inverse(qubits)\n})"
    ],
    "lineNumber": 357,
    "throws": [
      {
        "types": [
          "QubitManagementError"
        ],
        "description": "If qubits are allocated within Compute or within\nCustomUncompute context but are not deallocated."
      }
    ],
    "params": [
      {
        "name": "engine",
        "types": [
          "*"
        ]
      },
      {
        "name": "func",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 576,
    "kind": "function",
    "name": "Uncompute",
    "memberof": "src/meta/compute.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/meta/compute.js~Uncompute",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/meta/compute.js",
    "importStyle": "{Uncompute}",
    "description": "Uncompute automatically.",
    "examples": [
      "Compute(eng, () => {\ndo_something(qubits)\n})\naction(qubits)\nUncompute(eng) // runs inverse of the compute section"
    ],
    "lineNumber": 418,
    "params": [
      {
        "name": "engine",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 577,
    "kind": "file",
    "name": "src/meta/control.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/**\r\nContains the tools to make an entire section of operations controlled.\r\n\r\n    @example\r\n\r\nwith Control(eng, qubit1):\r\nH | qubit2\r\nX | qubit3\r\n*/\r\n\r\n// Adds control qubits to all commands that have no compute / uncompute tags.\r\nimport {ClassicalInstructionGate} from '../ops/basics'\r\nimport {BasicQubit} from '../types/qubit'\r\nimport {BasicEngine} from '../cengines/basics'\r\nimport {dropEngineAfter, insertEngine} from './util'\r\nimport {UncomputeTag, ComputeTag} from './tag'\r\nimport {instanceOf} from '../libs/util'\r\n\r\n/**\r\n * @class ControlEngine\r\n */\r\nexport class ControlEngine extends BasicEngine {\r\n  /**\r\n   * @constructor\r\n    @param {Array.<BasicQubit>} qubits qubits conditional on which the following operations are executed.\r\n     */\r\n  constructor(qubits) {\r\n    super()\r\n    this.qubits = qubits\r\n  }\r\n\r\n  /**\r\n    Return true if command cmd has a compute/uncompute tag.\r\n    @param {Command} cmd\r\n  */\r\n  hasComputeUnComputeTag(cmd) {\r\n    const tagClass = [UncomputeTag, ComputeTag]\r\n    return cmd.tags.some(looper => instanceOf(looper, tagClass))\r\n  }\r\n\r\n  handleCommand(cmd) {\r\n    if (!this.hasComputeUnComputeTag(cmd) && !(cmd.gate instanceof ClassicalInstructionGate)) {\r\n      cmd.addControlQubits(this.qubits)\r\n    }\r\n    this.send([cmd])\r\n  }\r\n\r\n  receive(commandList) {\r\n    commandList.forEach(cmd => this.handleCommand(cmd))\r\n  }\r\n}\r\n\r\n/**\r\nCondition an entire code block on the value of qubits being 1.\r\n\r\n@example\r\n\r\nwith Control(eng, ctrlqubits)\r\ndo_something(otherqubits)\r\n Enter a controlled section.\r\n\r\n @param {BasicEngine} engine Engine which handles the commands (usually MainEngine)\r\n @param {Array.<BasicQubit>} qubits Qubits to condition on\r\n @param {function} func\r\n Enter the section using a with-statement\r\n @example\r\n Control(eng, ctrlqubits, () => ...)\r\n */\r\nexport function Control(engine, qubits, func) {\r\n  if (qubits instanceof BasicQubit) {\r\n    qubits = [qubits]\r\n  }\r\n  const qs = qubits\r\n\r\n  const enter = () => {\r\n    if (qs.length > 0) {\r\n      const ce = new ControlEngine(qs)\r\n      insertEngine(engine, ce)\r\n    }\r\n  }\r\n\r\n  const exit = () => {\r\n    if (qs.length > 0) {\r\n      dropEngineAfter(engine)\r\n    }\r\n  }\r\n\r\n  if (typeof func === 'function') {\r\n    enter()\r\n    try {\r\n      func()\r\n    } catch (e) {\r\n      throw e\r\n    } finally {\r\n      exit()\r\n    }\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/meta/control.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 578,
    "kind": "class",
    "name": "ControlEngine",
    "memberof": "src/meta/control.js",
    "static": true,
    "longname": "src/meta/control.js~ControlEngine",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/meta/control.js",
    "importStyle": "{ControlEngine}",
    "description": "",
    "lineNumber": 38,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "ControlEngine"
      }
    ],
    "interface": false,
    "extends": [
      "src/cengines/basics.js~BasicEngine"
    ]
  },
  {
    "__docId__": 579,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/meta/control.js~ControlEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/control.js~ControlEngine#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 43,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Array.<BasicQubit>"
        ],
        "spread": false,
        "optional": false,
        "name": "qubits",
        "description": "qubits conditional on which the following operations are executed."
      }
    ]
  },
  {
    "__docId__": 580,
    "kind": "member",
    "name": "qubits",
    "memberof": "src/meta/control.js~ControlEngine",
    "static": false,
    "longname": "src/meta/control.js~ControlEngine#qubits",
    "access": "public",
    "description": null,
    "lineNumber": 45,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 581,
    "kind": "method",
    "name": "hasComputeUnComputeTag",
    "memberof": "src/meta/control.js~ControlEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/control.js~ControlEngine#hasComputeUnComputeTag",
    "access": "public",
    "description": "Return true if command cmd has a compute/uncompute tag.",
    "lineNumber": 52,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 582,
    "kind": "method",
    "name": "handleCommand",
    "memberof": "src/meta/control.js~ControlEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/control.js~ControlEngine#handleCommand",
    "access": "public",
    "description": null,
    "lineNumber": 57,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 583,
    "kind": "method",
    "name": "receive",
    "memberof": "src/meta/control.js~ControlEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/control.js~ControlEngine#receive",
    "access": "public",
    "description": null,
    "lineNumber": 64,
    "undocument": true,
    "params": [
      {
        "name": "commandList",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 584,
    "kind": "function",
    "name": "Control",
    "memberof": "src/meta/control.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/meta/control.js~Control",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/meta/control.js",
    "importStyle": "{Control}",
    "description": "Condition an entire code block on the value of qubits being 1.",
    "examples": [
      "\nwith Control(eng, ctrlqubits)\ndo_something(otherqubits)\nEnter a controlled section.",
      "Control(eng, ctrlqubits, () => ...)"
    ],
    "lineNumber": 85,
    "params": [
      {
        "nullable": null,
        "types": [
          "BasicEngine"
        ],
        "spread": false,
        "optional": false,
        "name": "engine",
        "description": "Engine which handles the commands (usually MainEngine)"
      },
      {
        "nullable": null,
        "types": [
          "Array.<BasicQubit>"
        ],
        "spread": false,
        "optional": false,
        "name": "qubits",
        "description": "Qubits to condition on"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "func",
        "description": "Enter the section using a with-statement"
      }
    ],
    "return": null
  },
  {
    "__docId__": 585,
    "kind": "file",
    "name": "src/meta/dagger.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/**\r\nTools to easily invert a sequence of gates.\r\n\r\n @example\r\n Dagger(eng, () => {\r\n  H.or(qubit1)\r\n  new Rz(0.5).or(qubit2)\r\n})\r\n*/\r\n\r\nimport {BasicEngine} from '../cengines/basics'\r\nimport {Allocate, Deallocate} from '../ops/gates'\r\nimport {insertEngine, dropEngineAfter} from './util'\r\nimport {setEqual} from '../libs/polyfill';\r\nimport {QubitManagementError} from './error';\r\n\r\n/**\r\n * @class DaggerEngine\r\n * @desc\r\n *  Stores all commands and, when done, inverts the circuit & runs it.\r\n*/\r\nexport class DaggerEngine extends BasicEngine {\r\n  /**\r\n   * @constructor\r\n   */\r\n  constructor() {\r\n    super()\r\n    this.commands = []\r\n    this.allocateQubitIDs = new Set()\r\n    this.deallocateQubitIDs = new Set()\r\n  }\r\n\r\n  /**\r\n    Run the stored circuit in reverse and check that local qubits have been deallocated.\r\n   */\r\n  run() {\r\n    if (!setEqual(this.deallocateQubitIDs, this.allocateQubitIDs)) {\r\n      throw new QubitManagementError(\r\n        \"\\n Error. Qubits have been allocated in 'with \"\r\n          + \"Dagger(eng)' context,\\n which have not explicitely \"\r\n          + 'been deallocated.\\n'\r\n          + 'Correct usage:\\n'\r\n          + 'with Dagger(eng):\\n'\r\n          + '    qubit = eng.allocateQubit()\\n'\r\n          + '    ...\\n'\r\n          + '    del qubit[0]\\n'\r\n      )\r\n    }\r\n    this.commands.rforEach((cmd) => {\r\n      this.send([cmd.getInverse()])\r\n    })\r\n  }\r\n\r\n  /**\r\n    Receive a list of commands and store them for later inversion.\r\n    @param {Command[]} cmdList List of commands to temporarily store.\r\n  */\r\n  receive(cmdList) {\r\n    cmdList.forEach((cmd) => {\r\n      if (cmd.gate.equal(Allocate)) {\r\n        this.allocateQubitIDs.add(cmd.qubits[0][0].id)\r\n      } else if (cmd.gate.equal(Deallocate)) {\r\n        this.deallocateQubitIDs.add(cmd.qubits[0][0].id)\r\n      }\r\n    })\r\n    this.commands = this.commands.concat(cmdList)\r\n  }\r\n}\r\n\r\n/**\r\nInvert an entire code block.\r\n\r\n    Use it with a with-statement, i.e.,\r\n\r\n @example\r\n    Dagger(eng, () => [code to invert])\r\n\r\nWarning:\r\n    If the code to invert contains allocation of qubits, those qubits have\r\nto be deleted prior to exiting the 'with Dagger()' context.\r\n\r\n    This code is **NOT VALID**:\r\n\r\n @example\r\n  Dagger(eng, () => {\r\n    qb = eng.allocateQubit()\r\n    H.or(qb) // qb is still available!!!\r\n  })\r\nThe **correct way** of handling qubit (de-)allocation is as follows:\r\n\r\n @example\r\n  Dagger(eng, () => {\r\n    qb = eng.allocateQubit()\r\n    ...\r\n    qb.deallocate() // sends deallocate gate (which becomes an allocate)\r\n  })\r\n\r\n @param {BasicEngine} engine Engine which handles the commands (usually MainEngine)\r\n @param {function} func\r\n */\r\nexport function Dagger(engine, func) {\r\n  let daggerEngine = null\r\n\r\n  const enter = () => {\r\n    daggerEngine = new DaggerEngine()\r\n    insertEngine(engine, daggerEngine)\r\n  }\r\n\r\n  const exit = () => {\r\n    daggerEngine.run()\r\n    daggerEngine = null\r\n    dropEngineAfter(engine)\r\n  }\r\n\r\n  if (typeof func === 'function') {\r\n    enter()\r\n    try {\r\n      func()\r\n    } catch (e) {\r\n      throw e\r\n    } finally {\r\n      exit()\r\n    }\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/meta/dagger.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 586,
    "kind": "class",
    "name": "DaggerEngine",
    "memberof": "src/meta/dagger.js",
    "static": true,
    "longname": "src/meta/dagger.js~DaggerEngine",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/meta/dagger.js",
    "importStyle": "{DaggerEngine}",
    "description": " Stores all commands and, when done, inverts the circuit & runs it.",
    "lineNumber": 38,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "DaggerEngine"
      }
    ],
    "interface": false,
    "extends": [
      "src/cengines/basics.js~BasicEngine"
    ]
  },
  {
    "__docId__": 587,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/meta/dagger.js~DaggerEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/dagger.js~DaggerEngine#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 42,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ]
  },
  {
    "__docId__": 588,
    "kind": "member",
    "name": "commands",
    "memberof": "src/meta/dagger.js~DaggerEngine",
    "static": false,
    "longname": "src/meta/dagger.js~DaggerEngine#commands",
    "access": "public",
    "description": null,
    "lineNumber": 44,
    "undocument": true,
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 589,
    "kind": "member",
    "name": "allocateQubitIDs",
    "memberof": "src/meta/dagger.js~DaggerEngine",
    "static": false,
    "longname": "src/meta/dagger.js~DaggerEngine#allocateQubitIDs",
    "access": "public",
    "description": null,
    "lineNumber": 45,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 590,
    "kind": "member",
    "name": "deallocateQubitIDs",
    "memberof": "src/meta/dagger.js~DaggerEngine",
    "static": false,
    "longname": "src/meta/dagger.js~DaggerEngine#deallocateQubitIDs",
    "access": "public",
    "description": null,
    "lineNumber": 46,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 591,
    "kind": "method",
    "name": "run",
    "memberof": "src/meta/dagger.js~DaggerEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/dagger.js~DaggerEngine#run",
    "access": "public",
    "description": "Run the stored circuit in reverse and check that local qubits have been deallocated.",
    "lineNumber": 52,
    "params": [],
    "return": null
  },
  {
    "__docId__": 592,
    "kind": "method",
    "name": "receive",
    "memberof": "src/meta/dagger.js~DaggerEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/dagger.js~DaggerEngine#receive",
    "access": "public",
    "description": "Receive a list of commands and store them for later inversion.",
    "lineNumber": 74,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command[]"
        ],
        "spread": false,
        "optional": false,
        "name": "cmdList",
        "description": "List of commands to temporarily store."
      }
    ],
    "return": null
  },
  {
    "__docId__": 594,
    "kind": "function",
    "name": "Dagger",
    "memberof": "src/meta/dagger.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/meta/dagger.js~Dagger",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/meta/dagger.js",
    "importStyle": "{Dagger}",
    "description": "Invert an entire code block.\n\nUse it with a with-statement, i.e.,",
    "examples": [
      "Dagger(eng, () => [code to invert])\n\nWarning:\nIf the code to invert contains allocation of qubits, those qubits have\nto be deleted prior to exiting the 'with Dagger()' context.\n\nThis code is **NOT VALID**:",
      "Dagger(eng, () => {\nqb = eng.allocateQubit()\nH.or(qb) // qb is still available!!!\n})\nThe **correct way** of handling qubit (de-)allocation is as follows:",
      "Dagger(eng, () => {\nqb = eng.allocateQubit()\n...\nqb.deallocate() // sends deallocate gate (which becomes an allocate)\n})"
    ],
    "lineNumber": 117,
    "params": [
      {
        "nullable": null,
        "types": [
          "BasicEngine"
        ],
        "spread": false,
        "optional": false,
        "name": "engine",
        "description": "Engine which handles the commands (usually MainEngine)"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "func",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 595,
    "kind": "file",
    "name": "src/meta/error.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nexport class NotMergeable extends Error {\r\n  constructor(...args) {\r\n    super(...args)\r\n    this.__proto__ = NotMergeable.prototype\r\n  }\r\n}\r\n\r\nexport class LastEngineError extends Error {\r\n  constructor(...args) {\r\n    super(...args)\r\n    this.__proto__ = LastEngineError.prototype\r\n  }\r\n}\r\n\r\nexport class QubitManagementError extends Error {\r\n  constructor(...args) {\r\n    super(...args)\r\n    this.__proto__ = QubitManagementError.prototype\r\n  }\r\n}\r\n\r\nexport class NotYetMeasuredError extends Error {\r\n  constructor(...args) {\r\n    super(...args)\r\n    this.__proto__ = NotYetMeasuredError.prototype\r\n  }\r\n}\r\n\r\nexport class NoGateDecompositionError extends Error {\r\n  constructor(...args) {\r\n    super(...args)\r\n    this.__proto__ = NoGateDecompositionError.prototype\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/meta/error.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 596,
    "kind": "class",
    "name": "NotMergeable",
    "memberof": "src/meta/error.js",
    "static": true,
    "longname": "src/meta/error.js~NotMergeable",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/meta/error.js",
    "importStyle": "{NotMergeable}",
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "interface": false,
    "extends": [
      "Error"
    ]
  },
  {
    "__docId__": 597,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/meta/error.js~NotMergeable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/error.js~NotMergeable#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 18,
    "undocument": true
  },
  {
    "__docId__": 598,
    "kind": "member",
    "name": "__proto__",
    "memberof": "src/meta/error.js~NotMergeable",
    "static": false,
    "longname": "src/meta/error.js~NotMergeable#__proto__",
    "access": "private",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 599,
    "kind": "class",
    "name": "LastEngineError",
    "memberof": "src/meta/error.js",
    "static": true,
    "longname": "src/meta/error.js~LastEngineError",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/meta/error.js",
    "importStyle": "{LastEngineError}",
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "interface": false,
    "extends": [
      "Error"
    ]
  },
  {
    "__docId__": 600,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/meta/error.js~LastEngineError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/error.js~LastEngineError#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 25,
    "undocument": true
  },
  {
    "__docId__": 601,
    "kind": "member",
    "name": "__proto__",
    "memberof": "src/meta/error.js~LastEngineError",
    "static": false,
    "longname": "src/meta/error.js~LastEngineError#__proto__",
    "access": "private",
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 602,
    "kind": "class",
    "name": "QubitManagementError",
    "memberof": "src/meta/error.js",
    "static": true,
    "longname": "src/meta/error.js~QubitManagementError",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/meta/error.js",
    "importStyle": "{QubitManagementError}",
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "interface": false,
    "extends": [
      "Error"
    ]
  },
  {
    "__docId__": 603,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/meta/error.js~QubitManagementError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/error.js~QubitManagementError#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 32,
    "undocument": true
  },
  {
    "__docId__": 604,
    "kind": "member",
    "name": "__proto__",
    "memberof": "src/meta/error.js~QubitManagementError",
    "static": false,
    "longname": "src/meta/error.js~QubitManagementError#__proto__",
    "access": "private",
    "description": null,
    "lineNumber": 34,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 605,
    "kind": "class",
    "name": "NotYetMeasuredError",
    "memberof": "src/meta/error.js",
    "static": true,
    "longname": "src/meta/error.js~NotYetMeasuredError",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/meta/error.js",
    "importStyle": "{NotYetMeasuredError}",
    "description": null,
    "lineNumber": 38,
    "undocument": true,
    "interface": false,
    "extends": [
      "Error"
    ]
  },
  {
    "__docId__": 606,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/meta/error.js~NotYetMeasuredError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/error.js~NotYetMeasuredError#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 39,
    "undocument": true
  },
  {
    "__docId__": 607,
    "kind": "member",
    "name": "__proto__",
    "memberof": "src/meta/error.js~NotYetMeasuredError",
    "static": false,
    "longname": "src/meta/error.js~NotYetMeasuredError#__proto__",
    "access": "private",
    "description": null,
    "lineNumber": 41,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 608,
    "kind": "class",
    "name": "NoGateDecompositionError",
    "memberof": "src/meta/error.js",
    "static": true,
    "longname": "src/meta/error.js~NoGateDecompositionError",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/meta/error.js",
    "importStyle": "{NoGateDecompositionError}",
    "description": null,
    "lineNumber": 45,
    "undocument": true,
    "interface": false,
    "extends": [
      "Error"
    ]
  },
  {
    "__docId__": 609,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/meta/error.js~NoGateDecompositionError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/error.js~NoGateDecompositionError#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 46,
    "undocument": true
  },
  {
    "__docId__": 610,
    "kind": "member",
    "name": "__proto__",
    "memberof": "src/meta/error.js~NoGateDecompositionError",
    "static": false,
    "longname": "src/meta/error.js~NoGateDecompositionError#__proto__",
    "access": "private",
    "description": null,
    "lineNumber": 48,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 611,
    "kind": "file",
    "name": "src/meta/index.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nexport {Compute, CustomUncompute, Uncompute, UncomputeEngine, ComputeEngine} from './compute'\r\n\r\nexport {Control, ControlEngine} from './control'\r\n\r\nexport {Dagger, DaggerEngine} from './dagger'\r\n\r\nexport {Loop, LoopTag, LoopEngine} from './loop'\r\n\r\nexport {LogicalQubitIDTag, DirtyQubitTag, ComputeTag, UncomputeTag} from './tag'\r\n\r\nexport {insertEngine, dropEngineAfter} from './util'\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/meta/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 612,
    "kind": "file",
    "name": "src/meta/loop.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport {BasicEngine} from '../cengines/basics'\r\nimport {setEqual} from '../libs/polyfill';\r\nimport {dropEngineAfter, insertEngine} from './util';\r\nimport {Allocate, Deallocate} from '../ops/gates'\r\nimport {QubitManagementError} from './error'\r\n\r\n/**\r\n * @class LoopTag\r\n */\r\nexport class LoopTag {\r\n  /**\r\n   * @constructor\r\n   * @param {number} num\r\n   */\r\n  constructor(num) {\r\n    this.num = num\r\n    this.id = LoopTag.loop_tag_id\r\n    LoopTag.loop_tag_id += 1\r\n  }\r\n\r\n  equal(other) {\r\n    return other instanceof LoopTag && other.id === this.id && this.num === other.num\r\n  }\r\n}\r\n\r\nLoopTag.loop_tag_id = 0\r\n\r\n/**\r\n * @class LoopEngine\r\n * @desc\r\nStores all commands and, when done, executes them num times if no loop tag\r\nhandler engine is available.\r\n    If there is one, it adds a loop_tag to the commands and sends them on.\r\n */\r\nexport class LoopEngine extends BasicEngine {\r\n  /**\r\n   * @constructor\r\n    @param {number} num Number of loop iterations.\r\n   */\r\n  constructor(num) {\r\n    super()\r\n    this._tag = new LoopTag(num)\r\n    this._cmdList = []\r\n    this._allocatedQubitIDs = new Set()\r\n    this._deallocatedQubitIDs = new Set()\r\n    // key: qubit id of a local qubit, i.e. a qubit which has been allocated\r\n    //     and deallocated within the loop body.\r\n    // value: list contain reference to each weakref qubit with this qubit\r\n    //        id either within control_qubits or qubits.\r\n    this._refsToLocalQB = {}\r\n    this._nextEnginesSupportLoopTag = false\r\n  }\r\n\r\n  /**\r\n  Apply the loop statements to all stored commands.\r\n   Unrolls the loop if LoopTag is not supported by any of the following engines, i.e., if\r\n\r\n   @example\r\n    is_meta_tag_supported(next_engine, LoopTag) == false\r\n   */\r\n  run() {\r\n    const error_message = ('\\n Error. Qubits have been allocated in with '\r\n    + 'Loop(eng, num) context,\\n which have not '\r\n    + 'explicitely been deallocated in the Loop context.\\n'\r\n    + 'Correct usage:\\nLoop(eng, 5):\\n'\r\n    + '    qubit = eng.allocateQubit()\\n'\r\n    + '    ...\\n'\r\n    + '    qubit[0].deallocate()\\n')\r\n\r\n    if (!this._nextEnginesSupportLoopTag) {\r\n      // Unroll the loop\r\n      // Check that local qubits have been deallocated\r\n      if (!setEqual(this._deallocatedQubitIDs, this._allocatedQubitIDs)) {\r\n        throw new QubitManagementError(error_message)\r\n      }\r\n      if (this._allocatedQubitIDs.size === 0) {\r\n        // No local qubits, just send the circuit num times\r\n        for (let i = 0; i < this._tag.num; ++i) {\r\n          this.send(this._cmdList.slice(0))\r\n        }\r\n      } else {\r\n        // Ancilla qubits have been allocated in loop body\r\n        // For each iteration, allocate and deallocate a new qubit and\r\n        // replace the qubit id in all commands using it.\r\n        for (let i = 0; i < this._tag.num; ++i) {\r\n          if (i === 0) {\r\n            this.send(this._cmdList.map(cmd => cmd.copy()))\r\n          } else {\r\n            // Change local qubit ids before sending them\r\n            Object.values(this._refsToLocalQB).forEach(refs_loc_qubit => {\r\n              const new_qb_id = this.main.getNewQubitID()\r\n              refs_loc_qubit.forEach(qubitRef => qubitRef.id = new_qb_id)\r\n            })\r\n            this.send(this._cmdList.map(cmd => cmd.copy()))\r\n          }\r\n        }\r\n      }\r\n    } else if (!setEqual(this._deallocatedQubitIDs, this._allocatedQubitIDs)) {\r\n      throw new QubitManagementError(error_message)\r\n    }\r\n  }\r\n\r\n  /**\r\n  Receive (and potentially temporarily store) all commands.\r\n\r\n    Add LoopTag to all receiving commands and send to the next engine if\r\n    a further engine is a LoopTag-handling engine. Otherwise store all\r\ncommands (to later unroll them). Check that within the loop body,\r\n    all allocated qubits have also been deallocated. If loop needs to be\r\nunrolled and ancilla qubits have been allocated within the loop body,\r\n    then store a reference all these qubit ids (to change them when\r\nunrolling the loop)\r\n\r\n@param {Command[]} commandList List of commands to store and later\r\nunroll or, if there is a LoopTag-handling engine, add the LoopTag.\r\n   */\r\n  receive(commandList) {\r\n    if (this._nextEnginesSupportLoopTag || this.next.isMetaTagSupported(LoopTag)) {\r\n      // Loop tag is supported, send everything with a LoopTag\r\n      // Don't check is_meta_tag_supported anymore\r\n      this._nextEnginesSupportLoopTag = true\r\n      if (this._tag.num === 0) {\r\n        return\r\n      }\r\n      commandList.forEach((cmd) => {\r\n        if (cmd.gate.equal(Allocate)) {\r\n          this._allocatedQubitIDs.add(cmd.qubits[0][0].id)\r\n        } else if (cmd.gate.equal(Deallocate)) {\r\n          this._deallocatedQubitIDs.add(cmd.qubits[0][0].id)\r\n        }\r\n        cmd.tags.push(this._tag)\r\n        this.send([cmd])\r\n      })\r\n    } else {\r\n      // LoopTag is not supported, save the full loop body\r\n      this._cmdList = this._cmdList.concat(commandList)\r\n      // Check for all local qubits allocated and deallocated in loop body\r\n      commandList.forEach((cmd) => {\r\n        const qb = cmd.qubits[0][0]\r\n        const qid = qb.id\r\n        if (cmd.gate.equal(Allocate)) {\r\n          this._allocatedQubitIDs.add(qid)\r\n          this._refsToLocalQB[qid] = [qb]\r\n        } else if (cmd.gate.equal(Deallocate)) {\r\n          this._deallocatedQubitIDs.add(qid)\r\n          this._refsToLocalQB[qid].push(qb)\r\n        } else {\r\n          cmd.controlQubits.forEach((ctrlQubit) => {\r\n            const v = this._allocatedQubitIDs.has(ctrlQubit.id)\r\n            if (v) {\r\n              this._refsToLocalQB[ctrlQubit.id].push(ctrlQubit)\r\n            }\r\n          })\r\n          cmd.qubits.forEach(qureg => qureg.forEach((qubit) => {\r\n            if (this._allocatedQubitIDs.has(qubit.id)) {\r\n              this._refsToLocalQB[qubit.id].push(qubit)\r\n            }\r\n          }))\r\n        }\r\n      })\r\n    }\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @param {BasicEngine} engine\r\n * @param {number} num\r\n * @param {function} func\r\nLoop n times over an entire code block.\r\n\r\n    @example\r\n    Loop(eng, 4, () => { })\r\n    // [quantum gates to be executed 4 times]\r\n\r\nWarning:\r\n    If the code in the loop contains allocation of qubits, those qubits\r\nhave to be deleted prior to exiting the 'Loop()' context.\r\n\r\n    This code is **NOT VALID**:\r\n\r\n @example\r\n\r\n  Loop(eng, 4, () => {\r\n    qb = eng.allocateQubit()\r\n    H.or(qb) // qb is still available!!!\r\n  })\r\n\r\nThe **correct way** of handling qubit (de-)allocation is as follows:\r\n\r\n @example\r\n  Loop(eng, 4, () => {\r\n    qb = eng.allocateQubit()\r\n    ...\r\n    qb.deallocate() // sends deallocate gate\r\n  })\r\n */\r\nexport function Loop(engine, num, func) {\r\n  if (typeof num === 'number' && num >= 0 && num % 1 === 0) {\r\n    const _num = num\r\n    let _loopEngine\r\n    const enter = () => {\r\n      if (_num !== 1) {\r\n        _loopEngine = new LoopEngine(num)\r\n        insertEngine(engine, _loopEngine)\r\n      }\r\n    }\r\n\r\n    const exit = () => {\r\n      if (_num !== 1) {\r\n        _loopEngine.run()\r\n        _loopEngine = null\r\n        dropEngineAfter(engine)\r\n      }\r\n    }\r\n\r\n    if (typeof func === 'function') {\r\n      enter()\r\n      try {\r\n        func()\r\n      } catch (e) {\r\n        throw e\r\n      } finally {\r\n        exit()\r\n      }\r\n    }\r\n  } else {\r\n    throw new Error('invalid number of loop iterations')\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/meta/loop.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 613,
    "kind": "class",
    "name": "LoopTag",
    "memberof": "src/meta/loop.js",
    "static": true,
    "longname": "src/meta/loop.js~LoopTag",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/meta/loop.js",
    "importStyle": "{LoopTag}",
    "description": "",
    "lineNumber": 26,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "LoopTag"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 614,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/meta/loop.js~LoopTag",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/loop.js~LoopTag#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 31,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "num",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 615,
    "kind": "member",
    "name": "num",
    "memberof": "src/meta/loop.js~LoopTag",
    "static": false,
    "longname": "src/meta/loop.js~LoopTag#num",
    "access": "public",
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 616,
    "kind": "member",
    "name": "id",
    "memberof": "src/meta/loop.js~LoopTag",
    "static": false,
    "longname": "src/meta/loop.js~LoopTag#id",
    "access": "public",
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 617,
    "kind": "method",
    "name": "equal",
    "memberof": "src/meta/loop.js~LoopTag",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/loop.js~LoopTag#equal",
    "access": "public",
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "params": [
      {
        "name": "other",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 618,
    "kind": "class",
    "name": "LoopEngine",
    "memberof": "src/meta/loop.js",
    "static": true,
    "longname": "src/meta/loop.js~LoopEngine",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/meta/loop.js",
    "importStyle": "{LoopEngine}",
    "description": "Stores all commands and, when done, executes them num times if no loop tag\nhandler engine is available.\nIf there is one, it adds a loop_tag to the commands and sends them on.",
    "lineNumber": 51,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "LoopEngine"
      }
    ],
    "interface": false,
    "extends": [
      "src/cengines/basics.js~BasicEngine"
    ]
  },
  {
    "__docId__": 619,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/meta/loop.js~LoopEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/loop.js~LoopEngine#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 56,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "num",
        "description": "Number of loop iterations."
      }
    ]
  },
  {
    "__docId__": 620,
    "kind": "member",
    "name": "_tag",
    "memberof": "src/meta/loop.js~LoopEngine",
    "static": false,
    "longname": "src/meta/loop.js~LoopEngine#_tag",
    "access": "private",
    "description": null,
    "lineNumber": 58,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 621,
    "kind": "member",
    "name": "_cmdList",
    "memberof": "src/meta/loop.js~LoopEngine",
    "static": false,
    "longname": "src/meta/loop.js~LoopEngine#_cmdList",
    "access": "private",
    "description": null,
    "lineNumber": 59,
    "undocument": true,
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 622,
    "kind": "member",
    "name": "_allocatedQubitIDs",
    "memberof": "src/meta/loop.js~LoopEngine",
    "static": false,
    "longname": "src/meta/loop.js~LoopEngine#_allocatedQubitIDs",
    "access": "private",
    "description": null,
    "lineNumber": 60,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 623,
    "kind": "member",
    "name": "_deallocatedQubitIDs",
    "memberof": "src/meta/loop.js~LoopEngine",
    "static": false,
    "longname": "src/meta/loop.js~LoopEngine#_deallocatedQubitIDs",
    "access": "private",
    "description": null,
    "lineNumber": 61,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 624,
    "kind": "member",
    "name": "_refsToLocalQB",
    "memberof": "src/meta/loop.js~LoopEngine",
    "static": false,
    "longname": "src/meta/loop.js~LoopEngine#_refsToLocalQB",
    "access": "private",
    "description": null,
    "lineNumber": 66,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 625,
    "kind": "member",
    "name": "_nextEnginesSupportLoopTag",
    "memberof": "src/meta/loop.js~LoopEngine",
    "static": false,
    "longname": "src/meta/loop.js~LoopEngine#_nextEnginesSupportLoopTag",
    "access": "private",
    "description": null,
    "lineNumber": 67,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 626,
    "kind": "method",
    "name": "run",
    "memberof": "src/meta/loop.js~LoopEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/loop.js~LoopEngine#run",
    "access": "public",
    "description": "Apply the loop statements to all stored commands.\nUnrolls the loop if LoopTag is not supported by any of the following engines, i.e., if",
    "examples": [
      "is_meta_tag_supported(next_engine, LoopTag) == false"
    ],
    "lineNumber": 77,
    "params": [],
    "return": null
  },
  {
    "__docId__": 627,
    "kind": "method",
    "name": "receive",
    "memberof": "src/meta/loop.js~LoopEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/loop.js~LoopEngine#receive",
    "access": "public",
    "description": "Receive (and potentially temporarily store) all commands.\n\nAdd LoopTag to all receiving commands and send to the next engine if\na further engine is a LoopTag-handling engine. Otherwise store all\ncommands (to later unroll them). Check that within the loop body,\nall allocated qubits have also been deallocated. If loop needs to be\nunrolled and ancilla qubits have been allocated within the loop body,\nthen store a reference all these qubit ids (to change them when\nunrolling the loop)",
    "lineNumber": 133,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command[]"
        ],
        "spread": false,
        "optional": false,
        "name": "commandList",
        "description": "List of commands to store and later\nunroll or, if there is a LoopTag-handling engine, add the LoopTag."
      }
    ],
    "return": null
  },
  {
    "__docId__": 630,
    "kind": "function",
    "name": "Loop",
    "memberof": "src/meta/loop.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/meta/loop.js~Loop",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/meta/loop.js",
    "importStyle": "{Loop}",
    "description": "",
    "examples": [
      "Loop(eng, 4, () => { })\n// [quantum gates to be executed 4 times]\n\nWarning:\nIf the code in the loop contains allocation of qubits, those qubits\nhave to be deleted prior to exiting the 'Loop()' context.\n\nThis code is **NOT VALID**:",
      "\nLoop(eng, 4, () => {\nqb = eng.allocateQubit()\nH.or(qb) // qb is still available!!!\n})\n\nThe **correct way** of handling qubit (de-)allocation is as follows:",
      "Loop(eng, 4, () => {\nqb = eng.allocateQubit()\n...\nqb.deallocate() // sends deallocate gate\n})"
    ],
    "lineNumber": 214,
    "params": [
      {
        "nullable": null,
        "types": [
          "BasicEngine"
        ],
        "spread": false,
        "optional": false,
        "name": "engine",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "num",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "func",
        "description": "Loop n times over an entire code block."
      }
    ],
    "return": null
  },
  {
    "__docId__": 631,
    "kind": "file",
    "name": "src/meta/tag.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/**\r\n * @class ComputeTag\r\n */\r\nexport class ComputeTag {\r\n  equal(other) {\r\n    return other instanceof ComputeTag\r\n  }\r\n}\r\n\r\n/**\r\n * @class UncomputeTag\r\n */\r\nexport class UncomputeTag {\r\n  equal(other) {\r\n    return other instanceof UncomputeTag\r\n  }\r\n}\r\n\r\n/**\r\n * @class DirtyQubitTag\r\n */\r\nexport class DirtyQubitTag {\r\n  equal(other) {\r\n    return other instanceof DirtyQubitTag\r\n  }\r\n}\r\n\r\n/**\r\n * @class LogicalQubitIDTag\r\n */\r\nexport class LogicalQubitIDTag {\r\n  /**\r\n   * @constructor\r\n   * @param {number} logical_qubit_id\r\n   */\r\n  constructor(logical_qubit_id) {\r\n    this.logical_qubit_id = logical_qubit_id\r\n  }\r\n\r\n  equal(other) {\r\n    return other instanceof LogicalQubitIDTag && other.logical_qubit_id === this.logical_qubit_id\r\n  }\r\n\r\n  /**\r\n   * check if self is in `array`\r\n   * @param array\r\n   * @return {boolean}\r\n   */\r\n  isInArray(array) {\r\n    if (Array.isArray(array)) {\r\n      for (let i = 0; i < array.length; ++i) {\r\n        if (this.equal(array[i])) {\r\n          return true\r\n        }\r\n      }\r\n    }\r\n    return false\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/meta/tag.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 632,
    "kind": "class",
    "name": "ComputeTag",
    "memberof": "src/meta/tag.js",
    "static": true,
    "longname": "src/meta/tag.js~ComputeTag",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/meta/tag.js",
    "importStyle": "{ComputeTag}",
    "description": "",
    "lineNumber": 20,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "ComputeTag"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 633,
    "kind": "method",
    "name": "equal",
    "memberof": "src/meta/tag.js~ComputeTag",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/tag.js~ComputeTag#equal",
    "access": "public",
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "params": [
      {
        "name": "other",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 634,
    "kind": "class",
    "name": "UncomputeTag",
    "memberof": "src/meta/tag.js",
    "static": true,
    "longname": "src/meta/tag.js~UncomputeTag",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/meta/tag.js",
    "importStyle": "{UncomputeTag}",
    "description": "",
    "lineNumber": 29,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "UncomputeTag"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 635,
    "kind": "method",
    "name": "equal",
    "memberof": "src/meta/tag.js~UncomputeTag",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/tag.js~UncomputeTag#equal",
    "access": "public",
    "description": null,
    "lineNumber": 30,
    "undocument": true,
    "params": [
      {
        "name": "other",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 636,
    "kind": "class",
    "name": "DirtyQubitTag",
    "memberof": "src/meta/tag.js",
    "static": true,
    "longname": "src/meta/tag.js~DirtyQubitTag",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/meta/tag.js",
    "importStyle": "{DirtyQubitTag}",
    "description": "",
    "lineNumber": 38,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "DirtyQubitTag"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 637,
    "kind": "method",
    "name": "equal",
    "memberof": "src/meta/tag.js~DirtyQubitTag",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/tag.js~DirtyQubitTag#equal",
    "access": "public",
    "description": null,
    "lineNumber": 39,
    "undocument": true,
    "params": [
      {
        "name": "other",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 638,
    "kind": "class",
    "name": "LogicalQubitIDTag",
    "memberof": "src/meta/tag.js",
    "static": true,
    "longname": "src/meta/tag.js~LogicalQubitIDTag",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/meta/tag.js",
    "importStyle": "{LogicalQubitIDTag}",
    "description": "",
    "lineNumber": 47,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "LogicalQubitIDTag"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 639,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/meta/tag.js~LogicalQubitIDTag",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/tag.js~LogicalQubitIDTag#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 52,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "logical_qubit_id",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 640,
    "kind": "member",
    "name": "logical_qubit_id",
    "memberof": "src/meta/tag.js~LogicalQubitIDTag",
    "static": false,
    "longname": "src/meta/tag.js~LogicalQubitIDTag#logical_qubit_id",
    "access": "public",
    "description": null,
    "lineNumber": 53,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 641,
    "kind": "method",
    "name": "equal",
    "memberof": "src/meta/tag.js~LogicalQubitIDTag",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/tag.js~LogicalQubitIDTag#equal",
    "access": "public",
    "description": null,
    "lineNumber": 56,
    "undocument": true,
    "params": [
      {
        "name": "other",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 642,
    "kind": "method",
    "name": "isInArray",
    "memberof": "src/meta/tag.js~LogicalQubitIDTag",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/tag.js~LogicalQubitIDTag#isInArray",
    "access": "public",
    "description": "check if self is in `array`",
    "lineNumber": 65,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "array",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 643,
    "kind": "file",
    "name": "src/meta/util.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/**\r\nInserts an engine into the singly-linked list of engines.\r\n    It also sets the correct main_engine for engine_to_insert.\r\n\r\n@param {BasicEngine} prevEngine The engine just before the insertion point.\r\n@param {BasicEngine} engineToInsert The engine to insert at the insertion point.\r\n */\r\nexport function insertEngine(prevEngine, engineToInsert) {\r\n  engineToInsert.main = prevEngine.main\r\n  engineToInsert.next = prevEngine.next\r\n  prevEngine.next = engineToInsert\r\n}\r\n\r\n/**\r\nRemoves an engine from the singly-linked list of engines.\r\n\r\n    @param {BasicEngine} engine The engine just before the engine to drop.\r\n    @return {BasicEngine} The dropped engine.\r\n */\r\nexport function dropEngineAfter(engine) {\r\n  const e = engine.next\r\n  engine.next = e.next\r\n  delete e.next\r\n  delete e.main\r\n  return e\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/meta/util.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 644,
    "kind": "function",
    "name": "insertEngine",
    "memberof": "src/meta/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/meta/util.js~insertEngine",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/meta/util.js",
    "importStyle": "{insertEngine}",
    "description": "Inserts an engine into the singly-linked list of engines.\nIt also sets the correct main_engine for engine_to_insert.",
    "lineNumber": 24,
    "params": [
      {
        "nullable": null,
        "types": [
          "BasicEngine"
        ],
        "spread": false,
        "optional": false,
        "name": "prevEngine",
        "description": "The engine just before the insertion point."
      },
      {
        "nullable": null,
        "types": [
          "BasicEngine"
        ],
        "spread": false,
        "optional": false,
        "name": "engineToInsert",
        "description": "The engine to insert at the insertion point."
      }
    ],
    "return": null
  },
  {
    "__docId__": 645,
    "kind": "function",
    "name": "dropEngineAfter",
    "memberof": "src/meta/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/meta/util.js~dropEngineAfter",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/meta/util.js",
    "importStyle": "{dropEngineAfter}",
    "description": "Removes an engine from the singly-linked list of engines.",
    "lineNumber": 36,
    "params": [
      {
        "nullable": null,
        "types": [
          "BasicEngine"
        ],
        "spread": false,
        "optional": false,
        "name": "engine",
        "description": "The engine just before the engine to drop."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "BasicEngine"
      ],
      "spread": false,
      "description": "The dropped engine."
    }
  },
  {
    "__docId__": 646,
    "kind": "file",
    "name": "src/ops/basics.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/**\r\nDefines the BasicGate class, the base class of all gates, the\r\nBasicRotationGate class, the SelfInverseGate, the FastForwardingGate, the\r\nClassicalInstruction gate, and the BasicMathGate class.\r\n\r\nGates overload the | operator to allow the following syntax:\r\n\r\n @example\r\nGate | (qureg1, qureg2, qureg2)\r\nGate | (qureg, qubit)\r\nGate | qureg\r\nGate | qubit\r\nGate | (qubit,)\r\n\r\nThis means that for more than one quantum argument (right side of | ), a tuple\r\nneeds to be made explicitely, while for one argument it is optional.\r\n*/\r\nimport math from 'mathjs'\r\nimport { BasicQubit } from '../types/qubit'\r\nimport Command from './command'\r\nimport {arrayIsTuple, ObjectCopy} from '../libs/util'\r\nimport {NotMergeable} from '../meta/error'\r\n\r\nconst ANGLE_PRECISION = 12\r\nconst ANGLE_TOLERANCE = 10 ** -ANGLE_PRECISION\r\n\r\n/**\r\n * @abstract\r\n * @class BasicGate\r\n * @desc Base class of all gates.\r\n */\r\nexport class BasicGate {\r\n  /**\r\n   * @constructor\r\n    Note:\r\nSet interchangeable qubit indices!\r\n    (gate.interchangeable_qubit_indices)\r\n\r\nAs an example, consider\r\n\r\n   @example\r\n   ExampleGate | (a,b,c,d,e)\r\n\r\nwhere a and b are interchangeable. Then, call this function as\r\nfollows:\r\n\r\n   @example\r\n   this.set_interchangeable_qubit_indices([[0,1]])\r\n\r\nAs another example, consider\r\n\r\n   @example\r\n   ExampleGate2 | (a,b,c,d,e)\r\n\r\nwhere a and b are interchangeable and, in addition, c, d, and e\r\nare interchangeable among themselves. Then, call this function as\r\n\r\n   @example\r\n    this.set_interchangeable_qubit_indices([[0,1],[2,3,4]])\r\n  */\r\n  constructor() {\r\n    this.interchangeableQubitIndices = []\r\n  }\r\n\r\n  /**\r\n   * @throws {Error}\r\n   */\r\n  getInverse() {\r\n    throw new Error('BasicGate: No getInverse() implemented.')\r\n  }\r\n\r\n  /**\r\n   * @throws {NotMergeable}\r\n   */\r\n  getMerged() {\r\n    throw new NotMergeable('BasicGate: No getMerged() implemented.')\r\n  }\r\n\r\n  /**\r\n   * @throws {Error}\r\n   */\r\n  toString() {\r\n    throw new Error('BasicGate: No toString() implemented.')\r\n  }\r\n\r\n  /**\r\n   * @return {string}\r\n   */\r\n  inspect() {\r\n    return this.toString()\r\n  }\r\n\r\n  /**\r\n    Convert quantum input of \"gate | quantum input\" to internal formatting.\r\n\r\n    A Command object only accepts tuples of Quregs (list of Qubit objects)\r\nas qubits input parameter. However, with this function we allow the\r\nuser to use a more flexible syntax:\r\n\r\n    1) Gate | qubit\r\n    2) Gate | [qubit0, qubit1]\r\n    3) Gate | qureg\r\n    4) Gate | (qubit, )\r\n    5) Gate | (qureg, qubit)\r\n\r\nwhere qubit is a Qubit object and qureg is a Qureg object. This\r\nfunction takes the right hand side of | and transforms it to the\r\ncorrect input parameter of a Command object which is:\r\n\r\n    1) -> Gate | ([qubit], )\r\n    2) -> Gate | ([qubit0, qubit1], )\r\n    3) -> Gate | (qureg, )\r\n    4) -> Gate | ([qubit], )\r\n    5) -> Gate | (qureg, [qubit])\r\n\r\n@param {Qubit|Qubit[]|Qureg|Qureg[]} qubits a Qubit object, a list of Qubit objects, a Qureg object,\r\n    or a tuple of Qubit or Qureg objects (can be mixed).\r\n@returns {Qureg[]} Canonical representation A tuple containing Qureg (or list of Qubits) objects.\r\n     */\r\n  static makeTupleOfQureg(qubits) {\r\n    const isTuple = arrayIsTuple(qubits)\r\n    if (!isTuple) {\r\n      qubits = [qubits]\r\n    }\r\n    qubits.forEach((looper, idx) => {\r\n      if (looper instanceof BasicQubit) {\r\n        qubits[idx] = [looper]\r\n      }\r\n    })\r\n    return qubits.slice(0)\r\n  }\r\n\r\n  /**\r\n    Helper function to generate a command consisting of the gate and the qubits being acted upon.\r\n\r\n    @param qubits {Qubit | Array.<Qubit> | Qureg} see BasicGate.makeTupleOfQureg(qubits)\r\n    @return {Command} A Command object containing the gate and the qubits.\r\n  */\r\n  generateCommand(qubits) {\r\n    const qs = BasicGate.makeTupleOfQureg(qubits)\r\n    const engines = []\r\n    qs.forEach((reg) => {\r\n      reg.forEach(q => engines.push(q.engine))\r\n    })\r\n    const eng = engines[0]\r\n    return new Command(eng, this, qs)\r\n  }\r\n\r\n  /**\r\n    Operator| overload which enables the syntax Gate | qubits.\r\n\r\n    @example\r\n1) Gate | qubit\r\n2) Gate | [qubit0, qubit1]\r\n3) Gate | qureg\r\n4) Gate | (qubit, )\r\n5) Gate | (qureg, qubit)\r\n\r\n   @param qubits {Qubit | Array.<Qubit> | Qureg}\r\n   a Qubit object, a list of Qubit objects, a Qureg object,\r\n   or a tuple of Qubit or Qureg objects (can be mixed).\r\n  */\r\n  or(qubits) {\r\n    const cmd = this.generateCommand(qubits)\r\n    cmd.apply()\r\n  }\r\n\r\n  /**\r\n   * @param {BasicGate | Object} other\r\n   * @return {boolean}\r\n   */\r\n  equal(other) {\r\n    return this.__proto__ === other.__proto__\r\n  }\r\n\r\n  /**\r\n   * @return {BasicGate}\r\n   */\r\n  copy() {\r\n    return ObjectCopy(this)\r\n  }\r\n}\r\n\r\n/**\r\n * @class SelfInverseGate\r\n * @desc Self-inverse basic gate class.\r\n * Automatic implementation of the getInverse-member function for self-inverse gates.\r\n * @example\r\n   // getInverse(H) == H, it is a self-inverse gate:\r\n    getInverse(H) | qubit\r\n */\r\nexport class SelfInverseGate extends BasicGate {\r\n  getInverse() {\r\n    return ObjectCopy(this)\r\n  }\r\n}\r\n\r\n/**\r\n * @class BasicRotationGate\r\n * @desc\r\nDefines a base class of a rotation gate.\r\n\r\n    A rotation gate has a continuous parameter (the angle), labeled 'angle' /\r\nthis.angle. Its inverse is the same gate with the negated argument.\r\n    Rotation gates of the same class can be merged by adding the angles.\r\n    The continuous parameter is modulo 4 * pi, this.angle is in the interval\r\n    [0, 4 * pi).\r\n */\r\nexport class BasicRotationGate extends BasicGate {\r\n  /**\r\n   * @constructor\r\n      Initialize a basic rotation gate.\r\n    @param angle {number} Angle of rotation (saved modulo 4 * pi)\r\n   */\r\n  constructor(angle, ...args) {\r\n    super(...args)\r\n\r\n    let rounded_angle = math.round(math.mod(angle, 4.0 * Math.PI), ANGLE_PRECISION)\r\n    if (rounded_angle > 4 * Math.PI - ANGLE_TOLERANCE) {\r\n      rounded_angle = 0.0\r\n    }\r\n    this.angle = rounded_angle\r\n  }\r\n\r\n  /**\r\n   * @return {BasicRotationGate}\r\nReturn the inverse of this rotation gate (negate the angle, return new\r\nobject).\r\n     */\r\n  getInverse() {\r\n    if (this.angle == 0) {\r\n      return new this.__proto__.constructor(0)\r\n    } else {\r\n      return new this.__proto__.constructor(-this.angle + 4 * Math.PI)\r\n    }\r\n  }\r\n\r\n  /**\r\n    Return self merged with another gate.\r\n\r\n    Default implementation handles rotation gate of the same type, where\r\nangles are simply added.\r\n\r\n    @param {BasicRotationGate|Object} other\r\n    @throws {NotMergeable}  For non-rotation gates or rotation gates of different type.\r\n    @return {BasicRotationGate} New object representing the merged gates.\r\n   */\r\n  getMerged(other) {\r\n    if (other instanceof BasicRotationGate) {\r\n      return new this.__proto__.constructor(this.angle + other.angle)\r\n    }\r\n    throw new NotMergeable('Can\\'t merge different types of rotation gates.')\r\n  }\r\n\r\n  toString() {\r\n    return `${this.constructor.name}(${this.angle})`\r\n  }\r\n\r\n  /**\r\n    Return the Latex string representation of a BasicRotationGate.\r\n\r\n  Returns the class name and the angle as a subscript, i.e.\r\n\r\n   @example\r\n  [CLASSNAME]$_[ANGLE]$\r\n   @return {string}\r\n   */\r\n  texString() {\r\n    return `${this.constructor.name}$_{${this.angle}}$`\r\n  }\r\n\r\n  equal(other) {\r\n    if (other instanceof BasicRotationGate) {\r\n      return this.angle == other.angle\r\n    }\r\n    return false\r\n  }\r\n}\r\n\r\n/**\r\n * @class BasicPhaseGate\r\n * @desc\r\nDefines a base class of a phase gate.\r\n\r\n    A phase gate has a continuous parameter (the angle), labeled 'angle' /\r\nthis.angle. Its inverse is the same gate with the negated argument.\r\n    Phase gates of the same class can be merged by adding the angles.\r\n    The continuous parameter is modulo 2 * pi, this.angle is in the interval\r\n    [0, 2 * pi).\r\n */\r\nexport class BasicPhaseGate extends BasicGate {\r\n  /**\r\n    Initialize a basic rotation gate.\r\n\r\n    @param {number} angle Angle of rotation (saved modulo 2 * pi)\r\n     */\r\n  constructor(angle, ...args) {\r\n    super(...args)\r\n    let rounded_angle = math.round(math.mod(angle, 2.0 * Math.PI), ANGLE_PRECISION)\r\n    if (rounded_angle > 2 * Math.PI - ANGLE_TOLERANCE) {\r\n      rounded_angle = 0.0\r\n    }\r\n    this.angle = rounded_angle\r\n  }\r\n\r\n  /**\r\n    Return the inverse of this rotation gate (negate the angle, return new object).\r\n    @return {BasicPhaseGate}\r\n   */\r\n  getInverse() {\r\n    if (this.angle == 0) {\r\n      return new this.__proto__.constructor(0)\r\n    } else {\r\n      return new this.__proto__.constructor(-this.angle + 2 * Math.PI)\r\n    }\r\n  }\r\n\r\n  /**\r\n    Return self merged with another gate.\r\n\r\n    Default implementation handles rotation gate of the same type, where angles are simply added.\r\n\r\n    @param {BasicPhaseGate} other Phase gate of same type.\r\n    @throws NotMergeable For non-rotation gates or rotation gates of different type.\r\n    @return {BasicPhaseGate} New object representing the merged gates.\r\n  */\r\n  getMerged(other) {\r\n    if (other instanceof BasicPhaseGate) {\r\n      return new this.__proto__.constructor(this.angle + other.angle)\r\n    }\r\n    throw new NotMergeable('Can\\'t merge different types of rotation gates.')\r\n  }\r\n\r\n  toString() {\r\n    return `${this.constructor.name}(${this.angle})`\r\n  }\r\n\r\n  texString() {\r\n    return `${this.constructor.name}$_{${this.angle}}$`\r\n  }\r\n\r\n  equal(other) {\r\n    if (other instanceof BasicPhaseGate) {\r\n      return this.angle === other.angle\r\n    }\r\n    return false\r\n  }\r\n}\r\n\r\n/**\r\n * @class ClassicalInstructionGate\r\n * @desc\r\n  Classical instruction gates never have control qubits.\r\n    Base class for all gates which are not quantum gates in the typical sense,\r\n    e.g., measurement, allocation/deallocation, ...\r\n */\r\nexport class ClassicalInstructionGate extends BasicGate {\r\n\r\n}\r\n\r\n/**\r\n * @class FastForwardingGate\r\n * @desc\r\nBase class for classical instruction gates which require a fast-forward\r\nthrough compiler engines that cache / buffer gates. Examples include\r\nMeasure and Deallocate, which both should be executed asap, such\r\nthat Measurement results are available and resources are freed,\r\n    respectively.\r\n\r\n        Note:\r\nThe only requirement is that FlushGate commands run the entire\r\ncircuit. FastForwardingGate objects can be used but the user cannot\r\nexpect a measurement result to be available for all back-ends when\r\ncalling only Measure. E.g., for the IBM Quantum Experience back-end,\r\n    sending the circuit for each Measure-gate would be too inefficient,\r\n    which is why a final\r\n\r\n @example\r\n\r\neng.flush()\r\n\r\nis required before the circuit gets sent through the API.\r\n */\r\nexport class FastForwardingGate extends ClassicalInstructionGate {\r\n\r\n}\r\n\r\n/**\r\n * @class BasicMathGate\r\n * @desc\r\nBase class for all math gates.\r\n\r\n    It allows efficient emulation by providing a mathematical representation\r\nwhich is given by the concrete gate which derives from this base class.\r\nThe AddConstant gate, for example, registers a function of the form\r\n\r\n @example\r\n\r\nfunction add(x)\r\nreturn (x+a,)\r\n\r\nupon initialization. More generally, the function takes integers as\r\nparameters and returns a tuple / list of outputs, each entry corresponding\r\nto the function input. As an example, consider out-of-place\r\nmultiplication, which takes two input registers and adds the result into a\r\nthird, i.e., (a,b,c) -> (a,b,c+a*b). The corresponding function then is\r\n\r\n @example\r\n\r\nfunction multiply(a,b,c)\r\nreturn (a,b,c+a*b)\r\n */\r\nexport class BasicMathGate extends BasicGate {\r\n  /**\r\n   * @constructor\r\n    Initialize a BasicMathGate by providing the mathematical function that it implements.\r\n\r\n    @param {function} mathFunc Function which takes as many int values as\r\ninput, as the gate takes registers. For each of these values,\r\n    it then returns the output (i.e., it returns a list/tuple of\r\noutput values).\r\n\r\n@example\r\n\r\nfunction add(a,b)\r\nreturn (a,a+b)\r\nBasicMathGate.__init__(self, add)\r\n\r\nIf the gate acts on, e.g., fixed point numbers, the number of bits per\r\nregister is also required in order to describe the action of such a\r\nmathematical gate. For this reason, there is\r\n\r\n   @example\r\n\r\nBasicMathGate.get_math_function(qubits)\r\n\r\nwhich can be overwritten by the gate deriving from BasicMathGate.\r\n\r\n    @example\r\n\r\nfunction get_math_function(self, qubits)\r\nn = len(qubits[0])\r\nscal = 2.**n\r\nfunction math_fun(a)\r\nreturn (int(scal * (math.sin(math.pi * a / scal))),)\r\nreturn math_fun\r\n     */\r\n  constructor(mathFunc, ...args) {\r\n    super(...args)\r\n    this.mathFunc = x => Array.from(mathFunc(...x))\r\n  }\r\n\r\n  /**\r\n    Return the math function which corresponds to the action of this math\r\ngate, given the input to the gate (a tuple of quantum registers).\r\n\r\n  @param {Array.<Qureg>} qubits Qubits to which the math gate is being applied.\r\n\r\n    @return {function} javascript function describing the action of this\r\n    gate. (See BasicMathGate.constructor for an example).\r\n   */\r\n  getMathFunction(qubits) {\r\n    return this.mathFunc\r\n  }\r\n\r\n  toString() {\r\n    return 'MATH'\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/ops/basics.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 647,
    "kind": "variable",
    "name": "ANGLE_PRECISION",
    "memberof": "src/ops/basics.js",
    "static": true,
    "longname": "src/ops/basics.js~ANGLE_PRECISION",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/ops/basics.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 40,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 648,
    "kind": "variable",
    "name": "ANGLE_TOLERANCE",
    "memberof": "src/ops/basics.js",
    "static": true,
    "longname": "src/ops/basics.js~ANGLE_TOLERANCE",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/ops/basics.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 41,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 649,
    "kind": "class",
    "name": "BasicGate",
    "memberof": "src/ops/basics.js",
    "static": true,
    "longname": "src/ops/basics.js~BasicGate",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/basics.js",
    "importStyle": "{BasicGate}",
    "description": "Base class of all gates.",
    "lineNumber": 48,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "BasicGate"
      }
    ],
    "abstract": true,
    "interface": false
  },
  {
    "__docId__": 650,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/ops/basics.js~BasicGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/basics.js~BasicGate#constructor",
    "access": "public",
    "description": "",
    "examples": [
      "ExampleGate | (a,b,c,d,e)\n\nwhere a and b are interchangeable. Then, call this function as\nfollows:",
      "this.set_interchangeable_qubit_indices([[0,1]])\n\nAs another example, consider",
      "ExampleGate2 | (a,b,c,d,e)\n\nwhere a and b are interchangeable and, in addition, c, d, and e\nare interchangeable among themselves. Then, call this function as",
      "this.set_interchangeable_qubit_indices([[0,1],[2,3,4]])"
    ],
    "lineNumber": 77,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": "Note:\nSet interchangeable qubit indices!\n(gate.interchangeable_qubit_indices)\n\nAs an example, consider"
      }
    ]
  },
  {
    "__docId__": 651,
    "kind": "member",
    "name": "interchangeableQubitIndices",
    "memberof": "src/ops/basics.js~BasicGate",
    "static": false,
    "longname": "src/ops/basics.js~BasicGate#interchangeableQubitIndices",
    "access": "public",
    "description": null,
    "lineNumber": 78,
    "undocument": true,
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 652,
    "kind": "method",
    "name": "getInverse",
    "memberof": "src/ops/basics.js~BasicGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/basics.js~BasicGate#getInverse",
    "access": "public",
    "description": "",
    "lineNumber": 84,
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": ""
      }
    ],
    "params": [],
    "return": null
  },
  {
    "__docId__": 653,
    "kind": "method",
    "name": "getMerged",
    "memberof": "src/ops/basics.js~BasicGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/basics.js~BasicGate#getMerged",
    "access": "public",
    "description": "",
    "lineNumber": 91,
    "throws": [
      {
        "types": [
          "NotMergeable"
        ],
        "description": ""
      }
    ],
    "params": [],
    "return": null
  },
  {
    "__docId__": 654,
    "kind": "method",
    "name": "toString",
    "memberof": "src/ops/basics.js~BasicGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/basics.js~BasicGate#toString",
    "access": "public",
    "description": "",
    "lineNumber": 98,
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": ""
      }
    ],
    "params": [],
    "return": null
  },
  {
    "__docId__": 655,
    "kind": "method",
    "name": "inspect",
    "memberof": "src/ops/basics.js~BasicGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/basics.js~BasicGate#inspect",
    "access": "public",
    "description": "",
    "lineNumber": 105,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 656,
    "kind": "method",
    "name": "makeTupleOfQureg",
    "memberof": "src/ops/basics.js~BasicGate",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/ops/basics.js~BasicGate.makeTupleOfQureg",
    "access": "public",
    "description": "Convert quantum input of \"gate | quantum input\" to internal formatting.\n\nA Command object only accepts tuples of Quregs (list of Qubit objects)\nas qubits input parameter. However, with this function we allow the\nuser to use a more flexible syntax:\n\n1) Gate | qubit\n2) Gate | [qubit0, qubit1]\n3) Gate | qureg\n4) Gate | (qubit, )\n5) Gate | (qureg, qubit)\n\nwhere qubit is a Qubit object and qureg is a Qureg object. This\nfunction takes the right hand side of | and transforms it to the\ncorrect input parameter of a Command object which is:\n\n1) -> Gate | ([qubit], )\n2) -> Gate | ([qubit0, qubit1], )\n3) -> Gate | (qureg, )\n4) -> Gate | ([qubit], )\n5) -> Gate | (qureg, [qubit])",
    "lineNumber": 136,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Qureg[]} Canonical representation A tuple containing Qureg (or list of Qubits) objects."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Qubit",
          "Qubit[]",
          "Qureg",
          "Qureg[]"
        ],
        "spread": false,
        "optional": false,
        "name": "qubits",
        "description": "a Qubit object, a list of Qubit objects, a Qureg object,\nor a tuple of Qubit or Qureg objects (can be mixed)."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Qureg[]"
      ],
      "spread": false,
      "description": "Canonical representation A tuple containing Qureg (or list of Qubits) objects."
    }
  },
  {
    "__docId__": 657,
    "kind": "method",
    "name": "generateCommand",
    "memberof": "src/ops/basics.js~BasicGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/basics.js~BasicGate#generateCommand",
    "access": "public",
    "description": "Helper function to generate a command consisting of the gate and the qubits being acted upon.",
    "lineNumber": 155,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "qubits",
        "description": "{Qubit | Array.<Qubit> | Qureg} see BasicGate.makeTupleOfQureg(qubits)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Command"
      ],
      "spread": false,
      "description": "A Command object containing the gate and the qubits."
    }
  },
  {
    "__docId__": 658,
    "kind": "method",
    "name": "or",
    "memberof": "src/ops/basics.js~BasicGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/basics.js~BasicGate#or",
    "access": "public",
    "description": "Operator| overload which enables the syntax Gate | qubits.",
    "examples": [
      "1) Gate | qubit\n2) Gate | [qubit0, qubit1]\n3) Gate | qureg\n4) Gate | (qubit, )\n5) Gate | (qureg, qubit)"
    ],
    "lineNumber": 179,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "qubits",
        "description": "{Qubit | Array.<Qubit> | Qureg}\na Qubit object, a list of Qubit objects, a Qureg object,\nor a tuple of Qubit or Qureg objects (can be mixed)."
      }
    ],
    "return": null
  },
  {
    "__docId__": 659,
    "kind": "method",
    "name": "equal",
    "memberof": "src/ops/basics.js~BasicGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/basics.js~BasicGate#equal",
    "access": "public",
    "description": "",
    "lineNumber": 188,
    "params": [
      {
        "nullable": null,
        "types": [
          "BasicGate ",
          " Object"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 660,
    "kind": "method",
    "name": "copy",
    "memberof": "src/ops/basics.js~BasicGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/basics.js~BasicGate#copy",
    "access": "public",
    "description": "",
    "lineNumber": 195,
    "return": {
      "nullable": null,
      "types": [
        "BasicGate"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 661,
    "kind": "class",
    "name": "SelfInverseGate",
    "memberof": "src/ops/basics.js",
    "static": true,
    "longname": "src/ops/basics.js~SelfInverseGate",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/basics.js",
    "importStyle": "{SelfInverseGate}",
    "description": "Self-inverse basic gate class.\nAutomatic implementation of the getInverse-member function for self-inverse gates.",
    "examples": [
      "// getInverse(H) == H, it is a self-inverse gate:\ngetInverse(H) | qubit"
    ],
    "lineNumber": 208,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "SelfInverseGate"
      }
    ],
    "interface": false,
    "extends": [
      "BasicGate"
    ]
  },
  {
    "__docId__": 662,
    "kind": "method",
    "name": "getInverse",
    "memberof": "src/ops/basics.js~SelfInverseGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/basics.js~SelfInverseGate#getInverse",
    "access": "public",
    "description": null,
    "lineNumber": 209,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 663,
    "kind": "class",
    "name": "BasicRotationGate",
    "memberof": "src/ops/basics.js",
    "static": true,
    "longname": "src/ops/basics.js~BasicRotationGate",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/basics.js",
    "importStyle": "{BasicRotationGate}",
    "description": "Defines a base class of a rotation gate.\n\nA rotation gate has a continuous parameter (the angle), labeled 'angle' /\nthis.angle. Its inverse is the same gate with the negated argument.\nRotation gates of the same class can be merged by adding the angles.\nThe continuous parameter is modulo 4 * pi, this.angle is in the interval\n[0, 4 * pi).",
    "lineNumber": 225,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "BasicRotationGate"
      }
    ],
    "interface": false,
    "extends": [
      "BasicGate"
    ]
  },
  {
    "__docId__": 664,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/ops/basics.js~BasicRotationGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/basics.js~BasicRotationGate#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 231,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": "Initialize a basic rotation gate."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "angle",
        "description": "{number} Angle of rotation (saved modulo 4 * pi)"
      }
    ]
  },
  {
    "__docId__": 665,
    "kind": "member",
    "name": "angle",
    "memberof": "src/ops/basics.js~BasicRotationGate",
    "static": false,
    "longname": "src/ops/basics.js~BasicRotationGate#angle",
    "access": "public",
    "description": null,
    "lineNumber": 238,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 666,
    "kind": "method",
    "name": "getInverse",
    "memberof": "src/ops/basics.js~BasicRotationGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/basics.js~BasicRotationGate#getInverse",
    "access": "public",
    "description": "",
    "lineNumber": 246,
    "return": {
      "nullable": null,
      "types": [
        "BasicRotationGate"
      ],
      "spread": false,
      "description": "Return the inverse of this rotation gate (negate the angle, return new\nobject)."
    },
    "params": []
  },
  {
    "__docId__": 667,
    "kind": "method",
    "name": "getMerged",
    "memberof": "src/ops/basics.js~BasicRotationGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/basics.js~BasicRotationGate#getMerged",
    "access": "public",
    "description": "Return self merged with another gate.\n\nDefault implementation handles rotation gate of the same type, where\nangles are simply added.",
    "lineNumber": 264,
    "params": [
      {
        "nullable": null,
        "types": [
          "BasicRotationGate",
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "BasicRotationGate"
      ],
      "spread": false,
      "description": "New object representing the merged gates."
    },
    "throws": [
      {
        "types": [
          "NotMergeable"
        ],
        "description": "For non-rotation gates or rotation gates of different type."
      }
    ]
  },
  {
    "__docId__": 668,
    "kind": "method",
    "name": "toString",
    "memberof": "src/ops/basics.js~BasicRotationGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/basics.js~BasicRotationGate#toString",
    "access": "public",
    "description": null,
    "lineNumber": 271,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 669,
    "kind": "method",
    "name": "texString",
    "memberof": "src/ops/basics.js~BasicRotationGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/basics.js~BasicRotationGate#texString",
    "access": "public",
    "description": "Return the Latex string representation of a BasicRotationGate.\n\nReturns the class name and the angle as a subscript, i.e.",
    "examples": [
      "[CLASSNAME]$_[ANGLE]$"
    ],
    "lineNumber": 284,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 670,
    "kind": "method",
    "name": "equal",
    "memberof": "src/ops/basics.js~BasicRotationGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/basics.js~BasicRotationGate#equal",
    "access": "public",
    "description": null,
    "lineNumber": 288,
    "undocument": true,
    "params": [
      {
        "name": "other",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 671,
    "kind": "class",
    "name": "BasicPhaseGate",
    "memberof": "src/ops/basics.js",
    "static": true,
    "longname": "src/ops/basics.js~BasicPhaseGate",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/basics.js",
    "importStyle": "{BasicPhaseGate}",
    "description": "Defines a base class of a phase gate.\n\nA phase gate has a continuous parameter (the angle), labeled 'angle' /\nthis.angle. Its inverse is the same gate with the negated argument.\nPhase gates of the same class can be merged by adding the angles.\nThe continuous parameter is modulo 2 * pi, this.angle is in the interval\n[0, 2 * pi).",
    "lineNumber": 307,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "BasicPhaseGate"
      }
    ],
    "interface": false,
    "extends": [
      "BasicGate"
    ]
  },
  {
    "__docId__": 672,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/ops/basics.js~BasicPhaseGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/basics.js~BasicPhaseGate#constructor",
    "access": "public",
    "description": "Initialize a basic rotation gate.",
    "lineNumber": 313,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "angle",
        "description": "Angle of rotation (saved modulo 2 * pi)"
      }
    ]
  },
  {
    "__docId__": 673,
    "kind": "member",
    "name": "angle",
    "memberof": "src/ops/basics.js~BasicPhaseGate",
    "static": false,
    "longname": "src/ops/basics.js~BasicPhaseGate#angle",
    "access": "public",
    "description": null,
    "lineNumber": 319,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 674,
    "kind": "method",
    "name": "getInverse",
    "memberof": "src/ops/basics.js~BasicPhaseGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/basics.js~BasicPhaseGate#getInverse",
    "access": "public",
    "description": "Return the inverse of this rotation gate (negate the angle, return new object).",
    "lineNumber": 326,
    "return": {
      "nullable": null,
      "types": [
        "BasicPhaseGate"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 675,
    "kind": "method",
    "name": "getMerged",
    "memberof": "src/ops/basics.js~BasicPhaseGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/basics.js~BasicPhaseGate#getMerged",
    "access": "public",
    "description": "Return self merged with another gate.\n\nDefault implementation handles rotation gate of the same type, where angles are simply added.",
    "lineNumber": 343,
    "params": [
      {
        "nullable": null,
        "types": [
          "BasicPhaseGate"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "Phase gate of same type."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "BasicPhaseGate"
      ],
      "spread": false,
      "description": "New object representing the merged gates."
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "NotMergeable For non-rotation gates or rotation gates of different type."
      }
    ]
  },
  {
    "__docId__": 676,
    "kind": "method",
    "name": "toString",
    "memberof": "src/ops/basics.js~BasicPhaseGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/basics.js~BasicPhaseGate#toString",
    "access": "public",
    "description": null,
    "lineNumber": 350,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 677,
    "kind": "method",
    "name": "texString",
    "memberof": "src/ops/basics.js~BasicPhaseGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/basics.js~BasicPhaseGate#texString",
    "access": "public",
    "description": null,
    "lineNumber": 354,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 678,
    "kind": "method",
    "name": "equal",
    "memberof": "src/ops/basics.js~BasicPhaseGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/basics.js~BasicPhaseGate#equal",
    "access": "public",
    "description": null,
    "lineNumber": 358,
    "undocument": true,
    "params": [
      {
        "name": "other",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 679,
    "kind": "class",
    "name": "ClassicalInstructionGate",
    "memberof": "src/ops/basics.js",
    "static": true,
    "longname": "src/ops/basics.js~ClassicalInstructionGate",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/basics.js",
    "importStyle": "{ClassicalInstructionGate}",
    "description": "Classical instruction gates never have control qubits.\nBase class for all gates which are not quantum gates in the typical sense,\ne.g., measurement, allocation/deallocation, ...",
    "lineNumber": 373,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "ClassicalInstructionGate"
      }
    ],
    "interface": false,
    "extends": [
      "BasicGate"
    ]
  },
  {
    "__docId__": 680,
    "kind": "class",
    "name": "FastForwardingGate",
    "memberof": "src/ops/basics.js",
    "static": true,
    "longname": "src/ops/basics.js~FastForwardingGate",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/basics.js",
    "importStyle": "{FastForwardingGate}",
    "description": "Base class for classical instruction gates which require a fast-forward\nthrough compiler engines that cache / buffer gates. Examples include\nMeasure and Deallocate, which both should be executed asap, such\nthat Measurement results are available and resources are freed,\nrespectively.\n\nNote:\nThe only requirement is that FlushGate commands run the entire\ncircuit. FastForwardingGate objects can be used but the user cannot\nexpect a measurement result to be available for all back-ends when\ncalling only Measure. E.g., for the IBM Quantum Experience back-end,\nsending the circuit for each Measure-gate would be too inefficient,\nwhich is why a final",
    "examples": [
      "\neng.flush()\n\nis required before the circuit gets sent through the API."
    ],
    "lineNumber": 400,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "FastForwardingGate"
      }
    ],
    "interface": false,
    "extends": [
      "ClassicalInstructionGate"
    ]
  },
  {
    "__docId__": 681,
    "kind": "class",
    "name": "BasicMathGate",
    "memberof": "src/ops/basics.js",
    "static": true,
    "longname": "src/ops/basics.js~BasicMathGate",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/basics.js",
    "importStyle": "{BasicMathGate}",
    "description": "Base class for all math gates.\n\nIt allows efficient emulation by providing a mathematical representation\nwhich is given by the concrete gate which derives from this base class.\nThe AddConstant gate, for example, registers a function of the form",
    "examples": [
      "\nfunction add(x)\nreturn (x+a,)\n\nupon initialization. More generally, the function takes integers as\nparameters and returns a tuple / list of outputs, each entry corresponding\nto the function input. As an example, consider out-of-place\nmultiplication, which takes two input registers and adds the result into a\nthird, i.e., (a,b,c) -> (a,b,c+a*b). The corresponding function then is",
      "\nfunction multiply(a,b,c)\nreturn (a,b,c+a*b)"
    ],
    "lineNumber": 429,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "BasicMathGate"
      }
    ],
    "interface": false,
    "extends": [
      "BasicGate"
    ]
  },
  {
    "__docId__": 682,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/ops/basics.js~BasicMathGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/basics.js~BasicMathGate#constructor",
    "access": "public",
    "description": "",
    "examples": [
      "\nfunction add(a,b)\nreturn (a,a+b)\nBasicMathGate.__init__(self, add)\n\nIf the gate acts on, e.g., fixed point numbers, the number of bits per\nregister is also required in order to describe the action of such a\nmathematical gate. For this reason, there is",
      "\nBasicMathGate.get_math_function(qubits)\n\nwhich can be overwritten by the gate deriving from BasicMathGate.",
      "\nfunction get_math_function(self, qubits)\nn = len(qubits[0])\nscal = 2.**n\nfunction math_fun(a)\nreturn (int(scal * (math.sin(math.pi * a / scal))),)\nreturn math_fun"
    ],
    "lineNumber": 464,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": "Initialize a BasicMathGate by providing the mathematical function that it implements."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "mathFunc",
        "description": "Function which takes as many int values as\ninput, as the gate takes registers. For each of these values,\nit then returns the output (i.e., it returns a list/tuple of\noutput values)."
      }
    ]
  },
  {
    "__docId__": 683,
    "kind": "member",
    "name": "mathFunc",
    "memberof": "src/ops/basics.js~BasicMathGate",
    "static": false,
    "longname": "src/ops/basics.js~BasicMathGate#mathFunc",
    "access": "public",
    "description": null,
    "lineNumber": 466,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 684,
    "kind": "method",
    "name": "getMathFunction",
    "memberof": "src/ops/basics.js~BasicMathGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/basics.js~BasicMathGate#getMathFunction",
    "access": "public",
    "description": "Return the math function which corresponds to the action of this math\ngate, given the input to the gate (a tuple of quantum registers).",
    "lineNumber": 478,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array.<Qureg>"
        ],
        "spread": false,
        "optional": false,
        "name": "qubits",
        "description": "Qubits to which the math gate is being applied."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "function"
      ],
      "spread": false,
      "description": "javascript function describing the action of this\ngate. (See BasicMathGate.constructor for an example)."
    }
  },
  {
    "__docId__": 685,
    "kind": "method",
    "name": "toString",
    "memberof": "src/ops/basics.js~BasicMathGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/basics.js~BasicMathGate#toString",
    "access": "public",
    "description": null,
    "lineNumber": 482,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 686,
    "kind": "file",
    "name": "src/ops/command.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/**\r\nThis file defines the apply_command function and the Command class.\r\n\r\nWhen a gate is applied to qubits, e.g.,\r\n\r\n @example\r\n\r\nCNOT | (qubit1, qubit2)\r\n\r\na Command object is generated which represents both the gate, qubits and\r\ncontrol qubits. This Command object then gets sent down the compilation\r\npipeline.\r\n\r\n    In detail, the Gate object overloads the operator| (magic method __or__)\r\nto generate a Command object which stores the qubits in a canonical order\r\nusing interchangeable qubit indices defined by the gate to allow the\r\noptimizer to cancel the following two gates\r\n\r\n @example\r\nSwap | (qubit1, qubit2)\r\nSwap | (qubit2, qubit1)\r\n\r\nThe command then gets sent to the MainEngine via the\r\napply wrapper (apply_command).\r\n*/\r\nimport assert from 'assert'\r\nimport {arrayEqual} from '../libs/polyfill'\r\nimport {getInverse} from './_cycle'\r\nimport {BasicQubit, Qureg} from '../types/qubit'\r\nimport {markTuple} from '../libs/util'\r\nimport {NotMergeable} from '../meta/error'\r\n\r\n/**\r\n * @class Command\r\n * @desc\r\nClass used as a container to store commands. If a gate is applied to\r\nqubits, then the gate and qubits are saved in a command object. Qubits\r\nare copied into WeakQubitRefs in order to allow early deallocation (would\r\nbe kept alive otherwise). WeakQubitRef qubits don't send deallocate gate\r\nwhen destructed.\r\n\r\n    Attributes:\r\ngate: The gate to execute\r\nqubits: Tuple of qubit lists (e.g. Quregs). Interchangeable qubits\r\nare stored in a unique order\r\ncontrol_qubits: The Qureg of control qubits in a unique order\r\nengine: The engine (usually: MainEngine)\r\ntags: The list of tag objects associated with this command\r\n(e.g., ComputeTag, UncomputeTag, LoopTag, ...). tag objects need to\r\nsupport ==, != (__eq__ and __ne__) for comparison as used in e.g.\r\n    TagRemover. New tags should always be added to the end of the list.\r\n    This means that if there are e.g. two LoopTags in a command, tag[0]\r\nis from the inner scope while tag[1] is from the other scope as the\r\nother scope receives the command after the inner scope LoopEngine\r\nand hence adds its LoopTag to the end.\r\n    all_qubits: A tuple of control_qubits + qubits\r\n */\r\nexport default class Command {\r\n  /**\r\n   * @constructor\r\n    Note:\r\ncontrol qubits (Command.control_qubits) are stored as a\r\nlist of qubits, and command tags (Command.tags) as a list of tag-\r\nobjects. All functions within this class also work if\r\n    BasicQubits are supplied instead of normal Qubit objects (see BasicQubits).\r\n\r\n@param {BasicEngine} engine engine which created the qubit (mostly the MainEngine)\r\n@param {BasicGate} gate Gate to be executed\r\n@param {Array.<Qureg>} qubits Array of quantum registers (to which the gate is applied)\r\n@param {Qureg|Array.<Qubit>} controls Qubits that condition the command.\r\n@param {any[]} tags Tags associated with the command.\r\n     */\r\n  constructor(engine, gate, qubits, controls = [], tags = []) {\r\n    const qs = qubits.map(qureg => new Qureg(...qureg.map(looper => new BasicQubit(looper.engine, looper.id))))\r\n    this.gate = gate\r\n    this.tags = tags\r\n    this.qubits = qs\r\n    this.controlQubits = controls\r\n    this.engine = engine\r\n  }\r\n\r\n  get qubits() {\r\n    return this._qubits\r\n  }\r\n\r\n  set qubits(nq) {\r\n    this._qubits = this.orderQubits(nq)\r\n  }\r\n\r\n  /**\r\n   * return the copy of current command\r\n   * @return {Command}\r\n   */\r\n  copy() {\r\n    const qubits = this.qubits.map(looper => BasicQubit.copyArray(looper))\r\n    const controlQubits = BasicQubit.copyArray(this.controlQubits)\r\n    return new Command(this.engine, this.gate.copy(), qubits, controlQubits, this.tags.slice(0))\r\n  }\r\n\r\n  /**\r\n    Get the command object corresponding to the inverse of this command.\r\n    Inverts the gate (if possible) and creates a new command object from the result.\r\n\r\n    @throws {NotInvertible} If the gate does not provide an inverse (see BasicGate.getInverse)\r\n     */\r\n  getInverse() {\r\n    return new Command(this.engine, getInverse(this.gate), this.qubits, this.controlQubits, this.tags.slice(0))\r\n  }\r\n\r\n  /**\r\n    Merge this command with another one and return the merged command object.\r\n    @param {Command} other Other command to merge with this one (self)\r\n    @throws NotMergeable if the gates don't supply a get_merged()-function or can't be merged for other reasons.\r\n     */\r\n  getMerged(other) {\r\n    if (arrayEqual(this.tags, other.tags) && arrayEqual(this.allQubits, other.allQubits) && this.engine === other.engine) {\r\n      return new Command(this.engine, this.gate.getMerged(other.gate), this.qubits, this.controlQubits, this.tags.slice(0))\r\n    }\r\n\r\n    throw new NotMergeable('Command not mergeable')\r\n  }\r\n\r\n  /**\r\n    Order the given qubits according to their IDs (for unique comparison of commands).\r\n\r\n    @param {Array.<Qubit>} qubits Array of quantum registers (i.e., tuple of lists of qubits)\r\n    @return {Array.<Qubit>} Ordered tuple of quantum registers\r\n  */\r\n  orderQubits(qubits) {\r\n    const orderedQubits = qubits.slice(0)\r\n    const iqi = this.interchangeableQubitIndices\r\n    iqi.forEach((old_positions) => {\r\n      const new_positions = old_positions.slice(0).sort((a, b) => orderedQubits[a][0].id - orderedQubits[b][0].id)\r\n      const qubits_new_order = []\r\n      new_positions.forEach(l => qubits_new_order.push(orderedQubits[l]))\r\n\r\n      old_positions.forEach((v, i) => {\r\n        orderedQubits[v] = qubits_new_order[i]\r\n      })\r\n    })\r\n\r\n    markTuple(orderedQubits)\r\n    return orderedQubits\r\n  }\r\n\r\n  /**\r\n    Return nested list of qubit indices which are interchangeable.\r\n\r\n    Certain qubits can be interchanged (e.g., the qubit order for a Swap\r\ngate). To ensure that only those are sorted when determining the\r\nordering (see _order_qubits), this.interchangeable_qubit_indices is\r\nused.\r\n    @example\r\nIf we can interchange qubits 0,1 and qubits 3,4,5,\r\n    then this function returns [[0,1],[3,4,5]]\r\n     */\r\n  get interchangeableQubitIndices() {\r\n    return this.gate.interchangeableQubitIndices\r\n  }\r\n\r\n  get controlQubits() {\r\n    return this._controlQubits\r\n  }\r\n\r\n  /**\r\n    Set control_qubits to qubits\r\n  @param {Qureg} nq quantum register\r\n  */\r\n  set controlQubits(nq) {\r\n    this._controlQubits = nq.sort((a, b) => a.id - b.id).map(q => new BasicQubit(q.engine, q.id))\r\n  }\r\n\r\n  /**\r\nAdd (additional) control qubits to this command object.\r\n\r\n    They are sorted to ensure a canonical order. Also Qubit objects\r\nare converted to WeakQubitRef objects to allow garbage collection and\r\nthus early deallocation of qubits.\r\n\r\n    @param {Array.<Qubit>} qubits List of qubits which control this\r\n    gate, i.e., the gate is only executed if all qubits are in state 1.\r\n  */\r\n  addControlQubits(qubits) {\r\n    assert(Array.isArray(qubits))\r\n    this._controlQubits = this._controlQubits.concat(BasicQubit.copyArray(qubits))\r\n    this._controlQubits.sort((a, b) => a.id - b.id)\r\n  }\r\n\r\n  /**\r\n  Apply a command.\r\n\r\n    Extracts the qubits-owning (target) engine from the Command object and sends the Command to it.\r\n   */\r\n  apply() {\r\n    this.engine.receive([this])\r\n  }\r\n\r\n  /**\r\nGet all qubits (gate and control qubits).\r\n\r\nReturns a tuple T where T[0] is a quantum register (a list of\r\nWeakQubitRef objects) containing the control qubits and T[1:] contains\r\nthe quantum registers to which the gate is applied.\r\n  */\r\n  get allQubits() {\r\n    return [this._controlQubits].concat(this.qubits)\r\n  }\r\n\r\n  get controlCount() {\r\n    return this.controlQubits.length\r\n  }\r\n\r\n  get engine() {\r\n    return this._engine\r\n  }\r\n\r\n  /**\r\n    Set / Change engine of all qubits to engine.\r\n    @param {BasicEngine} ng New owner of qubits and owner of this Command object\r\n  */\r\n  set engine(ng) {\r\n    this._engine = ng\r\n    this.qubits.forEach((qureg) => {\r\n      qureg.forEach((qubit) => {\r\n        qubit.engine = ng\r\n      })\r\n    })\r\n    this._controlQubits.forEach(qubit => qubit.engine = ng)\r\n  }\r\n\r\n  equal(other) {\r\n    if (other instanceof Command) {\r\n      try {\r\n        const f1 = this.gate.equal(other.gate)\r\n        const t1 = arrayEqual(this.tags, other.tags)\r\n        const e1 = this.engine === other.engine\r\n        const b = arrayEqual(this.allQubits, other.allQubits)\r\n        return f1 && t1 && e1 && b\r\n      } catch (e) {\r\n        return false\r\n      }\r\n    }\r\n    return false\r\n  }\r\n\r\n  /**\r\n   * @return {string}\r\n   */\r\n  toString() {\r\n    let {qubits} = this\r\n    const ctrlqubits = this.controlQubits\r\n\r\n    if (ctrlqubits.length > 0) {\r\n      qubits = [ctrlqubits].concat(qubits)\r\n    }\r\n    let qs = ''\r\n    if (qubits.length === 1) {\r\n      qs = new Qureg(qubits[0]).toString()\r\n    } else {\r\n      qs = '( '\r\n      qubits.forEach((qreg) => {\r\n        qs += new Qureg(qreg).toString()\r\n        qs += ', '\r\n      })\r\n      qs = `${qs.substring(0, qs.length - 2)} )`\r\n    }\r\n    let cs = ''\r\n    for (let i = 0; i < ctrlqubits.length; ++i) {\r\n      cs += 'C'\r\n    }\r\n    return `${cs}${this.gate.toString()} | ${qs}`\r\n  }\r\n\r\n  /**\r\n   * @return {string}\r\n   */\r\n  inspect() {\r\n    return this.toString()\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/ops/command.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 687,
    "kind": "class",
    "name": "Command",
    "memberof": "src/ops/command.js",
    "static": true,
    "longname": "src/ops/command.js~Command",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/command.js",
    "importStyle": "Command",
    "description": "Class used as a container to store commands. If a gate is applied to\nqubits, then the gate and qubits are saved in a command object. Qubits\nare copied into WeakQubitRefs in order to allow early deallocation (would\nbe kept alive otherwise). WeakQubitRef qubits don't send deallocate gate\nwhen destructed.\n\nAttributes:\ngate: The gate to execute\nqubits: Tuple of qubit lists (e.g. Quregs). Interchangeable qubits\nare stored in a unique order\ncontrol_qubits: The Qureg of control qubits in a unique order\nengine: The engine (usually: MainEngine)\ntags: The list of tag objects associated with this command\n(e.g., ComputeTag, UncomputeTag, LoopTag, ...). tag objects need to\nsupport ==, != (__eq__ and __ne__) for comparison as used in e.g.\nTagRemover. New tags should always be added to the end of the list.\nThis means that if there are e.g. two LoopTags in a command, tag[0]\nis from the inner scope while tag[1] is from the other scope as the\nother scope receives the command after the inner scope LoopEngine\nand hence adds its LoopTag to the end.\nall_qubits: A tuple of control_qubits + qubits",
    "lineNumber": 74,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "Command"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 688,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/ops/command.js~Command",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/command.js~Command#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 89,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": "Note:\ncontrol qubits (Command.control_qubits) are stored as a\nlist of qubits, and command tags (Command.tags) as a list of tag-\nobjects. All functions within this class also work if\nBasicQubits are supplied instead of normal Qubit objects (see BasicQubits)."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "BasicEngine"
        ],
        "spread": false,
        "optional": false,
        "name": "engine",
        "description": "engine which created the qubit (mostly the MainEngine)"
      },
      {
        "nullable": null,
        "types": [
          "BasicGate"
        ],
        "spread": false,
        "optional": false,
        "name": "gate",
        "description": "Gate to be executed"
      },
      {
        "nullable": null,
        "types": [
          "Array.<Qureg>"
        ],
        "spread": false,
        "optional": false,
        "name": "qubits",
        "description": "Array of quantum registers (to which the gate is applied)"
      },
      {
        "nullable": null,
        "types": [
          "Qureg",
          "Array.<Qubit>"
        ],
        "spread": false,
        "optional": false,
        "name": "controls",
        "description": "Qubits that condition the command."
      },
      {
        "nullable": null,
        "types": [
          "any[]"
        ],
        "spread": false,
        "optional": false,
        "name": "tags",
        "description": "Tags associated with the command."
      }
    ]
  },
  {
    "__docId__": 689,
    "kind": "member",
    "name": "gate",
    "memberof": "src/ops/command.js~Command",
    "static": false,
    "longname": "src/ops/command.js~Command#gate",
    "access": "public",
    "description": null,
    "lineNumber": 91,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 690,
    "kind": "member",
    "name": "tags",
    "memberof": "src/ops/command.js~Command",
    "static": false,
    "longname": "src/ops/command.js~Command#tags",
    "access": "public",
    "description": null,
    "lineNumber": 92,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 694,
    "kind": "get",
    "name": "qubits",
    "memberof": "src/ops/command.js~Command",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/command.js~Command#qubits",
    "access": "public",
    "description": null,
    "lineNumber": 98,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 695,
    "kind": "set",
    "name": "qubits",
    "memberof": "src/ops/command.js~Command",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/command.js~Command#qubits",
    "access": "public",
    "description": null,
    "lineNumber": 102,
    "undocument": true
  },
  {
    "__docId__": 696,
    "kind": "member",
    "name": "_qubits",
    "memberof": "src/ops/command.js~Command",
    "static": false,
    "longname": "src/ops/command.js~Command#_qubits",
    "access": "private",
    "description": null,
    "lineNumber": 103,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 697,
    "kind": "method",
    "name": "copy",
    "memberof": "src/ops/command.js~Command",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/command.js~Command#copy",
    "access": "public",
    "description": "return the copy of current command",
    "lineNumber": 110,
    "return": {
      "nullable": null,
      "types": [
        "Command"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 698,
    "kind": "method",
    "name": "getInverse",
    "memberof": "src/ops/command.js~Command",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/command.js~Command#getInverse",
    "access": "public",
    "description": "Get the command object corresponding to the inverse of this command.\nInverts the gate (if possible) and creates a new command object from the result.",
    "lineNumber": 122,
    "throws": [
      {
        "types": [
          "NotInvertible"
        ],
        "description": "If the gate does not provide an inverse (see BasicGate.getInverse)"
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 699,
    "kind": "method",
    "name": "getMerged",
    "memberof": "src/ops/command.js~Command",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/command.js~Command#getMerged",
    "access": "public",
    "description": "Merge this command with another one and return the merged command object.",
    "lineNumber": 131,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "Other command to merge with this one (self)"
      }
    ],
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "NotMergeable if the gates don't supply a get_merged()-function or can't be merged for other reasons."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 700,
    "kind": "method",
    "name": "orderQubits",
    "memberof": "src/ops/command.js~Command",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/command.js~Command#orderQubits",
    "access": "public",
    "description": "Order the given qubits according to their IDs (for unique comparison of commands).",
    "lineNumber": 145,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array.<Qubit>"
        ],
        "spread": false,
        "optional": false,
        "name": "qubits",
        "description": "Array of quantum registers (i.e., tuple of lists of qubits)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array.<Qubit>"
      ],
      "spread": false,
      "description": "Ordered tuple of quantum registers"
    }
  },
  {
    "__docId__": 701,
    "kind": "get",
    "name": "interchangeableQubitIndices",
    "memberof": "src/ops/command.js~Command",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/command.js~Command#interchangeableQubitIndices",
    "access": "public",
    "description": "Return nested list of qubit indices which are interchangeable.\n\nCertain qubits can be interchanged (e.g., the qubit order for a Swap\ngate). To ensure that only those are sorted when determining the\nordering (see _order_qubits), this.interchangeable_qubit_indices is\nused.",
    "examples": [
      "If we can interchange qubits 0,1 and qubits 3,4,5,\nthen this function returns [[0,1],[3,4,5]]"
    ],
    "lineNumber": 173,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 702,
    "kind": "get",
    "name": "controlQubits",
    "memberof": "src/ops/command.js~Command",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/command.js~Command#controlQubits",
    "access": "public",
    "description": null,
    "lineNumber": 177,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 703,
    "kind": "set",
    "name": "controlQubits",
    "memberof": "src/ops/command.js~Command",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/command.js~Command#controlQubits",
    "access": "public",
    "description": "Set control_qubits to qubits",
    "lineNumber": 185,
    "params": [
      {
        "nullable": null,
        "types": [
          "Qureg"
        ],
        "spread": false,
        "optional": false,
        "name": "nq",
        "description": "quantum register"
      }
    ]
  },
  {
    "__docId__": 704,
    "kind": "member",
    "name": "_controlQubits",
    "memberof": "src/ops/command.js~Command",
    "static": false,
    "longname": "src/ops/command.js~Command#_controlQubits",
    "access": "private",
    "description": null,
    "lineNumber": 186,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 705,
    "kind": "method",
    "name": "addControlQubits",
    "memberof": "src/ops/command.js~Command",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/command.js~Command#addControlQubits",
    "access": "public",
    "description": "Add (additional) control qubits to this command object.\n\nThey are sorted to ensure a canonical order. Also Qubit objects\nare converted to WeakQubitRef objects to allow garbage collection and\nthus early deallocation of qubits.",
    "lineNumber": 199,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array.<Qubit>"
        ],
        "spread": false,
        "optional": false,
        "name": "qubits",
        "description": "List of qubits which control this\ngate, i.e., the gate is only executed if all qubits are in state 1."
      }
    ],
    "return": null
  },
  {
    "__docId__": 707,
    "kind": "method",
    "name": "apply",
    "memberof": "src/ops/command.js~Command",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/command.js~Command#apply",
    "access": "public",
    "description": "Apply a command.\n\nExtracts the qubits-owning (target) engine from the Command object and sends the Command to it.",
    "lineNumber": 210,
    "params": [],
    "return": null
  },
  {
    "__docId__": 708,
    "kind": "get",
    "name": "allQubits",
    "memberof": "src/ops/command.js~Command",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/command.js~Command#allQubits",
    "access": "public",
    "description": "Get all qubits (gate and control qubits).\n\nReturns a tuple T where T[0] is a quantum register (a list of\nWeakQubitRef objects) containing the control qubits and T[1:] contains\nthe quantum registers to which the gate is applied.",
    "lineNumber": 221,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 709,
    "kind": "get",
    "name": "controlCount",
    "memberof": "src/ops/command.js~Command",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/command.js~Command#controlCount",
    "access": "public",
    "description": null,
    "lineNumber": 225,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 710,
    "kind": "get",
    "name": "engine",
    "memberof": "src/ops/command.js~Command",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/command.js~Command#engine",
    "access": "public",
    "description": null,
    "lineNumber": 229,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 711,
    "kind": "set",
    "name": "engine",
    "memberof": "src/ops/command.js~Command",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/command.js~Command#engine",
    "access": "public",
    "description": "Set / Change engine of all qubits to engine.",
    "lineNumber": 237,
    "params": [
      {
        "nullable": null,
        "types": [
          "BasicEngine"
        ],
        "spread": false,
        "optional": false,
        "name": "ng",
        "description": "New owner of qubits and owner of this Command object"
      }
    ]
  },
  {
    "__docId__": 712,
    "kind": "member",
    "name": "_engine",
    "memberof": "src/ops/command.js~Command",
    "static": false,
    "longname": "src/ops/command.js~Command#_engine",
    "access": "private",
    "description": null,
    "lineNumber": 238,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 713,
    "kind": "method",
    "name": "equal",
    "memberof": "src/ops/command.js~Command",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/command.js~Command#equal",
    "access": "public",
    "description": null,
    "lineNumber": 247,
    "undocument": true,
    "params": [
      {
        "name": "other",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 714,
    "kind": "method",
    "name": "toString",
    "memberof": "src/ops/command.js~Command",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/command.js~Command#toString",
    "access": "public",
    "description": "",
    "lineNumber": 265,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 715,
    "kind": "method",
    "name": "inspect",
    "memberof": "src/ops/command.js~Command",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/command.js~Command#inspect",
    "access": "public",
    "description": "",
    "lineNumber": 293,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 716,
    "kind": "file",
    "name": "src/ops/gates.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/**\r\nContains definitions of standard gates such as\r\n* Hadamard (H)\r\n* Pauli-X (X / NOT)\r\n* Pauli-Z (Z)\r\n* T and its inverse (T / Tdagger)\r\n* Swap gate (Swap)\r\n* Phase gate (Ph)\r\n* Rotation-Z (Rz)\r\n* Phase-shift (R)\r\n* Measurement (Measure)\r\n\r\nand meta gates, i.e.,\r\n* Allocate / Deallocate qubits\r\n* Flush gate (end of circuit)\r\n*/\r\nimport math from 'mathjs'\r\nimport {\r\n  SelfInverseGate, BasicPhaseGate, BasicRotationGate, BasicMathGate, BasicGate, FastForwardingGate, ClassicalInstructionGate\r\n} from './basics'\r\n\r\nimport {getInverse} from './_cycle'\r\n\r\nconst mc = math.complex\r\nconst mm = math.matrix\r\n\r\n/**\r\n * @class HGate\r\n */\r\nexport class HGate extends SelfInverseGate {\r\n  toString() {\r\n    return 'H'\r\n  }\r\n\r\n  get matrix() {\r\n    return mm([\r\n      [mc(Math.SQRT1_2, 0), mc(Math.SQRT1_2, 0)],\r\n      [mc(Math.SQRT1_2, 0), mc(-Math.SQRT1_2, 0)]\r\n    ])\r\n  }\r\n}\r\n\r\nexport const H = new HGate()\r\n\r\n/**\r\n * @class XGate\r\n */\r\n// Pauli-X gate class\r\nexport class XGate extends SelfInverseGate {\r\n  toString() {\r\n    return 'X'\r\n  }\r\n\r\n  get matrix() {\r\n    return mm([\r\n      [0, 1],\r\n      [1, 0]\r\n    ])\r\n  }\r\n}\r\n\r\n\r\n// Shortcut (instance of) `XGate`\r\nexport const X = new XGate()\r\nexport const NOT = X\r\n\r\n/**\r\n * @class YGate\r\n */\r\n// Pauli-Y gate class\r\nexport class YGate extends SelfInverseGate {\r\n  toString() {\r\n    return 'Y'\r\n  }\r\n\r\n  get matrix() {\r\n    return mm([\r\n      [0, mc(0, -1)],\r\n      [mc(0, 1), 0],\r\n    ])\r\n  }\r\n}\r\n\r\n// Shortcut (instance of) `YGate`\r\nexport const Y = new YGate()\r\n\r\n/**\r\n * @class ZGate\r\n * Pauli-Z gate class\r\n */\r\nexport class ZGate extends SelfInverseGate {\r\n  toString() {\r\n    return 'Z'\r\n  }\r\n\r\n  get matrix() {\r\n    return mm([\r\n      [1, 0],\r\n      [0, -1]\r\n    ])\r\n  }\r\n}\r\n\r\n// Shortcut (instance of) `ZGate`\r\nexport const Z = new ZGate()\r\n\r\n/**\r\n * @class SGate\r\n */\r\n// S gate class\r\nexport class SGate extends SelfInverseGate {\r\n  toString() {\r\n    return 'S'\r\n  }\r\n\r\n  get matrix() {\r\n    return mm([\r\n      [1, 0],\r\n      [0, mc(0, 1)]\r\n    ])\r\n  }\r\n}\r\n\r\n// Shortcut (instance of) `SGate`\r\nexport const S = new SGate()\r\n\r\n/**\r\n * @class TGate\r\n */\r\n// T gate class\r\nexport class TGate extends BasicGate {\r\n  get matrix() {\r\n    return mm([\r\n      [1, 0],\r\n      [0, mc(Math.SQRT1_2, Math.SQRT1_2)]\r\n    ])\r\n  }\r\n\r\n  toString() {\r\n    return 'T'\r\n  }\r\n}\r\n\r\n// Shortcut (instance of) `TGate`\r\nexport const T = new TGate()\r\n\r\n/**\r\n * @class SqrtXGate\r\n */\r\n// Square-root X gate class\r\nexport class SqrtXGate extends BasicGate {\r\n  get matrix() {\r\n    return mm([\r\n      [mc(0.5, 0.5), mc(0.5, -0.5)],\r\n      [mc(0.5, -0.5), mc(0.5, 0.5)]\r\n    ])\r\n  }\r\n\r\n  toString() {\r\n    return 'SqrtX'\r\n  }\r\n\r\n  texString() {\r\n    return '$\\\\sqrt{X}$'\r\n  }\r\n}\r\n\r\n// Shortcut (instance of) `SqrtXGate`\r\nexport const SqrtX = new SqrtXGate()\r\n\r\n/**\r\n * @class SwapGate\r\n * @desc Swap gate class (swaps 2 qubits) also self inverse gate\r\n */\r\nexport class SwapGate extends BasicMathGate {\r\n  constructor() {\r\n    super((x, y) => [y, x])\r\n    this.interchangeableQubitIndices = [[0, 1]]\r\n  }\r\n\r\n  toString() {\r\n    return 'Swap'\r\n  }\r\n\r\n  get matrix() {\r\n    return mm([\r\n      [1, 0, 0, 0],\r\n      [0, 0, 1, 0],\r\n      [0, 1, 0, 0],\r\n      [0, 0, 0, 1]\r\n    ])\r\n  }\r\n\r\n  getInverse() {\r\n    const inv = new SwapGate()\r\n    inv.interchangeableQubitIndices = this.interchangeableQubitIndices.slice(0)\r\n    return inv\r\n  }\r\n}\r\n\r\n// Shortcut (instance of) `SwapGate`\r\nexport const Swap = new SwapGate()\r\n\r\n/**\r\n * @class SqrtSwapGate\r\n * @desc Square-root Swap gate class\r\n */\r\nexport class SqrtSwapGate extends BasicGate {\r\n  constructor() {\r\n    super()\r\n    this.interchangeableQubitIndices = [[0, 1]]\r\n  }\r\n\r\n  toString() {\r\n    return 'SqrtSwap'\r\n  }\r\n\r\n  get matrix() {\r\n    return mm([\r\n      [1, 0, 0, 0],\r\n      [0, mc(0.5, 0.5), mc(0.5, -0.5), 0],\r\n      [0, mc(0.5, -0.5), mc(0.5, 0.5), 0],\r\n      [0, 0, 0, 1]\r\n    ])\r\n  }\r\n}\r\n\r\n// Shortcut (instance of) `SqrtSwapGate`\r\nexport const SqrtSwap = new SqrtSwapGate()\r\n\r\n/**\r\n * @class EntangleGate\r\n * @desc gate (Hadamard on first qubit, followed by CNOTs applied to all other qubits).\r\n*/\r\nexport class EntangleGate extends BasicGate {\r\n  toString() {\r\n    return 'Entangle'\r\n  }\r\n\r\n  get matrix() {\r\n    throw new Error('No Attribute')\r\n  }\r\n}\r\n\r\n\r\n// Shortcut (instance of) `EntangleGate`\r\nexport const Entangle = new EntangleGate()\r\n\r\n/**\r\n * @class Ph\r\n * @desc Phase gate (global phase)\r\n */\r\nexport class Ph extends BasicPhaseGate {\r\n  get matrix() {\r\n    return mm([\r\n      [mc(Math.cos(this.angle), Math.sin(this.angle)), 0],\r\n      [0, mc(Math.cos(this.angle), Math.sin(this.angle))]\r\n    ])\r\n  }\r\n}\r\n\r\n/**\r\n * @class Rx\r\n */\r\nexport class Rx extends BasicRotationGate {\r\n  get matrix() {\r\n    return mm([\r\n      [Math.cos(0.5 * this.angle), mc(0, -1 * Math.sin(0.5 * this.angle))],\r\n      [mc(0, -1 * Math.sin(0.5 * this.angle)), Math.cos(0.5 * this.angle)]\r\n    ])\r\n  }\r\n}\r\n\r\n/**\r\n * @class Ry\r\n */\r\nexport class Ry extends BasicRotationGate {\r\n  get matrix() {\r\n    return mm([\r\n      [Math.cos(0.5 * this.angle), -Math.sin(0.5 * this.angle)],\r\n      [Math.sin(0.5 * this.angle), Math.cos(0.5 * this.angle)]\r\n    ])\r\n  }\r\n}\r\n\r\n/**\r\n * @class Rz\r\n * @desc RotationZ gate class\r\n */\r\nexport class Rz extends BasicRotationGate {\r\n  get matrix() {\r\n    return mm([\r\n      [mc(Math.cos(-0.5 * this.angle), Math.sin(-0.5 * this.angle)), 0],\r\n      [0, mc(Math.cos(0.5 * this.angle), Math.sin(0.5 * this.angle))]\r\n    ])\r\n  }\r\n}\r\n\r\n/**\r\n * @class R\r\n * @desc Phase-shift gate (equivalent to Rz up to a global phase)\r\n */\r\nexport class R extends BasicPhaseGate {\r\n  get matrix() {\r\n    return mm([[1, 0], [0, mc(Math.cos(this.angle), Math.sin(this.angle))]])\r\n  }\r\n}\r\n\r\n/**\r\n * @class FlushGate\r\n * @desc\r\nFlush gate (denotes the end of the circuit).\r\n\r\nNote:\r\n    All compiler engines (cengines) which cache/buffer gates are obligated\r\nto flush and send all gates to the next compiler engine (followed by\r\nthe flush command).\r\n\r\nNote:\r\n    This gate is sent when calling\r\n\r\n @example\r\n\r\neng.flush()\r\n\r\non the MainEngine `eng`.\r\n\r\n */\r\nexport class FlushGate extends FastForwardingGate {\r\n  toString() {\r\n    return ''\r\n  }\r\n}\r\n\r\n/**\r\n * @class MeasureGate\r\n * @desc Measurement gate class (for single qubits).\r\n */\r\nexport class MeasureGate extends FastForwardingGate {\r\n  toString() {\r\n    return 'Measure'\r\n  }\r\n\r\n  /**\r\n    Previously (ProjectQ <= v0.3.6) MeasureGate/Measure was allowed to be\r\n    applied to any number of quantum registers. Now the MeasureGate/Measure\r\n    is strictly a single qubit gate. In the coming releases the backward\r\n    compatibility will be removed!\r\n\r\n     */\r\n  or(qubits) {\r\n    let num_qubits = 0\r\n    const qs = BasicGate.makeTupleOfQureg(qubits)\r\n    qs.forEach((qureg) => {\r\n      qureg.forEach((qubit) => {\r\n        num_qubits += 1\r\n        const cmd = this.generateCommand([qubit])\r\n        cmd.apply()\r\n      })\r\n    })\r\n    if (num_qubits > 1) {\r\n      console.warn('Pending syntax change in future versions of '\r\n      + 'ProjectQ: \\n Measure will be a single qubit gate '\r\n      + 'only. Use `All(Measure) | qureg` instead to '\r\n        + 'measure multiple qubits.')\r\n    }\r\n  }\r\n}\r\n\r\n\r\n// Shortcut (instance of) `MeasureGate`\r\nexport const Measure = new MeasureGate()\r\n\r\nexport let Deallocate\r\n\r\n/**\r\n * @class AllocateQubitGate\r\n */\r\nexport class AllocateQubitGate extends ClassicalInstructionGate {\r\n  toString() {\r\n    return 'Allocate'\r\n  }\r\n\r\n  getInverse() {\r\n    return Deallocate\r\n  }\r\n}\r\n\r\n// Shortcut (instance of) `AllocateQubitGate`\r\nexport const Allocate = new AllocateQubitGate()\r\n\r\n/**\r\n * @class DeallocateQubitGate\r\n */\r\nexport class DeallocateQubitGate extends FastForwardingGate {\r\n  toString() {\r\n    return 'Deallocate'\r\n  }\r\n\r\n  getInverse() {\r\n    return Allocate\r\n  }\r\n}\r\n\r\n// Shortcut (instance of) `DeallocateQubitGate`\r\nDeallocate = new DeallocateQubitGate()\r\n\r\n/**\r\n * @class AllocateDirtyQubitGate\r\n */\r\nexport class AllocateDirtyQubitGate extends ClassicalInstructionGate {\r\n  toString() {\r\n    return 'AllocateDirty'\r\n  }\r\n\r\n  getInverse() {\r\n    return Deallocate\r\n  }\r\n}\r\n\r\n// Shortcut (instance of) AllocateDirtyQubitGate\r\nexport const AllocateDirty = new AllocateDirtyQubitGate()\r\n\r\nexport let Barrier\r\n\r\nexport class BarrierGate extends BasicGate {\r\n  toString() {\r\n    return 'Barrier'\r\n  }\r\n\r\n  getInverse() {\r\n    return Barrier\r\n  }\r\n}\r\n\r\n// Shortcut (instance of) BarrierGate\r\nBarrier = new BarrierGate()\r\n\r\nconst obj = {}\r\nlet _sdag = null\r\nlet _tdag = null\r\nObject.defineProperties(obj, {\r\n  Sdag: {\r\n    get() {\r\n      if (!_sdag) {\r\n        _sdag = getInverse(S)\r\n      }\r\n      return _sdag\r\n    }\r\n  },\r\n  Sdagger: {\r\n    get() {\r\n      return obj.Sdag\r\n    }\r\n  },\r\n  Tdag: {\r\n    get() {\r\n      if (!_tdag) {\r\n        _tdag = getInverse(T)\r\n      }\r\n      return _tdag\r\n    }\r\n  },\r\n  Tdagger: {\r\n    get() {\r\n      return obj.Tdag\r\n    }\r\n  }\r\n})\r\n\r\n/**\r\n * @ignore\r\n */\r\nexport default obj\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/ops/gates.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 717,
    "kind": "variable",
    "name": "mc",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~mc",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 40,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 718,
    "kind": "variable",
    "name": "mm",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~mm",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 41,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 719,
    "kind": "class",
    "name": "HGate",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~HGate",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{HGate}",
    "description": "",
    "lineNumber": 46,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "HGate"
      }
    ],
    "interface": false,
    "extends": [
      "src/ops/basics.js~SelfInverseGate"
    ]
  },
  {
    "__docId__": 720,
    "kind": "method",
    "name": "toString",
    "memberof": "src/ops/gates.js~HGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~HGate#toString",
    "access": "public",
    "description": null,
    "lineNumber": 47,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 721,
    "kind": "get",
    "name": "matrix",
    "memberof": "src/ops/gates.js~HGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~HGate#matrix",
    "access": "public",
    "description": null,
    "lineNumber": 51,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 722,
    "kind": "variable",
    "name": "H",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~H",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{H}",
    "description": null,
    "lineNumber": 59,
    "undocument": true,
    "type": {
      "types": [
        "src/ops/gates.js~HGate"
      ]
    }
  },
  {
    "__docId__": 723,
    "kind": "class",
    "name": "XGate",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~XGate",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{XGate}",
    "description": "",
    "lineNumber": 65,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "XGate"
      }
    ],
    "interface": false,
    "extends": [
      "src/ops/basics.js~SelfInverseGate"
    ]
  },
  {
    "__docId__": 724,
    "kind": "method",
    "name": "toString",
    "memberof": "src/ops/gates.js~XGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~XGate#toString",
    "access": "public",
    "description": null,
    "lineNumber": 66,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 725,
    "kind": "get",
    "name": "matrix",
    "memberof": "src/ops/gates.js~XGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~XGate#matrix",
    "access": "public",
    "description": null,
    "lineNumber": 70,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 726,
    "kind": "variable",
    "name": "X",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~X",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{X}",
    "description": null,
    "lineNumber": 80,
    "undocument": true,
    "type": {
      "types": [
        "src/ops/gates.js~XGate"
      ]
    }
  },
  {
    "__docId__": 727,
    "kind": "variable",
    "name": "NOT",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~NOT",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{NOT}",
    "description": null,
    "lineNumber": 81,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 728,
    "kind": "class",
    "name": "YGate",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~YGate",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{YGate}",
    "description": "",
    "lineNumber": 87,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "YGate"
      }
    ],
    "interface": false,
    "extends": [
      "src/ops/basics.js~SelfInverseGate"
    ]
  },
  {
    "__docId__": 729,
    "kind": "method",
    "name": "toString",
    "memberof": "src/ops/gates.js~YGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~YGate#toString",
    "access": "public",
    "description": null,
    "lineNumber": 88,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 730,
    "kind": "get",
    "name": "matrix",
    "memberof": "src/ops/gates.js~YGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~YGate#matrix",
    "access": "public",
    "description": null,
    "lineNumber": 92,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 731,
    "kind": "variable",
    "name": "Y",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~Y",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{Y}",
    "description": null,
    "lineNumber": 101,
    "undocument": true,
    "type": {
      "types": [
        "src/ops/gates.js~YGate"
      ]
    }
  },
  {
    "__docId__": 732,
    "kind": "class",
    "name": "ZGate",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~ZGate",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{ZGate}",
    "description": "",
    "lineNumber": 107,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "ZGate\nPauli-Z gate class"
      }
    ],
    "interface": false,
    "extends": [
      "src/ops/basics.js~SelfInverseGate"
    ]
  },
  {
    "__docId__": 733,
    "kind": "method",
    "name": "toString",
    "memberof": "src/ops/gates.js~ZGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~ZGate#toString",
    "access": "public",
    "description": null,
    "lineNumber": 108,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 734,
    "kind": "get",
    "name": "matrix",
    "memberof": "src/ops/gates.js~ZGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~ZGate#matrix",
    "access": "public",
    "description": null,
    "lineNumber": 112,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 735,
    "kind": "variable",
    "name": "Z",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~Z",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{Z}",
    "description": null,
    "lineNumber": 121,
    "undocument": true,
    "type": {
      "types": [
        "src/ops/gates.js~ZGate"
      ]
    }
  },
  {
    "__docId__": 736,
    "kind": "class",
    "name": "SGate",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~SGate",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{SGate}",
    "description": "",
    "lineNumber": 127,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "SGate"
      }
    ],
    "interface": false,
    "extends": [
      "src/ops/basics.js~SelfInverseGate"
    ]
  },
  {
    "__docId__": 737,
    "kind": "method",
    "name": "toString",
    "memberof": "src/ops/gates.js~SGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~SGate#toString",
    "access": "public",
    "description": null,
    "lineNumber": 128,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 738,
    "kind": "get",
    "name": "matrix",
    "memberof": "src/ops/gates.js~SGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~SGate#matrix",
    "access": "public",
    "description": null,
    "lineNumber": 132,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 739,
    "kind": "variable",
    "name": "S",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~S",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{S}",
    "description": null,
    "lineNumber": 141,
    "undocument": true,
    "type": {
      "types": [
        "src/ops/gates.js~SGate"
      ]
    }
  },
  {
    "__docId__": 740,
    "kind": "class",
    "name": "TGate",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~TGate",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{TGate}",
    "description": "",
    "lineNumber": 147,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "TGate"
      }
    ],
    "interface": false,
    "extends": [
      "src/ops/basics.js~BasicGate"
    ]
  },
  {
    "__docId__": 741,
    "kind": "get",
    "name": "matrix",
    "memberof": "src/ops/gates.js~TGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~TGate#matrix",
    "access": "public",
    "description": null,
    "lineNumber": 148,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 742,
    "kind": "method",
    "name": "toString",
    "memberof": "src/ops/gates.js~TGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~TGate#toString",
    "access": "public",
    "description": null,
    "lineNumber": 155,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 743,
    "kind": "variable",
    "name": "T",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~T",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{T}",
    "description": null,
    "lineNumber": 161,
    "undocument": true,
    "type": {
      "types": [
        "src/ops/gates.js~TGate"
      ]
    }
  },
  {
    "__docId__": 744,
    "kind": "class",
    "name": "SqrtXGate",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~SqrtXGate",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{SqrtXGate}",
    "description": "",
    "lineNumber": 167,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "SqrtXGate"
      }
    ],
    "interface": false,
    "extends": [
      "src/ops/basics.js~BasicGate"
    ]
  },
  {
    "__docId__": 745,
    "kind": "get",
    "name": "matrix",
    "memberof": "src/ops/gates.js~SqrtXGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~SqrtXGate#matrix",
    "access": "public",
    "description": null,
    "lineNumber": 168,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 746,
    "kind": "method",
    "name": "toString",
    "memberof": "src/ops/gates.js~SqrtXGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~SqrtXGate#toString",
    "access": "public",
    "description": null,
    "lineNumber": 175,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 747,
    "kind": "method",
    "name": "texString",
    "memberof": "src/ops/gates.js~SqrtXGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~SqrtXGate#texString",
    "access": "public",
    "description": null,
    "lineNumber": 179,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 748,
    "kind": "variable",
    "name": "SqrtX",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~SqrtX",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{SqrtX}",
    "description": null,
    "lineNumber": 185,
    "undocument": true,
    "type": {
      "types": [
        "src/ops/gates.js~SqrtXGate"
      ]
    }
  },
  {
    "__docId__": 749,
    "kind": "class",
    "name": "SwapGate",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~SwapGate",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{SwapGate}",
    "description": "Swap gate class (swaps 2 qubits) also self inverse gate",
    "lineNumber": 191,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "SwapGate"
      }
    ],
    "interface": false,
    "extends": [
      "src/ops/basics.js~BasicMathGate"
    ]
  },
  {
    "__docId__": 750,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/ops/gates.js~SwapGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~SwapGate#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 192,
    "undocument": true
  },
  {
    "__docId__": 751,
    "kind": "member",
    "name": "interchangeableQubitIndices",
    "memberof": "src/ops/gates.js~SwapGate",
    "static": false,
    "longname": "src/ops/gates.js~SwapGate#interchangeableQubitIndices",
    "access": "public",
    "description": null,
    "lineNumber": 194,
    "undocument": true,
    "type": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 752,
    "kind": "method",
    "name": "toString",
    "memberof": "src/ops/gates.js~SwapGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~SwapGate#toString",
    "access": "public",
    "description": null,
    "lineNumber": 197,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 753,
    "kind": "get",
    "name": "matrix",
    "memberof": "src/ops/gates.js~SwapGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~SwapGate#matrix",
    "access": "public",
    "description": null,
    "lineNumber": 201,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 754,
    "kind": "method",
    "name": "getInverse",
    "memberof": "src/ops/gates.js~SwapGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~SwapGate#getInverse",
    "access": "public",
    "description": null,
    "lineNumber": 210,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 755,
    "kind": "variable",
    "name": "Swap",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~Swap",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{Swap}",
    "description": null,
    "lineNumber": 218,
    "undocument": true,
    "type": {
      "types": [
        "src/ops/gates.js~SwapGate"
      ]
    }
  },
  {
    "__docId__": 756,
    "kind": "class",
    "name": "SqrtSwapGate",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~SqrtSwapGate",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{SqrtSwapGate}",
    "description": "Square-root Swap gate class",
    "lineNumber": 224,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "SqrtSwapGate"
      }
    ],
    "interface": false,
    "extends": [
      "src/ops/basics.js~BasicGate"
    ]
  },
  {
    "__docId__": 757,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/ops/gates.js~SqrtSwapGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~SqrtSwapGate#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 225,
    "undocument": true
  },
  {
    "__docId__": 758,
    "kind": "member",
    "name": "interchangeableQubitIndices",
    "memberof": "src/ops/gates.js~SqrtSwapGate",
    "static": false,
    "longname": "src/ops/gates.js~SqrtSwapGate#interchangeableQubitIndices",
    "access": "public",
    "description": null,
    "lineNumber": 227,
    "undocument": true,
    "type": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 759,
    "kind": "method",
    "name": "toString",
    "memberof": "src/ops/gates.js~SqrtSwapGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~SqrtSwapGate#toString",
    "access": "public",
    "description": null,
    "lineNumber": 230,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 760,
    "kind": "get",
    "name": "matrix",
    "memberof": "src/ops/gates.js~SqrtSwapGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~SqrtSwapGate#matrix",
    "access": "public",
    "description": null,
    "lineNumber": 234,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 761,
    "kind": "variable",
    "name": "SqrtSwap",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~SqrtSwap",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{SqrtSwap}",
    "description": null,
    "lineNumber": 245,
    "undocument": true,
    "type": {
      "types": [
        "src/ops/gates.js~SqrtSwapGate"
      ]
    }
  },
  {
    "__docId__": 762,
    "kind": "class",
    "name": "EntangleGate",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~EntangleGate",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{EntangleGate}",
    "description": "gate (Hadamard on first qubit, followed by CNOTs applied to all other qubits).",
    "lineNumber": 251,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "EntangleGate"
      }
    ],
    "interface": false,
    "extends": [
      "src/ops/basics.js~BasicGate"
    ]
  },
  {
    "__docId__": 763,
    "kind": "method",
    "name": "toString",
    "memberof": "src/ops/gates.js~EntangleGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~EntangleGate#toString",
    "access": "public",
    "description": null,
    "lineNumber": 252,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 764,
    "kind": "get",
    "name": "matrix",
    "memberof": "src/ops/gates.js~EntangleGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~EntangleGate#matrix",
    "access": "public",
    "description": null,
    "lineNumber": 256,
    "undocument": true,
    "type": null
  },
  {
    "__docId__": 765,
    "kind": "variable",
    "name": "Entangle",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~Entangle",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{Entangle}",
    "description": null,
    "lineNumber": 263,
    "undocument": true,
    "type": {
      "types": [
        "src/ops/gates.js~EntangleGate"
      ]
    }
  },
  {
    "__docId__": 766,
    "kind": "class",
    "name": "Ph",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~Ph",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{Ph}",
    "description": "Phase gate (global phase)",
    "lineNumber": 269,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "Ph"
      }
    ],
    "interface": false,
    "extends": [
      "src/ops/basics.js~BasicPhaseGate"
    ]
  },
  {
    "__docId__": 767,
    "kind": "get",
    "name": "matrix",
    "memberof": "src/ops/gates.js~Ph",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~Ph#matrix",
    "access": "public",
    "description": null,
    "lineNumber": 270,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 768,
    "kind": "class",
    "name": "Rx",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~Rx",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{Rx}",
    "description": "",
    "lineNumber": 281,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "Rx"
      }
    ],
    "interface": false,
    "extends": [
      "src/ops/basics.js~BasicRotationGate"
    ]
  },
  {
    "__docId__": 769,
    "kind": "get",
    "name": "matrix",
    "memberof": "src/ops/gates.js~Rx",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~Rx#matrix",
    "access": "public",
    "description": null,
    "lineNumber": 282,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 770,
    "kind": "class",
    "name": "Ry",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~Ry",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{Ry}",
    "description": "",
    "lineNumber": 293,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "Ry"
      }
    ],
    "interface": false,
    "extends": [
      "src/ops/basics.js~BasicRotationGate"
    ]
  },
  {
    "__docId__": 771,
    "kind": "get",
    "name": "matrix",
    "memberof": "src/ops/gates.js~Ry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~Ry#matrix",
    "access": "public",
    "description": null,
    "lineNumber": 294,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 772,
    "kind": "class",
    "name": "Rz",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~Rz",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{Rz}",
    "description": "RotationZ gate class",
    "lineNumber": 306,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "Rz"
      }
    ],
    "interface": false,
    "extends": [
      "src/ops/basics.js~BasicRotationGate"
    ]
  },
  {
    "__docId__": 773,
    "kind": "get",
    "name": "matrix",
    "memberof": "src/ops/gates.js~Rz",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~Rz#matrix",
    "access": "public",
    "description": null,
    "lineNumber": 307,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 774,
    "kind": "class",
    "name": "R",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~R",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{R}",
    "description": "Phase-shift gate (equivalent to Rz up to a global phase)",
    "lineNumber": 319,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "R"
      }
    ],
    "interface": false,
    "extends": [
      "src/ops/basics.js~BasicPhaseGate"
    ]
  },
  {
    "__docId__": 775,
    "kind": "get",
    "name": "matrix",
    "memberof": "src/ops/gates.js~R",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~R#matrix",
    "access": "public",
    "description": null,
    "lineNumber": 320,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 776,
    "kind": "class",
    "name": "FlushGate",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~FlushGate",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{FlushGate}",
    "description": "Flush gate (denotes the end of the circuit).\n\nNote:\nAll compiler engines (cengines) which cache/buffer gates are obligated\nto flush and send all gates to the next compiler engine (followed by\nthe flush command).\n\nNote:\nThis gate is sent when calling",
    "examples": [
      "\neng.flush()\n\non the MainEngine `eng`."
    ],
    "lineNumber": 345,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "FlushGate"
      }
    ],
    "interface": false,
    "extends": [
      "src/ops/basics.js~FastForwardingGate"
    ]
  },
  {
    "__docId__": 777,
    "kind": "method",
    "name": "toString",
    "memberof": "src/ops/gates.js~FlushGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~FlushGate#toString",
    "access": "public",
    "description": null,
    "lineNumber": 346,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 778,
    "kind": "class",
    "name": "MeasureGate",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~MeasureGate",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{MeasureGate}",
    "description": "Measurement gate class (for single qubits).",
    "lineNumber": 355,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "MeasureGate"
      }
    ],
    "interface": false,
    "extends": [
      "src/ops/basics.js~FastForwardingGate"
    ]
  },
  {
    "__docId__": 779,
    "kind": "method",
    "name": "toString",
    "memberof": "src/ops/gates.js~MeasureGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~MeasureGate#toString",
    "access": "public",
    "description": null,
    "lineNumber": 356,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 780,
    "kind": "method",
    "name": "or",
    "memberof": "src/ops/gates.js~MeasureGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~MeasureGate#or",
    "access": "public",
    "description": "Previously (ProjectQ <= v0.3.6) MeasureGate/Measure was allowed to be\napplied to any number of quantum registers. Now the MeasureGate/Measure\nis strictly a single qubit gate. In the coming releases the backward\ncompatibility will be removed!",
    "lineNumber": 367,
    "params": [
      {
        "name": "qubits",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 781,
    "kind": "variable",
    "name": "Measure",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~Measure",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{Measure}",
    "description": null,
    "lineNumber": 388,
    "undocument": true,
    "type": {
      "types": [
        "src/ops/gates.js~MeasureGate"
      ]
    }
  },
  {
    "__docId__": 782,
    "kind": "class",
    "name": "AllocateQubitGate",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~AllocateQubitGate",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{AllocateQubitGate}",
    "description": "",
    "lineNumber": 395,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "AllocateQubitGate"
      }
    ],
    "interface": false,
    "extends": [
      "src/ops/basics.js~ClassicalInstructionGate"
    ]
  },
  {
    "__docId__": 783,
    "kind": "method",
    "name": "toString",
    "memberof": "src/ops/gates.js~AllocateQubitGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~AllocateQubitGate#toString",
    "access": "public",
    "description": null,
    "lineNumber": 396,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 784,
    "kind": "method",
    "name": "getInverse",
    "memberof": "src/ops/gates.js~AllocateQubitGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~AllocateQubitGate#getInverse",
    "access": "public",
    "description": null,
    "lineNumber": 400,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 785,
    "kind": "variable",
    "name": "Allocate",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~Allocate",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{Allocate}",
    "description": null,
    "lineNumber": 406,
    "undocument": true,
    "type": {
      "types": [
        "src/ops/gates.js~AllocateQubitGate"
      ]
    }
  },
  {
    "__docId__": 786,
    "kind": "class",
    "name": "DeallocateQubitGate",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~DeallocateQubitGate",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{DeallocateQubitGate}",
    "description": "",
    "lineNumber": 411,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "DeallocateQubitGate"
      }
    ],
    "interface": false,
    "extends": [
      "src/ops/basics.js~FastForwardingGate"
    ]
  },
  {
    "__docId__": 787,
    "kind": "method",
    "name": "toString",
    "memberof": "src/ops/gates.js~DeallocateQubitGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~DeallocateQubitGate#toString",
    "access": "public",
    "description": null,
    "lineNumber": 412,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 788,
    "kind": "method",
    "name": "getInverse",
    "memberof": "src/ops/gates.js~DeallocateQubitGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~DeallocateQubitGate#getInverse",
    "access": "public",
    "description": null,
    "lineNumber": 416,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 789,
    "kind": "class",
    "name": "AllocateDirtyQubitGate",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~AllocateDirtyQubitGate",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{AllocateDirtyQubitGate}",
    "description": "",
    "lineNumber": 427,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "AllocateDirtyQubitGate"
      }
    ],
    "interface": false,
    "extends": [
      "src/ops/basics.js~ClassicalInstructionGate"
    ]
  },
  {
    "__docId__": 790,
    "kind": "method",
    "name": "toString",
    "memberof": "src/ops/gates.js~AllocateDirtyQubitGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~AllocateDirtyQubitGate#toString",
    "access": "public",
    "description": null,
    "lineNumber": 428,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 791,
    "kind": "method",
    "name": "getInverse",
    "memberof": "src/ops/gates.js~AllocateDirtyQubitGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~AllocateDirtyQubitGate#getInverse",
    "access": "public",
    "description": null,
    "lineNumber": 432,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 792,
    "kind": "variable",
    "name": "AllocateDirty",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~AllocateDirty",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{AllocateDirty}",
    "description": null,
    "lineNumber": 438,
    "undocument": true,
    "type": {
      "types": [
        "src/ops/gates.js~AllocateDirtyQubitGate"
      ]
    }
  },
  {
    "__docId__": 793,
    "kind": "class",
    "name": "BarrierGate",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~BarrierGate",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{BarrierGate}",
    "description": null,
    "lineNumber": 442,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/ops/basics.js~BasicGate"
    ]
  },
  {
    "__docId__": 794,
    "kind": "method",
    "name": "toString",
    "memberof": "src/ops/gates.js~BarrierGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~BarrierGate#toString",
    "access": "public",
    "description": null,
    "lineNumber": 443,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 795,
    "kind": "method",
    "name": "getInverse",
    "memberof": "src/ops/gates.js~BarrierGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~BarrierGate#getInverse",
    "access": "public",
    "description": null,
    "lineNumber": 447,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 796,
    "kind": "variable",
    "name": "_sdag",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~_sdag",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 456,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 797,
    "kind": "variable",
    "name": "_tdag",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~_tdag",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 457,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 798,
    "kind": "variable",
    "name": "obj",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~obj",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "obj",
    "description": "",
    "lineNumber": 455,
    "ignore": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 799,
    "kind": "file",
    "name": "src/ops/metagates.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/**\r\n* Contains meta gates, i.e.,\r\n* DaggeredGate (Represents the inverse of an arbitrary gate)\r\n* ControlledGate (Represents a controlled version of an arbitrary gate)\r\n* Tensor/All (Applies a single qubit gate to all supplied qubits), e.g.,\r\n    @example\r\n\r\nTensor(H) | (qubit1, qubit2) # apply H to qubit #1 and #2\r\n\r\nAs well as the meta functions\r\n* getInverse (Tries to access the getInverse member function of a gate\r\nand upon failure returns a DaggeredGate)\r\n* C (Creates an n-ary controlled version of an arbitrary gate)\r\n*/\r\nimport math from 'mathjs'\r\nimport {BasicGate} from './basics'\r\nimport {Control} from '../meta/control'\r\nimport Cycle, {getInverse} from './_cycle'\r\nimport { arrayIsTuple } from '../libs/util'\r\n\r\n/**\r\n * @class DaggeredGate\r\n * @desc\r\nWrapper class allowing to execute the inverse of a gate, even when it does\r\nnot define one.\r\n\r\n    If there is a replacement available, then there is also one for the\r\n    inverse, namely the replacement function run in reverse, while inverting\r\n    all gates. This class enables using this emulation automatically.\r\n\r\n    A DaggeredGate is returned automatically when employing the getInverse-\r\nfunction on a gate which does not provide a getInverse() member function.\r\n\r\n@example\r\n\r\nwith Dagger(eng)\r\nMySpecialGate | qubits\r\n\r\nwill create a DaggeredGate if MySpecialGate does not implement\r\ngetInverse. If there is a decomposition function available, an auto-\r\nreplacer engine can automatically replace the inverted gate by a call to\r\nthe decomposition function inside a \"with Dagger\"-statement.\r\n */\r\nexport class DaggeredGate extends BasicGate {\r\n  /**\r\n   * @constructor\r\n    Initialize a DaggeredGate representing the inverse of the gate 'gate'.\r\n\r\n    @param {BasicGate} gate Any gate object of which to represent the inverse.\r\n     */\r\n  constructor(gate) {\r\n    super()\r\n    this.gate = gate\r\n    try {\r\n      this._matrix = math.ctranspose(gate.matrix)\r\n    } catch (e) {\r\n\r\n    }\r\n  }\r\n\r\n  getInverse() {\r\n    return this.gate\r\n  }\r\n\r\n  get matrix() {\r\n    if (!this._matrix) {\r\n      throw new Error('No this attribute')\r\n    }\r\n    return this._matrix\r\n  }\r\n\r\n\r\n  /**\r\n    Return true if self is equal to other, i.e., same type and representing the inverse of the same gate.\r\n  */\r\n  equal(other) {\r\n    return other instanceof DaggeredGate && other.gate.equal(this.gate)\r\n  }\r\n\r\n  toString() {\r\n    return `${this.gate.toString()}^\\\\dagger`\r\n  }\r\n\r\n  texString() {\r\n    if (this.gate.texString) {\r\n      return `$${this.gate.texString()}^\\\\dagger$`\r\n    } else {\r\n      return `$${this.gate.toString()}^\\\\dagger$`\r\n    }\r\n  }\r\n}\r\n\r\nCycle.add('DaggeredGate', DaggeredGate)\r\n\r\n/**\r\n * @class ControlledGate\r\n * @desc\r\nControlled version of a gate.\r\n\r\n    Note:\r\nUse the meta function :func:`C()` to create a controlled gate\r\n\r\nA wrapper class which enables (multi-) controlled gates. It overloads\r\nthe __or__-operator, using the first qubits provided as control qubits.\r\n    The n control-qubits need to be the first n qubits. They can be in\r\nseparate quregs.\r\n\r\n    @example\r\n\r\nControlledGate(gate, 2) | (qb0, qb2, qb3) # qb0 & qb2 are controls\r\nC(gate, 2) | (qb0, qb2, qb3) # This is much nicer.\r\nC(gate, 2) | ([qb0,qb2], qb3) # Is equivalent\r\n\r\nNote:\r\n    Use :func:`C` rather than ControlledGate, i.e.,\r\n\r\n @example\r\n\r\nC(X, 2) == Toffoli\r\n */\r\nexport class ControlledGate extends BasicGate {\r\n  /**\r\n   * @constructor\r\n    @param {BasicGate} gate Gate to wrap.\r\n    @param {number} n Number of control qubits.\r\n  */\r\n  constructor(gate, n = 1) {\r\n    super()\r\n    if (gate instanceof ControlledGate) {\r\n      this.gate = gate.gate\r\n      this.n = gate.n + n\r\n    } else {\r\n      this.gate = gate\r\n      this.n = n\r\n    }\r\n  }\r\n\r\n  getInverse() {\r\n    return new ControlledGate(getInverse(this.gate), this.n)\r\n  }\r\n\r\n  /**\r\n    Apply the controlled gate to qubits, using the first n qubits as\r\ncontrols.\r\n\r\n    Note: The control qubits can be split across the first quregs.\r\n    However, the n-th control qubit needs to be the last qubit in a\r\nqureg. The following quregs belong to the gate.\r\n\r\n    @param {Array.<Qureg>} qubits qubits to which to apply the gate.\r\n     */\r\n  or(qubits) {\r\n    qubits = BasicGate.makeTupleOfQureg(qubits)\r\n    let ctrl = []\r\n    const gateQuregs = []\r\n    let addingToControls = true\r\n    qubits.forEach((reg) => {\r\n      if (addingToControls) {\r\n        ctrl = ctrl.concat(reg)\r\n        addingToControls = ctrl.length < this.n\r\n      } else {\r\n        gateQuregs.push(reg)\r\n      }\r\n    })\r\n\r\n    // Test that there were enough control quregs and that that\r\n    // the last control qubit was the last qubit in a qureg.\r\n    if (ctrl.length !== this.n) {\r\n      throw new Error('Wrong number of control qubits. '\r\n            + 'First qureg(s) need to contain exactly '\r\n            + 'the required number of control quregs.')\r\n    }\r\n\r\n    Control(gateQuregs[0][0].engine, ctrl, () => this.gate.or(gateQuregs))\r\n  }\r\n\r\n  toString() {\r\n    let prefix = ''\r\n    for (let i = 0; i < this.n; ++i) {\r\n      prefix += 'C'\r\n    }\r\n    return `${prefix}${this.gate.toString()}`\r\n  }\r\n\r\n  equal(other) {\r\n    if (other instanceof this.__proto__.constructor) {\r\n      return this.gate.equal(other.gate) && this.n === other.n\r\n    }\r\n    return false\r\n  }\r\n}\r\n\r\n/**\r\nReturn n-controlled version of the provided gate.\r\n\r\n    @param {BasicGate} gate Gate to turn into its controlled version\r\n    @param {number} n Number of controls (default: 1)\r\n\r\n@example\r\n\r\nC(NOT) | (c, q) # equivalent to CNOT | (c, q)\r\n */\r\nexport function C(gate, n = 1) {\r\n  return new ControlledGate(gate, n)\r\n}\r\n\r\n/**\r\n * @class Tensor\r\n * @desc\r\nWrapper class allowing to apply a (single-qubit) gate to every qubit in a\r\nquantum register. Allowed syntax is to supply either a qureg or a tuple\r\nwhich contains only one qureg.\r\n\r\n    @example\r\n\r\nTensor(H) | x # applies H to every qubit in the list of qubits x\r\nTensor(H) | (x,) # alternative to be consistent with other syntax\r\n */\r\nexport class Tensor extends BasicGate {\r\n  /**\r\n   * @constructor\r\n   * @param {BasicGate} gate\r\n   */\r\n  constructor(gate) {\r\n    super()\r\n    this.gate = gate\r\n  }\r\n\r\n  getInverse() {\r\n    return new Tensor(getInverse(this.gate))\r\n  }\r\n\r\n  or(qubits) {\r\n    const isTuple = arrayIsTuple(qubits)\r\n    let array = null\r\n    if (isTuple) {\r\n      if (qubits.length !== 1) {\r\n        throw new Error('wrong length')\r\n      }\r\n      array = qubits[0]\r\n    } else {\r\n      array = qubits\r\n    }\r\n    if (!Array.isArray(array)) {\r\n      throw new Error('should be array type!')\r\n    }\r\n    array.forEach(q => this.gate.or(q))\r\n  }\r\n\r\n  toString() {\r\n    return `Tensor(${this.gate.toString()})`\r\n  }\r\n}\r\n\r\nexport const All = Tensor\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/ops/metagates.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 800,
    "kind": "class",
    "name": "DaggeredGate",
    "memberof": "src/ops/metagates.js",
    "static": true,
    "longname": "src/ops/metagates.js~DaggeredGate",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/metagates.js",
    "importStyle": "{DaggeredGate}",
    "description": "Wrapper class allowing to execute the inverse of a gate, even when it does\nnot define one.\n\nIf there is a replacement available, then there is also one for the\ninverse, namely the replacement function run in reverse, while inverting\nall gates. This class enables using this emulation automatically.\n\nA DaggeredGate is returned automatically when employing the getInverse-\nfunction on a gate which does not provide a getInverse() member function.",
    "examples": [
      "\nwith Dagger(eng)\nMySpecialGate | qubits\n\nwill create a DaggeredGate if MySpecialGate does not implement\ngetInverse. If there is a decomposition function available, an auto-\nreplacer engine can automatically replace the inverted gate by a call to\nthe decomposition function inside a \"with Dagger\"-statement."
    ],
    "lineNumber": 60,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "DaggeredGate"
      }
    ],
    "interface": false,
    "extends": [
      "src/ops/basics.js~BasicGate"
    ]
  },
  {
    "__docId__": 801,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/ops/metagates.js~DaggeredGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/metagates.js~DaggeredGate#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 67,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": "Initialize a DaggeredGate representing the inverse of the gate 'gate'."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "BasicGate"
        ],
        "spread": false,
        "optional": false,
        "name": "gate",
        "description": "Any gate object of which to represent the inverse."
      }
    ]
  },
  {
    "__docId__": 802,
    "kind": "member",
    "name": "gate",
    "memberof": "src/ops/metagates.js~DaggeredGate",
    "static": false,
    "longname": "src/ops/metagates.js~DaggeredGate#gate",
    "access": "public",
    "description": null,
    "lineNumber": 69,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 803,
    "kind": "member",
    "name": "_matrix",
    "memberof": "src/ops/metagates.js~DaggeredGate",
    "static": false,
    "longname": "src/ops/metagates.js~DaggeredGate#_matrix",
    "access": "private",
    "description": null,
    "lineNumber": 71,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 804,
    "kind": "method",
    "name": "getInverse",
    "memberof": "src/ops/metagates.js~DaggeredGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/metagates.js~DaggeredGate#getInverse",
    "access": "public",
    "description": null,
    "lineNumber": 77,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 805,
    "kind": "get",
    "name": "matrix",
    "memberof": "src/ops/metagates.js~DaggeredGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/metagates.js~DaggeredGate#matrix",
    "access": "public",
    "description": null,
    "lineNumber": 81,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 806,
    "kind": "method",
    "name": "equal",
    "memberof": "src/ops/metagates.js~DaggeredGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/metagates.js~DaggeredGate#equal",
    "access": "public",
    "description": "Return true if self is equal to other, i.e., same type and representing the inverse of the same gate.",
    "lineNumber": 92,
    "params": [
      {
        "name": "other",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 807,
    "kind": "method",
    "name": "toString",
    "memberof": "src/ops/metagates.js~DaggeredGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/metagates.js~DaggeredGate#toString",
    "access": "public",
    "description": null,
    "lineNumber": 96,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 808,
    "kind": "method",
    "name": "texString",
    "memberof": "src/ops/metagates.js~DaggeredGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/metagates.js~DaggeredGate#texString",
    "access": "public",
    "description": null,
    "lineNumber": 100,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 809,
    "kind": "class",
    "name": "ControlledGate",
    "memberof": "src/ops/metagates.js",
    "static": true,
    "longname": "src/ops/metagates.js~ControlledGate",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/metagates.js",
    "importStyle": "{ControlledGate}",
    "description": "Controlled version of a gate.\n\nNote:\nUse the meta function :func:`C()` to create a controlled gate\n\nA wrapper class which enables (multi-) controlled gates. It overloads\nthe __or__-operator, using the first qubits provided as control qubits.\nThe n control-qubits need to be the first n qubits. They can be in\nseparate quregs.",
    "examples": [
      "\nControlledGate(gate, 2) | (qb0, qb2, qb3) # qb0 & qb2 are controls\nC(gate, 2) | (qb0, qb2, qb3) # This is much nicer.\nC(gate, 2) | ([qb0,qb2], qb3) # Is equivalent\n\nNote:\nUse :func:`C` rather than ControlledGate, i.e.,",
      "\nC(X, 2) == Toffoli"
    ],
    "lineNumber": 137,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "ControlledGate"
      }
    ],
    "interface": false,
    "extends": [
      "src/ops/basics.js~BasicGate"
    ]
  },
  {
    "__docId__": 810,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/ops/metagates.js~ControlledGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/metagates.js~ControlledGate#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 143,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "BasicGate"
        ],
        "spread": false,
        "optional": false,
        "name": "gate",
        "description": "Gate to wrap."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "n",
        "description": "Number of control qubits."
      }
    ]
  },
  {
    "__docId__": 811,
    "kind": "member",
    "name": "gate",
    "memberof": "src/ops/metagates.js~ControlledGate",
    "static": false,
    "longname": "src/ops/metagates.js~ControlledGate#gate",
    "access": "public",
    "description": null,
    "lineNumber": 146,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 812,
    "kind": "member",
    "name": "n",
    "memberof": "src/ops/metagates.js~ControlledGate",
    "static": false,
    "longname": "src/ops/metagates.js~ControlledGate#n",
    "access": "public",
    "description": null,
    "lineNumber": 147,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 815,
    "kind": "method",
    "name": "getInverse",
    "memberof": "src/ops/metagates.js~ControlledGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/metagates.js~ControlledGate#getInverse",
    "access": "public",
    "description": null,
    "lineNumber": 154,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 816,
    "kind": "method",
    "name": "or",
    "memberof": "src/ops/metagates.js~ControlledGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/metagates.js~ControlledGate#or",
    "access": "public",
    "description": "Apply the controlled gate to qubits, using the first n qubits as\ncontrols.\n\nNote: The control qubits can be split across the first quregs.\nHowever, the n-th control qubit needs to be the last qubit in a\nqureg. The following quregs belong to the gate.",
    "lineNumber": 168,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array.<Qureg>"
        ],
        "spread": false,
        "optional": false,
        "name": "qubits",
        "description": "qubits to which to apply the gate."
      }
    ],
    "return": null
  },
  {
    "__docId__": 817,
    "kind": "method",
    "name": "toString",
    "memberof": "src/ops/metagates.js~ControlledGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/metagates.js~ControlledGate#toString",
    "access": "public",
    "description": null,
    "lineNumber": 193,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 818,
    "kind": "method",
    "name": "equal",
    "memberof": "src/ops/metagates.js~ControlledGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/metagates.js~ControlledGate#equal",
    "access": "public",
    "description": null,
    "lineNumber": 201,
    "undocument": true,
    "params": [
      {
        "name": "other",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 819,
    "kind": "function",
    "name": "C",
    "memberof": "src/ops/metagates.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/ops/metagates.js~C",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/metagates.js",
    "importStyle": "{C}",
    "description": "Return n-controlled version of the provided gate.",
    "examples": [
      "\nC(NOT) | (c, q) # equivalent to CNOT | (c, q)"
    ],
    "lineNumber": 219,
    "params": [
      {
        "nullable": null,
        "types": [
          "BasicGate"
        ],
        "spread": false,
        "optional": false,
        "name": "gate",
        "description": "Gate to turn into its controlled version"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "n",
        "description": "Number of controls (default: 1)"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 820,
    "kind": "class",
    "name": "Tensor",
    "memberof": "src/ops/metagates.js",
    "static": true,
    "longname": "src/ops/metagates.js~Tensor",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/metagates.js",
    "importStyle": "{Tensor}",
    "description": "Wrapper class allowing to apply a (single-qubit) gate to every qubit in a\nquantum register. Allowed syntax is to supply either a qureg or a tuple\nwhich contains only one qureg.",
    "examples": [
      "\nTensor(H) | x # applies H to every qubit in the list of qubits x\nTensor(H) | (x,) # alternative to be consistent with other syntax"
    ],
    "lineNumber": 235,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "Tensor"
      }
    ],
    "interface": false,
    "extends": [
      "src/ops/basics.js~BasicGate"
    ]
  },
  {
    "__docId__": 821,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/ops/metagates.js~Tensor",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/metagates.js~Tensor#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 240,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "BasicGate"
        ],
        "spread": false,
        "optional": false,
        "name": "gate",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 822,
    "kind": "member",
    "name": "gate",
    "memberof": "src/ops/metagates.js~Tensor",
    "static": false,
    "longname": "src/ops/metagates.js~Tensor#gate",
    "access": "public",
    "description": null,
    "lineNumber": 242,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 823,
    "kind": "method",
    "name": "getInverse",
    "memberof": "src/ops/metagates.js~Tensor",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/metagates.js~Tensor#getInverse",
    "access": "public",
    "description": null,
    "lineNumber": 245,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 824,
    "kind": "method",
    "name": "or",
    "memberof": "src/ops/metagates.js~Tensor",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/metagates.js~Tensor#or",
    "access": "public",
    "description": null,
    "lineNumber": 249,
    "undocument": true,
    "params": [
      {
        "name": "qubits",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 825,
    "kind": "method",
    "name": "toString",
    "memberof": "src/ops/metagates.js~Tensor",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/metagates.js~Tensor#toString",
    "access": "public",
    "description": null,
    "lineNumber": 266,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 826,
    "kind": "variable",
    "name": "All",
    "memberof": "src/ops/metagates.js",
    "static": true,
    "longname": "src/ops/metagates.js~All",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/metagates.js",
    "importStyle": "{All}",
    "description": null,
    "lineNumber": 271,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 827,
    "kind": "file",
    "name": "src/ops/qftgate.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport {BasicGate} from './basics'\r\n\r\n/**\r\n * Quantum Fourier Transform gate\r\n */\r\nexport default class QFTGate extends BasicGate {\r\n  toString() {\r\n    return 'QFT'\r\n  }\r\n}\r\n\r\nexport const QFT = new QFTGate()\r\n\r\n// Shortcut (instance of) :class:`projectq.ops.QFTGate`\r\nQFTGate.QFT = QFT\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/ops/qftgate.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 828,
    "kind": "class",
    "name": "QFTGate",
    "memberof": "src/ops/qftgate.js",
    "static": true,
    "longname": "src/ops/qftgate.js~QFTGate",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/qftgate.js",
    "importStyle": "QFTGate",
    "description": "Quantum Fourier Transform gate",
    "lineNumber": 22,
    "interface": false,
    "extends": [
      "src/ops/basics.js~BasicGate"
    ]
  },
  {
    "__docId__": 829,
    "kind": "method",
    "name": "toString",
    "memberof": "src/ops/qftgate.js~QFTGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/qftgate.js~QFTGate#toString",
    "access": "public",
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 830,
    "kind": "variable",
    "name": "QFT",
    "memberof": "src/ops/qftgate.js",
    "static": true,
    "longname": "src/ops/qftgate.js~QFT",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/qftgate.js",
    "importStyle": "{QFT}",
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "type": {
      "types": [
        "src/ops/qftgate.js~QFTGate"
      ]
    }
  },
  {
    "__docId__": 831,
    "kind": "file",
    "name": "src/ops/qubitoperator.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport math from 'mathjs'\r\n\r\n// QubitOperator stores a sum of Pauli operators acting on qubits.\"\"\"\r\nimport {isNumeric, symmetricDifference} from '../libs/polyfill'\r\n\r\nconst mc = math.complex\r\n\r\nconst EQ_TOLERANCE = 1e-12\r\n\r\n\r\n/**\r\n * Define products of all Pauli operators for symbolic multiplication.\r\n * @ignore\r\n */\r\nexport const PAULI_OPERATOR_PRODUCTS = {\r\n  [['I', 'I']]: [1.0, 'I'],\r\n  [['I', 'X']]: [1.0, 'X'],\r\n  [['X', 'I']]: [1.0, 'X'],\r\n  [['I', 'Y']]: [1.0, 'Y'],\r\n  [['Y', 'I']]: [1.0, 'Y'],\r\n  [['I', 'Z']]: [1.0, 'Z'],\r\n  [['Z', 'I']]: [1.0, 'Z'],\r\n  [['X', 'X']]: [1.0, 'I'],\r\n  [['Y', 'Y']]: [1.0, 'I'],\r\n  [['Z', 'Z']]: [1.0, 'I'],\r\n  [['X', 'Y']]: [mc(0, 1), 'Z'],\r\n  [['X', 'Z']]: [mc(0, -1), 'Y'],\r\n  [['Y', 'X']]: [mc(0, -1), 'Z'],\r\n  [['Y', 'Z']]: [mc(0, 1), 'X'],\r\n  [['Z', 'X']]: [mc(0, 1), 'Y'],\r\n  [['Z', 'Y']]: [mc(0, -1), 'X']\r\n}\r\n\r\n/**\r\n * @ignore\r\n * @param {string} key\r\n * @return {Array}\r\n */\r\nexport function stringToArray(key) {\r\n  const parts = key.split(',').filter(item => item.length > 0)\r\n  if (parts.length % 2 === 0) {\r\n    const result = []\r\n    for (let i = 0; i < parts.length; i += 2) {\r\n      result.push([parseInt(parts[i], 10), parts[i + 1]])\r\n    }\r\n    return result\r\n  } else {\r\n    throw new Error(`invalid key ${key}`)\r\n  }\r\n}\r\n\r\nfunction checkTerm(term) {\r\n  term.forEach((localOperator) => {\r\n    if (!Array.isArray(localOperator) || localOperator.length !== 2) {\r\n      throw new Error('term specified incorrectly')\r\n    }\r\n    const [qubitNum, action] = localOperator\r\n    if (typeof action !== 'string' || 'XYZ'.indexOf(action) === -1) {\r\n      throw new Error('Invalid action provided: must be string \\'X\\', \\'Y\\', or \\'Z\\'.')\r\n    }\r\n    if (typeof qubitNum !== 'number' || qubitNum < 0) {\r\n      throw new Error('Invalid qubit number '\r\n          + 'provided to QubitTerm: '\r\n          + 'must be a non-negative '\r\n          + 'int.')\r\n    }\r\n  })\r\n}\r\n\r\n/**\r\n * @class QubitOperator\r\n * @desc\r\nA sum of terms acting on qubits, e.g., 0.5 * 'X0 X5' + 0.3 * 'Z1 Z2'.\r\n\r\n    A term is an operator acting on n qubits and can be represented as:\r\n\r\ncoefficent * local_operator[0] x ... x local_operator[n-1]\r\n\r\nwhere x is the tensor product. A local operator is a Pauli operator\r\n('I', 'X', 'Y', or 'Z') which acts on one qubit. In math notation a term\r\nis, for example, 0.5 * 'X0 X5', which means that a Pauli X operator acts\r\non qubit 0 and 5, while the identity operator acts on all other qubits.\r\n\r\n    A QubitOperator represents a sum of terms acting on qubits and overloads\r\noperations for easy manipulation of these objects by the user.\r\n\r\n    Note for a QubitOperator to be a Hamiltonian which is a hermitian\r\noperator, the coefficients of all terms must be real.\r\n\r\n @example\r\n\r\nhamiltonian = 0.5 * QubitOperator('X0 X5') + 0.3 * QubitOperator('Z0')\r\n\r\nAttributes:\r\n    terms (dict): **key**: A term represented by a tuple containing all\r\nnon-trivial local Pauli operators ('X', 'Y', or 'Z').\r\nA non-trivial local Pauli operator is specified by a\r\ntuple with the first element being an integer\r\nindicating the qubit on which a non-trivial local\r\noperator acts and the second element being a string,\r\n    either 'X', 'Y', or 'Z', indicating which non-trivial\r\nPauli operator acts on that qubit. Examples:\r\n((1, 'X'),) or ((1, 'X'), (4,'Z')) or the identity ().\r\n    The tuples representing the non-trivial local terms\r\nare sorted according to the qubit number they act on,\r\n    starting from 0.\r\n**value**: Coefficient of this term as a (complex) float\r\n */\r\nexport default class QubitOperator {\r\n  /**\r\n   * @constructor\r\n    The init function only allows to initialize one term. Additional terms\r\nhave to be added using += (which is fast) or using + of two\r\nQubitOperator objects:\r\n\r\n    @example\r\n\r\nham = ((QubitOperator('X0 Y3', 0.5)\r\n    + 0.6 * QubitOperator('X0 Y3')))\r\n# Equivalently\r\nham2 = QubitOperator('X0 Y3', 0.5)\r\nham2 += 0.6 * QubitOperator('X0 Y3')\r\n\r\nNote:\r\n    Adding terms to QubitOperator is faster using += (as this is done\r\nby in-place addition). Specifying the coefficient in the __init__\r\nis faster than by multiplying a QubitOperator with a scalar as\r\ncalls an out-of-place multiplication.\r\n\r\n    @param {number|Complex} coefficient The coefficient of the\r\nfirst term of this QubitOperator. Default is 1.0.\r\n    @param {Array.<Array>|string} term (optional, empy array, a array of arrays, or a string):\r\n1) Default is None which means there are no terms in the\r\nQubitOperator hence it is the \"zero\" Operator\r\n2) An empty tuple means there are no non-trivial Pauli\r\noperators acting on the qubits hence only identities\r\nwith a coefficient (which by default is 1.0).\r\n3) A sorted tuple of tuples. The first element of each tuple\r\nis an integer indicating the qubit on which a non-trivial\r\nlocal operator acts, starting from zero. The second element\r\nof each tuple is a string, either 'X', 'Y' or 'Z',\r\n    indicating which local operator acts on that qubit.\r\n4) A string of the form 'X0 Z2 Y5', indicating an X on\r\nqubit 0, Z on qubit 2, and Y on qubit 5. The string should\r\nbe sorted by the qubit number. '' is the identity.\r\n\r\n    @throws {QubitOperatorError} Invalid operators provided to QubitOperator.\r\n     */\r\n  constructor(term, coefficient = 1.0) {\r\n    // assert coefficient as numeric\r\n    this.terms = {}\r\n    if (!isNumeric(coefficient)) {\r\n      throw new Error('Coefficient must be a numeric type.')\r\n    }\r\n\r\n    if (typeof term === 'undefined') {\r\n      // leave it empty\r\n    } else if (Array.isArray(term)) {\r\n      if (term.length === 0) {\r\n        this.terms[[]] = coefficient\r\n      } else {\r\n        checkTerm(term)\r\n        term = term.sort((a, b) => a[0] - b[0])\r\n        this.terms[term] = coefficient\r\n      }\r\n    } else if (typeof term === 'string') {\r\n      const listOPs = []\r\n      const parts = term.split(/\\s+/).filter(item => item.length > 0)\r\n      parts.forEach((el) => {\r\n        if (el.length < 2) {\r\n          throw new Error('term specified incorrectly.')\r\n        }\r\n        listOPs.push([parseInt(el.substring(1), 10), el[0]])\r\n      })\r\n\r\n      checkTerm(listOPs)\r\n\r\n      term = listOPs.sort((a, b) => a[0] - b[0])\r\n      this.terms[term] = coefficient\r\n    } else {\r\n      throw new Error('term specified incorrectly.')\r\n    }\r\n  }\r\n\r\n  /**\r\n    Eliminates all terms with coefficients close to zero and removes\r\nimaginary parts of coefficients that are close to zero.\r\n\r\n    @param {number} absTolerance Absolute tolerance, must be at least 0.0\r\n     */\r\n  compress(absTolerance = 1e-12) {\r\n    const new_terms = {}\r\n    Object.keys(this.terms).forEach((key) => {\r\n      let coeff = this.terms[key]\r\n      if (math.abs(math.im(coeff)) <= absTolerance) {\r\n        coeff = math.re(coeff)\r\n      }\r\n      if (math.abs(coeff) > absTolerance) {\r\n        new_terms[key] = coeff\r\n      }\r\n    })\r\n    this.terms = new_terms\r\n  }\r\n\r\n  /**\r\n    Returns true if other (QubitOperator) is close to this.\r\n\r\n    Comparison is done for each term individually. Return true\r\nif the difference between each term in self and other is\r\nless than the relative tolerance w.r.t. either other or self\r\n(symmetric test) or if the difference is less than the absolute\r\ntolerance.\r\n\r\n    @param {QubitOperator} other QubitOperator to compare against.\r\n    @param {number} realTolerance Relative tolerance, must be greater than 0.0\r\n    @param {number} absTolerance Absolute tolerance, must be at least 0.0\r\n  */\r\n  isClose(other, realTolerance = EQ_TOLERANCE, absTolerance = EQ_TOLERANCE) {\r\n    // terms which are in both\r\n    const otherKeys = new Set(Object.keys(other.terms))\r\n    const myKeys = Object.keys(this.terms)\r\n    const intersection = new Set(myKeys.filter(x => otherKeys.has(x)))\r\n    for (const term of intersection) {\r\n      const a = this.terms[term]\r\n      const b = other.terms[term]\r\n      //\r\n      const tmp = math.multiply(realTolerance, math.max(math.abs(a), math.abs(b)))\r\n      if (math.abs(math.subtract(a, b)) > math.max(tmp, absTolerance)) {\r\n        return false\r\n      }\r\n    }\r\n    const diff = symmetricDifference(new Set(myKeys), otherKeys)\r\n    // terms only in one (compare to 0.0 so only abs_tol)\r\n    for (const term of diff) {\r\n      const value = this.terms[term]\r\n      if (typeof value !== 'undefined') {\r\n        if (math.abs(value) > absTolerance) {\r\n          return false\r\n        }\r\n      } else if (math.abs(other.terms[term]) > absTolerance) {\r\n        return false\r\n      }\r\n    }\r\n    return true\r\n  }\r\n\r\n  /**\r\n    In-place multiply (*=) terms with scalar or QubitOperator.\r\n    @param {Complex|number|QubitOperator} multiplier\r\n  */\r\n  imul(multiplier) {\r\n    // Handle QubitOperator.\r\n    if (multiplier instanceof QubitOperator) {\r\n      const result_terms = {}\r\n      Object.keys(this.terms).forEach((left_term) => {\r\n        const leftKey = stringToArray(left_term)\r\n        Object.keys(multiplier.terms).forEach((right_term) => {\r\n          let new_coefficient = math.multiply(this.terms[left_term], multiplier.terms[right_term])\r\n          // Loop through local operators and create new sorted list\r\n          // of representing the product local operator\r\n          let product_operators = []\r\n          let left_operator_index = 0\r\n          let right_operator_index = 0\r\n          const rightKey = stringToArray(right_term)\r\n          const n_operators_left = leftKey.length\r\n          const n_operators_right = rightKey.length\r\n\r\n          while (left_operator_index < n_operators_left && right_operator_index < n_operators_right) {\r\n            const [left_qubit, left_loc_op] = leftKey[left_operator_index]\r\n            const [right_qubit, right_loc_op] = rightKey[right_operator_index]\r\n\r\n            // Multiply local operators acting on the same qubit\r\n            if (left_qubit === right_qubit) {\r\n              left_operator_index += 1\r\n              right_operator_index += 1\r\n              const [scalar, loc_op] = PAULI_OPERATOR_PRODUCTS[[left_loc_op, right_loc_op]]\r\n\r\n              // Add new term.\r\n              if (loc_op !== 'I') {\r\n                product_operators.push([left_qubit, loc_op])\r\n                new_coefficient = math.multiply(new_coefficient, scalar)\r\n              }\r\n              // Note if loc_op == 'I', then scalar == 1.0\r\n\r\n              // If left_qubit > right_qubit, add right_loc_op; else,\r\n              // add left_loc_op.\r\n            } else if (left_qubit > right_qubit) {\r\n              product_operators.push([right_qubit, right_loc_op])\r\n              right_operator_index += 1\r\n            } else {\r\n              product_operators.push([left_qubit, left_loc_op])\r\n              left_operator_index += 1\r\n            }\r\n          }\r\n\r\n          // Finish the remainding operators\r\n          if (left_operator_index === n_operators_left) {\r\n            product_operators = product_operators.concat(rightKey.slice(right_operator_index))\r\n          } else if (right_operator_index === n_operators_right) {\r\n            product_operators = product_operators.concat(leftKey.slice(left_operator_index))\r\n          }\r\n\r\n          // Add to result dict\r\n          const tmp_key = product_operators\r\n          if (tmp_key in result_terms) {\r\n            result_terms[tmp_key] = math.add(result_terms[tmp_key], new_coefficient)\r\n          } else {\r\n            result_terms[tmp_key] = new_coefficient\r\n          }\r\n        })\r\n      })\r\n      this.terms = result_terms\r\n      return this\r\n    } else // Handle scalars.\r\n    if (isNumeric(multiplier)) {\r\n      Object.keys(this.terms).forEach((key) => {\r\n        this.terms[key] = math.multiply(this.terms[key], multiplier)\r\n      })\r\n      return this\r\n    } else {\r\n      throw new Error('Cannot in-place multiply term of invalid type '\r\n        + 'to QubitTerm.')\r\n    }\r\n  }\r\n\r\n  /**\r\n  Return self * multiplier for a scalar, or a QubitOperator.\r\n\r\n    @param {Complex|number|QubitOperator} multiplier A scalar, or a QubitOperator.\r\n\r\n    @return {QubitOperator}\r\n\r\n    @throws {Error} Invalid type cannot be multiply with QubitOperator.\r\n   */\r\n  mul(multiplier) {\r\n    if (isNumeric(multiplier) || multiplier instanceof QubitOperator) {\r\n      const product = this.copy()\r\n      return product.imul(multiplier)\r\n    }\r\n    throw new Error('Object of invalid type cannot multiply with QubitOperator.')\r\n  }\r\n\r\n  /**\r\n   * in-Place add\r\n   * @param {Complex|number|QubitOperator} addend\r\n   * @return {QubitOperator}\r\n   */\r\n  iadd(addend) {\r\n    if (addend instanceof QubitOperator) {\r\n      Object.keys(addend.terms).forEach((key) => {\r\n        const value = this.terms[key]\r\n        const ov = addend.terms[key]\r\n        if (typeof value !== 'undefined') {\r\n          const tmp = math.add(ov, value)\r\n          if (math.abs(tmp) > 0) {\r\n            this.terms[key] = tmp\r\n          } else {\r\n            delete this.terms[key]\r\n          }\r\n        } else {\r\n          this.terms[key] = ov\r\n        }\r\n      })\r\n    } else {\r\n      throw new Error('Cannot add invalid type to QubitOperator.')\r\n    }\r\n    return this\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {Complex|number|QubitOperator} addend\r\n   * @return {QubitOperator}\r\n   */\r\n  add(addend) {\r\n    const inst = this.copy()\r\n    inst.iadd(addend)\r\n    return inst\r\n  }\r\n\r\n  div(divisor) {\r\n    if (isNumeric(divisor)) {\r\n      return this.mul(math.divide(1.0, divisor))\r\n    } else {\r\n      throw new Error('Cannot divide QubitOperator by non-scalar type.')\r\n    }\r\n  }\r\n\r\n  /**\r\n   * in-Place dived by divisor\r\n   * @param {(Complex|number|QubitOperator)} divisor\r\n * @return {QubitOperator}\r\n   */\r\n  idiv(divisor) {\r\n    if (isNumeric(divisor)) {\r\n      return this.imul(math.divide(1.0, divisor))\r\n    } else {\r\n      throw new Error('Cannot divide QubitOperator by non-scalar type.')\r\n    }\r\n  }\r\n\r\n  /**\r\n   * in-Place subtract\r\n   * @param {Complex|number|QubitOperator} subtrahend\r\n   * @return {QubitOperator}\r\n   */\r\n  isub(subtrahend) {\r\n    if (subtrahend instanceof QubitOperator) {\r\n      Object.keys(subtrahend.terms).forEach((key) => {\r\n        const ov = subtrahend.terms[key]\r\n        const v = this.terms[key]\r\n        if (typeof v !== 'undefined') {\r\n          if (math.abs(math.subtract(v, ov)) > 0) {\r\n            this.terms[key] = math.subtract(v, ov)\r\n          } else {\r\n            delete this.terms[key]\r\n          }\r\n        } else {\r\n          this.terms[key] = math.subtract(0, ov)\r\n        }\r\n      })\r\n    } else {\r\n      throw new Error('Cannot subtract invalid type from QubitOperator.')\r\n    }\r\n    return this\r\n  }\r\n\r\n  sub(subtrahend) {\r\n    const ret = this.copy()\r\n    return ret.isub(subtrahend)\r\n  }\r\n\r\n  /**\r\n   * return negative of current qubit operator\r\n   * @return {QubitOperator}\r\n   */\r\n  negative() {\r\n    return this.mul(-1.0)\r\n  }\r\n\r\n  /**\r\n   * return copy of current qubit operator\r\n   * @return {QubitOperator}\r\n   */\r\n  copy() {\r\n    const terms = {}\r\n    Object.assign(terms, this.terms)\r\n    const inst = new QubitOperator([])\r\n    inst.terms = terms\r\n    return inst\r\n  }\r\n\r\n  /**\r\n   * string description of current qubit operator\r\n   * @return {string}\r\n   */\r\n  toString() {\r\n    const keys = Object.keys(this.terms)\r\n    if (keys.length === 0) {\r\n      return '0'\r\n    }\r\n    let string_rep = ''\r\n    keys.forEach((term) => {\r\n      const parts = stringToArray(term)\r\n      const v = this.terms[term]\r\n      let tmp_string = `${v}`\r\n      if (parts.length === 0) {\r\n        tmp_string += ' I'\r\n      }\r\n      parts.forEach((operator) => {\r\n        switch (operator[1]) {\r\n          case 'X':\r\n          case 'Y':\r\n          case 'Z': {\r\n            tmp_string += ` ${operator[1]}${operator[0]}`\r\n            break\r\n          }\r\n          default: {\r\n            throw new Error('invalid operator')\r\n            break\r\n          }\r\n        }\r\n      })\r\n      string_rep += `${tmp_string} +\\n`\r\n    })\r\n\r\n    return string_rep.substring(0, string_rep.length - 3)\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/ops/qubitoperator.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 832,
    "kind": "variable",
    "name": "mc",
    "memberof": "src/ops/qubitoperator.js",
    "static": true,
    "longname": "src/ops/qubitoperator.js~mc",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/ops/qubitoperator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 833,
    "kind": "variable",
    "name": "EQ_TOLERANCE",
    "memberof": "src/ops/qubitoperator.js",
    "static": true,
    "longname": "src/ops/qubitoperator.js~EQ_TOLERANCE",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/ops/qubitoperator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 834,
    "kind": "variable",
    "name": "PAULI_OPERATOR_PRODUCTS",
    "memberof": "src/ops/qubitoperator.js",
    "static": true,
    "longname": "src/ops/qubitoperator.js~PAULI_OPERATOR_PRODUCTS",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/qubitoperator.js",
    "importStyle": "{PAULI_OPERATOR_PRODUCTS}",
    "description": "Define products of all Pauli operators for symbolic multiplication.",
    "lineNumber": 31,
    "ignore": true,
    "type": {
      "types": [
        "{\"undefined\": *}"
      ]
    }
  },
  {
    "__docId__": 835,
    "kind": "function",
    "name": "stringToArray",
    "memberof": "src/ops/qubitoperator.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/ops/qubitoperator.js~stringToArray",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/qubitoperator.js",
    "importStyle": "{stringToArray}",
    "description": null,
    "lineNumber": 55,
    "undocument": true,
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 836,
    "kind": "function",
    "name": "checkTerm",
    "memberof": "src/ops/qubitoperator.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/ops/qubitoperator.js~checkTerm",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/ops/qubitoperator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 68,
    "undocument": true,
    "params": [
      {
        "name": "term",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 837,
    "kind": "class",
    "name": "QubitOperator",
    "memberof": "src/ops/qubitoperator.js",
    "static": true,
    "longname": "src/ops/qubitoperator.js~QubitOperator",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/qubitoperator.js",
    "importStyle": "QubitOperator",
    "description": "A sum of terms acting on qubits, e.g., 0.5 * 'X0 X5' + 0.3 * 'Z1 Z2'.\n\nA term is an operator acting on n qubits and can be represented as:\n\ncoefficent * local_operator[0] x ... x local_operator[n-1]\n\nwhere x is the tensor product. A local operator is a Pauli operator\n('I', 'X', 'Y', or 'Z') which acts on one qubit. In math notation a term\nis, for example, 0.5 * 'X0 X5', which means that a Pauli X operator acts\non qubit 0 and 5, while the identity operator acts on all other qubits.\n\nA QubitOperator represents a sum of terms acting on qubits and overloads\noperations for easy manipulation of these objects by the user.\n\nNote for a QubitOperator to be a Hamiltonian which is a hermitian\noperator, the coefficients of all terms must be real.",
    "examples": [
      "\nhamiltonian = 0.5 * QubitOperator('X0 X5') + 0.3 * QubitOperator('Z0')\n\nAttributes:\nterms (dict): **key**: A term represented by a tuple containing all\nnon-trivial local Pauli operators ('X', 'Y', or 'Z').\nA non-trivial local Pauli operator is specified by a\ntuple with the first element being an integer\nindicating the qubit on which a non-trivial local\noperator acts and the second element being a string,\neither 'X', 'Y', or 'Z', indicating which non-trivial\nPauli operator acts on that qubit. Examples:\n((1, 'X'),) or ((1, 'X'), (4,'Z')) or the identity ().\nThe tuples representing the non-trivial local terms\nare sorted according to the qubit number they act on,\nstarting from 0.\n*value**: Coefficient of this term as a (complex) float"
    ],
    "lineNumber": 125,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "QubitOperator"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 838,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/ops/qubitoperator.js~QubitOperator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/qubitoperator.js~QubitOperator#constructor",
    "access": "public",
    "description": "",
    "examples": [
      "\nham = ((QubitOperator('X0 Y3', 0.5)\n+ 0.6 * QubitOperator('X0 Y3')))\n# Equivalently\nham2 = QubitOperator('X0 Y3', 0.5)\nham2 += 0.6 * QubitOperator('X0 Y3')\n\nNote:\nAdding terms to QubitOperator is faster using += (as this is done\nby in-place addition). Specifying the coefficient in the __init__\nis faster than by multiplying a QubitOperator with a scalar as\ncalls an out-of-place multiplication."
    ],
    "lineNumber": 165,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": "The init function only allows to initialize one term. Additional terms\nhave to be added using += (which is fast) or using + of two\nQubitOperator objects:"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number",
          "Complex"
        ],
        "spread": false,
        "optional": false,
        "name": "coefficient",
        "description": "The coefficient of the\nfirst term of this QubitOperator. Default is 1.0."
      },
      {
        "nullable": null,
        "types": [
          "Array.<Array>",
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "term",
        "description": "(optional, empy array, a array of arrays, or a string):\n1) Default is None which means there are no terms in the\nQubitOperator hence it is the \"zero\" Operator\n2) An empty tuple means there are no non-trivial Pauli\noperators acting on the qubits hence only identities\nwith a coefficient (which by default is 1.0).\n3) A sorted tuple of tuples. The first element of each tuple\nis an integer indicating the qubit on which a non-trivial\nlocal operator acts, starting from zero. The second element\nof each tuple is a string, either 'X', 'Y' or 'Z',\nindicating which local operator acts on that qubit.\n4) A string of the form 'X0 Z2 Y5', indicating an X on\nqubit 0, Z on qubit 2, and Y on qubit 5. The string should\nbe sorted by the qubit number. '' is the identity."
      }
    ],
    "throws": [
      {
        "types": [
          "QubitOperatorError"
        ],
        "description": "Invalid operators provided to QubitOperator."
      }
    ]
  },
  {
    "__docId__": 839,
    "kind": "member",
    "name": "terms",
    "memberof": "src/ops/qubitoperator.js~QubitOperator",
    "static": false,
    "longname": "src/ops/qubitoperator.js~QubitOperator#terms",
    "access": "public",
    "description": null,
    "lineNumber": 167,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 840,
    "kind": "method",
    "name": "compress",
    "memberof": "src/ops/qubitoperator.js~QubitOperator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/qubitoperator.js~QubitOperator#compress",
    "access": "public",
    "description": "Eliminates all terms with coefficients close to zero and removes\nimaginary parts of coefficients that are close to zero.",
    "lineNumber": 207,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "absTolerance",
        "description": "Absolute tolerance, must be at least 0.0"
      }
    ],
    "return": null
  },
  {
    "__docId__": 842,
    "kind": "method",
    "name": "isClose",
    "memberof": "src/ops/qubitoperator.js~QubitOperator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/qubitoperator.js~QubitOperator#isClose",
    "access": "public",
    "description": "Returns true if other (QubitOperator) is close to this.\n\nComparison is done for each term individually. Return true\nif the difference between each term in self and other is\nless than the relative tolerance w.r.t. either other or self\n(symmetric test) or if the difference is less than the absolute\ntolerance.",
    "lineNumber": 234,
    "params": [
      {
        "nullable": null,
        "types": [
          "QubitOperator"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "QubitOperator to compare against."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "realTolerance",
        "description": "Relative tolerance, must be greater than 0.0"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "absTolerance",
        "description": "Absolute tolerance, must be at least 0.0"
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 843,
    "kind": "method",
    "name": "imul",
    "memberof": "src/ops/qubitoperator.js~QubitOperator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/qubitoperator.js~QubitOperator#imul",
    "access": "public",
    "description": "In-place multiply (*=) terms with scalar or QubitOperator.",
    "lineNumber": 267,
    "params": [
      {
        "nullable": null,
        "types": [
          "Complex",
          "number",
          "QubitOperator"
        ],
        "spread": false,
        "optional": false,
        "name": "multiplier",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 845,
    "kind": "method",
    "name": "mul",
    "memberof": "src/ops/qubitoperator.js~QubitOperator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/qubitoperator.js~QubitOperator#mul",
    "access": "public",
    "description": "Return self * multiplier for a scalar, or a QubitOperator.",
    "lineNumber": 351,
    "params": [
      {
        "nullable": null,
        "types": [
          "Complex",
          "number",
          "QubitOperator"
        ],
        "spread": false,
        "optional": false,
        "name": "multiplier",
        "description": "A scalar, or a QubitOperator."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "QubitOperator"
      ],
      "spread": false,
      "description": ""
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Invalid type cannot be multiply with QubitOperator."
      }
    ]
  },
  {
    "__docId__": 846,
    "kind": "method",
    "name": "iadd",
    "memberof": "src/ops/qubitoperator.js~QubitOperator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/qubitoperator.js~QubitOperator#iadd",
    "access": "public",
    "description": "in-Place add",
    "lineNumber": 364,
    "params": [
      {
        "nullable": null,
        "types": [
          "Complex",
          "number",
          "QubitOperator"
        ],
        "spread": false,
        "optional": false,
        "name": "addend",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "QubitOperator"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 847,
    "kind": "method",
    "name": "add",
    "memberof": "src/ops/qubitoperator.js~QubitOperator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/qubitoperator.js~QubitOperator#add",
    "access": "public",
    "description": "",
    "lineNumber": 391,
    "params": [
      {
        "nullable": null,
        "types": [
          "Complex",
          "number",
          "QubitOperator"
        ],
        "spread": false,
        "optional": false,
        "name": "addend",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "QubitOperator"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 848,
    "kind": "method",
    "name": "div",
    "memberof": "src/ops/qubitoperator.js~QubitOperator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/qubitoperator.js~QubitOperator#div",
    "access": "public",
    "description": null,
    "lineNumber": 397,
    "undocument": true,
    "params": [
      {
        "name": "divisor",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 849,
    "kind": "method",
    "name": "idiv",
    "memberof": "src/ops/qubitoperator.js~QubitOperator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/qubitoperator.js~QubitOperator#idiv",
    "access": "public",
    "description": "in-Place dived by divisor",
    "lineNumber": 410,
    "params": [
      {
        "nullable": null,
        "types": [
          "Complex",
          "number",
          "QubitOperator"
        ],
        "spread": false,
        "optional": false,
        "name": "divisor",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "QubitOperator"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 850,
    "kind": "method",
    "name": "isub",
    "memberof": "src/ops/qubitoperator.js~QubitOperator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/qubitoperator.js~QubitOperator#isub",
    "access": "public",
    "description": "in-Place subtract",
    "lineNumber": 423,
    "params": [
      {
        "nullable": null,
        "types": [
          "Complex",
          "number",
          "QubitOperator"
        ],
        "spread": false,
        "optional": false,
        "name": "subtrahend",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "QubitOperator"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 851,
    "kind": "method",
    "name": "sub",
    "memberof": "src/ops/qubitoperator.js~QubitOperator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/qubitoperator.js~QubitOperator#sub",
    "access": "public",
    "description": null,
    "lineNumber": 444,
    "undocument": true,
    "params": [
      {
        "name": "subtrahend",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 852,
    "kind": "method",
    "name": "negative",
    "memberof": "src/ops/qubitoperator.js~QubitOperator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/qubitoperator.js~QubitOperator#negative",
    "access": "public",
    "description": "return negative of current qubit operator",
    "lineNumber": 453,
    "return": {
      "nullable": null,
      "types": [
        "QubitOperator"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 853,
    "kind": "method",
    "name": "copy",
    "memberof": "src/ops/qubitoperator.js~QubitOperator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/qubitoperator.js~QubitOperator#copy",
    "access": "public",
    "description": "return copy of current qubit operator",
    "lineNumber": 461,
    "return": {
      "nullable": null,
      "types": [
        "QubitOperator"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 854,
    "kind": "method",
    "name": "toString",
    "memberof": "src/ops/qubitoperator.js~QubitOperator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/qubitoperator.js~QubitOperator#toString",
    "access": "public",
    "description": "string description of current qubit operator",
    "lineNumber": 473,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 855,
    "kind": "file",
    "name": "src/ops/shortcuts.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport {C} from './metagates'\r\nimport {Rz, NOT, Z} from './gates'\r\n\r\nexport function CRz(angle) {\r\n  return C(new Rz(angle), 1)\r\n}\r\n\r\nexport const CNOT = C(NOT)\r\n\r\nexport const CX = CNOT\r\n\r\nexport const CZ = C(Z)\r\n\r\nexport const Toffoli = C(CNOT)\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/ops/shortcuts.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 856,
    "kind": "function",
    "name": "CRz",
    "memberof": "src/ops/shortcuts.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/ops/shortcuts.js~CRz",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/shortcuts.js",
    "importStyle": "{CRz}",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "params": [
      {
        "name": "angle",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 857,
    "kind": "variable",
    "name": "CNOT",
    "memberof": "src/ops/shortcuts.js",
    "static": true,
    "longname": "src/ops/shortcuts.js~CNOT",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/shortcuts.js",
    "importStyle": "{CNOT}",
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 858,
    "kind": "variable",
    "name": "CX",
    "memberof": "src/ops/shortcuts.js",
    "static": true,
    "longname": "src/ops/shortcuts.js~CX",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/shortcuts.js",
    "importStyle": "{CX}",
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 859,
    "kind": "variable",
    "name": "CZ",
    "memberof": "src/ops/shortcuts.js",
    "static": true,
    "longname": "src/ops/shortcuts.js~CZ",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/shortcuts.js",
    "importStyle": "{CZ}",
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 860,
    "kind": "variable",
    "name": "Toffoli",
    "memberof": "src/ops/shortcuts.js",
    "static": true,
    "longname": "src/ops/shortcuts.js~Toffoli",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/shortcuts.js",
    "importStyle": "{Toffoli}",
    "description": null,
    "lineNumber": 30,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 861,
    "kind": "file",
    "name": "src/ops/timeevolution.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport assert from 'assert'\r\nimport math from 'mathjs'\r\nimport {BasicGate} from './basics'\r\nimport QubitOperator, {stringToArray} from './qubitoperator'\r\nimport {setEqual, isComplex, isNumeric} from '../libs/polyfill'\r\nimport {Ph} from './gates'\r\nimport {NotMergeable} from \"../meta/error\";\r\n\r\n/**\r\n * @class TimeEvolution\r\n * @desc\r\nGate for time evolution under a Hamiltonian (QubitOperator object).\r\n\r\nThis gate is the unitary time evolution propagator:\r\n    exp(-i * H * t),\r\n        where H is the Hamiltonian of the system and t is the time. Note that -i\r\nfactor is stored implicitely.\r\n\r\n    @example\r\n\r\nwavefunction = eng.allocateQureg(5)\r\nhamiltonian = 0.5 * QubitOperator(\"X0 Z1 Y5\")\r\n# Apply exp(-i * H * t) to the wavefunction:\r\n    TimeEvolution(time=2.0, hamiltonian=hamiltonian) | wavefunction\r\n\r\nAttributes:\r\n    time(float, int): time t\r\nhamiltonian(QubitOperator): hamiltonaian H\r\n */\r\nexport default class TimeEvolution extends BasicGate {\r\n  /**\r\n   * @constructor\r\n    Note:\r\nThe hamiltonian must be hermitian and therefore only terms with\r\n    real coefficients are allowed.\r\n    Coefficients are internally converted to float.\r\n\r\n    @param {number} time time to evolve under (can be negative).\r\n    @param {QubitOperator} hamiltonian hamiltonian to evolve under.\r\n\r\n    @throws {Error} If time is not a numeric type and hamiltonian is not a QubitOperator.\r\n    @throws {NotHermitianOperatorError} If the input hamiltonian is not hermitian (only real coefficients).\r\n   */\r\n  constructor(time, hamiltonian) {\r\n    super()\r\n    if (typeof time !== 'number') {\r\n      throw new Error('time needs to be a (real) numeric type.')\r\n    }\r\n\r\n    if (!(hamiltonian instanceof QubitOperator)) {\r\n      throw new Error('hamiltonian needs to be QubitOperator object.')\r\n    }\r\n\r\n    this.time = time\r\n    this.hamiltonian = hamiltonian.copy()\r\n    Object.keys(hamiltonian.terms).forEach((term) => {\r\n      const item = this.hamiltonian.terms[term]\r\n      if (isNumeric(item)) {\r\n        if (isComplex(item)) {\r\n          if (math.im(item) === 0) {\r\n            this.hamiltonian.terms[term] = math.re(item)\r\n          } else {\r\n            throw new Error('hamiltonian must be '\r\n                + 'hermitian and hence only '\r\n                + 'have real coefficients.')\r\n          }\r\n        } else {\r\n          this.hamiltonian.terms[term] = item\r\n        }\r\n      } else {\r\n        throw new Error('hamiltonian must be '\r\n        + 'hermitian and hence only '\r\n        + 'have real coefficients.')\r\n      }\r\n    })\r\n  }\r\n\r\n  getInverse() {\r\n    return new TimeEvolution(-this.time, this.hamiltonian)\r\n  }\r\n\r\n  /**\r\n  Return self merged with another TimeEvolution gate if possible.\r\n\r\n    Two TimeEvolution gates are merged if:\r\n1) both have the same terms\r\n2) the proportionality factor for each of the terms\r\nmust have relative error <= 1e-9 compared to the\r\nproportionality factors of the other terms.\r\n\r\n    Note:\r\nWhile one could merge gates for which both hamiltonians commute,\r\n    we are not doing this as in general the resulting gate would have\r\nto be decomposed again.\r\n\r\n    Note:\r\nWe are not comparing if terms are proportional to each other with\r\n    an absolute tolerance. It is up to the user to remove terms close\r\nto zero because we cannot choose a suitable absolute error which\r\nworks for everyone. Use, e.g., a decomposition rule for that.\r\n\r\n   @param {TimeEvolution} other TimeEvolution gate\r\n\r\n   @throws {NotMergeable} If the other gate is not a TimeEvolution gate or\r\n    hamiltonians are not suitable for merging.\r\n\r\n   @return {TimeEvolution} New TimeEvolution gate equivalent to the two merged gates.\r\n   */\r\n  getMerged(other) {\r\n    const rel_tol = 1e-9\r\n    if (!(other instanceof TimeEvolution)) {\r\n      throw new NotMergeable('Cannot merge these two gates.')\r\n    }\r\n    const k1 = Object.keys(this.hamiltonian.terms)\r\n    const k2 = Object.keys(other.hamiltonian.terms)\r\n    if (setEqual(new Set(k1), new Set(k2))) {\r\n      let factor\r\n      Object.keys(this.hamiltonian.terms).forEach((term) => {\r\n        const v1 = this.hamiltonian.terms[term]\r\n        const v2 = other.hamiltonian.terms[term]\r\n        if (typeof factor === 'undefined') {\r\n          factor = math.divide(v1, v2)\r\n        } else {\r\n          const tmp = math.divide(v1, v2)\r\n          if (math.abs(math.subtract(factor, tmp)) > rel_tol * math.max(math.abs(factor), math.abs(tmp))) {\r\n            throw new NotMergeable('Cannot merge these two gates.')\r\n          }\r\n        }\r\n      })\r\n\r\n      const newTime = this.time + other.time / factor\r\n      return new TimeEvolution(newTime, this.hamiltonian)\r\n    } else {\r\n      throw new NotMergeable('Cannot merge these two gates.')\r\n    }\r\n  }\r\n\r\n  /**\r\n  Operator| overload which enables the following syntax:\r\n\r\n   @example\r\n\r\nTimeEvolution(...) | qureg\r\nTimeEvolution(...) | (qureg,)\r\nTimeEvolution(...) | qubit\r\nTimeEvolution(...) | (qubit,)\r\n\r\nUnlike other gates, this gate is only allowed to be applied to one\r\nquantum register or one qubit.\r\n\r\n    @example\r\n\r\nwavefunction = eng.allocateQureg(5)\r\nhamiltonian = QubitOperator(\"X1 Y3\", 0.5)\r\nTimeEvolution(time=2.0, hamiltonian=hamiltonian) | wavefunction\r\n\r\nWhile in the above example the TimeEvolution gate is applied to 5\r\nqubits, the hamiltonian of this TimeEvolution gate acts only\r\nnon-trivially on the two qubits wavefunction[1] and wavefunction[3].\r\n    Therefore, the operator| will rescale the indices in the hamiltonian\r\nand sends the equivalent of the following new gate to the MainEngine:\r\n\r\n   @example\r\n\r\nh = QubitOperator(\"X0 Y1\", 0.5)\r\nTimeEvolution(2.0, h) | [wavefunction[1], wavefunction[3]]\r\n\r\nwhich is only a two qubit gate.\r\n\r\n    @param {Array.<Qubit>|Qureg|Qubit} qubits one Qubit object, one list of Qubit objects, one Qureg\r\n      object, or a tuple of the former three cases.\r\n  */\r\n  or(qubits) {\r\n    // Check that input is only one qureg or one qubit\r\n    qubits = BasicGate.makeTupleOfQureg(qubits)\r\n    if (qubits.length !== 1) {\r\n      throw new Error('Only one qubit or qureg allowed.')\r\n    }\r\n    // Check that if hamiltonian has only an identity term,\r\n    // apply a global phase\r\n    const keys = Object.keys(this.hamiltonian.terms)\r\n    const v = this.hamiltonian.terms[[]]\r\n    if (keys.length === 1 && typeof v !== 'undefined') {\r\n      new Ph(math.multiply(-this.time, v)).or(qubits[0][0])\r\n      return\r\n    }\r\n    const num_qubits = qubits[0].length\r\n    let non_trivial_qubits = new Set()\r\n\r\n    keys.forEach(key => {\r\n      const term = stringToArray(key)\r\n      term.forEach(([index, action]) => {\r\n        non_trivial_qubits.add(index)\r\n      })\r\n    })\r\n\r\n    if (Math.max(...non_trivial_qubits) >= num_qubits) {\r\n      throw new Error('hamiltonian acts on more qubits than the gate is applied to.')\r\n    }\r\n    // create new TimeEvolution gate with rescaled qubit indices in\r\n    // this.hamiltonian which are ordered from\r\n    // 0,...,len(non_trivial_qubits) - 1\r\n    const new_index = {}\r\n    non_trivial_qubits = Array.from(non_trivial_qubits).sort()\r\n\r\n    non_trivial_qubits.forEach((looper, i) => {\r\n      new_index[looper] = i\r\n    })\r\n\r\n    const new_hamiltonian = new QubitOperator()\r\n    assert(Object.keys(new_hamiltonian.terms).length === 0, '')\r\n\r\n    Object.keys(this.hamiltonian.terms).forEach((term) => {\r\n      const parts = stringToArray(term)\r\n      const newTerm = parts.map(([index, action]) => [new_index[index], action])\r\n      new_hamiltonian.terms[newTerm] = this.hamiltonian.terms[term]\r\n    })\r\n\r\n    const new_gate = new TimeEvolution(this.time, new_hamiltonian)\r\n    const new_qubits = non_trivial_qubits.map((looper) => qubits[0][looper])\r\n    // Apply new gate\r\n    const cmd = new_gate.generateCommand(new_qubits)\r\n    cmd.apply()\r\n  }\r\n\r\n  equal() {\r\n    throw new Error('Not implemented')\r\n  }\r\n\r\n  toString() {\r\n    return `exp(${-this.time}j * (${this.hamiltonian}))`\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/ops/timeevolution.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 862,
    "kind": "class",
    "name": "TimeEvolution",
    "memberof": "src/ops/timeevolution.js",
    "static": true,
    "longname": "src/ops/timeevolution.js~TimeEvolution",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/timeevolution.js",
    "importStyle": "TimeEvolution",
    "description": "Gate for time evolution under a Hamiltonian (QubitOperator object).\n\nThis gate is the unitary time evolution propagator:\nexp(-i * H * t),\nwhere H is the Hamiltonian of the system and t is the time. Note that -i\nfactor is stored implicitely.",
    "examples": [
      "\nwavefunction = eng.allocateQureg(5)\nhamiltonian = 0.5 * QubitOperator(\"X0 Z1 Y5\")\n# Apply exp(-i * H * t) to the wavefunction:\nTimeEvolution(time=2.0, hamiltonian=hamiltonian) | wavefunction\n\nAttributes:\ntime(float, int): time t\nhamiltonian(QubitOperator): hamiltonaian H"
    ],
    "lineNumber": 46,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "TimeEvolution"
      }
    ],
    "interface": false,
    "extends": [
      "src/ops/basics.js~BasicGate"
    ]
  },
  {
    "__docId__": 863,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/ops/timeevolution.js~TimeEvolution",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/timeevolution.js~TimeEvolution#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 60,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": "Note:\nThe hamiltonian must be hermitian and therefore only terms with\nreal coefficients are allowed.\nCoefficients are internally converted to float."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "time",
        "description": "time to evolve under (can be negative)."
      },
      {
        "nullable": null,
        "types": [
          "QubitOperator"
        ],
        "spread": false,
        "optional": false,
        "name": "hamiltonian",
        "description": "hamiltonian to evolve under."
      }
    ],
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If time is not a numeric type and hamiltonian is not a QubitOperator."
      },
      {
        "types": [
          "NotHermitianOperatorError"
        ],
        "description": "If the input hamiltonian is not hermitian (only real coefficients)."
      }
    ]
  },
  {
    "__docId__": 864,
    "kind": "member",
    "name": "time",
    "memberof": "src/ops/timeevolution.js~TimeEvolution",
    "static": false,
    "longname": "src/ops/timeevolution.js~TimeEvolution#time",
    "access": "public",
    "description": null,
    "lineNumber": 70,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 865,
    "kind": "member",
    "name": "hamiltonian",
    "memberof": "src/ops/timeevolution.js~TimeEvolution",
    "static": false,
    "longname": "src/ops/timeevolution.js~TimeEvolution#hamiltonian",
    "access": "public",
    "description": null,
    "lineNumber": 71,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 866,
    "kind": "method",
    "name": "getInverse",
    "memberof": "src/ops/timeevolution.js~TimeEvolution",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/timeevolution.js~TimeEvolution#getInverse",
    "access": "public",
    "description": null,
    "lineNumber": 94,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 867,
    "kind": "method",
    "name": "getMerged",
    "memberof": "src/ops/timeevolution.js~TimeEvolution",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/timeevolution.js~TimeEvolution#getMerged",
    "access": "public",
    "description": "Return self merged with another TimeEvolution gate if possible.\n\nTwo TimeEvolution gates are merged if:\n1) both have the same terms\n2) the proportionality factor for each of the terms\nmust have relative error <= 1e-9 compared to the\nproportionality factors of the other terms.\n\nNote:\nWhile one could merge gates for which both hamiltonians commute,\nwe are not doing this as in general the resulting gate would have\nto be decomposed again.\n\nNote:\nWe are not comparing if terms are proportional to each other with\nan absolute tolerance. It is up to the user to remove terms close\nto zero because we cannot choose a suitable absolute error which\nworks for everyone. Use, e.g., a decomposition rule for that.",
    "lineNumber": 125,
    "params": [
      {
        "nullable": null,
        "types": [
          "TimeEvolution"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "TimeEvolution gate"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "TimeEvolution"
      ],
      "spread": false,
      "description": "New TimeEvolution gate equivalent to the two merged gates."
    },
    "throws": [
      {
        "types": [
          "NotMergeable"
        ],
        "description": "If the other gate is not a TimeEvolution gate or\nhamiltonians are not suitable for merging."
      }
    ]
  },
  {
    "__docId__": 868,
    "kind": "method",
    "name": "or",
    "memberof": "src/ops/timeevolution.js~TimeEvolution",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/timeevolution.js~TimeEvolution#or",
    "access": "public",
    "description": "Operator| overload which enables the following syntax:",
    "examples": [
      "\nTimeEvolution(...) | qureg\nTimeEvolution(...) | (qureg,)\nTimeEvolution(...) | qubit\nTimeEvolution(...) | (qubit,)\n\nUnlike other gates, this gate is only allowed to be applied to one\nquantum register or one qubit.",
      "\nwavefunction = eng.allocateQureg(5)\nhamiltonian = QubitOperator(\"X1 Y3\", 0.5)\nTimeEvolution(time=2.0, hamiltonian=hamiltonian) | wavefunction\n\nWhile in the above example the TimeEvolution gate is applied to 5\nqubits, the hamiltonian of this TimeEvolution gate acts only\nnon-trivially on the two qubits wavefunction[1] and wavefunction[3].\nTherefore, the operator| will rescale the indices in the hamiltonian\nand sends the equivalent of the following new gate to the MainEngine:",
      "\nh = QubitOperator(\"X0 Y1\", 0.5)\nTimeEvolution(2.0, h) | [wavefunction[1], wavefunction[3]]\n\nwhich is only a two qubit gate."
    ],
    "lineNumber": 189,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array.<Qubit>",
          "Qureg",
          "Qubit"
        ],
        "spread": false,
        "optional": false,
        "name": "qubits",
        "description": "one Qubit object, one list of Qubit objects, one Qureg\nobject, or a tuple of the former three cases."
      }
    ],
    "return": null
  },
  {
    "__docId__": 869,
    "kind": "method",
    "name": "equal",
    "memberof": "src/ops/timeevolution.js~TimeEvolution",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/timeevolution.js~TimeEvolution#equal",
    "access": "public",
    "description": null,
    "lineNumber": 242,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 870,
    "kind": "method",
    "name": "toString",
    "memberof": "src/ops/timeevolution.js~TimeEvolution",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/timeevolution.js~TimeEvolution#toString",
    "access": "public",
    "description": null,
    "lineNumber": 246,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 871,
    "kind": "file",
    "name": "src/ops/_cycle.js",
    "content": "\r\n/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nconst shared = {}\r\n\r\n/**\r\n * @ignore\r\n * @param {string} key\r\n * @param {any} value\r\n */\r\nexport function add(key, value) {\r\n  shared[key] = value\r\n}\r\n\r\n/**\r\n * @ignore\r\n * @param {string} key\r\n * @return {*}\r\n */\r\nexport function get(key) {\r\n  return shared[key]\r\n}\r\n\r\n\r\n/**\r\nReturn the inverse of a gate.\r\n\r\n    Tries to call gate.getInverse and, upon failure, creates a DaggeredGate\r\ninstead.\r\n\r\n    @param {BasicGate} gate Gate of which to get the inverse\r\n\r\n@example\r\n\r\ngetInverse(H) // returns a Hadamard gate (HGate object)\r\n */\r\nexport function getInverse(gate) {\r\n  try {\r\n    return gate.getInverse()\r\n  } catch (e) {\r\n    const DaggeredGate = get('DaggeredGate')\r\n    return new DaggeredGate(gate)\r\n  }\r\n}\r\n\r\nexport default {\r\n  add,\r\n  get\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/ops/_cycle.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 872,
    "kind": "variable",
    "name": "shared",
    "memberof": "src/ops/_cycle.js",
    "static": true,
    "longname": "src/ops/_cycle.js~shared",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/ops/_cycle.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 873,
    "kind": "function",
    "name": "add",
    "memberof": "src/ops/_cycle.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/ops/_cycle.js~add",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/_cycle.js",
    "importStyle": "{add}",
    "description": "",
    "lineNumber": 25,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "any"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 874,
    "kind": "function",
    "name": "get",
    "memberof": "src/ops/_cycle.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/ops/_cycle.js~get",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/_cycle.js",
    "importStyle": "{get}",
    "description": "",
    "lineNumber": 34,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 875,
    "kind": "function",
    "name": "getInverse",
    "memberof": "src/ops/_cycle.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/ops/_cycle.js~getInverse",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/_cycle.js",
    "importStyle": "{getInverse}",
    "description": "Return the inverse of a gate.\n\nTries to call gate.getInverse and, upon failure, creates a DaggeredGate\ninstead.",
    "examples": [
      "\ngetInverse(H) // returns a Hadamard gate (HGate object)"
    ],
    "lineNumber": 51,
    "params": [
      {
        "nullable": null,
        "types": [
          "BasicGate"
        ],
        "spread": false,
        "optional": false,
        "name": "gate",
        "description": "Gate of which to get the inverse"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 876,
    "kind": "file",
    "name": "src/setups/decompositions/arb1qubit2rzandry.js",
    "content": "import math from 'mathjs'\r\nimport {Control} from '../../meta';\r\nimport {len, productLoop, productLoop3} from '../../libs/polyfill';\r\nimport DecompositionRule from '../../cengines/replacer/decompositionrule';\r\nimport {\r\n  BasicGate, Rz, Ry, Ph\r\n} from '../../ops';\r\n\r\nconst TOLERANCE = 1e-12\r\n\r\n/**\r\n * @ignore\r\n * @param {number|{{re: number, im: number}}} c\r\n * @return {number}\r\n */\r\nexport function phase(c) {\r\n  if (typeof c === 'number') {\r\n    return Math.atan2(0, c)\r\n  }\r\n  return Math.atan2(c.im, c.re)\r\n}\r\n\r\n/**\r\n * @ignore\r\nRecognize an arbitrary one qubit gate which has a matrix property.\r\n\r\n    It does not allow gates which have control qubits as otherwise the\r\nAutoReplacer might go into an infinite loop. Use\r\ncarb1qubit2cnotrzandry instead.\r\n @param {Command} cmd\r\n @return {boolean}\r\n */\r\nexport const _recognize_arb1qubit = (cmd) => {\r\n  try {\r\n    const m = cmd.gate.matrix\r\n    return len(m) === 2 && cmd.controlCount === 0\r\n  } catch (e) {\r\n    return false\r\n  }\r\n}\r\n\r\n/**\r\n * @ignore\r\nIt builds matrix U with parameters (a, b/2, c/2, d/2) and compares against\r\nmatrix.\r\n\r\n    U = [[exp(j*(a-b/2-d/2))*cos(c/2), -exp(j*(a-b/2+d/2))*sin(c/2)],\r\n  [exp(j*(a+b/2-d/2))*sin(c/2), exp(j*(a+b/2+d/2))*cos(c/2)]]\r\n\r\n  @param {Array.<number[]>} matrix 2x2 matrix\r\n  @param {number} a parameter of U\r\n  @param {number} b_half b/2. parameter of U\r\n  @param {number} c_half c/2. parameter of U\r\n  @param {number} d_half d/2. parameter of U\r\n\r\n@return {boolean} true if matrix elements of U and `matrix` are TOLERANCE close.\r\n */\r\nconst _test_parameters = (matrix, a, b_half, c_half, d_half) => {\r\n  const mc = math.complex\r\n  const mm = math.multiply\r\n  const U = [\r\n    [\r\n      mm(math.exp(mc(0, a - b_half - d_half)), math.cos(c_half)),\r\n      mm(mm(math.exp(mc(0, a - b_half + d_half)), -1), math.sin(c_half))\r\n    ],\r\n    [\r\n      mm(math.exp(mc(0, a + b_half - d_half)), math.sin(c_half)),\r\n      mm(math.exp(mc(0, a + b_half + d_half)), math.cos(c_half))\r\n    ]\r\n  ]\r\n  return math.deepEqual(U, matrix)\r\n}\r\n\r\n/**\r\n * @ignore\r\nGiven a 2x2 unitary matrix, find the parameters\r\na, b/2, c/2, and d/2 such that\r\nmatrix == [[exp(j*(a-b/2-d/2))*cos(c/2), -exp(j*(a-b/2+d/2))*sin(c/2)],\r\n  [exp(j*(a+b/2-d/2))*sin(c/2), exp(j*(a+b/2+d/2))*cos(c/2)]]\r\n\r\nNote:\r\n    If the matrix is element of SU(2) (determinant == 1), then\r\nwe can choose a = 0.\r\n\r\n@param {Array.<number[]>} matrix 2x2 unitary matrix\r\n\r\n@return {number[]} parameters of the matrix: (a, b/2, c/2, d/2)\r\n */\r\nexport const _find_parameters = (matrix) => {\r\n  // Determine a, b/2, c/2 and d/2 (3 different cases).\r\n// Note: everything is modulo 2pi.\r\n  let a\r\n  let b_half\r\n  let c_half\r\n  let d_half\r\n  const mm = math.multiply\r\n  // Case 1: sin(c/2) == 0:\r\n  if (math.abs(matrix[0][1]) < TOLERANCE) {\r\n    const t = phase(mm(matrix[0][0], matrix[1][1]))\r\n    const two_a = math.mod(t, 2 * math.pi)\r\n    if (math.abs(two_a) < TOLERANCE || math.abs(two_a) > 2 * math.pi - TOLERANCE) {\r\n      // from 2a==0 (mod 2pi), it follows that a==0 or a==pi,\r\n      // w.l.g. we can choose a==0 because (see U above)\r\n      // c/2 -> c/2 + pi would have the same effect as as a==0 -> a==pi.\r\n      a = 0\r\n    } else {\r\n      a = two_a / 2.0\r\n    }\r\n    d_half = 0 // w.l.g\r\n    const b = phase(matrix[1][1]) - phase(matrix[0][0])\r\n    const possible_b_half = [math.mod(b / 2.0, 2 * math.pi), math.mod(b / 2.0 + math.pi, 2 * math.pi)]\r\n    // As we have fixed a, we need to find correct sign for cos(c/2)\r\n    const possible_c_half = [0.0, math.pi]\r\n    let found = false\r\n    productLoop(possible_b_half, possible_c_half, (_b, _c) => {\r\n      b_half = _b\r\n      c_half = _c\r\n      if (_test_parameters(matrix, a, b_half, c_half, d_half)) {\r\n        found = true\r\n        return true\r\n      }\r\n    })\r\n\r\n    if (!found) {\r\n      throw new Error(`Couldn't find parameters for matrix ${matrix},\r\n        This shouldn't happen. Maybe the matrix is \r\n        not unitary?`)\r\n    }\r\n  }\r\n  // Case 2: cos(c/2) == 0:\r\n  else if (math.abs(matrix[0][0]) < TOLERANCE) {\r\n    const t = phase(mm(mm(matrix[0][1], matrix[1][0]), -1))\r\n    const two_a = math.mod(t, 2 * math.pi)\r\n    if (math.abs(two_a) < TOLERANCE || math.abs(two_a) > 2 * math.pi - TOLERANCE) {\r\n      // from 2a==0 (mod 2pi), it follows that a==0 or a==pi,\r\n      // w.l.g. we can choose a==0 because (see U above)\r\n      // c/2 -> c/2 + pi would have the same effect as as a==0 -> a==pi.\r\n      a = 0\r\n    } else {\r\n      a = two_a / 2.0\r\n    }\r\n    d_half = 0 // w.l.g\r\n    const b = phase(matrix[1][0]) - phase(matrix[0][1]) + math.pi\r\n    const possible_b_half = [math.mod(b / 2.0, 2 * math.pi), math.mod(b / 2.0 + math.pi, 2 * math.pi)]\r\n    // As we have fixed a, we need to find correct sign for sin(c/2)\r\n    const possible_c_half = [math.pi / 2.0, 3.0 / 2.0 * math.pi]\r\n    let found = false\r\n    productLoop(possible_b_half, possible_c_half, (_b, _c) => {\r\n      b_half = _b\r\n      c_half = _c\r\n      if (_test_parameters(matrix, a, b_half, c_half, d_half)) {\r\n        found = true\r\n        return true\r\n      }\r\n    })\r\n    if (!found) {\r\n      throw new Error(`Couldn't find parameters for matrix ${matrix},\r\n        This shouldn't happen. Maybe the matrix is \r\n        not unitary?`)\r\n    }\r\n  }\r\n  // Case 3: sin(c/2) != 0 and cos(c/2) !=0:\r\n  else {\r\n    const t = phase(mm(matrix[0][0], matrix[1][1]))\r\n    const two_a = math.mod(t, 2 * math.pi)\r\n    if (math.abs(two_a) < TOLERANCE || math.abs(two_a) > 2 * math.pi - TOLERANCE) {\r\n      // from 2a==0 (mod 2pi), it follows that a==0 or a==pi,\r\n      // w.l.g. we can choose a==0 because (see U above)\r\n      // c/2 -> c/2 + pi would have the same effect as as a==0 -> a==pi.\r\n      a = 0\r\n    } else {\r\n      a = two_a / 2.0\r\n    }\r\n    const two_d = 2.0 * phase(matrix[0][1]) - 2.0 * phase(matrix[0][0])\r\n    const possible_d_half = [\r\n      math.mod(two_d / 4.0, 2 * math.pi),\r\n      math.mod(two_d / 4.0 + math.pi / 2.0, 2 * math.pi),\r\n      math.mod(two_d / 4.0 + math.pi, 2 * math.pi),\r\n      math.mod(two_d / 4.0 + 3.0 / 2.0 * math.pi, 2 * math.pi)]\r\n    const two_b = 2.0 * phase(matrix[1][0]) - 2.0 * phase(matrix[0][0])\r\n    const possible_b_half = [\r\n      math.mod(two_b / 4.0, 2 * math.pi),\r\n      math.mod(two_b / 4.0 + math.pi / 2.0, 2 * math.pi),\r\n      math.mod(two_b / 4.0 + math.pi, 2 * math.pi),\r\n      math.mod(two_b / 4.0 + 3.0 / 2.0 * math.pi, 2 * math.pi)]\r\n    const tmp = math.acos(math.abs(matrix[1][1]))\r\n    const possible_c_half = [\r\n      math.mod(tmp, 2 * math.pi),\r\n      math.mod(tmp + math.pi, 2 * math.pi),\r\n      math.mod(-1.0 * tmp, 2 * math.pi),\r\n      math.mod(-1.0 * tmp + math.pi, 2 * math.pi)]\r\n    let found = false\r\n    productLoop3(possible_b_half, possible_c_half, possible_d_half, (_b, _c, _d) => {\r\n      b_half = _b\r\n      c_half = _c\r\n      d_half = _d\r\n      if (_test_parameters(matrix, a, b_half, c_half, d_half)) {\r\n        found = true\r\n        return true\r\n      }\r\n    })\r\n    if (!found) {\r\n      throw new Error(`Couldn't find parameters for matrix ${matrix},\r\n        This shouldn't happen. Maybe the matrix is \r\n        not unitary?`)\r\n    }\r\n  }\r\n  return [a, b_half, c_half, d_half]\r\n}\r\n\r\n/**\r\n * @param {Command} cmd\r\nUse Z-Y decomposition of Nielsen and Chuang (Theorem 4.1).\r\n\r\nAn arbitrary one qubit gate matrix can be writen as\r\nU = [[exp(j*(a-b/2-d/2))*cos(c/2), -exp(j*(a-b/2+d/2))*sin(c/2)],\r\n  [exp(j*(a+b/2-d/2))*sin(c/2), exp(j*(a+b/2+d/2))*cos(c/2)]]\r\nwhere a,b,c,d are real numbers.\r\n    Then U = exp(j*a) Rz(b) Ry(c) Rz(d).\r\n    If the matrix is element of SU(2) (determinant == 1), then\r\nwe can choose a = 0.\r\n */\r\nconst _decompose_arb1qubit = (cmd) => {\r\n  const matrix = cmd.gate.matrix._data.slice(0)\r\n  const [a, b_half, c_half, d_half] = _find_parameters(matrix)\r\n  const qb = cmd.qubits\r\n  const eng = cmd.engine\r\n  Control(eng, cmd.controlQubits, () => {\r\n    if (!new Rz(2 * d_half).equal(new Rz(0))) {\r\n      new Rz(2 * d_half).or(qb)\r\n    }\r\n\r\n    if (!new Ry(2 * c_half).equal(new Ry(0))) {\r\n      new Ry(2 * c_half).or(qb)\r\n    }\r\n    if (!new Rz(2 * b_half).equal(new Rz(0))) {\r\n      new Rz(2 * b_half).or(qb)\r\n    }\r\n    if (a !== 0) {\r\n      new Ph(a).or(qb)\r\n    }\r\n  })\r\n}\r\n\r\n\r\nexport default [\r\n  new DecompositionRule(BasicGate, _decompose_arb1qubit, _recognize_arb1qubit)\r\n]\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/decompositions/arb1qubit2rzandry.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 877,
    "kind": "variable",
    "name": "TOLERANCE",
    "memberof": "src/setups/decompositions/arb1qubit2rzandry.js",
    "static": true,
    "longname": "src/setups/decompositions/arb1qubit2rzandry.js~TOLERANCE",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/arb1qubit2rzandry.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 878,
    "kind": "function",
    "name": "phase",
    "memberof": "src/setups/decompositions/arb1qubit2rzandry.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/arb1qubit2rzandry.js~phase",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/setups/decompositions/arb1qubit2rzandry.js",
    "importStyle": "{phase}",
    "description": "",
    "lineNumber": 16,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "number",
          "{{re: number, im: number}}"
        ],
        "spread": false,
        "optional": false,
        "name": "c",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 879,
    "kind": "function",
    "name": "_recognize_arb1qubit",
    "memberof": "src/setups/decompositions/arb1qubit2rzandry.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/arb1qubit2rzandry.js~_recognize_arb1qubit",
    "access": "private",
    "export": true,
    "importPath": "projectq/src/setups/decompositions/arb1qubit2rzandry.js",
    "importStyle": "{_recognize_arb1qubit}",
    "description": "",
    "lineNumber": 33,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 880,
    "kind": "function",
    "name": "_test_parameters",
    "memberof": "src/setups/decompositions/arb1qubit2rzandry.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/arb1qubit2rzandry.js~_test_parameters",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/arb1qubit2rzandry.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 58,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array.<number[]>"
        ],
        "spread": false,
        "optional": false,
        "name": "matrix",
        "description": "2x2 matrix"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "a",
        "description": "parameter of U"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "b_half",
        "description": "b/2. parameter of U"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "c_half",
        "description": "c/2. parameter of U"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "d_half",
        "description": "d/2. parameter of U"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if matrix elements of U and `matrix` are TOLERANCE close."
    }
  },
  {
    "__docId__": 881,
    "kind": "function",
    "name": "_find_parameters",
    "memberof": "src/setups/decompositions/arb1qubit2rzandry.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/arb1qubit2rzandry.js~_find_parameters",
    "access": "private",
    "export": true,
    "importPath": "projectq/src/setups/decompositions/arb1qubit2rzandry.js",
    "importStyle": "{_find_parameters}",
    "description": "",
    "lineNumber": 89,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array.<number[]>"
        ],
        "spread": false,
        "optional": false,
        "name": "matrix",
        "description": "2x2 unitary matrix"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number[]"
      ],
      "spread": false,
      "description": "parameters of the matrix: (a, b/2, c/2, d/2)"
    }
  },
  {
    "__docId__": 882,
    "kind": "function",
    "name": "_decompose_arb1qubit",
    "memberof": "src/setups/decompositions/arb1qubit2rzandry.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/arb1qubit2rzandry.js~_decompose_arb1qubit",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/arb1qubit2rzandry.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 223,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": "Use Z-Y decomposition of Nielsen and Chuang (Theorem 4.1).\n\nAn arbitrary one qubit gate matrix can be writen as\nU = [[exp(j*(a-b/2-d/2))*cos(c/2), -exp(j*(a-b/2+d/2))*sin(c/2)],\n[exp(j*(a+b/2-d/2))*sin(c/2), exp(j*(a+b/2+d/2))*cos(c/2)]]\nwhere a,b,c,d are real numbers.\nThen U = exp(j*a) Rz(b) Ry(c) Rz(d).\nIf the matrix is element of SU(2) (determinant == 1), then\nwe can choose a = 0."
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 883,
    "kind": "file",
    "name": "src/setups/decompositions/barrier.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport DecompositionRule from '../../cengines/replacer/decompositionrule'\r\nimport {BarrierGate} from '../../ops/gates'\r\n\r\n/**\r\n * @ignore\r\n * @param cmd\r\n * @private\r\n */\r\nexport function _decompose_barrier(cmd) {\r\n  // Throw out all barriers if they are not supported.\r\n}\r\n\r\n/**\r\n * @ignore\r\n * @param cmd\r\n * @return {boolean}\r\n * @private\r\n */\r\nexport function _recognize_barrier(cmd) {\r\n  // Recognize all barriers. \"\r\n  return true\r\n}\r\n\r\nexport default [\r\n  new DecompositionRule(BarrierGate, _decompose_barrier, _recognize_barrier)\r\n]\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/decompositions/barrier.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 884,
    "kind": "function",
    "name": "_decompose_barrier",
    "memberof": "src/setups/decompositions/barrier.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/barrier.js~_decompose_barrier",
    "access": "private",
    "export": true,
    "importPath": "projectq/src/setups/decompositions/barrier.js",
    "importStyle": "{_decompose_barrier}",
    "description": "",
    "lineNumber": 25,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 885,
    "kind": "function",
    "name": "_recognize_barrier",
    "memberof": "src/setups/decompositions/barrier.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/barrier.js~_recognize_barrier",
    "access": "private",
    "export": true,
    "importPath": "projectq/src/setups/decompositions/barrier.js",
    "importStyle": "{_recognize_barrier}",
    "description": "",
    "lineNumber": 35,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 886,
    "kind": "file",
    "name": "src/setups/decompositions/carb1qubit2cnotrzandry.js",
    "content": "import math from 'mathjs'\r\nimport assert from 'assert'\r\nimport DecompositionRule from '../../cengines/replacer/decompositionrule';\r\nimport {\r\n  BasicGate, Ph, Ry, Rz, X\r\n} from '../../ops';\r\nimport {Control} from '../../meta';\r\nimport {len, productLoop} from '../../libs/polyfill';\r\nimport {_find_parameters, phase} from './arb1qubit2rzandry'\r\n\r\nconst mm = math.multiply\r\nconst mc = math.complex\r\nconst TOLERANCE = 1e-12\r\n\r\n/**\r\n * @ignore\r\n * Recognize single controlled one qubit gates with a matrix.\r\n * @param {Command} cmd\r\n * @return {boolean}\r\n * @private\r\n */\r\nexport function _recognize_carb1qubit(cmd) {\r\n  if (cmd.controlCount === 1) {\r\n    try {\r\n      const m = cmd.gate.matrix\r\n      if (len(m) === 2) {\r\n        return true\r\n      }\r\n    } catch (e) {\r\n      return false\r\n    }\r\n  }\r\n  return false\r\n}\r\n\r\n/**\r\nIt builds matrix V with parameters (a, b, c/2) and compares against\r\nmatrix.\r\n\r\n    V = [[-sin(c/2) * exp(j*a), exp(j*(a-b)) * cos(c/2)],\r\n  [exp(j*(a+b)) * cos(c/2), exp(j*a) * sin(c/2)]]\r\n\r\n  @param {Array.<number[]>} matrix 2x2 matrix\r\n  @param {number} a Parameter of V\r\n  @param {number} b Parameter of V\r\n  @param {number} c_half c/2. Parameter of V\r\n\r\n  @return {boolean} true if matrix elements of V and `matrix` are TOLERANCE close.\r\n */\r\nfunction _test_parameters(matrix, a, b, c_half) {\r\n  const {exp} = math\r\n  const cosc = math.cos(c_half)\r\n  const sinc = math.sin(c_half)\r\n  const V = [\r\n    [mm(mm(sinc, exp(mc(0, a))), -1), mm(exp(mc(0, a - b)), cosc)],\r\n    [mm(exp(mc(0, a + b)), cosc), mm(exp(mc(0, a)), sinc)]]\r\n  return math.deepEqual(V, matrix)\r\n}\r\n\r\n/**\r\n * @ignore\r\nRecognizes a matrix which can be written in the following form:\r\n\r\n    V = [[-sin(c/2) * exp(j*a), exp(j*(a-b)) * cos(c/2)],\r\n      [exp(j*(a+b)) * cos(c/2), exp(j*a) * sin(c/2)]]\r\n\r\n  @param {Array.<number[]>} matrix 2x2 matrix\r\n  @return {boolean} false if it is not possible otherwise (a, b, c/2)\r\n */\r\nexport function _recognize_v(matrix) {\r\n  let a\r\n  let b\r\n  let c_half\r\n  if (math.abs(matrix[0][0]) < TOLERANCE) {\r\n    const t = phase(mm(matrix[0][1], matrix[1][0]))\r\n    const two_a = math.mod(t, 2 * math.pi)\r\n    if (math.abs(two_a) < TOLERANCE || math.abs(two_a) > 2 * math.pi - TOLERANCE) {\r\n      // from 2a==0 (mod 2pi), it follows that a==0 or a==pi,\r\n      // w.l.g. we can choose a==0 because (see U above)\r\n      // c/2 -> c/2 + pi would have the same effect as as a==0 -> a==pi.\r\n      a = 0\r\n    } else {\r\n      a = two_a / 2.0\r\n    }\r\n    const two_b = phase(matrix[1][0]) - phase(matrix[0][1])\r\n    const possible_b = [math.mod(two_b / 2.0, 2 * math.pi),\r\n      math.mod(two_b / 2.0 + math.pi, 2 * math.pi)]\r\n    const possible_c_half = [0, math.pi]\r\n    let found = false\r\n    productLoop(possible_b, possible_c_half, (_b, _c) => {\r\n      b = _b\r\n      c_half = _c\r\n      if (_test_parameters(matrix, a, b, c_half)) {\r\n        found = true\r\n        return true\r\n      }\r\n    })\r\n\r\n    assert(found) // It should work for all matrices with matrix[0][0]==0.\r\n    return [a, b, c_half]\r\n  } else if (math.abs(matrix[0][1]) < TOLERANCE) {\r\n    const t = phase(mm(mm(matrix[0][0], matrix[1][1]), -1))\r\n    const two_a = math.mod(t, 2 * math.pi)\r\n    if (math.abs(two_a) < TOLERANCE || math.abs(two_a) > 2 * math.pi - TOLERANCE) {\r\n      // from 2a==0 (mod 2pi), it follows that a==0 or a==pi,\r\n      // w.l.g. we can choose a==0 because (see U above)\r\n      // c/2 -> c/2 + pi would have the same effect as as a==0 -> a==pi.\r\n      a = 0\r\n    } else {\r\n      a = two_a / 2.0\r\n    }\r\n    b = 0\r\n    const possible_c_half = [math.pi / 2.0, 3.0 / 2.0 * math.pi]\r\n    const found = false\r\n    for (let i = 0; i < possible_c_half.length; ++i) {\r\n      c_half = possible_c_half[i]\r\n      if (_test_parameters(matrix, a, b, c_half)) {\r\n        return [a, b, c_half]\r\n      }\r\n    }\r\n    return []\r\n  } else {\r\n    const t = mm(mm(-1.0, matrix[0][0]), matrix[1][1])\r\n    const two_a = math.mod(phase(t), 2 * math.pi)\r\n    if (math.abs(two_a) < TOLERANCE || math.abs(two_a) > 2 * math.pi - TOLERANCE) {\r\n      // from 2a==0 (mod 2pi), it follows that a==0 or a==pi,\r\n      // w.l.g. we can choose a==0 because (see U above)\r\n      // c/2 -> c/2 + pi would have the same effect as as a==0 -> a==pi.\r\n      a = 0\r\n    } else {\r\n      a = two_a / 2.0\r\n    }\r\n    const two_b = phase(matrix[1][0]) - phase(matrix[0][1])\r\n    const possible_b = [\r\n      math.mod((two_b / 2.0), 2 * math.pi),\r\n      math.mod((two_b / 2.0 + math.pi), 2 * math.pi)]\r\n    const tmp = math.acos(math.abs(matrix[1][0]))\r\n    const possible_c_half = [\r\n      math.mod(tmp, 2 * math.pi),\r\n      math.mod(tmp + math.pi, 2 * math.pi),\r\n      math.mod(-1.0 * tmp, 2 * math.pi),\r\n      math.mod(-1.0 * tmp + math.pi, 2 * math.pi)]\r\n    let found = false\r\n    productLoop(possible_b, possible_c_half, (_b, _c) => {\r\n      b = _b\r\n      c_half = _c\r\n      if (_test_parameters(matrix, a, b, c_half)) {\r\n        found = true\r\n        return true\r\n      }\r\n    })\r\n    if (!found) {\r\n      return []\r\n    }\r\n    return [a, b, c_half]\r\n  }\r\n}\r\n\r\n/**\r\nDecompose the single controlled 1 qubit gate into CNOT, Rz, Ry, C(Ph).\r\n\r\n    See Nielsen and Chuang chapter 4.3.\r\n\r\n    An arbitrary one qubit gate matrix can be writen as\r\nU = [[exp(j*(a-b/2-d/2))*cos(c/2), -exp(j*(a-b/2+d/2))*sin(c/2)],\r\n  [exp(j*(a+b/2-d/2))*sin(c/2), exp(j*(a+b/2+d/2))*cos(c/2)]]\r\nwhere a,b,c,d are real numbers.\r\n    Then U = exp(j*a) Rz(b) Ry(c) Rz(d).\r\n\r\n    Then C(U) = C(exp(ja)) * A * CNOT * B * CNOT * C with\r\n    A = Rz(b) * Ry(c/2)\r\n  B = Ry(-c/2) * Rz(-(d+b)/2)\r\nC = Rz((d-b)/2)\r\nNote that a == 0 if U is element of SU(2). Also note that\r\nthe controlled phase C(exp(ia)) can be implemented with single\r\n  qubit gates.\r\n\r\n    If the one qubit gate matrix can be writen as\r\nV = [[-sin(c/2) * exp(j*a), exp(j*(a-b)) * cos(c/2)],\r\n  [exp(j*(a+b)) * cos(c/2), exp(j*a) * sin(c/2)]]\r\nThen C(V) = C(exp(ja))* E * CNOT * D with\r\n    E = Rz(b)Ry(c/2)\r\nD = Ry(-c/2)Rz(-b)\r\nThis improvement is important for C(Y) or C(Z)\r\n\r\nFor a proof follow Lemma 5.5 of Barenco et al.\r\n @param {Command} cmd\r\n */\r\nfunction _decompose_carb1qubit(cmd) {\r\n  const matrix = cmd.gate.matrix._data\r\n  const qb = cmd.qubits\r\n  const eng = cmd.engine\r\n\r\n  // Case 1: Unitary matrix which can be written in the form of V:\r\n  const parameters_for_v = _recognize_v(matrix)\r\n  if (parameters_for_v.length > 0) {\r\n    const [a, b, c_half] = parameters_for_v\r\n    if (!new Rz(-b).equal(new Rz(0))) {\r\n      new Rz(-b).or(qb)\r\n    }\r\n    if (!new Ry(-c_half).equal(new Ry(0))) {\r\n      new Ry(-c_half).or(qb)\r\n    }\r\n    Control(eng, cmd.controlQubits, () => X.or(qb))\r\n    if (!new Ry(c_half).equal(new Ry(0))) {\r\n      new Ry(c_half).or(qb)\r\n    }\r\n    if (!new Rz(b).equal(new Rz(0))) {\r\n      new Rz(b).or(qb)\r\n    }\r\n    if (a !== 0) {\r\n      Control(eng, cmd.controlQubits, () => new Ph(a).or(qb))\r\n    }\r\n    // Case 2: General matrix U:\r\n  } else {\r\n    const [a, b_half, c_half, d_half] = _find_parameters(matrix)\r\n    const d = 2 * d_half\r\n    const b = 2 * b_half\r\n    if (!new Rz((d - b) / 2.0).equal(new Rz(0))) {\r\n      new Rz((d - b) / 2.0).or(qb)\r\n    }\r\n    Control(eng, cmd.controlQubits, () => X.or(qb))\r\n    if (!new Rz(-(d + b) / 2.0).equal(new Rz(0))) {\r\n      new Rz(-(d + b) / 2.0).or(qb)\r\n    }\r\n    if (!new Ry(-c_half).equal(new Ry(0))) {\r\n      new Ry(-c_half).or(qb)\r\n    }\r\n    Control(eng, cmd.controlQubits, () => X.or(qb))\r\n    if (!new Ry(c_half).equal(new Ry(0))) {\r\n      new Ry(c_half).or(qb)\r\n    }\r\n    if (!new Rz(b).equal(new Rz(0))) {\r\n      new Rz(b).or(qb)\r\n    }\r\n    if (a !== 0) {\r\n      Control(eng, cmd.controlQubits, () => new Ph(a).or(qb))\r\n    }\r\n  }\r\n}\r\n\r\nexport default [\r\n  new DecompositionRule(BasicGate, _decompose_carb1qubit, _recognize_carb1qubit)\r\n]\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/decompositions/carb1qubit2cnotrzandry.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 887,
    "kind": "variable",
    "name": "mm",
    "memberof": "src/setups/decompositions/carb1qubit2cnotrzandry.js",
    "static": true,
    "longname": "src/setups/decompositions/carb1qubit2cnotrzandry.js~mm",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/carb1qubit2cnotrzandry.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 888,
    "kind": "variable",
    "name": "mc",
    "memberof": "src/setups/decompositions/carb1qubit2cnotrzandry.js",
    "static": true,
    "longname": "src/setups/decompositions/carb1qubit2cnotrzandry.js~mc",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/carb1qubit2cnotrzandry.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 889,
    "kind": "variable",
    "name": "TOLERANCE",
    "memberof": "src/setups/decompositions/carb1qubit2cnotrzandry.js",
    "static": true,
    "longname": "src/setups/decompositions/carb1qubit2cnotrzandry.js~TOLERANCE",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/carb1qubit2cnotrzandry.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 890,
    "kind": "function",
    "name": "_recognize_carb1qubit",
    "memberof": "src/setups/decompositions/carb1qubit2cnotrzandry.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/carb1qubit2cnotrzandry.js~_recognize_carb1qubit",
    "access": "private",
    "export": true,
    "importPath": "projectq/src/setups/decompositions/carb1qubit2cnotrzandry.js",
    "importStyle": "{_recognize_carb1qubit}",
    "description": "",
    "lineNumber": 22,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 891,
    "kind": "function",
    "name": "_test_parameters",
    "memberof": "src/setups/decompositions/carb1qubit2cnotrzandry.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/carb1qubit2cnotrzandry.js~_test_parameters",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/carb1qubit2cnotrzandry.js",
    "importStyle": null,
    "description": "It builds matrix V with parameters (a, b, c/2) and compares against\nmatrix.\n\nV = [[-sin(c/2) * exp(j*a), exp(j*(a-b)) * cos(c/2)],\n[exp(j*(a+b)) * cos(c/2), exp(j*a) * sin(c/2)]]",
    "lineNumber": 50,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array.<number[]>"
        ],
        "spread": false,
        "optional": false,
        "name": "matrix",
        "description": "2x2 matrix"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "a",
        "description": "Parameter of V"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "b",
        "description": "Parameter of V"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "c_half",
        "description": "c/2. Parameter of V"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if matrix elements of V and `matrix` are TOLERANCE close."
    },
    "ignore": true
  },
  {
    "__docId__": 892,
    "kind": "function",
    "name": "_recognize_v",
    "memberof": "src/setups/decompositions/carb1qubit2cnotrzandry.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/carb1qubit2cnotrzandry.js~_recognize_v",
    "access": "private",
    "export": true,
    "importPath": "projectq/src/setups/decompositions/carb1qubit2cnotrzandry.js",
    "importStyle": "{_recognize_v}",
    "description": "",
    "lineNumber": 70,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array.<number[]>"
        ],
        "spread": false,
        "optional": false,
        "name": "matrix",
        "description": "2x2 matrix"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "false if it is not possible otherwise (a, b, c/2)"
    }
  },
  {
    "__docId__": 893,
    "kind": "function",
    "name": "_decompose_carb1qubit",
    "memberof": "src/setups/decompositions/carb1qubit2cnotrzandry.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/carb1qubit2cnotrzandry.js~_decompose_carb1qubit",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/carb1qubit2cnotrzandry.js",
    "importStyle": null,
    "description": "Decompose the single controlled 1 qubit gate into CNOT, Rz, Ry, C(Ph).\n\nSee Nielsen and Chuang chapter 4.3.\n\nAn arbitrary one qubit gate matrix can be writen as\nU = [[exp(j*(a-b/2-d/2))*cos(c/2), -exp(j*(a-b/2+d/2))*sin(c/2)],\n[exp(j*(a+b/2-d/2))*sin(c/2), exp(j*(a+b/2+d/2))*cos(c/2)]]\nwhere a,b,c,d are real numbers.\nThen U = exp(j*a) Rz(b) Ry(c) Rz(d).\n\nThen C(U) = C(exp(ja)) * A * CNOT * B * CNOT * C with\nA = Rz(b) * Ry(c/2)\nB = Ry(-c/2) * Rz(-(d+b)/2)\nC = Rz((d-b)/2)\nNote that a == 0 if U is element of SU(2). Also note that\nthe controlled phase C(exp(ia)) can be implemented with single\nqubit gates.\n\nIf the one qubit gate matrix can be writen as\nV = [[-sin(c/2) * exp(j*a), exp(j*(a-b)) * cos(c/2)],\n[exp(j*(a+b)) * cos(c/2), exp(j*a) * sin(c/2)]]\nThen C(V) = C(exp(ja))* E * CNOT * D with\nE = Rz(b)Ry(c/2)\nD = Ry(-c/2)Rz(-b)\nThis improvement is important for C(Y) or C(Z)\n\nFor a proof follow Lemma 5.5 of Barenco et al.",
    "lineNumber": 189,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": ""
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 894,
    "kind": "file",
    "name": "src/setups/decompositions/cnot2cz.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n// Decompose CNOT gates\r\nimport {Compute, Uncompute} from '../../meta/compute';\r\nimport {H, XGate} from '../../ops/gates';\r\nimport {tuple} from '../../libs/util';\r\n\r\nimport {CZ} from '../../ops/shortcuts'\r\nimport DecompositionRule from '../../cengines/replacer/decompositionrule';\r\n\r\nconst _decompose_cnot = (cmd) => {\r\n  const ctrl = cmd.controlQubits\r\n  const eng = cmd.engine\r\n  Compute(eng, () => {\r\n    H.or(cmd.qubits[0])\r\n  })\r\n  CZ.or(tuple(ctrl[0], cmd.qubits[0][0]))\r\n  Uncompute(eng)\r\n}\r\n\r\n/**\r\n * @ignore\r\n * @param cmd\r\n * @return {boolean}\r\n * @private\r\n */\r\nexport const _recognize_cnot = cmd => (cmd.controlCount === 1)\r\n\r\nexport default [\r\n  new DecompositionRule(XGate, _decompose_cnot, _recognize_cnot)\r\n]\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/decompositions/cnot2cz.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 895,
    "kind": "function",
    "name": "_decompose_cnot",
    "memberof": "src/setups/decompositions/cnot2cz.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/cnot2cz.js~_decompose_cnot",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/cnot2cz.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 896,
    "kind": "function",
    "name": "_recognize_cnot",
    "memberof": "src/setups/decompositions/cnot2cz.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/cnot2cz.js~_recognize_cnot",
    "access": "private",
    "export": true,
    "importPath": "projectq/src/setups/decompositions/cnot2cz.js",
    "importStyle": "{_recognize_cnot}",
    "description": "",
    "lineNumber": 41,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 897,
    "kind": "file",
    "name": "src/setups/decompositions/cnu2toffoliandcu.js",
    "content": "\r\nimport {Control} from '../../meta/control'\r\nimport {XGate} from '../../ops/gates';\r\nimport DecompositionRule from '../../cengines/replacer/decompositionrule';\r\nimport {BasicGate} from '../../ops/basics';\r\nimport {Compute, Uncompute} from '../../meta/compute';\r\nimport {Toffoli} from '../../ops/shortcuts';\r\nimport {tuple} from '../../libs/util';\r\n\r\n/**\r\n * @ignore\r\n Recognize an arbitrary gate which has n>=2 control qubits, except a Toffoli gate.\r\n*/\r\nexport const _recognize_CnU = (cmd) => {\r\n  const count = cmd.controlCount\r\n  if (count === 2) {\r\n    if (!(cmd.gate instanceof XGate)) {\r\n      return true\r\n    }\r\n  } else if (count > 2) {\r\n    return true\r\n  }\r\n  return false\r\n}\r\n\r\n/**\r\n * @ignore\r\nDecompose a multi-controlled gate U into a single-controlled U.\r\n    It uses (n-1) work qubits and 2 * (n-1) Toffoli gates.\r\n */\r\nexport const _decompose_CnU = (cmd) => {\r\n  const eng = cmd.engine\r\n  const ctrl_qureg = cmd.controlQubits\r\n  const {qubits, gate} = cmd\r\n  const n = cmd.controlCount\r\n  const ancilla_qureg = eng.allocateQureg(n - 1)\r\n\r\n  Compute(eng, () => {\r\n    Toffoli.or(tuple(ctrl_qureg[0], ctrl_qureg[1], ancilla_qureg[0]))\r\n    for (let ctrl_index = 2; ctrl_index < n; ++ctrl_index) {\r\n      Toffoli.or(tuple(ctrl_qureg[ctrl_index], ancilla_qureg[ctrl_index - 2], ancilla_qureg[ctrl_index - 1]))\r\n    }\r\n  })\r\n\r\n  Control(eng, ancilla_qureg[ancilla_qureg.length - 1], () => gate.or(qubits))\r\n  Uncompute(eng)\r\n}\r\n\r\nexport default [\r\n  new DecompositionRule(BasicGate, _decompose_CnU, _recognize_CnU)\r\n]\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/decompositions/cnu2toffoliandcu.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 898,
    "kind": "function",
    "name": "_recognize_CnU",
    "memberof": "src/setups/decompositions/cnu2toffoliandcu.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/cnu2toffoliandcu.js~_recognize_CnU",
    "access": "private",
    "export": true,
    "importPath": "projectq/src/setups/decompositions/cnu2toffoliandcu.js",
    "importStyle": "{_recognize_CnU}",
    "description": "",
    "lineNumber": 14,
    "ignore": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 899,
    "kind": "function",
    "name": "_decompose_CnU",
    "memberof": "src/setups/decompositions/cnu2toffoliandcu.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/cnu2toffoliandcu.js~_decompose_CnU",
    "access": "private",
    "export": true,
    "importPath": "projectq/src/setups/decompositions/cnu2toffoliandcu.js",
    "importStyle": "{_decompose_CnU}",
    "description": "",
    "lineNumber": 31,
    "ignore": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 900,
    "kind": "file",
    "name": "src/setups/decompositions/crz2cxandrz.js",
    "content": ";\r\nimport {NOT, Rz} from '../../ops/gates';\r\nimport {C} from '../../ops/metagates';\r\nimport {tuple} from '../../libs/util';\r\nimport DecompositionRule from '../../cengines/replacer/decompositionrule';\r\n\r\nconst _decompose_CRz = (cmd) => {\r\n  const qubit = cmd.qubits[0]\r\n  const ctrl = cmd.controlQubits\r\n  const gate = cmd.gate\r\n  const n = cmd.controlCount\r\n\r\n  new Rz(0.5 * gate.angle).or(qubit)\r\n  C(NOT, n).or(tuple(ctrl, qubit))\r\n  new Rz(-0.5 * gate.angle).or(qubit)\r\n  C(NOT, n).or(tuple(ctrl, qubit))\r\n}\r\n\r\nconst _recognize_CRz = cmd => cmd.controlCount >= 1\r\n\r\nexport default [\r\n  new DecompositionRule(Rz, _decompose_CRz, _recognize_CRz)\r\n]\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/decompositions/crz2cxandrz.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 901,
    "kind": "function",
    "name": "_decompose_CRz",
    "memberof": "src/setups/decompositions/crz2cxandrz.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/crz2cxandrz.js~_decompose_CRz",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/crz2cxandrz.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 902,
    "kind": "function",
    "name": "_recognize_CRz",
    "memberof": "src/setups/decompositions/crz2cxandrz.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/crz2cxandrz.js~_recognize_CRz",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/crz2cxandrz.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 903,
    "kind": "file",
    "name": "src/setups/decompositions/entangle.js",
    "content": "\r\n// Decompose the entangle gate.\r\nimport {Control} from '../../meta/control';\r\nimport {All} from '../../ops/metagates';\r\nimport {\r\n  X, H, EntangleGate\r\n} from '../../ops/gates';\r\nimport DecompositionRule from '../../cengines/replacer/decompositionrule';\r\n\r\nconst _decompose_entangle = (cmd) => {\r\n  const qr = cmd.qubits[0]\r\n  const eng = cmd.engine\r\n\r\n  Control(eng, cmd.controlQubits, () => {\r\n    H.or(qr[0])\r\n    Control(eng, qr[0], () => new All(X).or(qr.slice(1)))\r\n  })\r\n}\r\n\r\nexport default [\r\n  new DecompositionRule(EntangleGate, _decompose_entangle)\r\n]\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/decompositions/entangle.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 904,
    "kind": "function",
    "name": "_decompose_entangle",
    "memberof": "src/setups/decompositions/entangle.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/entangle.js~_decompose_entangle",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/entangle.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 905,
    "kind": "file",
    "name": "src/setups/decompositions/globalphase.js",
    "content": "\r\n// Throw out global phases (no controls).\r\n;\r\nimport DecompositionRule from '../../cengines/replacer/decompositionrule';\r\nimport {Ph} from '../../ops/gates';\r\n\r\nconst _decompose_PhNoCtrl = (cmd) => { };\r\n\r\n// Recognize global phases (no controls).\r\nconst _recognize_PhNoCtrl = cmd => cmd.controlCount === 0\r\n\r\nexport default [\r\n  new DecompositionRule(Ph, _decompose_PhNoCtrl, _recognize_PhNoCtrl)\r\n]\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/decompositions/globalphase.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 906,
    "kind": "function",
    "name": "_decompose_PhNoCtrl",
    "memberof": "src/setups/decompositions/globalphase.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/globalphase.js~_decompose_PhNoCtrl",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/globalphase.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 907,
    "kind": "function",
    "name": "_recognize_PhNoCtrl",
    "memberof": "src/setups/decompositions/globalphase.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/globalphase.js~_recognize_PhNoCtrl",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/globalphase.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 908,
    "kind": "file",
    "name": "src/setups/decompositions/index.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nimport arb1qubit2rzandry from './arb1qubit2rzandry'\r\nimport barrier from './barrier'\r\nimport cnot2cz from './cnot2cz'\r\nimport carb1qubit2cnotrzandry from './carb1qubit2cnotrzandry'\r\nimport entangle from './entangle'\r\nimport globalphase from './globalphase'\r\nimport ph2r from './ph2r'\r\nimport toffoli2cnotandtgate from './toffoli2cnotandtgate'\r\nimport crz2cxandrz from './crz2cxandrz'\r\nimport cnu2toffoliandcu from './cnu2toffoliandcu'\r\nimport qft2crandhadamard from './qft2crandhadamard'\r\nimport r2rzandph from './r2rzandph'\r\nimport rx2rz from './rx2rz'\r\nimport ry2rz from './ry2rz'\r\nimport swap2cnot from './swap2cnot'\r\nimport timeevolution from './time_evolution'\r\n\r\nexport default [\r\n  ...arb1qubit2rzandry,\r\n  ...barrier,\r\n  ...carb1qubit2cnotrzandry,\r\n  ...cnot2cz,\r\n  ...cnu2toffoliandcu,\r\n  ...crz2cxandrz,\r\n  ...entangle,\r\n  ...globalphase,\r\n  ...ph2r,\r\n  ...qft2crandhadamard,\r\n  ...r2rzandph,\r\n  ...rx2rz,\r\n  ...ry2rz,\r\n  ...swap2cnot,\r\n  ...timeevolution,\r\n  ...toffoli2cnotandtgate\r\n]\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/decompositions/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 909,
    "kind": "file",
    "name": "src/setups/decompositions/ph2r.js",
    "content": "import {Control} from '../../meta/control'\r\nimport {Ph, R} from '../../ops/gates';\r\nimport DecompositionRule from '../../cengines/replacer/decompositionrule';\r\n\r\n// Decompose the controlled phase gate (C^nPh(phase)).\r\nconst _decompose_Ph = (cmd) => {\r\n  const ctrl = cmd.controlQubits\r\n  const gate = cmd.gate\r\n  const eng = cmd.engine\r\n\r\n  Control(eng, ctrl.slice(1), () => new R(gate.angle).or(ctrl[0]))\r\n}\r\n\r\n// Recognize the controlled phase gate.\r\nconst _recognize_Ph = cmd => cmd.controlCount >= 1\r\n\r\nexport default [\r\n  new DecompositionRule(Ph, _decompose_Ph, _recognize_Ph)\r\n]\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/decompositions/ph2r.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 910,
    "kind": "function",
    "name": "_decompose_Ph",
    "memberof": "src/setups/decompositions/ph2r.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/ph2r.js~_decompose_Ph",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/ph2r.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 911,
    "kind": "function",
    "name": "_recognize_Ph",
    "memberof": "src/setups/decompositions/ph2r.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/ph2r.js~_recognize_Ph",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/ph2r.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 912,
    "kind": "file",
    "name": "src/setups/decompositions/qft2crandhadamard.js",
    "content": "import math from 'mathjs'\r\nimport {Control} from '../../meta/control';\r\nimport {H, R} from '../../ops/gates';\r\nimport DecompositionRule from '../../cengines/replacer/decompositionrule';\r\nimport QFTGate from '../../ops/qftgate';\r\n\r\nconst _decompose_QFT = (cmd) => {\r\n  const qb = cmd.qubits[0]\r\n  const eng = cmd.engine\r\n  Control(eng, cmd.controlQubits, () => {\r\n    for (let i = 0; i < qb.length; ++i) {\r\n      const count = qb.length - 1 - i\r\n      H.or(qb[count])\r\n      for (let j = 0; j < count; ++j) {\r\n        Control(eng, qb[qb.length - 1 - (j + i + 1)], () => {\r\n          new R(math.pi / (1 << (1 + j))).or(qb[count])\r\n        })\r\n      }\r\n    }\r\n  })\r\n}\r\n\r\nexport default [\r\n  new DecompositionRule(QFTGate, _decompose_QFT)\r\n]\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/decompositions/qft2crandhadamard.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 913,
    "kind": "function",
    "name": "_decompose_QFT",
    "memberof": "src/setups/decompositions/qft2crandhadamard.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/qft2crandhadamard.js~_decompose_QFT",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/qft2crandhadamard.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 914,
    "kind": "file",
    "name": "src/setups/decompositions/r2rzandph.js",
    "content": "import {Control} from '../../meta/control';\r\nimport DecompositionRule from '../../cengines/replacer/decompositionrule';\r\nimport {R, Rz, Ph} from '../../ops/gates';\r\n\r\nconst _decompose_R = (cmd) => {\r\n  const ctrl = cmd.controlQubits\r\n  const eng = cmd.engine\r\n  const gate = cmd.gate\r\n\r\n  Control(eng, ctrl, () => {\r\n    new Ph(0.5 * gate.angle).or(cmd.qubits)\r\n    new Rz(gate.angle).or(cmd.qubits)\r\n  })\r\n}\r\n\r\nexport default [\r\n  new DecompositionRule(R, _decompose_R)\r\n]\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/decompositions/r2rzandph.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 915,
    "kind": "function",
    "name": "_decompose_R",
    "memberof": "src/setups/decompositions/r2rzandph.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/r2rzandph.js~_decompose_R",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/r2rzandph.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 916,
    "kind": "file",
    "name": "src/setups/decompositions/rx2rz.js",
    "content": "import {Control} from '../../meta/control'\r\nimport {Compute, Uncompute} from '../../meta/compute';\r\nimport {H, Rx, Rz} from '../../ops/gates';\r\nimport DecompositionRule from '../../cengines/replacer/decompositionrule';\r\n\r\nconst _decompose_rx = (cmd) => {\r\n  const qubit = cmd.qubits[0]\r\n  const eng = cmd.engine\r\n  const angle = cmd.gate.angle\r\n\r\n  Control(eng, cmd.controlQubits, () => {\r\n    Compute(eng, () => {\r\n      H.or(qubit)\r\n    })\r\n    new Rz(angle).or(qubit)\r\n    Uncompute(eng)\r\n  })\r\n}\r\n/**\r\n * @ignore\r\n * @param cmd\r\n * @return {boolean}\r\n * @private\r\n */\r\nexport const _recognize_RxNoCtrl = cmd => cmd.controlCount === 0\r\n\r\nexport default [\r\n  new DecompositionRule(Rx, _decompose_rx, _recognize_RxNoCtrl)\r\n]\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/decompositions/rx2rz.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 917,
    "kind": "function",
    "name": "_decompose_rx",
    "memberof": "src/setups/decompositions/rx2rz.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/rx2rz.js~_decompose_rx",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/rx2rz.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 918,
    "kind": "function",
    "name": "_recognize_RxNoCtrl",
    "memberof": "src/setups/decompositions/rx2rz.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/rx2rz.js~_recognize_RxNoCtrl",
    "access": "private",
    "export": true,
    "importPath": "projectq/src/setups/decompositions/rx2rz.js",
    "importStyle": "{_recognize_RxNoCtrl}",
    "description": "",
    "lineNumber": 25,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 919,
    "kind": "file",
    "name": "src/setups/decompositions/ry2rz.js",
    "content": "import {Control} from '../../meta/control'\r\nimport {Compute, Uncompute} from '../../meta/compute';\r\nimport {Rx, Ry, Rz} from '../../ops/gates';\r\nimport DecompositionRule from '../../cengines/replacer/decompositionrule';\r\n\r\n/**\r\n * @ignore\r\n * @param {Command} cmd\r\n * @private\r\n */\r\nexport const _decompose_ry = (cmd) => {\r\n  const qubit = cmd.qubits[0]\r\n  const eng = cmd.engine\r\n  const angle = cmd.gate.angle\r\n\r\n  Control(eng, cmd.controlQubits, () => {\r\n    Compute(eng, () => {\r\n      new Rx(Math.PI / 2.0).or(qubit)\r\n    })\r\n    new Rz(angle).or(qubit)\r\n    Uncompute(eng)\r\n  })\r\n}\r\n\r\n/**\r\n * @ignore\r\n * @param {Command} cmd\r\n * @return {boolean}\r\n * @private\r\n */\r\nexport const _recognize_RyNoCtrl = cmd => cmd.controlCount === 0\r\n\r\nexport default [\r\n  new DecompositionRule(Ry, _decompose_ry, _recognize_RyNoCtrl)\r\n]\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/decompositions/ry2rz.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 920,
    "kind": "function",
    "name": "_decompose_ry",
    "memberof": "src/setups/decompositions/ry2rz.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/ry2rz.js~_decompose_ry",
    "access": "private",
    "export": true,
    "importPath": "projectq/src/setups/decompositions/ry2rz.js",
    "importStyle": "{_decompose_ry}",
    "description": "",
    "lineNumber": 11,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 921,
    "kind": "function",
    "name": "_recognize_RyNoCtrl",
    "memberof": "src/setups/decompositions/ry2rz.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/ry2rz.js~_recognize_RyNoCtrl",
    "access": "private",
    "export": true,
    "importPath": "projectq/src/setups/decompositions/ry2rz.js",
    "importStyle": "{_recognize_RyNoCtrl}",
    "description": "",
    "lineNumber": 31,
    "ignore": true,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 922,
    "kind": "file",
    "name": "src/setups/decompositions/swap2cnot.js",
    "content": "import {Compute, Uncompute} from '../../meta/compute';\r\nimport {CNOT} from '../../ops/shortcuts';\r\nimport {tuple} from '../../libs/util';\r\nimport {Control} from '../../meta/control';\r\nimport DecompositionRule from '../../cengines/replacer/decompositionrule';\r\nimport {SwapGate} from '../../ops/gates';\r\n\r\nconst _decompose_swap = (cmd) => {\r\n  const ctrl = cmd.controlQubits\r\n  const eng = cmd.engine\r\n  Compute(eng, () => {\r\n    CNOT.or(tuple(cmd.qubits[0], cmd.qubits[1]))\r\n  })\r\n  Control(eng, ctrl, () => {\r\n    CNOT.or(tuple(cmd.qubits[1], cmd.qubits[0]))\r\n  })\r\n  Uncompute(eng)\r\n}\r\n\r\nexport default [\r\n  new DecompositionRule(SwapGate, _decompose_swap)\r\n]\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/decompositions/swap2cnot.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 923,
    "kind": "function",
    "name": "_decompose_swap",
    "memberof": "src/setups/decompositions/swap2cnot.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/swap2cnot.js~_decompose_swap",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/swap2cnot.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 924,
    "kind": "file",
    "name": "src/setups/decompositions/time_evolution.js",
    "content": "\r\n/*\r\nRegisters decomposition for the TimeEvolution gates.\r\n\r\n    An exact straight forward decomposition of a TimeEvolution gate is possible\r\nif the hamiltonian has only one term or if all the terms commute with each\r\n  other in which case one can implement each term individually.\r\n*/\r\n\r\nimport assert from 'assert'\r\nimport QubitOperator, {stringToArray} from '../../ops/qubitoperator';\r\nimport {len, setEqual, setFromRange} from '../../libs/polyfill';\r\nimport {Compute, Control, Uncompute} from '../../meta';\r\nimport TimeEvolution from '../../ops/timeevolution';\r\nimport {tuple} from '../../libs/util';\r\nimport DecompositionRule from '../../cengines/replacer/decompositionrule';\r\nimport {\r\n  CNOT, Rx, Ry, Rz, H\r\n} from '../../ops';\r\n\r\n// Recognize all TimeEvolution gates with >1 terms but which all commute.\r\nfunction _recognize_time_evolution_commuting_terms(cmd) {\r\n  const {hamiltonian} = cmd.gate\r\n  if (len(hamiltonian.terms) === 1) {\r\n    return false\r\n  } else {\r\n    const id_op = new QubitOperator([], 0.0)\r\n    const keys = Object.keys(hamiltonian.terms)\r\n    for (let i = 0; i < keys.length; ++i) {\r\n      const k = keys[i]\r\n      const term = stringToArray(k)\r\n      const coefficient = hamiltonian.terms[k]\r\n      const test_op = new QubitOperator(term, coefficient)\r\n      for (let j = 0; j < keys.length; ++j) {\r\n        const other = keys[j]\r\n        const other_op = new QubitOperator(stringToArray(other), hamiltonian.terms[other])\r\n        const commutator = test_op.mul(other_op).sub(other_op.mul(test_op))\r\n        if (!commutator.isClose(id_op, 1e-9, 1e-9)) {\r\n          return false\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return true\r\n}\r\n\r\nfunction _decompose_time_evolution_commuting_terms(cmd) {\r\n  const qureg = cmd.qubits\r\n  const eng = cmd.engine\r\n  const {hamiltonian, time} = cmd.gate\r\n  Control(eng, cmd.controlQubits, () => {\r\n    Object.keys(hamiltonian.terms).forEach((key) => {\r\n      const coefficient = hamiltonian.terms[key]\r\n      const term = stringToArray(key)\r\n      const ind_operator = new QubitOperator(term, coefficient)\r\n      new TimeEvolution(time, ind_operator).or(qureg)\r\n    })\r\n  })\r\n}\r\n\r\nfunction _recognize_time_evolution_individual_terms(cmd) {\r\n  return len(cmd.gate.hamiltonian.terms) === 1\r\n}\r\n\r\n/**\r\nImplements a TimeEvolution gate with a hamiltonian having only one term.\r\n\r\n    To implement exp(-i * t * hamiltonian), where the hamiltonian is only one\r\nterm, e.g., hamiltonian = X0 x Y1 X Z2, we first perform local\r\ntransformations to in order that all Pauli operators in the hamiltonian\r\nare Z. We then implement  exp(-i * t * (Z1 x Z2 x Z3) and transform the\r\nbasis back to the original. For more details see, e.g.,\r\n\r\n    James D. Whitfield, Jacob Biamonte & Aspuru-Guzik\r\nSimulation of electronic structure Hamiltonians using quantum computers,\r\n    Molecular Physics, 109:5, 735-750 (2011).\r\n\r\n    or\r\n\r\nNielsen and Chuang, Quantum Computation and Information.\r\n @param {Command} cmd\r\n */\r\nfunction _decompose_time_evolution_individual_terms(cmd) {\r\n  assert(len(cmd.qubits) === 1)\r\n  const qureg = cmd.qubits[0]\r\n  const eng = cmd.engine\r\n  const {time, hamiltonian} = cmd.gate\r\n  assert(len(hamiltonian.terms) === 1)\r\n  let term = Object.keys(hamiltonian.terms)[0]\r\n  term = stringToArray(term)\r\n  const coefficient = hamiltonian.terms[term]\r\n  const check_indices = new Set()\r\n\r\n  // Check that hamiltonian is not identity term,\r\n  // Previous __or__ operator should have apply a global phase instead:\r\n  assert(term.length !== 0)\r\n\r\n  // hamiltonian has only a single local operator\r\n  if (len(term) === 1) {\r\n    Control(eng, cmd.controlQubits, () => {\r\n      const [idx, action] = term[0]\r\n      if (action === 'X') {\r\n        new Rx(time * coefficient * 2.0).or(qureg[idx])\r\n      } else if (action === 'Y') {\r\n        new Ry(time * coefficient * 2.0).or(qureg[idx])\r\n      } else {\r\n        new Rz(time * coefficient * 2.0).or(qureg[idx])\r\n      }\r\n    })\r\n\r\n    // hamiltonian has more than one local operator\r\n  } else {\r\n    Control(eng, cmd.controlQubits, () => {\r\n      Compute(eng, () => {\r\n        // Apply local basis rotations\r\n        term.forEach(([index, action]) => {\r\n          check_indices.add(index)\r\n          if (action === 'X') {\r\n            H.or(qureg[index])\r\n          } else if (action === 'Y') {\r\n            new Rx(Math.PI / 2.0).or(qureg[index])\r\n          }\r\n        })\r\n\r\n        // Check that qureg had exactly as many qubits as indices:\r\n        assert(setEqual(check_indices, setFromRange(qureg.length)))\r\n        // Compute parity\r\n        for (let i = 0; i < qureg.length - 1; ++i) {\r\n          CNOT.or(tuple(qureg[i], qureg[i + 1]))\r\n        }\r\n      })\r\n\r\n      new Rz(time * coefficient * 2.0).or(qureg[qureg.length - 1])\r\n      // Uncompute parity and basis change\r\n      Uncompute(eng)\r\n    })\r\n  }\r\n}\r\n\r\n/**\r\n * @ignore\r\n * @type {DecompositionRule}\r\n */\r\nexport const rule_commuting_terms = new DecompositionRule(\r\n  TimeEvolution,\r\n  _decompose_time_evolution_commuting_terms,\r\n  _recognize_time_evolution_commuting_terms\r\n)\r\n\r\n/**\r\n * @ignore\r\n * @type {DecompositionRule}\r\n */\r\nexport const rule_individual_terms = new DecompositionRule(\r\n  TimeEvolution,\r\n  _decompose_time_evolution_individual_terms,\r\n  _recognize_time_evolution_individual_terms\r\n)\r\n\r\nexport default [rule_commuting_terms, rule_individual_terms]\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/decompositions/time_evolution.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 925,
    "kind": "function",
    "name": "_recognize_time_evolution_commuting_terms",
    "memberof": "src/setups/decompositions/time_evolution.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/time_evolution.js~_recognize_time_evolution_commuting_terms",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/time_evolution.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 926,
    "kind": "function",
    "name": "_decompose_time_evolution_commuting_terms",
    "memberof": "src/setups/decompositions/time_evolution.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/time_evolution.js~_decompose_time_evolution_commuting_terms",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/time_evolution.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 47,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 927,
    "kind": "function",
    "name": "_recognize_time_evolution_individual_terms",
    "memberof": "src/setups/decompositions/time_evolution.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/time_evolution.js~_recognize_time_evolution_individual_terms",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/time_evolution.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 61,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 928,
    "kind": "function",
    "name": "_decompose_time_evolution_individual_terms",
    "memberof": "src/setups/decompositions/time_evolution.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/time_evolution.js~_decompose_time_evolution_individual_terms",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/time_evolution.js",
    "importStyle": null,
    "description": "Implements a TimeEvolution gate with a hamiltonian having only one term.\n\nTo implement exp(-i * t * hamiltonian), where the hamiltonian is only one\nterm, e.g., hamiltonian = X0 x Y1 X Z2, we first perform local\ntransformations to in order that all Pauli operators in the hamiltonian\nare Z. We then implement  exp(-i * t * (Z1 x Z2 x Z3) and transform the\nbasis back to the original. For more details see, e.g.,\n\nJames D. Whitfield, Jacob Biamonte & Aspuru-Guzik\nSimulation of electronic structure Hamiltonians using quantum computers,\nMolecular Physics, 109:5, 735-750 (2011).\n\nor\n\nNielsen and Chuang, Quantum Computation and Information.",
    "lineNumber": 83,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": ""
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 929,
    "kind": "variable",
    "name": "rule_commuting_terms",
    "memberof": "src/setups/decompositions/time_evolution.js",
    "static": true,
    "longname": "src/setups/decompositions/time_evolution.js~rule_commuting_terms",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/setups/decompositions/time_evolution.js",
    "importStyle": "{rule_commuting_terms}",
    "description": "",
    "lineNumber": 144,
    "ignore": true,
    "type": {
      "nullable": null,
      "types": [
        "DecompositionRule"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 930,
    "kind": "variable",
    "name": "rule_individual_terms",
    "memberof": "src/setups/decompositions/time_evolution.js",
    "static": true,
    "longname": "src/setups/decompositions/time_evolution.js~rule_individual_terms",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/setups/decompositions/time_evolution.js",
    "importStyle": "{rule_individual_terms}",
    "description": "",
    "lineNumber": 154,
    "ignore": true,
    "type": {
      "nullable": null,
      "types": [
        "DecompositionRule"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 931,
    "kind": "file",
    "name": "src/setups/decompositions/toffoli2cnotandtgate.js",
    "content": "// \"\"\" Decompose the Toffoli gate into CNOT, H, T, and Tdagger gates. \"\"\"\r\nimport {tuple} from '../../libs/util';\r\nimport Gates, {H, NOT, T} from '../../ops/gates';\r\nimport {CNOT} from '../../ops/shortcuts';\r\n;\r\nimport DecompositionRule from '../../cengines/replacer/decompositionrule';\r\n\r\nconst {Tdag} = Gates\r\n\r\nconst _decompose_toffoli = (cmd) => {\r\n  const ctrl = cmd.controlQubits\r\n\r\n  const target = cmd.qubits[0]\r\n  const c1 = ctrl[0]\r\n  const c2 = ctrl[1]\r\n\r\n  H.or(target)\r\n  CNOT.or(tuple(c1, target))\r\n  T.or(c1)\r\n  Tdag.or(target)\r\n  CNOT.or(tuple(c2, target))\r\n  CNOT.or(tuple(c2, c1))\r\n  Tdag.or(c1)\r\n  T.or(target)\r\n  CNOT.or(tuple(c2, c1))\r\n  CNOT.or(tuple(c1, target))\r\n  Tdag.or(target)\r\n  CNOT.or(tuple(c2, target))\r\n  T.or(target)\r\n  T.or(c2)\r\n  H.or(target)\r\n}\r\n\r\nconst _recognize_toffoli = cmd => cmd.controlCount === 2\r\n\r\nexport default [\r\n  new DecompositionRule(NOT.constructor, _decompose_toffoli, _recognize_toffoli)\r\n]\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/decompositions/toffoli2cnotandtgate.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 932,
    "kind": "variable",
    "name": "Tdag",
    "memberof": "src/setups/decompositions/toffoli2cnotandtgate.js",
    "static": true,
    "longname": "src/setups/decompositions/toffoli2cnotandtgate.js~Tdag",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/toffoli2cnotandtgate.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 933,
    "kind": "function",
    "name": "_decompose_toffoli",
    "memberof": "src/setups/decompositions/toffoli2cnotandtgate.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/toffoli2cnotandtgate.js~_decompose_toffoli",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/toffoli2cnotandtgate.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 934,
    "kind": "function",
    "name": "_recognize_toffoli",
    "memberof": "src/setups/decompositions/toffoli2cnotandtgate.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/toffoli2cnotandtgate.js~_recognize_toffoli",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/toffoli2cnotandtgate.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 34,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 935,
    "kind": "file",
    "name": "src/setups/grid.js",
    "content": "\r\nimport assert from 'assert'\r\nimport {\r\n  BasicMathGate, ClassicalInstructionGate, CNOT, ControlledGate, QFT, Swap\r\n} from '../ops';\r\nimport {getInverse} from '../ops/_cycle';\r\nimport DecompositionRuleSet from '../cengines/replacer/decompositionruleset';\r\nimport {instanceOf, isKindclassOf} from '../libs/util';\r\nimport {AutoReplacer, InstructionFilter} from '../cengines';\r\nimport TagRemover from '../cengines/tagremover'\r\nimport LocalOptimizer from '../cengines/optimize'\r\nimport math from '../libs/math/defaultrules'\r\nimport decompositions from './decompositions'\r\nimport GridMapper from '../cengines/twodmapper';\r\n\r\n/**\r\n * @ignore\r\n * @desc Remove any MathGates\r\n */\r\nexport function high_level_gates(eng, cmd) {\r\n  const {gate} = cmd\r\n  if (gate.equal(QFT) || getInverse(gate).equal(QFT) || gate.equal(Swap)) {\r\n    return true\r\n  }\r\n  if (gate instanceof BasicMathGate) {\r\n    return false\r\n  }\r\n  return true\r\n}\r\n\r\nfunction one_and_two_qubit_gates(eng, cmd) {\r\n  const allqubits = []\r\n  cmd.allQubits.forEach(qr => qr.forEach(q => allqubits.push(q)))\r\n\r\n  // This is required to allow Measure, Allocate, Deallocate, Flush\r\n  if (cmd.gate instanceof ClassicalInstructionGate) {\r\n    return true\r\n  } else if (allqubits.length <= 2) {\r\n    return true\r\n  }\r\n  return false\r\n}\r\n\r\n/**\r\n * @desc\r\n * Returns an engine list to compile to a 2-D grid of qubits.\r\n\r\n Note:\r\n If you choose a new gate set for which the compiler does not yet have\r\n standard rules, it raises an `NoGateDecompositionError` or a\r\n `RuntimeError: maximum recursion depth exceeded...`. Also note that\r\n even the gate sets which work might not yet be optimized. So make sure\r\n to double check and potentially extend the decomposition rules.\r\n This implemention currently requires that the one qubit gates must\r\n contain Rz and at least one of {Ry(best), Rx, H} and the two qubit gate\r\n must contain CNOT (recommended) or CZ.\r\n\r\n Note:\r\n Classical instructions gates such as e.g. Flush and Measure are\r\n automatically allowed.\r\n\r\n @example\r\n  getEngineList(2, 3, tuple(Rz, Ry, Rx, H), tuple(CNOT))\r\n\r\n @param {number} num_rows Number of rows in the grid\r\n @param {number} num_columns Number of columns in the grid.\r\n @param {string|Array.<BasicGate>} one_qubit_gates \"any\" allows any one qubit gate, otherwise provide\r\n   a tuple of the allowed gates. If the gates are instances of a class (e.g. X), it allows all gates\r\n   which are equal to it. If the gate is a class (Rz), it allows all instances of this class. Default is \"any\"\r\n @param {string|Array.<BasicGate>} two_qubit_gates \"any\" allows any two qubit gate, otherwise provide\r\n   a tuple of the allowed gates. If the gates are instances of a class (e.g. CNOT), it allows all gates\r\n   which are equal to it. If the gate is a class, it allows all instances of this class.\r\n   Default is (CNOT, Swap).\r\n @throws {Error} If input is for the gates is not \"any\" or a tuple.\r\n\r\n @return {Array<BasicEngine>} A list of suitable compiler engines.\r\n */\r\nexport function getEngineList(num_rows, num_columns, one_qubit_gates = 'any', two_qubit_gates = [CNOT, Swap]) {\r\n  if (two_qubit_gates !== 'any' && !Array.isArray(two_qubit_gates)) {\r\n    throw new Error(\"two_qubit_gates parameter must be 'any' or a tuple. \"\r\n        + 'When supplying only one gate, make sure to correctly '\r\n        + \"create the tuple (don't miss the comma), \"\r\n        + 'e.g. tuple(CNOT)')\r\n  }\r\n  if (one_qubit_gates !== 'any' && !Array.isArray(one_qubit_gates)) {\r\n    throw new Error(\"one_qubit_gates parameter must be 'any' or a tuple.\")\r\n  }\r\n  const rule_set = new DecompositionRuleSet([...math, ...decompositions])\r\n  const allowed_gate_classes = []\r\n  const allowed_gate_instances = []\r\n\r\n  if (one_qubit_gates !== 'any') {\r\n    one_qubit_gates.forEach((gate) => {\r\n      if (typeof gate === 'function') {\r\n        allowed_gate_classes.push(gate)\r\n      } else {\r\n        allowed_gate_instances.push([gate, 0])\r\n      }\r\n    })\r\n  }\r\n  if (two_qubit_gates !== 'any') {\r\n    two_qubit_gates.forEach((gate) => {\r\n      if (typeof gate === 'function') {\r\n        //  Controlled gate classes don't yet exists and would require\r\n        //  separate treatment\r\n        assert(!isKindclassOf(gate, ControlledGate))\r\n        allowed_gate_classes.push(gate)\r\n      } else if (gate instanceof ControlledGate) {\r\n        allowed_gate_instances.push([gate.gate, gate.n])\r\n      } else {\r\n        allowed_gate_instances.push([gate, 0])\r\n      }\r\n    })\r\n  }\r\n\r\n  function low_level_gates(eng, cmd) {\r\n    const allqubits = []\r\n    cmd.allQubits.forEach(qr => qr.forEach(q => allqubits.push(q)))\r\n\r\n    assert(allqubits.length <= 2)\r\n    if (cmd.gate instanceof ClassicalInstructionGate) {\r\n      // This is required to allow Measure, Allocate, Deallocate, Flush\r\n      return true\r\n    } else if (one_qubit_gates === 'any' && allqubits.length === 1) {\r\n      return true\r\n    } else if (two_qubit_gates === 'any' && allqubits.length === 2) {\r\n      return true\r\n    } else if (instanceOf(cmd.gate, allowed_gate_classes)) {\r\n      return true\r\n    } else {\r\n      const cn = cmd.controlQubits.length\r\n      const idx = allowed_gate_instances.findIndex((looper) => {\r\n        try {\r\n          return cmd.gate.equal(looper[0]) && cn === looper[1]\r\n        } catch (e) {\r\n          return false\r\n        }\r\n      })\r\n      if (idx !== -1) {\r\n        return true\r\n      }\r\n    }\r\n    return false\r\n  }\r\n  return [\r\n    new AutoReplacer(rule_set),\r\n    new TagRemover(),\r\n    new InstructionFilter(high_level_gates),\r\n    new LocalOptimizer(5),\r\n    new AutoReplacer(rule_set),\r\n    new TagRemover(),\r\n    new InstructionFilter(one_and_two_qubit_gates),\r\n    new LocalOptimizer(5),\r\n    new GridMapper({num_rows, num_columns}),\r\n    new AutoReplacer(rule_set),\r\n    new TagRemover(),\r\n    new InstructionFilter(low_level_gates),\r\n    new LocalOptimizer(5),\r\n  ]\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/grid.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 936,
    "kind": "function",
    "name": "high_level_gates",
    "memberof": "src/setups/grid.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/grid.js~high_level_gates",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/setups/grid.js",
    "importStyle": "{high_level_gates}",
    "description": "Remove any MathGates",
    "lineNumber": 20,
    "ignore": true,
    "params": [
      {
        "name": "eng",
        "types": [
          "*"
        ]
      },
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 937,
    "kind": "function",
    "name": "one_and_two_qubit_gates",
    "memberof": "src/setups/grid.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/grid.js~one_and_two_qubit_gates",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/setups/grid.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "params": [
      {
        "name": "eng",
        "types": [
          "*"
        ]
      },
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 938,
    "kind": "function",
    "name": "getEngineList",
    "memberof": "src/setups/grid.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/grid.js~getEngineList",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/setups/grid.js",
    "importStyle": "{getEngineList}",
    "description": "Returns an engine list to compile to a 2-D grid of qubits.\n\nNote:\nIf you choose a new gate set for which the compiler does not yet have\nstandard rules, it raises an `NoGateDecompositionError` or a\n`RuntimeError: maximum recursion depth exceeded...`. Also note that\neven the gate sets which work might not yet be optimized. So make sure\nto double check and potentially extend the decomposition rules.\nThis implemention currently requires that the one qubit gates must\ncontain Rz and at least one of {Ry(best), Rx, H} and the two qubit gate\nmust contain CNOT (recommended) or CZ.\n\nNote:\nClassical instructions gates such as e.g. Flush and Measure are\nautomatically allowed.",
    "examples": [
      "getEngineList(2, 3, tuple(Rz, Ry, Rx, H), tuple(CNOT))"
    ],
    "lineNumber": 78,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "num_rows",
        "description": "Number of rows in the grid"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "num_columns",
        "description": "Number of columns in the grid."
      },
      {
        "nullable": null,
        "types": [
          "string",
          "Array.<BasicGate>"
        ],
        "spread": false,
        "optional": false,
        "name": "one_qubit_gates",
        "description": "\"any\" allows any one qubit gate, otherwise provide\na tuple of the allowed gates. If the gates are instances of a class (e.g. X), it allows all gates\nwhich are equal to it. If the gate is a class (Rz), it allows all instances of this class. Default is \"any\""
      },
      {
        "nullable": null,
        "types": [
          "string",
          "Array.<BasicGate>"
        ],
        "spread": false,
        "optional": false,
        "name": "two_qubit_gates",
        "description": "\"any\" allows any two qubit gate, otherwise provide\na tuple of the allowed gates. If the gates are instances of a class (e.g. CNOT), it allows all gates\nwhich are equal to it. If the gate is a class, it allows all instances of this class.\nDefault is (CNOT, Swap)."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<BasicEngine>"
      ],
      "spread": false,
      "description": "A list of suitable compiler engines."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If input is for the gates is not \"any\" or a tuple."
      }
    ]
  },
  {
    "__docId__": 939,
    "kind": "file",
    "name": "src/setups/ibm.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n\r\nimport DecompositionRuleSet from '../cengines/replacer/decompositionruleset'\r\nimport TagRemover from '../cengines/tagremover'\r\nimport LocalOptimizer from '../cengines/optimize'\r\nimport { AutoReplacer } from '../cengines/replacer/replacer'\r\nimport SwapAndCNOTFlipper from '../cengines/swapandcnotflipper'\r\nimport decompositions from './decompositions'\r\nimport IBM5QubitMapper, {ibmqx4_connections} from '../cengines/ibm5qubitmapper';\r\n\r\n/**\r\n *\r\n * @return {BasicEngine[]}\r\n */\r\nexport function getEngineList() {\r\n  const rule_set = new DecompositionRuleSet(decompositions)\r\n  return [new TagRemover(),\r\n    new LocalOptimizer(10),\r\n    new AutoReplacer(rule_set),\r\n    new TagRemover(),\r\n    new IBM5QubitMapper(),\r\n    new SwapAndCNOTFlipper(ibmqx4_connections),\r\n    new LocalOptimizer(10)\r\n  ]\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/ibm.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 940,
    "kind": "function",
    "name": "getEngineList",
    "memberof": "src/setups/ibm.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/ibm.js~getEngineList",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/setups/ibm.js",
    "importStyle": "{getEngineList}",
    "description": "",
    "lineNumber": 30,
    "return": {
      "nullable": null,
      "types": [
        "BasicEngine[]"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 941,
    "kind": "file",
    "name": "src/setups/ibm16.js",
    "content": "\r\nimport DecompositionRuleSet from '../cengines/replacer/decompositionruleset'\r\nimport {AutoReplacer, InstructionFilter} from '../cengines'\r\nimport TagRemover from '../cengines/tagremover'\r\nimport LocalOptimizer from '../cengines/optimize'\r\nimport GridMapper from '../cengines/twodmapper'\r\nimport math from '../libs/math/defaultrules'\r\nimport decompositions from './decompositions'\r\nimport SwapAndCNOTFlipper from '../cengines/swapandcnotflipper';\r\nimport {high_level_gates} from './grid'\r\n\r\nexport const ibmqx5_connections = new Set([\r\n  '1,0', '1,2', '2,3', '3,4', '3,14', '5,4',\r\n  '6,5', '6,7', '6,11', '7,10', '8,7', '9,8',\r\n  '9,10', '11,10', '12,5', '12,11', '12,13',\r\n  '13,4', '13,14', '15,0', '15,2', '15,14'])\r\n\r\n\r\nconst grid_to_physical = {\r\n  0: 1,\r\n  1: 2,\r\n  2: 3,\r\n  3: 4,\r\n  4: 5,\r\n  5: 6,\r\n  6: 7,\r\n  7: 8,\r\n  8: 0,\r\n  9: 15,\r\n  10: 14,\r\n  11: 13,\r\n  12: 12,\r\n  13: 11,\r\n  14: 10,\r\n  15: 9\r\n}\r\n\r\n/**\r\n *\r\n * @return {BasicEngine[]}\r\n */\r\nexport function getEngineList() {\r\n  const rule_set = new DecompositionRuleSet([...math, ...decompositions])\r\n  return [\r\n    new TagRemover(),\r\n    new LocalOptimizer(5),\r\n    new AutoReplacer(rule_set),\r\n    new InstructionFilter(high_level_gates),\r\n    new TagRemover(),\r\n    new LocalOptimizer(5),\r\n    new AutoReplacer(rule_set),\r\n    new TagRemover(),\r\n    new GridMapper({num_rows: 2, num_columns: 8, mapped_ids_to_backend_ids: grid_to_physical}),\r\n    new LocalOptimizer(5),\r\n    new SwapAndCNOTFlipper(ibmqx5_connections),\r\n    new LocalOptimizer(5)]\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/ibm16.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 942,
    "kind": "variable",
    "name": "ibmqx5_connections",
    "memberof": "src/setups/ibm16.js",
    "static": true,
    "longname": "src/setups/ibm16.js~ibmqx5_connections",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/setups/ibm16.js",
    "importStyle": "{ibmqx5_connections}",
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 943,
    "kind": "variable",
    "name": "grid_to_physical",
    "memberof": "src/setups/ibm16.js",
    "static": true,
    "longname": "src/setups/ibm16.js~grid_to_physical",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/setups/ibm16.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "{\"0\": number, \"1\": number, \"2\": number, \"3\": number, \"4\": number, \"5\": number, \"6\": number, \"7\": number, \"8\": *, \"9\": number, \"10\": number, \"11\": number, \"12\": number, \"13\": number, \"14\": number, \"15\": number}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 944,
    "kind": "function",
    "name": "getEngineList",
    "memberof": "src/setups/ibm16.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/ibm16.js~getEngineList",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/setups/ibm16.js",
    "importStyle": "{getEngineList}",
    "description": null,
    "lineNumber": 42,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 945,
    "kind": "file",
    "name": "src/setups/index.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport DecompositionRuleSet from '../cengines/replacer/decompositionruleset'\r\nimport TagRemover from '../cengines/tagremover'\r\nimport decompositions from './decompositions'\r\nimport LocalOptimizer from '../cengines/optimize'\r\nimport {AutoReplacer} from '../cengines/replacer/replacer'\r\n/**\r\n *\r\n * @return {BasicEngine[]}\r\n */\r\nexport function getEngineList() {\r\n  const rule_set = new DecompositionRuleSet(decompositions)\r\n  return [new TagRemover(),\r\n    new LocalOptimizer(10),\r\n    new AutoReplacer(rule_set),\r\n    new TagRemover(),\r\n    new LocalOptimizer(10)]\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 946,
    "kind": "function",
    "name": "getEngineList",
    "memberof": "src/setups/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/index.js~getEngineList",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/setups/index.js",
    "importStyle": "{getEngineList}",
    "description": "",
    "lineNumber": 26,
    "return": {
      "nullable": null,
      "types": [
        "BasicEngine[]"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 947,
    "kind": "file",
    "name": "src/setups/linear.js",
    "content": "import assert from 'assert'\r\nimport {\r\n  BasicMathGate, ClassicalInstructionGate, CNOT, ControlledGate, QFT, Swap\r\n} from '../ops';\r\nimport {getInverse} from '../ops/_cycle';\r\nimport DecompositionRuleSet from '../cengines/replacer/decompositionruleset';\r\nimport {instanceOf, isKindclassOf, tuple} from '../libs/util';\r\nimport {len} from '../libs/polyfill';\r\nimport {AutoReplacer, InstructionFilter} from '../cengines';\r\nimport TagRemover from '../cengines/tagremover';\r\nimport LocalOptimizer from '../cengines/optimize';\r\nimport LinearMapper from '../cengines/linearmapper';\r\nimport math from '../libs/math/defaultrules'\r\nimport decompositions from './decompositions'\r\n\r\nfunction high_level_gates(eng, cmd) {\r\n  const g = cmd.gate\r\n  if (g.equal(QFT) || getInverse(g).equal(QFT) || g.equal(Swap)) {\r\n    return true\r\n  } else if (g instanceof BasicMathGate) {\r\n    return false\r\n  }\r\n  return true\r\n}\r\n\r\nfunction one_and_two_qubit_gates(eng, cmd) {\r\n  const all_qubits = []\r\n  cmd.allQubits.forEach(qr => qr.forEach(q => all_qubits.push(q)))\r\n\r\n  if (cmd.gate instanceof ClassicalInstructionGate) {\r\n    // This is required to allow Measure, Allocate, Deallocate, Flush\r\n    return true\r\n  } else if (all_qubits.length <= 2) {\r\n    return true\r\n  } else {\r\n    return false\r\n  }\r\n}\r\n\r\n/**\r\nReturns an engine list to compile to a linear chain of qubits.\r\n\r\n    Note:\r\nIf you choose a new gate set for which the compiler does not yet have\r\nstandard rules, it raises an `NoGateDecompositionError` or a\r\n    `RuntimeError: maximum recursion depth exceeded...`. Also note that\r\neven the gate sets which work might not yet be optimized. So make sure\r\nto double check and potentially extend the decomposition rules.\r\n    This implemention currently requires that the one qubit gates must\r\ncontain Rz and at least one of {Ry(best), Rx, H} and the two qubit gate\r\nmust contain CNOT (recommended) or CZ.\r\n\r\n    Note:\r\nClassical instructions gates such as e.g. Flush and Measure are\r\nautomatically allowed.\r\n\r\n    @example\r\n    getEngineList(10, false, tuple(Rz, Ry, Rx, H), tuple(CNOT))\r\n\r\n  @param {number} num_qubits Number of qubits in the chain\r\n  @param {boolean} cyclic If a circle or not. Default is false\r\n  @param {string|Array.<BasicGate>} one_qubit_gates \"any\" allows any one qubit gate, otherwise provide\r\na tuple of the allowed gates. If the gates are instances of a class (e.g. X), it allows all gates\r\nwhich are equal to it. If the gate is a class (Rz), it allows all instances of this class. Default is \"any\"\r\n  @param {string|Array.<BasicGate>} two_qubit_gates \"any\" allows any two qubit gate, otherwise provide\r\na tuple of the allowed gates. If the gates are instances of a class (e.g. CNOT), it allows all gates\r\nwhich are equal to it. If the gate is a class, it allows all instances of this class.\r\nDefault is (CNOT, Swap).\r\n    @throws {Error} If input is for the gates is not \"any\" or a tuple.\r\n\r\n    @return {Array<BasicEngine>} A list of suitable compiler engines.\r\n */\r\nexport function getEngineList(num_qubits, cyclic = false, one_qubit_gates = 'any', two_qubit_gates = [CNOT, Swap]) {\r\n  if (two_qubit_gates !== 'any' && !Array.isArray(two_qubit_gates)) {\r\n    throw new Error(\"two_qubit_gates parameter must be 'any' or a tuple. \"\r\n    + 'When supplying only one gate, make sure to correctly '\r\n    + \"create the tuple (don't miss the comma), \"\r\n    + 'e.g. tuple(CNOT)')\r\n  }\r\n  if (one_qubit_gates !== 'any' && !Array.isArray(one_qubit_gates)) {\r\n    throw new Error(\"one_qubit_gates parameter must be 'any' or a tuple.\")\r\n  }\r\n  const rule_set = new DecompositionRuleSet([...math, ...decompositions])\r\n  const allowed_gate_classes = []\r\n  const allowed_gate_instances = []\r\n  if (one_qubit_gates !== 'any') {\r\n    one_qubit_gates.forEach((gate) => {\r\n      if (typeof gate === 'function') {\r\n        allowed_gate_classes.push(gate)\r\n      } else {\r\n        allowed_gate_instances.push([gate, 0])\r\n      }\r\n    })\r\n  }\r\n  if (two_qubit_gates !== 'any') {\r\n    two_qubit_gates.forEach((gate) => {\r\n      if (typeof gate === 'function') {\r\n        //  Controlled gate classes don't yet exists and would require\r\n        //  separate treatment\r\n        assert(!isKindclassOf(gate, ControlledGate))\r\n        allowed_gate_classes.push(gate)\r\n      } else if (gate instanceof ControlledGate) {\r\n        allowed_gate_instances.push([gate.gate, gate.n])\r\n      } else {\r\n        allowed_gate_instances.push([gate, 0])\r\n      }\r\n    })\r\n  }\r\n\r\n  function low_level_gates(eng, cmd) {\r\n    const all_qubits = []\r\n    cmd.allQubits.forEach(qr => qr.forEach(q => all_qubits.push(q)))\r\n\r\n    assert(all_qubits.length <= 2)\r\n    if (cmd.gate instanceof ClassicalInstructionGate) {\r\n      // This is required to allow Measure, Allocate, Deallocate, Flush\r\n      return true\r\n    } else if (one_qubit_gates === 'any' && len(all_qubits) === 1) {\r\n      return true\r\n    } else if (two_qubit_gates === 'any' && len(all_qubits) === 2) {\r\n      return true\r\n    } else if (instanceOf(cmd.gate, allowed_gate_classes)) {\r\n      return true\r\n    } else {\r\n      const cn = cmd.controlQubits.length\r\n      const idx = allowed_gate_instances.findIndex(looper => cmd.gate.equal(looper[0]) && cn === looper[1])\r\n      if (idx !== -1) {\r\n        return true\r\n      }\r\n    }\r\n    return false\r\n  }\r\n  return [new AutoReplacer(rule_set),\r\n    new TagRemover(),\r\n    new InstructionFilter(high_level_gates),\r\n    new LocalOptimizer(5),\r\n    new AutoReplacer(rule_set),\r\n    new TagRemover(),\r\n    new InstructionFilter(one_and_two_qubit_gates),\r\n    new LocalOptimizer(5),\r\n    new LinearMapper(num_qubits, cyclic),\r\n    new AutoReplacer(rule_set),\r\n    new TagRemover(),\r\n    new InstructionFilter(low_level_gates),\r\n    new LocalOptimizer(5),\r\n  ]\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/linear.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 948,
    "kind": "function",
    "name": "high_level_gates",
    "memberof": "src/setups/linear.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/linear.js~high_level_gates",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/setups/linear.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "params": [
      {
        "name": "eng",
        "types": [
          "*"
        ]
      },
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 949,
    "kind": "function",
    "name": "one_and_two_qubit_gates",
    "memberof": "src/setups/linear.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/linear.js~one_and_two_qubit_gates",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/setups/linear.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "params": [
      {
        "name": "eng",
        "types": [
          "*"
        ]
      },
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 950,
    "kind": "function",
    "name": "getEngineList",
    "memberof": "src/setups/linear.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/linear.js~getEngineList",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/setups/linear.js",
    "importStyle": "{getEngineList}",
    "description": "Returns an engine list to compile to a linear chain of qubits.\n\nNote:\nIf you choose a new gate set for which the compiler does not yet have\nstandard rules, it raises an `NoGateDecompositionError` or a\n`RuntimeError: maximum recursion depth exceeded...`. Also note that\neven the gate sets which work might not yet be optimized. So make sure\nto double check and potentially extend the decomposition rules.\nThis implemention currently requires that the one qubit gates must\ncontain Rz and at least one of {Ry(best), Rx, H} and the two qubit gate\nmust contain CNOT (recommended) or CZ.\n\nNote:\nClassical instructions gates such as e.g. Flush and Measure are\nautomatically allowed.",
    "examples": [
      "getEngineList(10, false, tuple(Rz, Ry, Rx, H), tuple(CNOT))"
    ],
    "lineNumber": 73,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "num_qubits",
        "description": "Number of qubits in the chain"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "cyclic",
        "description": "If a circle or not. Default is false"
      },
      {
        "nullable": null,
        "types": [
          "string",
          "Array.<BasicGate>"
        ],
        "spread": false,
        "optional": false,
        "name": "one_qubit_gates",
        "description": "\"any\" allows any one qubit gate, otherwise provide\na tuple of the allowed gates. If the gates are instances of a class (e.g. X), it allows all gates\nwhich are equal to it. If the gate is a class (Rz), it allows all instances of this class. Default is \"any\""
      },
      {
        "nullable": null,
        "types": [
          "string",
          "Array.<BasicGate>"
        ],
        "spread": false,
        "optional": false,
        "name": "two_qubit_gates",
        "description": "\"any\" allows any two qubit gate, otherwise provide\na tuple of the allowed gates. If the gates are instances of a class (e.g. CNOT), it allows all gates\nwhich are equal to it. If the gate is a class, it allows all instances of this class.\nDefault is (CNOT, Swap)."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<BasicEngine>"
      ],
      "spread": false,
      "description": "A list of suitable compiler engines."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If input is for the gates is not \"any\" or a tuple."
      }
    ]
  },
  {
    "__docId__": 951,
    "kind": "file",
    "name": "src/setups/restrictedgateset.js",
    "content": "import assert from 'assert'\r\nimport {\r\n  BasicMathGate, ClassicalInstructionGate, CNOT, ControlledGate, QFT, Swap\r\n} from '../ops';\r\nimport {getInverse} from '../ops/_cycle';\r\nimport DecompositionRuleSet from '../cengines/replacer/decompositionruleset';\r\nimport {instanceOf, isKindclassOf} from '../libs/util';\r\nimport {len} from '../libs/polyfill';\r\nimport {AutoReplacer, InstructionFilter} from '../cengines';\r\nimport TagRemover from '../cengines/tagremover'\r\nimport LocalOptimizer from '../cengines/optimize'\r\nimport math from '../libs/math/defaultrules'\r\nimport decompositions from './decompositions'\r\n\r\nfunction high_level_gates(eng, cmd) {\r\n  const g = cmd.gate\r\n  if (eng.next.isAvailable(cmd)) {\r\n    return true\r\n  }\r\n  if (QFT.equal(g) || QFT.equal(getInverse(g)) || Swap.equal(g)) {\r\n    return true\r\n  }\r\n  if (g instanceof BasicMathGate) {\r\n    return false\r\n  }\r\n  return true\r\n}\r\n\r\nfunction one_and_two_qubit_gates(eng, cmd) {\r\n  const all_qubits = []\r\n  cmd.allQubits.forEach(qr => qr.forEach(q => all_qubits.push(q)))\r\n\r\n  if (cmd.gate instanceof ClassicalInstructionGate) {\r\n    // This is required to allow Measure, Allocate, Deallocate, Flush\r\n    return true\r\n  } else if (eng.next.isAvailable(cmd)) {\r\n    return true\r\n  } else if (all_qubits.length <= 2) {\r\n    return true\r\n  } else {\r\n    return false\r\n  }\r\n}\r\n\r\n/**\r\nReturns an engine list to compile to a restricted gate set.\r\n\r\n    Note:\r\nIf you choose a new gate set for which the compiler does not yet have\r\nstandard rules, it raises an `NoGateDecompositionError` or a\r\n    `RuntimeError: maximum recursion depth exceeded...`. Also note that\r\neven the gate sets which work might not yet be optimized. So make sure\r\nto double check and potentially extend the decomposition rules.\r\n    This implemention currently requires that the one qubit gates must\r\ncontain Rz and at least one of {Ry(best), Rx, H} and the two qubit gate\r\nmust contain CNOT (recommended) or CZ.\r\n\r\n    Note:\r\nClassical instructions gates such as e.g. Flush and Measure are\r\nautomatically allowed.\r\n\r\n    @example\r\n    getEngineList(tuple(Rz, Ry, Rx, H), tuple(CNOT), tuple(TimeEvolution))\r\n\r\n@param {string|Array.<BasicGate>} one_qubit_gates \"any\" allows any one qubit gate, otherwise provide\r\na tuple of the allowed gates. If the gates are instances of a class (e.g. X), it allows all gates\r\nwhich are equal to it. If the gate is a class (Rz), it allows all instances of this class. Default is \"any\"\r\n @param {string|Array.<BasicGate>} two_qubit_gates \"any\" allows any two qubit gate, otherwise provide\r\na tuple of the allowed gates. If the gates are instances of a class (e.g. CNOT), it allows all gates\r\nwhich are equal to it. If the gate is a class, it allows all instances of this class.\r\nDefault is (CNOT,).\r\n @param {string|Array.<BasicGate>} other_gates A tuple of the allowed gates. If the gates are\r\ninstances of a class (e.g. QFT), it allows all gates which are equal to it. If the gate is a\r\nclass, it allows all instances of this class.\r\n\r\n@throws {Error} If input is for the gates is not \"any\" or a tuple.\r\n    @return {Array<BasicEngine>} A list of suitable compiler engines.\r\n */\r\nexport function getEngineList(one_qubit_gates = 'any', two_qubit_gates = [CNOT], other_gates = []) {\r\n  if (two_qubit_gates !== 'any' && !Array.isArray(two_qubit_gates)) {\r\n    throw new Error(\"two_qubit_gates parameter must be 'any' or a tuple. \"\r\n        + 'When supplying only one gate, make sure to correctly '\r\n        + \"create the tuple (don't miss the comma), \"\r\n        + 'e.g. tuple(CNOT)')\r\n  }\r\n  if (one_qubit_gates !== 'any' && !Array.isArray(one_qubit_gates)) {\r\n    throw new Error(\"one_qubit_gates parameter must be 'any' or a tuple.\")\r\n  }\r\n\r\n  if (!Array.isArray(other_gates)) {\r\n    throw new Error('other_gates parameter must be a tuple.')\r\n  }\r\n  const rule_set = new DecompositionRuleSet([...math, ...decompositions])\r\n  const allowed_gate_classes = []\r\n  const allowed_gate_instances = []\r\n  if (one_qubit_gates !== 'any') {\r\n    one_qubit_gates.forEach((gate) => {\r\n      if (typeof gate === 'function') {\r\n        allowed_gate_classes.push(gate)\r\n      } else {\r\n        allowed_gate_instances.push([gate, 0])\r\n      }\r\n    })\r\n  }\r\n  if (two_qubit_gates !== 'any') {\r\n    two_qubit_gates.forEach((gate) => {\r\n      if (typeof gate === 'function') {\r\n        //  Controlled gate classes don't yet exists and would require\r\n        //  separate treatment\r\n        assert(!isKindclassOf(gate, ControlledGate))\r\n        allowed_gate_classes.push(gate)\r\n      } else if (gate instanceof ControlledGate) {\r\n        allowed_gate_instances.push([gate.gate, gate.n])\r\n      } else {\r\n        allowed_gate_instances.push([gate, 0])\r\n      }\r\n    })\r\n  }\r\n\r\n  other_gates.forEach((gate) => {\r\n    if (typeof gate === 'function') {\r\n      //  Controlled gate classes don't yet exists and would require\r\n      //  separate treatment\r\n      assert(!isKindclassOf(gate, ControlledGate))\r\n      allowed_gate_classes.push(gate)\r\n    } else if (gate instanceof ControlledGate) {\r\n      allowed_gate_instances.push([gate.gate, gate.n])\r\n    } else {\r\n      allowed_gate_instances.push([gate, 0])\r\n    }\r\n  })\r\n\r\n  function low_level_gates(eng, cmd) {\r\n    const all_qubits = []\r\n    cmd.allQubits.forEach(qr => qr.forEach(q => all_qubits.push(q)))\r\n\r\n    if (cmd.gate instanceof ClassicalInstructionGate) {\r\n      // This is required to allow Measure, Allocate, Deallocate, Flush\r\n      return true\r\n    } else if (one_qubit_gates === 'any' && len(all_qubits) === 1) {\r\n      return true\r\n    } else if (two_qubit_gates === 'any' && len(all_qubits) === 2) {\r\n      return true\r\n    } else if (instanceOf(cmd.gate, allowed_gate_classes)) {\r\n      return true\r\n    } else {\r\n      const cn = cmd.controlQubits.length\r\n      const idx = allowed_gate_instances.findIndex((looper) => {\r\n        try {\r\n          return cmd.gate.equal(looper[0]) && cn === looper[1]\r\n        } catch (e) {\r\n          return false\r\n        }\r\n      })\r\n      if (idx !== -1) {\r\n        return true\r\n      }\r\n    }\r\n    return false\r\n  }\r\n\r\n  return [\r\n    new AutoReplacer(rule_set),\r\n    new TagRemover(),\r\n    new InstructionFilter(high_level_gates),\r\n    new LocalOptimizer(5),\r\n    new AutoReplacer(rule_set),\r\n    new TagRemover(),\r\n    new InstructionFilter(one_and_two_qubit_gates),\r\n    new LocalOptimizer(5),\r\n    new AutoReplacer(rule_set),\r\n    new TagRemover(),\r\n    new InstructionFilter(low_level_gates),\r\n    new LocalOptimizer(5),\r\n  ]\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/restrictedgateset.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 952,
    "kind": "function",
    "name": "high_level_gates",
    "memberof": "src/setups/restrictedgateset.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/restrictedgateset.js~high_level_gates",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/setups/restrictedgateset.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "params": [
      {
        "name": "eng",
        "types": [
          "*"
        ]
      },
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 953,
    "kind": "function",
    "name": "one_and_two_qubit_gates",
    "memberof": "src/setups/restrictedgateset.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/restrictedgateset.js~one_and_two_qubit_gates",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/setups/restrictedgateset.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 29,
    "undocument": true,
    "params": [
      {
        "name": "eng",
        "types": [
          "*"
        ]
      },
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 954,
    "kind": "function",
    "name": "getEngineList",
    "memberof": "src/setups/restrictedgateset.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/restrictedgateset.js~getEngineList",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/setups/restrictedgateset.js",
    "importStyle": "{getEngineList}",
    "description": "Returns an engine list to compile to a restricted gate set.\n\nNote:\nIf you choose a new gate set for which the compiler does not yet have\nstandard rules, it raises an `NoGateDecompositionError` or a\n`RuntimeError: maximum recursion depth exceeded...`. Also note that\neven the gate sets which work might not yet be optimized. So make sure\nto double check and potentially extend the decomposition rules.\nThis implemention currently requires that the one qubit gates must\ncontain Rz and at least one of {Ry(best), Rx, H} and the two qubit gate\nmust contain CNOT (recommended) or CZ.\n\nNote:\nClassical instructions gates such as e.g. Flush and Measure are\nautomatically allowed.",
    "examples": [
      "getEngineList(tuple(Rz, Ry, Rx, H), tuple(CNOT), tuple(TimeEvolution))"
    ],
    "lineNumber": 79,
    "params": [
      {
        "nullable": null,
        "types": [
          "string",
          "Array.<BasicGate>"
        ],
        "spread": false,
        "optional": false,
        "name": "one_qubit_gates",
        "description": "\"any\" allows any one qubit gate, otherwise provide\na tuple of the allowed gates. If the gates are instances of a class (e.g. X), it allows all gates\nwhich are equal to it. If the gate is a class (Rz), it allows all instances of this class. Default is \"any\""
      },
      {
        "nullable": null,
        "types": [
          "string",
          "Array.<BasicGate>"
        ],
        "spread": false,
        "optional": false,
        "name": "two_qubit_gates",
        "description": "\"any\" allows any two qubit gate, otherwise provide\na tuple of the allowed gates. If the gates are instances of a class (e.g. CNOT), it allows all gates\nwhich are equal to it. If the gate is a class, it allows all instances of this class.\nDefault is (CNOT,)."
      },
      {
        "nullable": null,
        "types": [
          "string",
          "Array.<BasicGate>"
        ],
        "spread": false,
        "optional": false,
        "name": "other_gates",
        "description": "A tuple of the allowed gates. If the gates are\ninstances of a class (e.g. QFT), it allows all gates which are equal to it. If the gate is a\nclass, it allows all instances of this class."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<BasicEngine>"
      ],
      "spread": false,
      "description": "A list of suitable compiler engines."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If input is for the gates is not \"any\" or a tuple."
      }
    ]
  },
  {
    "__docId__": 955,
    "kind": "file",
    "name": "src/types/qubit.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/**\r\n    This file defines BasicQubit, Qubit, WeakQubit and Qureg.\r\n\r\n    A Qureg represents a list of Qubit or WeakQubit objects.\r\n    Qubit represents a (logical-level) qubit with a unique index provided by the\r\n    MainEngine. Qubit objects are automatically deallocated if they go out of\r\n    scope and intented to be used within Qureg objects in user code.\r\n\r\n @example\r\n      import MainEngine\r\n      const eng = new MainEngine()\r\n      const qubit = eng.allocateQubit()\r\n\r\n    qubit is a Qureg of size 1 with one Qubit object which is deallocated once\r\n    qubit goes out of scope.\r\n\r\n    WeakQubit are used inside the Command object and are not automatically deallocated.\r\n*/\r\nimport {arrayEqual} from '../libs/polyfill'\r\n\r\n/**\r\n * @class BasicQubit\r\n * @desc\r\n * objects represent qubits. They have an id and a reference to the owning engine.\r\n */\r\nexport class BasicQubit {\r\n  /**\r\n   *  @constructor\r\n   *  Initialize a BasicQubit object.\r\n   *  @param {BasicEngine} engine Owning engine / engine that created the qubit\r\n   *  @param {number} idx Unique index of the qubit referenced by this qubit\r\n   */\r\n  constructor(engine, idx) {\r\n    /**\r\n     * @type {BasicEngine}\r\n     */\r\n    this.engine = engine\r\n    this.id = idx\r\n  }\r\n\r\n  /**\r\n    Return string representation of this qubit.\r\n   @return {string}\r\n   */\r\n  toString() {\r\n    return `${this.id}`\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @return {string}\r\n   */\r\n  inspect() {\r\n    return this.toString()\r\n  }\r\n\r\n  /**\r\n    Access the result of a previous measurement and return false / true (0 / 1)\r\n    @return {boolean}\r\n  */\r\n  toBoolean() {\r\n    return this.engine.main.getMeasurementResult(this)\r\n  }\r\n\r\n  /**\r\n   * @return {number}\r\n   */\r\n  toNumber() {\r\n    return this.toBoolean() ? 1 : 0\r\n  }\r\n\r\n  /**\r\n   * Compare with other qubit (Returns true if equal id and engine).\r\n   *\r\n   * @param other {BasicQubit|Object} BasicQubit to which to compare this one\r\n   * @return {boolean}\r\n   */\r\n  equal(other) {\r\n    if (this === other) {\r\n      return true\r\n    }\r\n    return other instanceof BasicQubit && this.id === other.id && this.engine === other.engine\r\n  }\r\n\r\n  weakCopy() {\r\n    return new BasicQubit(this.engine, this.id)\r\n  }\r\n\r\n  static copyArray(array) {\r\n    return array.map(i => i.weakCopy())\r\n  }\r\n}\r\n\r\n/**\r\n * @class Qubit\r\n * @desc\r\n    Represents a (logical-level) qubit with a unique index provided by the\r\n    MainEngine. Once the qubit goes out of scope (and is garbage-collected),\r\n    it deallocates itself automatically, allowing automatic resource management.\r\n\r\n    Thus the qubit is not copyable only returns a reference to the same object.\r\n */\r\nexport class Qubit extends BasicQubit {\r\n  deallocate() {\r\n    // # If a user directly calls this function, then the qubit gets id == -1\r\n    // # but stays in active_qubits as it is not yet deleted, hence remove\r\n    // # it manually (if the garbage collector calls this function, then the\r\n    // # WeakRef in active qubits is already gone):\r\n    if (this.id === -1) {\r\n      return\r\n    }\r\n\r\n    try {\r\n      const qubits = this.engine.main.activeQubits\r\n      if (qubits.has(this)) {\r\n        qubits.delete(this)\r\n      }\r\n      this.engine.deallocateQubit(this)\r\n    } catch (e) {\r\n      throw e\r\n    } finally {\r\n      this.id = -1\r\n    }\r\n  }\r\n\r\n  /**\r\n    Non-copyable (returns reference to self).\r\n    Note:\r\n      To prevent problems with automatic deallocation, qubits are not copyable!\r\n  */\r\n  copy() {\r\n    return this\r\n  }\r\n}\r\n\r\n/**\r\n * Quantum register class.\r\nSimplifies accessing measured values for single-qubit registers (no []-access necessary)\r\n and enables pretty-printing of general quantum registers).\r\n @class Qureg\r\n */\r\nexport class Qureg extends Array {\r\n  /**\r\n   * a little different with `Array`: when pass an array as argument, will copy the passed array\r\n   * @constructor\r\n   * @param {...any|number|Array} args\r\n   */\r\n  constructor(...args) {\r\n    const arg0 = args[0]\r\n    if (Array.isArray(arg0)) {\r\n      super(...arg0)\r\n    } else {\r\n      super(...args)\r\n    }\r\n    /**\r\n     * @ignore\r\n     * @private\r\n     */\r\n    this.__proto__ = Qureg.prototype\r\n  }\r\n\r\n  /**\r\n   * test if two Quregs are equal\r\n   * @param {Qureg|Object} other\r\n   * @return {boolean}\r\n   */\r\n  equal(other) {\r\n    if (other instanceof Qureg) {\r\n      return arrayEqual(this, other, (x, y) => x.equal(y))\r\n    }\r\n    return false\r\n  }\r\n\r\n  /**\r\n   * only supported when `length === 1`, use the qubit value as qureg value\r\n   * @throws {Error} will throw when `length !== 1`\r\n   * @return {boolean}\r\n   */\r\n  toBoolean() {\r\n    if (this.length === 1) {\r\n      return this[0].toBoolean()\r\n    }\r\n    throw new Error('qureg.toBoolean(): Quantum register contains more \"\\n'\r\n        + '\"than 1 qubit. Use qureg[idx].toBoolean() instead.')\r\n  }\r\n\r\n  /**\r\n   * number representation\r\n   * @return {number}\r\n   */\r\n  toNumber() {\r\n    return this.toBoolean() ? 1 : 0\r\n  }\r\n\r\n  /**\r\n   * add qubits from `other`, return a new Qureg instance\r\n   * @param {Array<Qubit>|Qureg} other\r\n   * @return {Qureg}\r\n   */\r\n  add(other) {\r\n    const array = this.concat(other)\r\n    return new Qureg(array)\r\n  }\r\n\r\n  /**\r\n   * string description\r\n   * @return {string}\r\n   */\r\n  toString() {\r\n    if (this.length === 0) return 'Qureg[]'\r\n    const ids = this.slice(1).map(({id}) => id)\r\n    ids.push(null) // Forces a flush on last loop iteration.\r\n\r\n    const out_list = []\r\n    let start_id = this[0].id\r\n    let count = 1\r\n    ids.forEach((qubit_id) => {\r\n      if (qubit_id === start_id + count) {\r\n        count += 1\r\n      } else {\r\n        // TODO\r\n        if (count > 1) {\r\n          out_list.push(`${start_id}-${start_id + count - 1}`)\r\n        } else {\r\n          out_list.push(`${start_id}`)\r\n        }\r\n        start_id = qubit_id\r\n        count = 1\r\n      }\r\n    })\r\n\r\n    return `Qureg[${out_list.join(', ')}]`\r\n  }\r\n\r\n  /**\r\n   * deallocate all qubit, then clear the qureg\r\n   */\r\n  deallocate() {\r\n    this.forEach(qubit => qubit.deallocate())\r\n    this.length = 0\r\n  }\r\n\r\n  /**\r\n   * @return {BasicEngine}\r\n   */\r\n  get engine() {\r\n    return this[0].engine\r\n  }\r\n\r\n  /**\r\n   * @param {BasicEngine} newEngine\r\n   */\r\n  set engine(newEngine) {\r\n    this.forEach(looper => looper.engine = newEngine)\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/types/qubit.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 956,
    "kind": "class",
    "name": "BasicQubit",
    "memberof": "src/types/qubit.js",
    "static": true,
    "longname": "src/types/qubit.js~BasicQubit",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/types/qubit.js",
    "importStyle": "{BasicQubit}",
    "description": "objects represent qubits. They have an id and a reference to the owning engine.",
    "lineNumber": 42,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "BasicQubit"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 957,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/types/qubit.js~BasicQubit",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/types/qubit.js~BasicQubit#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 49,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": " Initialize a BasicQubit object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "BasicEngine"
        ],
        "spread": false,
        "optional": false,
        "name": "engine",
        "description": "Owning engine / engine that created the qubit"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "idx",
        "description": "Unique index of the qubit referenced by this qubit"
      }
    ]
  },
  {
    "__docId__": 958,
    "kind": "member",
    "name": "engine",
    "memberof": "src/types/qubit.js~BasicQubit",
    "static": false,
    "longname": "src/types/qubit.js~BasicQubit#engine",
    "access": "public",
    "description": "",
    "lineNumber": 53,
    "type": {
      "nullable": null,
      "types": [
        "BasicEngine"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 959,
    "kind": "member",
    "name": "id",
    "memberof": "src/types/qubit.js~BasicQubit",
    "static": false,
    "longname": "src/types/qubit.js~BasicQubit#id",
    "access": "public",
    "description": null,
    "lineNumber": 54,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 960,
    "kind": "method",
    "name": "toString",
    "memberof": "src/types/qubit.js~BasicQubit",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/types/qubit.js~BasicQubit#toString",
    "access": "public",
    "description": "Return string representation of this qubit.",
    "lineNumber": 61,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 961,
    "kind": "method",
    "name": "inspect",
    "memberof": "src/types/qubit.js~BasicQubit",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/types/qubit.js~BasicQubit#inspect",
    "access": "public",
    "description": "",
    "lineNumber": 69,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 962,
    "kind": "method",
    "name": "toBoolean",
    "memberof": "src/types/qubit.js~BasicQubit",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/types/qubit.js~BasicQubit#toBoolean",
    "access": "public",
    "description": "Access the result of a previous measurement and return false / true (0 / 1)",
    "lineNumber": 77,
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 963,
    "kind": "method",
    "name": "toNumber",
    "memberof": "src/types/qubit.js~BasicQubit",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/types/qubit.js~BasicQubit#toNumber",
    "access": "public",
    "description": "",
    "lineNumber": 84,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 964,
    "kind": "method",
    "name": "equal",
    "memberof": "src/types/qubit.js~BasicQubit",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/types/qubit.js~BasicQubit#equal",
    "access": "public",
    "description": "Compare with other qubit (Returns true if equal id and engine).",
    "lineNumber": 94,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "{BasicQubit|Object} BasicQubit to which to compare this one"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 965,
    "kind": "method",
    "name": "weakCopy",
    "memberof": "src/types/qubit.js~BasicQubit",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/types/qubit.js~BasicQubit#weakCopy",
    "access": "public",
    "description": null,
    "lineNumber": 101,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 966,
    "kind": "method",
    "name": "copyArray",
    "memberof": "src/types/qubit.js~BasicQubit",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/types/qubit.js~BasicQubit.copyArray",
    "access": "public",
    "description": null,
    "lineNumber": 105,
    "undocument": true,
    "params": [
      {
        "name": "array",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 967,
    "kind": "class",
    "name": "Qubit",
    "memberof": "src/types/qubit.js",
    "static": true,
    "longname": "src/types/qubit.js~Qubit",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/types/qubit.js",
    "importStyle": "{Qubit}",
    "description": "Represents a (logical-level) qubit with a unique index provided by the\nMainEngine. Once the qubit goes out of scope (and is garbage-collected),\nit deallocates itself automatically, allowing automatic resource management.\n\nThus the qubit is not copyable only returns a reference to the same object.",
    "lineNumber": 119,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "Qubit"
      }
    ],
    "interface": false,
    "extends": [
      "BasicQubit"
    ]
  },
  {
    "__docId__": 968,
    "kind": "method",
    "name": "deallocate",
    "memberof": "src/types/qubit.js~Qubit",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/types/qubit.js~Qubit#deallocate",
    "access": "public",
    "description": null,
    "lineNumber": 120,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 969,
    "kind": "member",
    "name": "id",
    "memberof": "src/types/qubit.js~Qubit",
    "static": false,
    "longname": "src/types/qubit.js~Qubit#id",
    "access": "public",
    "description": null,
    "lineNumber": 138,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 970,
    "kind": "method",
    "name": "copy",
    "memberof": "src/types/qubit.js~Qubit",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/types/qubit.js~Qubit#copy",
    "access": "public",
    "description": "Non-copyable (returns reference to self).\nNote:\nTo prevent problems with automatic deallocation, qubits are not copyable!",
    "lineNumber": 147,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 971,
    "kind": "class",
    "name": "Qureg",
    "memberof": "src/types/qubit.js",
    "static": true,
    "longname": "src/types/qubit.js~Qureg",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/types/qubit.js",
    "importStyle": "{Qureg}",
    "description": "Quantum register class.\nSimplifies accessing measured values for single-qubit registers (no []-access necessary)\nand enables pretty-printing of general quantum registers).",
    "lineNumber": 158,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "Qureg"
      }
    ],
    "interface": false,
    "extends": [
      "Array"
    ]
  },
  {
    "__docId__": 972,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/types/qubit.js~Qureg",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/types/qubit.js~Qureg#constructor",
    "access": "public",
    "description": "a little different with `Array`: when pass an array as argument, will copy the passed array",
    "lineNumber": 164,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "...any",
          "number",
          "Array"
        ],
        "spread": true,
        "optional": false,
        "name": "args",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 973,
    "kind": "member",
    "name": "__proto__",
    "memberof": "src/types/qubit.js~Qureg",
    "static": false,
    "longname": "src/types/qubit.js~Qureg#__proto__",
    "access": "private",
    "description": "",
    "lineNumber": 175,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 974,
    "kind": "method",
    "name": "equal",
    "memberof": "src/types/qubit.js~Qureg",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/types/qubit.js~Qureg#equal",
    "access": "public",
    "description": "test if two Quregs are equal",
    "lineNumber": 183,
    "params": [
      {
        "nullable": null,
        "types": [
          "Qureg",
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 975,
    "kind": "method",
    "name": "toBoolean",
    "memberof": "src/types/qubit.js~Qureg",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/types/qubit.js~Qureg#toBoolean",
    "access": "public",
    "description": "only supported when `length === 1`, use the qubit value as qureg value",
    "lineNumber": 195,
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "will throw when `length !== 1`"
      }
    ],
    "params": []
  },
  {
    "__docId__": 976,
    "kind": "method",
    "name": "toNumber",
    "memberof": "src/types/qubit.js~Qureg",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/types/qubit.js~Qureg#toNumber",
    "access": "public",
    "description": "number representation",
    "lineNumber": 207,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 977,
    "kind": "method",
    "name": "add",
    "memberof": "src/types/qubit.js~Qureg",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/types/qubit.js~Qureg#add",
    "access": "public",
    "description": "add qubits from `other`, return a new Qureg instance",
    "lineNumber": 216,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array<Qubit>",
          "Qureg"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Qureg"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 978,
    "kind": "method",
    "name": "toString",
    "memberof": "src/types/qubit.js~Qureg",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/types/qubit.js~Qureg#toString",
    "access": "public",
    "description": "string description",
    "lineNumber": 225,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 979,
    "kind": "method",
    "name": "deallocate",
    "memberof": "src/types/qubit.js~Qureg",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/types/qubit.js~Qureg#deallocate",
    "access": "public",
    "description": "deallocate all qubit, then clear the qureg",
    "lineNumber": 254,
    "params": [],
    "return": null
  },
  {
    "__docId__": 980,
    "kind": "member",
    "name": "length",
    "memberof": "src/types/qubit.js~Qureg",
    "static": false,
    "longname": "src/types/qubit.js~Qureg#length",
    "access": "public",
    "description": null,
    "lineNumber": 256,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 981,
    "kind": "get",
    "name": "engine",
    "memberof": "src/types/qubit.js~Qureg",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/types/qubit.js~Qureg#engine",
    "access": "public",
    "description": "",
    "lineNumber": 262,
    "return": {
      "nullable": null,
      "types": [
        "BasicEngine"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 982,
    "kind": "set",
    "name": "engine",
    "memberof": "src/types/qubit.js~Qureg",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/types/qubit.js~Qureg#engine",
    "access": "public",
    "description": "",
    "lineNumber": 269,
    "params": [
      {
        "nullable": null,
        "types": [
          "BasicEngine"
        ],
        "spread": false,
        "optional": false,
        "name": "newEngine",
        "description": ""
      }
    ]
  },
  {
    "kind": "index",
    "content": "# Q-js\r\nNodeJS version of [ProjectQ](https://github.com/ProjectQ-Framework/ProjectQ)\r\n\r\nCircleCI build status: [![CircleCI](https://circleci.com/gh/tearsofphoenix/Q-js/tree/master.svg?style=svg)](https://circleci.com/gh/tearsofphoenix/Q-js/tree/master)\r\n\r\n[![NPM](https://nodei.co/npm/projectq.png)](https://nodei.co/npm/projectq/)\r\n\r\n### install\r\n 1. use `git` to clone the repository \r\n 2. run `yarn install` \r\n 3. run `yarn build` to build native cpp simulator \r\n 4. run `yarn test`, check examples \r\n \r\n### notice\r\n  1. Most of the `class` have same name with the original ProjectQ project\r\n  2. Using `camelcase` rules to renamed most class methods. `get_inverse`\r\n     has been changed to `getInverse`.\r\n  3. Some class (like `GridMapper`) have too much arguments for it's constructor,\r\n     so changed to only pass an `Object` which contains all original arguments.\r\n  4. Python `tuple` type has been ported to Javascript `Array`. It's the programmer's\r\n     responsibility to make sure not to mutate immutable object, but not the language.  \r\n  5. `ibm` and `GridMapper` is still under porting. \r\n  6. Issues and pull requests are welcome.      ",
    "longname": "E:\\workpace\\Q\\README.md",
    "name": "./README.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "packageJSON",
    "content": "{\n  \"name\": \"projectq\",\n  \"version\": \"0.1.6\",\n  \"libq\": \"0.1.1\",\n  \"private\": false,\n  \"license\": \"Apache\",\n  \"author\": \"Isaac Phoenix (tearsofphoenix@icloud.com)\",\n  \"main\": \"./dist/index.js\",\n  \"scripts\": {\n    \"install\": \"node scripts/install.js\",\n    \"cover\": \"cross-env NODE_ENV=test nyc mocha --recursive ./test\",\n    \"test\": \"mocha --require babel-register --require babel-polyfill --recursive ./test\",\n    \"build\": \"node scripts/build.js --force\",\n    \"doc\": \"./node_modules/.bin/esdoc\",\n    \"prepublish\": \"rimraf dist/* && babel ./src -d ./dist\"\n  },\n  \"dependencies\": {\n    \"axios\": \"^0.18.0\",\n    \"big-integer\": \"^1.6.34\",\n    \"decimal.js\": \"^10.0.1\",\n    \"itertools\": \"^1.3.0\",\n    \"mathjs\": \"^5.1.0\",\n    \"nan\": \"^2.10.0\",\n    \"node-gyp\": \"^3.8.0\",\n    \"request\": \"^2.88.0\",\n    \"npmlog\": \"^4.1.2\",\n    \"mkdirp\": \"^0.5.1\",\n    \"true-case-path\": \"^1.0.2\",\n    \"cross-spawn\": \"^6.0.5\"\n  },\n  \"devDependencies\": {\n    \"babel-cli\": \"^6.26.0\",\n    \"babel-core\": \"^6.26.3\",\n    \"babel-eslint\": \"^8.2.6\",\n    \"babel-plugin-istanbul\": \"^4.1.6\",\n    \"babel-polyfill\": \"^6.26.0\",\n    \"babel-preset-env\": \"^1.7.0\",\n    \"babel-preset-stage-0\": \"^6.24.1\",\n    \"babel-register\": \"^6.26.0\",\n    \"chai\": \"^4.1.2\",\n    \"cross-env\": \"^5.2.0\",\n    \"esdoc\": \"^1.1.0\",\n    \"esdoc-standard-plugin\": \"^1.0.0\",\n    \"eslint\": \"^5.4.0\",\n    \"eslint-config-airbnb\": \"^17.1.0\",\n    \"eslint-loader\": \"^2.1.0\",\n    \"eslint-plugin-import\": \"^2.14.0\",\n    \"eslint-plugin-jsx-a11y\": \"^6.1.1\",\n    \"eslint-plugin-react\": \"^7.11.1\",\n    \"istanbul\": \"^0.4.5\",\n    \"jshint\": \"^2.9.6\",\n    \"mocha\": \"^5.2.0\",\n    \"nyc\": \"^12.0.2\",\n    \"sinon\": \"^6.1.5\"\n  },\n  \"files\": [\n    \"dist/\",\n    \"scripts/\",\n    \"binding.gyp\",\n    \"libq.gyp\",\n    \".babelrc\",\n    \".eslintrc\"\n  ],\n  \"nyc\": {\n    \"require\": [\n      \"babel-register\",\n      \"babel-polyfill\"\n    ],\n    \"reporter\": [\n      \"lcov\",\n      \"text\"\n    ],\n    \"sourceMap\": false,\n    \"instrument\": false\n  }\n}\n",
    "longname": "E:\\workpace\\Q\\package.json",
    "name": "package.json",
    "static": true,
    "access": "public"
  }
]