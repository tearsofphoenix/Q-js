[
  {
    "__docId__": 1,
    "kind": "external",
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Infinity",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 2,
    "kind": "external",
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~NaN",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 3,
    "kind": "external",
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~undefined",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 4,
    "kind": "external",
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~null",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 5,
    "kind": "external",
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 6,
    "kind": "external",
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 7,
    "kind": "external",
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 8,
    "kind": "external",
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 9,
    "kind": "external",
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 10,
    "kind": "external",
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 11,
    "kind": "external",
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Symbol",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 12,
    "kind": "external",
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Error",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 13,
    "kind": "external",
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~EvalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 14,
    "kind": "external",
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~InternalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 15,
    "kind": "external",
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RangeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 16,
    "kind": "external",
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ReferenceError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 17,
    "kind": "external",
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~SyntaxError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 18,
    "kind": "external",
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~TypeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 19,
    "kind": "external",
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~URIError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 20,
    "kind": "external",
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 21,
    "kind": "external",
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 22,
    "kind": "external",
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Date",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 23,
    "kind": "external",
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~String",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 24,
    "kind": "external",
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~string",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 25,
    "kind": "external",
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RegExp",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 26,
    "kind": "external",
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 27,
    "kind": "external",
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 28,
    "kind": "external",
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 29,
    "kind": "external",
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8ClampedArray",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 30,
    "kind": "external",
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 31,
    "kind": "external",
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 32,
    "kind": "external",
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 33,
    "kind": "external",
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 34,
    "kind": "external",
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 35,
    "kind": "external",
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float64Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 36,
    "kind": "external",
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Map",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 37,
    "kind": "external",
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Set",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 38,
    "kind": "external",
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakMap",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 39,
    "kind": "external",
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakSet",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 40,
    "kind": "external",
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ArrayBuffer",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 41,
    "kind": "external",
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~DataView",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 42,
    "kind": "external",
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~JSON",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 43,
    "kind": "external",
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Promise",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 44,
    "kind": "external",
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Generator",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 45,
    "kind": "external",
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~GeneratorFunction",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 46,
    "kind": "external",
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Reflect",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 47,
    "kind": "external",
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Proxy",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 48,
    "kind": "file",
    "name": "src/backends/circuits/drawer.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport assert from 'assert'\r\nimport {LastEngineError} from '../../meta/error'\r\nimport {arrayEqual, len} from '../../libs/polyfill'\r\n\r\nimport {\r\n  Allocate, Deallocate, FlushGate, Measure\r\n} from '../../ops';\r\nimport {BasicEngine} from '../../cengines'\r\nimport ToLatex from './tolatex'\r\n\r\n/**\r\n * @class CircuitItem\r\n */\r\nexport class CircuitItem {\r\n  /**\r\n   * @constructor\r\n    @param {BasicGate} gate\r\n    @param {number[]} lines Circuit lines the gate acts on.\r\n    @param {number[]} ctrl_lines Circuit lines which control the gate.\r\n  */\r\n  constructor(gate, lines, ctrl_lines) {\r\n    this.gate = gate\r\n    this.lines = lines\r\n    this.ctrl_lines = ctrl_lines\r\n    this.id = -1\r\n  }\r\n\r\n  /**\r\n   * @return {CircuitItem}\r\n   */\r\n  copy() {\r\n    const l = Array.isArray(this.lines) ? this.lines.slice(0) : this.lines\r\n    const cl = Array.isArray(this.ctrl_lines) ? this.ctrl_lines.slice(0) : this.ctrl_lines\r\n    const inst = new CircuitItem(this.gate, l, cl)\r\n    inst.id = this.id\r\n    return inst\r\n  }\r\n\r\n  /**\r\n   * @param {(CircuitItem|Object)} other\r\n   * @return {boolean}\r\n   */\r\n  equal(other) {\r\n    if (other instanceof CircuitItem) {\r\n      let f = false\r\n      if (this.gate.equal) {\r\n        f = this.gate.equal(other.gate)\r\n      } else {\r\n        f = this.gate === other.gate\r\n      }\r\n      return f && arrayEqual(this.lines, other.lines)\r\n          && arrayEqual(this.ctrl_lines, other.ctrl_lines) && this.id === other.id\r\n    }\r\n    return false\r\n  }\r\n}\r\n\r\n/**\r\n * @class CircuitDrawer\r\n * @desc\r\nCircuitDrawer is a compiler engine which generates TikZ code for drawing\r\n  quantum circuits.\r\n\r\n    The circuit can be modified by editing the settings.json file which is\r\ngenerated upon first execution. This includes adjusting the gate width,\r\n    height, shadowing, line thickness, and many more options.\r\n\r\n    After initializing the CircuitDrawer, it can also be given the mapping\r\nfrom qubit IDs to wire location (via the :meth:`set_qubit_locations`\r\nfunction):\r\n\r\n  @example\r\n\r\nconst circuit_backend = new CircuitDrawer()\r\ncircuit_backend.setQubitLocations({0: 1, 1: 0}) // swap lines 0 and 1\r\nconst eng = new MainEngine(circuit_backend)\r\n\r\n... // run quantum algorithm on this main engine\r\n\r\nconsole.log(circuit_backend.getLatex()) // prints LaTeX code\r\n\r\nTo see the qubit IDs in the generated circuit, simply set the `draw_id`\r\noption in the settings.json file under \"gates\":\"AllocateQubitGate\" to\r\ntrue:\r\n\r\n @example\r\n\r\n\"gates\": {\r\n  \"AllocateQubitGate\": {\r\n    \"draw_id\": true,\r\n        \"height\": 0.15,\r\n        \"width\": 0.2,\r\n        \"pre_offset\": 0.1,\r\n        \"offset\": 0.1\r\n  },\r\n...\r\n\r\n  The settings.json file has the following structure:\r\n\r\n      @example\r\n\r\n  {\r\n    \"control\": { // settings for control \"circle\"\r\n    \"shadow\": false,\r\n        \"size\": 0.1\r\n  },\r\n    \"gate_shadow\": true, // enable/disable shadows for all gates\r\n    \"gates\": {\r\n    \"GateClassString\": {\r\n      GATE_PROPERTIES\r\n    }\r\n    \"GateClassString2\": {\r\n    ...\r\n    },\r\n    \"lines\": { // settings for qubit lines\r\n      \"double_classical\": true, // draw double-lines for classical bits\r\n      \"double_lines_sep\": 0.04, // gap between the two lines for double lines\r\n      \"init_quantum\": true, // start out with quantum bits\r\n      \"style\": \"very thin\" // line style\r\n    }\r\n  }\r\n\r\n    All gates (except for the ones requiring special treatment) support the\r\n    following properties:\r\n\r\n    @example\r\n\r\n    \"GateClassString\": {\r\n    \"height\": GATE_HEIGHT,\r\n        \"width\": GATE_WIDTH\r\n    \"pre_offset\": OFFSET_BEFORE_PLACEMENT,\r\n        \"offset\": OFFSET_AFTER_PLACEMENT,\r\n  },\r\n */\r\nexport class CircuitDrawer extends BasicEngine {\r\n  /**\r\n   * @constructor\r\n  Initialize a circuit drawing engine.\r\n\r\n      The TikZ code generator uses a settings file (settings.json), which\r\n    can be altered by the user. It contains gate widths, heights, offsets,\r\n      etc.\r\n\r\n    @param {boolean} accept_input If accept_input is true, the printer queries\r\n    the user to input measurement results if the CircuitDrawer is\r\n    the last engine. Otherwise, all measurements yield the result\r\n    default_measure (0 or 1).\r\n    @param {number} default_measure Default value to use as measurement\r\n    results if accept_input is false and there is no underlying\r\n    backend to register real measurement results.\r\n   */\r\n  constructor(accept_input = false, default_measure = 0) {\r\n    super()\r\n    this._accept_input = accept_input\r\n    this._default_measure = default_measure\r\n    this._qubit_lines = {}\r\n    this._free_lines = []\r\n    this._map = {}\r\n  }\r\n\r\n  /**\r\n  Specialized implementation of isAvailable: Returns true if the\r\n    CircuitDrawer is the last engine (since it can print any command).\r\n\r\n    @param {Command} cmd Command for which to check availability (all Commands can be printed).\r\n    @return {boolean} true, unless the next engine cannot handle the Command (if there is a next engine).\r\n   */\r\n  isAvailable(cmd) {\r\n    try {\r\n      return super.isAvailable(cmd)\r\n    } catch (e) {\r\n      if (e instanceof LastEngineError) {\r\n        return true\r\n      }\r\n    }\r\n    return false\r\n  }\r\n\r\n  /**\r\n  Sets the qubit lines to use for the qubits explicitly.\r\n\r\n      To figure out the qubit IDs, simply use the setting `draw_id` in the\r\n    settings file. It is located in \"gates\":\"AllocateQubitGate\".\r\n      If draw_id is true, the qubit IDs are drawn in red.\r\n\r\n      @param {Object} idToLoc Dictionary mapping qubit ids to qubit line numbers.\r\n\r\n      @throws {Error} If the mapping has already begun (this function\r\n  needs be called before any gates have been received).\r\n   */\r\n  setQubitLocations(idToLoc) {\r\n    if (len(this._map) > 0) {\r\n      throw new Error('set_qubit_locations() has to be called before applying gates!')\r\n    }\r\n\r\n    const min = Math.min(...Object.keys(idToLoc))\r\n    const max = Math.max(...Object.keys(idToLoc)) + 1\r\n    for (let k = min; k < max; ++k) {\r\n      if (!(k in idToLoc)) {\r\n        throw new Error('set_qubit_locations(): Invalid id_to_loc '\r\n        + 'mapping provided. All ids in the provided'\r\n        + ' range of qubit ids have to be mapped '\r\n        + 'somewhere.')\r\n      }\r\n    }\r\n    this._map = idToLoc\r\n  }\r\n\r\n  /**\r\n  Add the command cmd to the circuit diagram, taking care of potential\r\n    measurements as specified in the __init__ function.\r\n\r\n    Queries the user for measurement input if a measurement command\r\n    arrives if accept_input was set to true. Otherwise, it uses the\r\n    default_measure parameter to register the measurement outcome.\r\n\r\n      @param {Command} cmd Command to add to the circuit diagram.\r\n   */\r\n  printCMD(cmd) {\r\n    if (cmd.gate.equal(Allocate)) {\r\n      const qubit_id = cmd.qubits[0][0].id\r\n      if (!(qubit_id in this._map)) {\r\n        this._map[qubit_id] = qubit_id\r\n      }\r\n      this._qubit_lines[qubit_id] = []\r\n    }\r\n    if (cmd.gate.equal(Deallocate)) {\r\n      const qubit_id = cmd.qubits[0][0].id\r\n      this._free_lines.push(qubit_id)\r\n    }\r\n    if (this.isLastEngine && cmd.gate === Measure) {\r\n      assert(cmd.controlCount === 0)\r\n\r\n      cmd.qubits.forEach(qureg => qureg.forEach((qubit) => {\r\n        let m\r\n        if (this._accept_input) {\r\n          // TODO\r\n        } else {\r\n          m = this._default_measure\r\n        }\r\n        this.main.setMeasurementResult(qubit, m)\r\n      }))\r\n    }\r\n\r\n    const all_lines = []\r\n    cmd.allQubits.forEach(qr => qr.forEach(qb => all_lines.push(qb.id)))\r\n\r\n    const gate = cmd.gate\r\n    const lines = []\r\n    cmd.qubits.forEach(qr => qr.forEach(qb => lines.push(qb.id)))\r\n    const ctrl_lines = cmd.controlQubits.map(qb => qb.id)\r\n    const item = new CircuitItem(gate, lines, ctrl_lines)\r\n\r\n    all_lines.forEach(l => this._qubit_lines[l].push(item))\r\n  }\r\n\r\n  /**\r\n  Return the latex document string representing the circuit.\r\n\r\n      Simply write this string into a tex-file or, alternatively, pipe the\r\n    output directly to, e.g., pdflatex:\r\n\r\n   @example\r\n\r\n    node my_circuit.js | pdflatex\r\n\r\n    where my_circuit.js calls this function and prints it to the terminal.\r\n   @return {string}\r\n   */\r\n  getLatex() {\r\n    const qubit_lines = {}\r\n\r\n    const linesCount = len(this._qubit_lines)\r\n    for (let line = 0; line < linesCount; ++line) {\r\n      const new_line = this._map[line]\r\n      qubit_lines[new_line] = []\r\n\r\n      this._qubit_lines[line].forEach((cmd) => {\r\n        const lines = cmd.lines.map(qb_id => this._map[qb_id])\r\n        const ctrl_lines = cmd.ctrl_lines.map(qb_id => this._map[qb_id])\r\n        const {gate} = cmd\r\n        const new_cmd = new CircuitItem(gate, lines, ctrl_lines)\r\n        if (gate.equal(Allocate)) {\r\n          new_cmd.id = cmd.lines[0]\r\n        }\r\n        qubit_lines[new_line].push(new_cmd)\r\n      })\r\n    }\r\n\r\n\r\n    const circuit = []\r\n    Object.keys(qubit_lines).forEach(lines => circuit.push(qubit_lines[lines]))\r\n    return ToLatex.toLatex(qubit_lines)\r\n  }\r\n\r\n  /**\r\n  Receive a list of commands from the previous engine, print the\r\n    commands, and then send them on to the next engine.\r\n\r\n    @param {Command[]} commandList List of Commands to print (and potentially send on to the next engine).\r\n  */\r\n  receive(commandList) {\r\n    commandList.forEach((cmd) => {\r\n      if (!(cmd.gate instanceof FlushGate)) {\r\n        this.printCMD(cmd)\r\n      }\r\n      if (!this.isLastEngine) {\r\n        this.send([cmd])\r\n      }\r\n    })\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/backends/circuits/drawer.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 49,
    "kind": "class",
    "name": "CircuitItem",
    "memberof": "src/backends/circuits/drawer.js",
    "static": true,
    "longname": "src/backends/circuits/drawer.js~CircuitItem",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/backends/circuits/drawer.js",
    "importStyle": "{CircuitItem}",
    "description": "",
    "lineNumber": 30,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "CircuitItem"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 50,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/backends/circuits/drawer.js~CircuitItem",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/circuits/drawer.js~CircuitItem#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 37,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "BasicGate"
        ],
        "spread": false,
        "optional": false,
        "name": "gate",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "lines",
        "description": "Circuit lines the gate acts on."
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "ctrl_lines",
        "description": "Circuit lines which control the gate."
      }
    ]
  },
  {
    "__docId__": 51,
    "kind": "member",
    "name": "gate",
    "memberof": "src/backends/circuits/drawer.js~CircuitItem",
    "static": false,
    "longname": "src/backends/circuits/drawer.js~CircuitItem#gate",
    "access": "public",
    "description": null,
    "lineNumber": 38,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 52,
    "kind": "member",
    "name": "lines",
    "memberof": "src/backends/circuits/drawer.js~CircuitItem",
    "static": false,
    "longname": "src/backends/circuits/drawer.js~CircuitItem#lines",
    "access": "public",
    "description": null,
    "lineNumber": 39,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 53,
    "kind": "member",
    "name": "ctrl_lines",
    "memberof": "src/backends/circuits/drawer.js~CircuitItem",
    "static": false,
    "longname": "src/backends/circuits/drawer.js~CircuitItem#ctrl_lines",
    "access": "public",
    "description": null,
    "lineNumber": 40,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 54,
    "kind": "member",
    "name": "id",
    "memberof": "src/backends/circuits/drawer.js~CircuitItem",
    "static": false,
    "longname": "src/backends/circuits/drawer.js~CircuitItem#id",
    "access": "public",
    "description": null,
    "lineNumber": 41,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 55,
    "kind": "method",
    "name": "copy",
    "memberof": "src/backends/circuits/drawer.js~CircuitItem",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/circuits/drawer.js~CircuitItem#copy",
    "access": "public",
    "description": "",
    "lineNumber": 47,
    "return": {
      "nullable": null,
      "types": [
        "CircuitItem"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 56,
    "kind": "method",
    "name": "equal",
    "memberof": "src/backends/circuits/drawer.js~CircuitItem",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/circuits/drawer.js~CircuitItem#equal",
    "access": "public",
    "description": "",
    "lineNumber": 59,
    "params": [
      {
        "nullable": null,
        "types": [
          "CircuitItem",
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 57,
    "kind": "class",
    "name": "CircuitDrawer",
    "memberof": "src/backends/circuits/drawer.js",
    "static": true,
    "longname": "src/backends/circuits/drawer.js~CircuitDrawer",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/backends/circuits/drawer.js",
    "importStyle": "{CircuitDrawer}",
    "description": "CircuitDrawer is a compiler engine which generates TikZ code for drawing\nquantum circuits.\n\nThe circuit can be modified by editing the settings.json file which is\ngenerated upon first execution. This includes adjusting the gate width,\nheight, shadowing, line thickness, and many more options.\n\nAfter initializing the CircuitDrawer, it can also be given the mapping\nfrom qubit IDs to wire location (via the :meth:`set_qubit_locations`\nfunction):",
    "examples": [
      "\nconst circuit_backend = new CircuitDrawer()\ncircuit_backend.setQubitLocations({0: 1, 1: 0}) // swap lines 0 and 1\nconst eng = new MainEngine(circuit_backend)\n\n... // run quantum algorithm on this main engine\n\nconsole.log(circuit_backend.getLatex()) // prints LaTeX code\n\nTo see the qubit IDs in the generated circuit, simply set the `draw_id`\noption in the settings.json file under \"gates\":\"AllocateQubitGate\" to\ntrue:",
      "\n\"gates\": {\n\"AllocateQubitGate\": {\n\"draw_id\": true,\n\"height\": 0.15,\n\"width\": 0.2,\n\"pre_offset\": 0.1,\n\"offset\": 0.1\n},\n...\n\nThe settings.json file has the following structure:",
      "\n{\n\"control\": { // settings for control \"circle\"\n\"shadow\": false,\n\"size\": 0.1\n},\n\"gate_shadow\": true, // enable/disable shadows for all gates\n\"gates\": {\n\"GateClassString\": {\nGATE_PROPERTIES\n}\n\"GateClassString2\": {\n...\n},\n\"lines\": { // settings for qubit lines\n\"double_classical\": true, // draw double-lines for classical bits\n\"double_lines_sep\": 0.04, // gap between the two lines for double lines\n\"init_quantum\": true, // start out with quantum bits\n\"style\": \"very thin\" // line style\n}\n}\n\nAll gates (except for the ones requiring special treatment) support the\nfollowing properties:",
      "\n\"GateClassString\": {\n\"height\": GATE_HEIGHT,\n\"width\": GATE_WIDTH\n\"pre_offset\": OFFSET_BEFORE_PLACEMENT,\n\"offset\": OFFSET_AFTER_PLACEMENT,\n},"
    ],
    "lineNumber": 151,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "CircuitDrawer"
      }
    ],
    "interface": false,
    "extends": [
      "src/cengines.js~BasicEngine"
    ]
  },
  {
    "__docId__": 58,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/backends/circuits/drawer.js~CircuitDrawer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/circuits/drawer.js~CircuitDrawer#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 168,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": "Initialize a circuit drawing engine.\n\nThe TikZ code generator uses a settings file (settings.json), which\ncan be altered by the user. It contains gate widths, heights, offsets,\netc."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "accept_input",
        "description": "If accept_input is true, the printer queries\nthe user to input measurement results if the CircuitDrawer is\nthe last engine. Otherwise, all measurements yield the result\ndefault_measure (0 or 1)."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "default_measure",
        "description": "Default value to use as measurement\nresults if accept_input is false and there is no underlying\nbackend to register real measurement results."
      }
    ]
  },
  {
    "__docId__": 59,
    "kind": "member",
    "name": "_accept_input",
    "memberof": "src/backends/circuits/drawer.js~CircuitDrawer",
    "static": false,
    "longname": "src/backends/circuits/drawer.js~CircuitDrawer#_accept_input",
    "access": "private",
    "description": null,
    "lineNumber": 170,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 60,
    "kind": "member",
    "name": "_default_measure",
    "memberof": "src/backends/circuits/drawer.js~CircuitDrawer",
    "static": false,
    "longname": "src/backends/circuits/drawer.js~CircuitDrawer#_default_measure",
    "access": "private",
    "description": null,
    "lineNumber": 171,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 61,
    "kind": "member",
    "name": "_qubit_lines",
    "memberof": "src/backends/circuits/drawer.js~CircuitDrawer",
    "static": false,
    "longname": "src/backends/circuits/drawer.js~CircuitDrawer#_qubit_lines",
    "access": "private",
    "description": null,
    "lineNumber": 172,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 62,
    "kind": "member",
    "name": "_free_lines",
    "memberof": "src/backends/circuits/drawer.js~CircuitDrawer",
    "static": false,
    "longname": "src/backends/circuits/drawer.js~CircuitDrawer#_free_lines",
    "access": "private",
    "description": null,
    "lineNumber": 173,
    "undocument": true,
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 63,
    "kind": "member",
    "name": "_map",
    "memberof": "src/backends/circuits/drawer.js~CircuitDrawer",
    "static": false,
    "longname": "src/backends/circuits/drawer.js~CircuitDrawer#_map",
    "access": "private",
    "description": null,
    "lineNumber": 174,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 64,
    "kind": "method",
    "name": "isAvailable",
    "memberof": "src/backends/circuits/drawer.js~CircuitDrawer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/circuits/drawer.js~CircuitDrawer#isAvailable",
    "access": "public",
    "description": "Specialized implementation of isAvailable: Returns true if the\nCircuitDrawer is the last engine (since it can print any command).",
    "lineNumber": 184,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": "Command for which to check availability (all Commands can be printed)."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true, unless the next engine cannot handle the Command (if there is a next engine)."
    }
  },
  {
    "__docId__": 65,
    "kind": "method",
    "name": "setQubitLocations",
    "memberof": "src/backends/circuits/drawer.js~CircuitDrawer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/circuits/drawer.js~CircuitDrawer#setQubitLocations",
    "access": "public",
    "description": "Sets the qubit lines to use for the qubits explicitly.\n\nTo figure out the qubit IDs, simply use the setting `draw_id` in the\nsettings file. It is located in \"gates\":\"AllocateQubitGate\".\nIf draw_id is true, the qubit IDs are drawn in red.",
    "lineNumber": 207,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "idToLoc",
        "description": "Dictionary mapping qubit ids to qubit line numbers."
      }
    ],
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If the mapping has already begun (this function\nneeds be called before any gates have been received)."
      }
    ],
    "return": null
  },
  {
    "__docId__": 67,
    "kind": "method",
    "name": "printCMD",
    "memberof": "src/backends/circuits/drawer.js~CircuitDrawer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/circuits/drawer.js~CircuitDrawer#printCMD",
    "access": "public",
    "description": "Add the command cmd to the circuit diagram, taking care of potential\nmeasurements as specified in the __init__ function.\n\nQueries the user for measurement input if a measurement command\narrives if accept_input was set to true. Otherwise, it uses the\ndefault_measure parameter to register the measurement outcome.",
    "lineNumber": 235,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": "Command to add to the circuit diagram."
      }
    ],
    "return": null
  },
  {
    "__docId__": 68,
    "kind": "method",
    "name": "getLatex",
    "memberof": "src/backends/circuits/drawer.js~CircuitDrawer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/circuits/drawer.js~CircuitDrawer#getLatex",
    "access": "public",
    "description": "Return the latex document string representing the circuit.\n\nSimply write this string into a tex-file or, alternatively, pipe the\noutput directly to, e.g., pdflatex:",
    "examples": [
      "\nnode my_circuit.js | pdflatex\n\nwhere my_circuit.js calls this function and prints it to the terminal."
    ],
    "lineNumber": 286,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 69,
    "kind": "method",
    "name": "receive",
    "memberof": "src/backends/circuits/drawer.js~CircuitDrawer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/circuits/drawer.js~CircuitDrawer#receive",
    "access": "public",
    "description": "Receive a list of commands from the previous engine, print the\ncommands, and then send them on to the next engine.",
    "lineNumber": 318,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command[]"
        ],
        "spread": false,
        "optional": false,
        "name": "commandList",
        "description": "List of Commands to print (and potentially send on to the next engine)."
      }
    ],
    "return": null
  },
  {
    "__docId__": 70,
    "kind": "file",
    "name": "src/backends/circuits/drawer.spec.js",
    "content": "import {expect} from 'chai'\r\nimport ToLatex from './tolatex'\r\nimport {CircuitDrawer, CircuitItem} from './drawer';\r\nimport MainEngine from '../../cengines/main';\r\nimport {tuple} from '../../libs/util';\r\nimport {len} from '../../libs/polyfill';\r\nimport {\r\n  CNOT, H, Measure, X\r\n} from '../../ops';\r\n\r\ndescribe('drawer test', () => {\r\n  it('should test_drawer_getlatex', () => {\r\n    const old_latex = ToLatex.toLatex\r\n    ToLatex.toLatex = x => x\r\n\r\n    const drawer = new CircuitDrawer()\r\n    drawer.setQubitLocations({0: 1, 1: 0})\r\n\r\n    const drawer2 = new CircuitDrawer()\r\n\r\n    const eng = new MainEngine(drawer, [drawer2])\r\n    const qureg = eng.allocateQureg(2)\r\n    H.or(qureg[1])\r\n    H.or(qureg[0])\r\n    X.or(qureg[0])\r\n    CNOT.or(tuple(qureg[0], qureg[1]))\r\n\r\n    let lines = drawer2.getLatex()\r\n    expect(len(lines)).to.equal(2)\r\n    expect(len(lines[0])).to.equal(4)\r\n    expect(len(lines[1])).to.equal(3)\r\n\r\n    // check if it was sent on correctly:\r\n    lines = drawer.getLatex()\r\n    expect(len(lines)).to.equal(2)\r\n    expect(len(lines[0])).to.equal(3)\r\n    expect(len(lines[1])).to.equal(4)\r\n\r\n    ToLatex.toLatex = old_latex\r\n  });\r\n\r\n  it('should test_drawer_measurement', () => {\r\n    let drawer = new CircuitDrawer(false, 0)\r\n    let eng = new MainEngine(drawer, [])\r\n    let qubit = eng.allocateQubit()\r\n    Measure.or(qubit)\r\n    expect(qubit.toNumber()).to.equal(0)\r\n\r\n    drawer = new CircuitDrawer(false, 1)\r\n    eng = new MainEngine(drawer, [])\r\n    qubit = eng.allocateQubit()\r\n    Measure.or(qubit)\r\n    expect(qubit.toNumber()).to.equal(1)\r\n  });\r\n\r\n  it('should test_drawer_qubitmapping', () => {\r\n    let drawer = new CircuitDrawer()\r\n    // mapping should still work (no gate has been applied yet)\r\n    const valid_mappings = [{0: 1, 1: 0}, {2: 1, 1: 2}]\r\n    valid_mappings.forEach((valid_mapping) => {\r\n      drawer.setQubitLocations(valid_mapping)\r\n      drawer = new CircuitDrawer()\r\n    })\r\n\r\n    // invalid mapping should raise an error:\r\n    const invalid_mappings = [{3: 1, 0: 2}, {0: 1, 2: 1}]\r\n    invalid_mappings.forEach((invalid_mapping) => {\r\n      drawer = new CircuitDrawer()\r\n      expect(() => drawer.setQubitLocations(invalid_mapping)).to.throw()\r\n    })\r\n\r\n    const eng = new MainEngine(drawer, [])\r\n    const qubit = eng.allocateQubit()\r\n    // mapping has begun --> can't assign it anymore\r\n\r\n    expect(() => drawer.setQubitLocations({0: 1, 1: 0})).to.throw()\r\n  });\r\n  class MockEngine {\r\n    isAvailable(cmd) {\r\n      this.cmd = cmd\r\n      this.called = true\r\n      return false\r\n    }\r\n  }\r\n\r\n  it('should test_drawer_isavailable', () => {\r\n    const drawer = new CircuitDrawer()\r\n    drawer.isLastEngine = true\r\n\r\n    expect(drawer.isAvailable()).to.equal(true)\r\n    expect(drawer.isAvailable('Everything')).to.equal(true)\r\n\r\n    const mock_engine = new MockEngine()\r\n    mock_engine.called = false\r\n    drawer.isLastEngine = false\r\n    drawer.next = mock_engine\r\n\r\n    expect(!drawer.isAvailable()).to.equal(true)\r\n    expect(mock_engine.called).to.equal(true)\r\n    expect(typeof mock_engine.cmd === 'undefined').to.equal(true)\r\n  });\r\n\r\n  it('should test_drawer_circuititem', () => {\r\n    const circuit_item = new CircuitItem(1, 2, 3)\r\n    expect(circuit_item.gate).to.equal(1)\r\n    expect(circuit_item.lines).to.equal(2)\r\n    expect(circuit_item.ctrl_lines).to.equal(3)\r\n    expect(circuit_item.id).to.equal(-1)\r\n\r\n    const circuit_item2 = new CircuitItem(1, 2, 2)\r\n    expect(circuit_item2.equal(circuit_item)).to.equal(false)\r\n\r\n    circuit_item2.ctrl_lines = 3\r\n    expect(circuit_item2.equal(circuit_item)).to.equal(true)\r\n\r\n    circuit_item2.gate = 2\r\n    expect(circuit_item2.equal(circuit_item)).to.equal(false)\r\n\r\n    circuit_item2.gate = 1\r\n    expect(circuit_item2.equal(circuit_item)).to.equal(true)\r\n\r\n    circuit_item2.lines = 1\r\n    expect(circuit_item2.equal(circuit_item)).to.equal(false)\r\n\r\n    circuit_item2.lines = 2\r\n    expect(circuit_item2.equal(circuit_item)).to.equal(true)\r\n  });\r\n})\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/backends/circuits/drawer.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 71,
    "kind": "file",
    "name": "src/backends/circuits/tolatex.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport assert from 'assert'\r\nimport fs from 'fs'\r\nimport {Decimal} from 'decimal.js'\r\nimport {len, narray} from '../../libs/polyfill'\r\nimport {\r\n  DaggeredGate, X, Measure, Allocate, Deallocate, Z, Swap, SqrtSwap\r\n} from '../../ops'\r\nimport { getInverse } from '../../ops/_cycle'\r\n\r\n// decimalToString\r\nfunction dts(number) {\r\n  return new Decimal(number).toString()\r\n}\r\n\r\nfunction minmax(array) {\r\n  const min = Math.min(...array)\r\n  const max = Math.max(...array)\r\n  return [min, max]\r\n}\r\n\r\nfunction maxOfDecimals(decimals = []) {\r\n  let max = new Decimal(0)\r\n  decimals.forEach((d) => {\r\n    if (d.greaterThan(max)) {\r\n      max = d\r\n    }\r\n  })\r\n  return max\r\n}\r\n\r\nexport const _exports = {\r\n  /**\r\nWrite all settings to a json-file.\r\n\r\n    @param {Object} settings: Settings dict to write.\r\n */\r\n  write_settings(settings) {\r\n    fs.writeFileSync('settings.json', JSON.stringify(settings))\r\n    return settings\r\n  },\r\n  /**\r\nReturn the default settings for the circuit drawing function to_latex().\r\n\r\n@return {Object} settings: Default circuit settings\r\n */\r\n  get_default_settings() {\r\n    const settings = {}\r\n    settings.gate_shadow = true\r\n    settings.lines = ({\r\n      'style': 'very thin',\r\n      'double_classical': true,\r\n      'init_quantum': true,\r\n      'double_lines_sep': 0.04\r\n    })\r\n    settings.gates = ({\r\n      'HGate': {\r\n        'width': 0.5,\r\n        'offset': 0.3,\r\n        'pre_offset': 0.1\r\n      },\r\n      'XGate': {\r\n        'width': 0.35,\r\n        'height': 0.35,\r\n        'offset': 0.1\r\n      },\r\n      'SqrtXGate': {\r\n        'width': 0.7,\r\n        'offset': 0.3,\r\n        'pre_offset': 0.1\r\n      },\r\n      'SwapGate': {\r\n        'width': 0.35,\r\n        'height': 0.35,\r\n        'offset': 0.1\r\n      },\r\n      'SqrtSwapGate': {\r\n        'width': 0.35,\r\n        'height': 0.35,\r\n        'offset': 0.1\r\n      },\r\n      'Rx': {\r\n        'width': 1.0,\r\n        'height': 0.8,\r\n        'pre_offset': 0.2,\r\n        'offset': 0.3\r\n      },\r\n      'Ry': {\r\n        'width': 1.0,\r\n        'height': 0.8,\r\n        'pre_offset': 0.2,\r\n        'offset': 0.3\r\n      },\r\n      'Rz': {\r\n        'width': 1.0,\r\n        'height': 0.8,\r\n        'pre_offset': 0.2,\r\n        'offset': 0.3\r\n      },\r\n      'Ph': {\r\n        'width': 1.0,\r\n        'height': 0.8,\r\n        'pre_offset': 0.2,\r\n        'offset': 0.3\r\n      },\r\n      'EntangleGate': {\r\n        'width': 1.8,\r\n        'offset': 0.2,\r\n        'pre_offset': 0.2\r\n      },\r\n      'DeallocateQubitGate': {\r\n        'height': 0.15,\r\n        'offset': 0.2,\r\n        'width': 0.2,\r\n        'pre_offset': 0.1\r\n      },\r\n      'AllocateQubitGate': {\r\n        'height': 0.15,\r\n        'width': 0.2,\r\n        'offset': 0.1,\r\n        'pre_offset': 0.1,\r\n        'draw_id': false,\r\n        'allocate_at_zero': false\r\n      },\r\n      'MeasureGate': {\r\n        'width': 0.75,\r\n        'offset': 0.2,\r\n        'height': 0.5,\r\n        'pre_offset': 0.2\r\n      }\r\n    })\r\n    settings.control = {'size': 0.1, 'shadow': false}\r\n    return settings\r\n  },\r\n  /**\r\nWrites the Latex header using the settings file.\r\n\r\n    The header includes all packages and defines all tikz styles.\r\n\r\n    @return {string} Header of the Latex document.\r\n */\r\n  _header(settings) {\r\n    const packages = ('\\\\documentclass{standalone}\\n\\\\usepackage[margin=1in]'\r\n      + '{geometry}\\n\\\\usepackage[hang,small,bf]{caption}\\n'\r\n      + '\\\\usepackage{tikz}\\n'\r\n      + '\\\\usepackage{braket}\\n\\\\usetikzlibrary{backgrounds,shadows.'\r\n      + 'blur,fit,decorations.pathreplacing,shapes}\\n\\n')\r\n\r\n\r\n    const init = ('\\\\begin{document}\\n'\r\n      + '\\\\begin{tikzpicture}[scale=0.8, transform shape]\\n\\n')\r\n\r\n    let gate_style = ('\\\\tikzstyle{basicshadow}=[blur shadow={shadow blur steps=8,'\r\n      + ' shadow xshift=0.7pt, shadow yshift=-0.7pt, shadow scale='\r\n      + '1.02}]')\r\n\r\n    if (!(settings.gate_shadow || settings.control.shadow)) {\r\n      gate_style = ''\r\n    }\r\n    gate_style += '\\\\tikzstyle{basic}=[draw,fill=white,'\r\n    if (settings.gate_shadow) {\r\n      gate_style += 'basicshadow'\r\n    }\r\n    gate_style += ']\\n'\r\n\r\n    gate_style += (`\\\\tikzstyle{operator}=[basic,minimum size=1.5em]\\n\\\\tikzstyle{phase}=[fill=black,shape=circle,minimum size=${settings.control.size}cm,inner sep=0pt,outer sep=0pt,draw=black`\r\n    )\r\n    if (settings.control.shadow) {\r\n      gate_style += ',basicshadow'\r\n    }\r\n    gate_style += (`]\\n\\\\tikzstyle{none}=[inner sep=0pt,outer sep=-.5pt,minimum height=0.5cm+1pt]\r\n\\\\tikzstyle{measure}=[operator,inner sep=0pt,minimum height=${settings.gates.MeasureGate.height}cm, minimum width=${settings.gates.MeasureGate.width}cm]\r\n\\\\tikzstyle{xstyle}=[circle,basic,minimum height=`)\r\n    const x_gate_radius = Math.min(settings.gates.XGate.height, settings.gates.XGate.width)\r\n    gate_style += (`${x_gate_radius}cm,minimum width=${x_gate_radius}cm,inner sep=-1pt,${settings.lines.style}]\\n`)\r\n    if (settings.gate_shadow) {\r\n      gate_style += ('\\\\tikzset{\\nshadowed/.style={preaction={transform '\r\n        + 'canvas={shift={(0.5pt,-0.5pt)}}, draw=gray, opacity='\r\n        + '0.4}},\\n}\\n')\r\n    }\r\n    gate_style += '\\\\tikzstyle{swapstyle}=['\r\n    gate_style += 'inner sep=-1pt, outer sep=-1pt, minimum width=0pt]\\n'\r\n    const edge_style = (`\\\\tikzstyle{edgestyle}=[${settings.lines.style\r\n    }]\\n`)\r\n\r\n    return packages + init + gate_style + edge_style\r\n  },\r\n  /**\r\nReturn the body of the Latex document, including the entire circuit in\r\nTikZ format.\r\n\r\n    @param {Array.<CircuitItem[]>} circuit Circuit to draw.\r\n    @param {Object} settings\r\n    @return {string} Latex string to draw the entire circuit.\r\n */\r\n  _body(circuit, settings) {\r\n    const code = []\r\n\r\n    const conv = new _Circ2Tikz(settings, len(circuit))\r\n    Object.keys(circuit).forEach((_, line) => code.push(conv.to_tikz(line, circuit)))\r\n\r\n    return code.join('')\r\n  },\r\n\r\n  /**\r\n  Return the footer of the Latex document.\r\n\r\n      @return {string} Latex document footer.\r\n   */\r\n  _footer() {\r\n    return '\\n\\n\\\\end{tikzpicture}\\n\\\\end{document}'\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\nTranslates a given circuit to a TikZ picture in a Latex document.\r\n\r\n    It uses a json-configuration file which (if it does not exist) is created\r\nautomatically upon running this function for the first time. The config\r\nfile can be used to determine custom gate sizes, offsets, etc.\r\n\r\n    New gate options can be added under settings['gates'], using the gate\r\nclass name string as a key. Every gate can have its own width, height, pre\r\noffset and offset.\r\n\r\n    @example\r\n settings['gates']['HGate'] = {'width': .5, 'offset': .15}\r\n\r\nThe default settings can be acquired using the get_default_settings()\r\nfunction, and written using write_settings().\r\n\r\n    @param {Array.<CircuitItem[]>} circuit Each qubit line is a list of\r\nCircuitItem objects, i.e., in circuit[line].\r\n\r\n    @return {string} Latex document string which can be compiled using, e.g., pdflatex.\r\n */\r\nfunction toLatex(circuit) {\r\n  let content\r\n  let settings\r\n  let text\r\n  if (fs.existsSync('settings.json')) {\r\n    content = fs.readFileSync('settings.json')\r\n    try {\r\n      settings = JSON.parse(content)\r\n    } catch (e) {\r\n      settings = _exports.get_default_settings()\r\n      _exports.write_settings(settings)\r\n    }\r\n  } else {\r\n    settings = _exports.get_default_settings()\r\n    _exports.write_settings(settings)\r\n  }\r\n\r\n  text = _exports._header(settings)\r\n  text += _exports._body(circuit, settings)\r\n  text += _exports._footer(settings)\r\n\r\n  return text\r\n}\r\n\r\n_exports.toLatex = toLatex\r\n\r\n/**\r\n * @class _Circ2Tikz\r\n * @desc\r\nThe Circ2Tikz class takes a circuit (list of lists of CircuitItem objects)\r\nand turns them into Latex/TikZ code.\r\n\r\n    It uses the settings dictionary for gate offsets, sizes, spacing, ...\r\n */\r\nexport class _Circ2Tikz {\r\n  /**\r\n   * @constructor\r\n  Initialize a circuit to latex converter object.\r\n\r\n    @param {Object} settings Dictionary of settings to use for the TikZ image.\r\n    @param {number} num_lines Number of qubit lines to use for the entire\r\ncircuit.\r\n   */\r\n  constructor(settings, num_lines) {\r\n    this.settings = settings\r\n    this.pos = narray(() => new Decimal(0.0), num_lines)\r\n    this.op_count = narray(0, num_lines)\r\n    this.is_quantum = narray(settings.lines.init_quantum, num_lines)\r\n  }\r\n\r\n  /**\r\n  Generate the TikZ code for one line of the circuit up to a certain\r\n  gate.\r\n\r\n  It modifies the circuit to include only the gates which have not been\r\n  drawn. It automatically switches to other lines if the gates on those\r\n  lines have to be drawn earlier.\r\n\r\n   @param {number} line Line to generate the TikZ code for.\r\n   @param {Array.<CircuitItem[]>} circuit The circuit to draw.\r\n   @param {number} end Gate index to stop at (for recursion).\r\n\r\n  @return {string} TikZ code representing the current qubit line\r\n  and, if it was necessary to draw other lines, those lines as\r\n  well.\r\n   */\r\n  to_tikz(line, circuit, end) {\r\n    if (typeof end === 'undefined') {\r\n      end = len(circuit[line])\r\n    }\r\n    const tikz_code = []\r\n\r\n    const cmds = circuit[line]\r\n    for (let i = 0; i < end; ++i) {\r\n      const {gate, lines, ctrl_lines} = cmds[i]\r\n      let all_lines = lines.concat(ctrl_lines)\r\n      const idx = all_lines.indexOf(line)\r\n      all_lines.splice(idx, 1) // remove current line\r\n      all_lines.forEach((l) => {\r\n        let gate_idx = 0\r\n        while (!circuit[l][gate_idx].equal(cmds[i])) {\r\n          gate_idx += 1\r\n        }\r\n\r\n        tikz_code.push(this.to_tikz(l, circuit, gate_idx))\r\n        // we are taking care of gate 0 (the current one)\r\n        circuit[l] = circuit[l].slice(1)\r\n      })\r\n\r\n      all_lines = lines.concat(ctrl_lines)\r\n      const tmp = []\r\n      const [min, max] = minmax(all_lines)\r\n      for (let l = min; l < max + 1; ++l) {\r\n        tmp.push(this.pos[l])\r\n      }\r\n      const pos = maxOfDecimals(tmp)\r\n      for (let l = min; l < max + 1; ++l) {\r\n        this.pos[l] = pos.add(this._gate_offset(gate))\r\n      }\r\n\r\n      let connections = ''\r\n      all_lines.forEach((l) => {\r\n        connections += this._line(this.op_count[l] - 1, this.op_count[l], l)\r\n      })\r\n\r\n      let add_str = ''\r\n      if (gate.equal(X)) {\r\n        // draw NOT-gate with controls\r\n        add_str = this._x_gate(lines, ctrl_lines)\r\n        // and make the target qubit quantum if one of the controls is\r\n        if (!this.is_quantum[lines[0]]) {\r\n          let sum = 0\r\n          ctrl_lines.forEach(iL => sum += this.is_quantum[iL])\r\n          if (sum > 0) {\r\n            this.is_quantum[lines[0]] = true\r\n          }\r\n        }\r\n      } else if (gate.equal(Z) && len(ctrl_lines) > 0) {\r\n        add_str = this._cz_gate(lines.concat(ctrl_lines))\r\n      } else if (gate.equal(Swap)) {\r\n        add_str = this._swap_gate(lines, ctrl_lines)\r\n      } else if (gate.equal(SqrtSwap)) {\r\n        add_str = this._sqrtswap_gate(lines, ctrl_lines, false)\r\n      } else if (gate.equal(getInverse(SqrtSwap))) {\r\n        add_str = this._sqrtswap_gate(lines, ctrl_lines, true)\r\n      } else if (gate.equal(Measure)) {\r\n        // draw measurement gate\r\n        lines.forEach((l) => {\r\n          const op = this._op(l)\r\n          const width = this._gate_width(Measure)\r\n          const height = this._gate_height(Measure)\r\n          const shift0 = new Decimal(height).mul(0.07)\r\n          const shift1 = new Decimal(height).mul(0.36)\r\n          const shift2 = new Decimal(width).mul(0.1)\r\n\r\n          add_str += `\\n\\\\node[measure,edgestyle] (${op}) at (${dts(this.pos[l])},-${l}) {};`\r\n          add_str += `\\n\\\\draw[edgestyle] ([yshift=-${shift1}cm,xshift=${shift2}cm]${op}.west) to [out=60,in=180] ([yshift=${shift0}cm]${op}.center) to [out=0, in=120] ([yshift=-${shift1}cm,xshift=-${shift2}cm]${op}.east);`\r\n          add_str += `\\n\\\\draw[edgestyle] ([yshift=-${shift1}cm]${op}.center) to ([yshift=-${shift2}cm,xshift=-${shift1}cm]${op}.north east);`\r\n\r\n          this.op_count[l] += 1\r\n          this.pos[l] = this.pos[l].add(this._gate_width(gate)).add(this._gate_offset(gate))\r\n          this.is_quantum[l] = false\r\n        })\r\n      } else if (gate.equal(Allocate)) {\r\n        // draw 'begin line'\r\n        let id_str = ''\r\n        if (this.settings.gates.AllocateQubitGate.draw_id) {\r\n          id_str = `^{\\\\textcolor{red}{${cmds[i].id}}}`\r\n        }\r\n        let xpos = this.pos[line]\r\n\r\n        if (this.settings.gates.AllocateQubitGate.allocate_at_zero) {\r\n          this.pos[line] = xpos.sub(this._gate_pre_offset(gate))\r\n          xpos = new Decimal(this._gate_pre_offset(gate))\r\n        }\r\n        this.pos[line] = maxOfDecimals([xpos.add(this._gate_offset(gate)).add(this._gate_width(gate)), this.pos[line]])\r\n        add_str = `\\n\\\\node[none] (${this._op(line)}) at (${dts(xpos)},-${line}) {$\\\\Ket{0}${id_str}$};`\r\n        this.op_count[line] += 1\r\n        this.is_quantum[line] = this.settings.lines.init_quantum\r\n      } else if (gate.equal(Deallocate)) {\r\n        // draw 'end of line'\r\n        const op = this._op(line)\r\n        add_str = `\\n\\\\node[none] (${op}) at (${dts(this.pos[line])},-${line}) {};`\r\n        const yshift = `${this._gate_height(gate)}cm]`\r\n        add_str += `\\n\\\\draw ([yshift=${yshift}${op}.center) edge [edgestyle] ([yshift=-${yshift}${op}.center);`\r\n\r\n        this.op_count[line] += 1\r\n        this.pos[line] = this.pos[line].add(this._gate_width(gate)).add(this._gate_offset(gate))\r\n      } else {\r\n        // regular gate must draw the lines it does not act upon\r\n        // if it spans multiple qubits\r\n        add_str = this._regular_gate(gate, lines, ctrl_lines)\r\n        lines.forEach(l => this.is_quantum[l] = true)\r\n      }\r\n      tikz_code.push(add_str)\r\n      if (!gate.equal(Allocate)) {\r\n        tikz_code.push(connections)\r\n      }\r\n    }\r\n\r\n    circuit[line] = circuit[line].slice(end)\r\n    return tikz_code.join('')\r\n  }\r\n\r\n  /**\r\n    Return the string representation of the gate.\r\n    Tries to use gate.tex_str and, if that is not available, uses str(gate) instead.\r\n\r\n    @param {BasicGate} gate Gate object of which to get the name / latex representation.\r\n    @return {string} Latex gate name.\r\n  */\r\n  _gate_name(gate) {\r\n    let name\r\n    if (gate.texString) {\r\n      name = gate.texString()\r\n    }\r\n    name = gate.toString()\r\n    return name\r\n  }\r\n\r\n  /**\r\n  Return the TikZ code for a Square-root Swap-gate.\r\n\r\n    @param {number[]} lines List of length 2 denoting the target qubit of the Swap gate.\r\n    @param {number[]} ctrl_lines List of qubit lines which act as controls.\r\n    @param {boolean} daggered Show the daggered one if true.\r\n   */\r\n  _sqrtswap_gate(lines, ctrl_lines, daggered) {\r\n    assert(len(lines) === 2) // sqrt swap gate acts on 2 qubits\r\n    const delta_pos = this._gate_offset(SqrtSwap)\r\n    const gate_width = this._gate_width(SqrtSwap)\r\n    lines.sort()\r\n\r\n    let gate_str = ''\r\n    lines.forEach((line) => {\r\n      const op = this._op(line)\r\n      const w = `${new Decimal(gate_width).mul(0.5).toString()}cm`\r\n      const s1 = `[xshift=-${w},yshift=-${w}]${op}.center`\r\n      const s2 = `[xshift=${w},yshift=${w}]${op}.center`\r\n      const s3 = `[xshift=-${w},yshift=${w}]${op}.center`\r\n      const s4 = `[xshift=${w},yshift=-${w}]${op}.center`\r\n      let swap_style = 'swapstyle,edgestyle'\r\n      if (this.settings.gate_shadow) {\r\n        swap_style += ',shadowed'\r\n      }\r\n      gate_str += `\\n\\\\node[swapstyle] (${op}) at (${dts(this.pos[line])},-${line}) {};`\r\n      gate_str += `\\n\\\\draw[${swap_style}] (${s1})--(${s2});`\r\n      gate_str += `\\n\\\\draw[${swap_style}] (${s3})--(${s4});`\r\n    })\r\n\r\n    // add a circled 1/2\r\n    const midpoint = (lines[0] + lines[1]) / 2.0\r\n    const pos = this.pos[lines[0]]\r\n    const op_mid = `line${lines[0]}-${lines[1]}_gate${this.op_count[lines[0]]}`\r\n    gate_str += `\\n\\\\node[xstyle] (${op_mid}) at (${dts(pos)},-${midpoint})\\\r\n                {\\\\scriptsize $\\\\frac{1}{2}${daggered ? '^{{\\\\dagger}}' : ''}$};`\r\n\r\n    // add two vertical lines to connect circled 1/2\r\n    gate_str += `\\n\\\\draw (${this._op(lines[0])}) edge[edgestyle] (${op_mid});`\r\n    gate_str += `\\n\\\\draw (${op_mid}) edge[edgestyle] (${this._op(lines[1])});`\r\n\r\n\r\n    ctrl_lines.forEach((ctrl) => {\r\n      gate_str += this._phase(ctrl, this.pos[lines[0]])\r\n      if (ctrl > lines[1] || ctrl < lines[0]) {\r\n        let closer_line = lines[0]\r\n        if (ctrl > lines[1]) {\r\n          closer_line = lines[1]\r\n        }\r\n        gate_str += this._line(ctrl, closer_line)\r\n      }\r\n    })\r\n\r\n    const all_lines = ctrl_lines.concat(lines)\r\n    const new_pos = this.pos[lines[0]].add(delta_pos).add(gate_width)\r\n    all_lines.forEach(i => this.op_count[i] += 1)\r\n    const [min, max] = minmax(all_lines)\r\n    for (let i = min; i < max + 1; ++i) {\r\n      this.pos[i] = new_pos\r\n    }\r\n    return gate_str\r\n  }\r\n\r\n  /**\r\n  Return the TikZ code for a Swap-gate.\r\n\r\n    @param {number[]} lines List of length 2 denoting the target qubit of the Swap gate.\r\n    @param {number[]} ctrl_lines List of qubit lines which act as controls.\r\n  */\r\n  _swap_gate(lines, ctrl_lines) {\r\n    assert(len(lines) === 2) // swap gate acts on 2 qubits\r\n    const delta_pos = this._gate_offset(Swap)\r\n    const gate_width = this._gate_width(Swap)\r\n    lines.sort()\r\n\r\n    let gate_str = ''\r\n    lines.forEach((line) => {\r\n      const op = this._op(line)\r\n      const w = `${new Decimal(gate_width).mul(0.5)}cm`\r\n      const s1 = `[xshift=-${w},yshift=-${w}]${op}.center`\r\n      const s2 = `[xshift=${w},yshift=${w}]${op}.center`\r\n      const s3 = `[xshift=-${w},yshift=${w}]${op}.center`\r\n      const s4 = `[xshift=${w},yshift=-${w}]${op}.center`\r\n      let swap_style = 'swapstyle,edgestyle'\r\n      if (this.settings.gate_shadow) {\r\n        swap_style += ',shadowed'\r\n      }\r\n      gate_str += `\\n\\\\node[swapstyle] (${op}) at (${dts(this.pos[line])},-${line}) {};`\r\n      gate_str += `\\n\\\\draw[${swap_style}] (${s1})--(${s2});`\r\n      gate_str += `\\n\\\\draw[${swap_style}] (${s3})--(${s4});`\r\n    })\r\n\r\n    gate_str += this._line(lines[0], lines[1])\r\n\r\n    ctrl_lines.forEach((ctrl) => {\r\n      gate_str += this._phase(ctrl, this.pos[lines[0]])\r\n      if (ctrl > lines[1] || ctrl < lines[0]) {\r\n        let closer_line = lines[0]\r\n        if (ctrl > lines[1]) {\r\n          closer_line = lines[1]\r\n        }\r\n        gate_str += this._line(ctrl, closer_line)\r\n      }\r\n    })\r\n\r\n    const all_lines = ctrl_lines.concat(lines)\r\n    const new_pos = this.pos[lines[0]].add(delta_pos).add(gate_width)\r\n    all_lines.forEach(i => this.op_count[i] += 1)\r\n    const [min, max] = minmax(all_lines)\r\n    for (let i = min; i < max + 1; ++i) {\r\n      this.pos[i] = new_pos\r\n    }\r\n    return gate_str\r\n  }\r\n\r\n  /**\r\n  Return the TikZ code for a NOT-gate.\r\n\r\n    @param {number[]} lines List of length 1 denoting the target qubit of the NOT / X gate.\r\n    @param {number[]} ctrl_lines List of qubit lines which act as controls.\r\n   */\r\n  _x_gate(lines, ctrl_lines = []) {\r\n    assert(len(lines) === 1) // NOT gate only acts on 1 qubit\r\n    const line = lines[0]\r\n    const delta_pos = this._gate_offset(X)\r\n    const gate_width = this._gate_width(X)\r\n    const op = this._op(line)\r\n    let gate_str = `\\n\\\\node[xstyle] (${op}) at (${dts(this.pos[line])},-${line}) {};`\r\n    gate_str += `\\n\\\\draw[edgestyle] (${op}.north)--(${op}.south);`\r\n    gate_str += `\\n\\\\draw[edgestyle] (${op}.west)--(${op}.east);`\r\n\r\n    ctrl_lines.forEach((ctrl) => {\r\n      gate_str += this._phase(ctrl, this.pos[line])\r\n      gate_str += this._line(ctrl, line)\r\n    })\r\n\r\n    ctrl_lines.push(line)\r\n    const all_lines = ctrl_lines\r\n    const new_pos = this.pos[line].add(delta_pos).add(gate_width)\r\n    all_lines.forEach(i => this.op_count[i] += 1)\r\n    const [min, max] = minmax(all_lines)\r\n    for (let i = min; i < max + 1; ++i) {\r\n      this.pos[i] = new_pos\r\n    }\r\n    return gate_str\r\n  }\r\n\r\n  /**\r\n  Return the TikZ code for an n-controlled Z-gate.\r\n\r\n    @param {number[]} lines List of all qubits involved.\r\n   */\r\n  _cz_gate(lines) {\r\n    assert(len(lines) > 1)\r\n    const line = lines[0]\r\n    const delta_pos = this._gate_offset(Z)\r\n    const gate_width = this._gate_width(Z)\r\n    let gate_str = this._phase(line, this.pos[line])\r\n\r\n    lines.slice(1).forEach((ctrl) => {\r\n      gate_str += this._phase(ctrl, this.pos[line])\r\n      gate_str += this._line(ctrl, line)\r\n    })\r\n\r\n    const new_pos = this.pos[line].add(delta_pos).add(gate_width)\r\n    lines.forEach(i => this.op_count[i] += 1)\r\n    const [min, max] = minmax(lines)\r\n    for (let i = min; i < max + 1; ++i) {\r\n      this.pos[i] = new_pos\r\n    }\r\n    return gate_str\r\n  }\r\n\r\n  /**\r\n  Return the gate width, using the settings (if available).\r\n\r\n    @return {number} Width of the gate. (settings['gates'][gate_class_name]['width'])\r\n  */\r\n  _gate_width(gate) {\r\n    if (gate instanceof DaggeredGate) {\r\n      gate = gate.gate\r\n    }\r\n\r\n    const {gates} = this.settings\r\n    const config = gates[gate.constructor.name] || {}\r\n    return config.width || 0.5\r\n  }\r\n\r\n  /**\r\n  Return the offset to use before placing this gate.\r\n\r\n    @return {number} Offset to use before the gate. (settings['gates'][gate_class_name]['pre_offset'])\r\n   */\r\n  _gate_pre_offset(gate) {\r\n    if (gate instanceof DaggeredGate) {\r\n      gate = gate._gate\r\n    }\r\n\r\n    const {gates} = this.settings\r\n    return gates[gate.constructor.name].pre_offset || this._gate_offset(gate)\r\n  }\r\n\r\n  /**\r\n  Return the offset to use after placing this gate and, if no pre_offset\r\nis defined, the same offset is used in front of the gate.\r\n\r\n    @return {number} Offset. (settings['gates'][gate_class_name]['offset'])\r\n   */\r\n  _gate_offset(gate) {\r\n    if (gate instanceof DaggeredGate) {\r\n      gate = gate.gate\r\n    }\r\n    const {gates} = this.settings\r\n    const config = gates[gate.constructor.name] || {}\r\n    return config.offset || 0.2\r\n  }\r\n\r\n  /**\r\n  Return the height to use for this gate.\r\n\r\n    @return {number} Height of the gate. (settings['gates'][gate_class_name]['height'])\r\n   */\r\n  _gate_height(gate) {\r\n    if (gate instanceof DaggeredGate) {\r\n      gate = gate.gate\r\n    }\r\n    const config = this.settings.gates[gate.constructor.name] || {}\r\n    return config.height || 0.5\r\n  }\r\n\r\n  /**\r\n  Places a phase / control circle on a qubit line at a given position.\r\n\r\n    @param {number} line Qubit line at which to place the circle.\r\n    @param {number} pos Position at which to place the circle.\r\n    @return {string} Latex string representing a control circle at the given position.\r\n   */\r\n  _phase(line, pos) {\r\n    return `\\n\\\\node[phase] (${this._op(line)}) at (${dts(pos)},-${line}) {};`\r\n  }\r\n\r\n  /**\r\n  Returns the gate name for placing a gate on a line.\r\n\r\n    @param {number} line Line number.\r\n    @param {?number} op Operation number or, by default, uses the current op count.\r\n    @param {number} offset\r\n    @return {string} Gate name.\r\n   */\r\n  _op(line, op = null, offset = 0) {\r\n    if (op === null) {\r\n      op = this.op_count[line] || 0\r\n    }\r\n    return `line${line}_gate${op + offset}`\r\n  }\r\n\r\n  /**\r\n  Connects p1 and p2, where p1 and p2 are either to qubit line indices,\r\nin which case the two most recent gates are connected, or two gate\r\nindices, in which case line denotes the line number and the two gates\r\nare connected on the given line.\r\n\r\n    @param {number} p1 Index of the first object to connect.\r\n    @param {number} p2 Index of the second object to connect.\r\n    @param {number} line (int or null) Line index - if provided, p1 and p2 are gate indices.\r\n\r\n    @return {string} Latex code to draw this / these line(s).\r\n   */\r\n  _line(p1, p2, line = null) {\r\n    const dbl_classical = this.settings.lines.double_classical\r\n\r\n    let quantum\r\n    let op1\r\n    let op2\r\n    let loc1\r\n    let loc2\r\n    let shift\r\n    if (line === null) {\r\n      quantum = !dbl_classical || this.is_quantum[p1]\r\n      op1 = this._op(p1)\r\n      op2 = this._op(p2)\r\n      loc1 = 'north'\r\n      loc2 = 'south'\r\n      shift = 'xshift='\r\n    } else {\r\n      quantum = !dbl_classical || this.is_quantum[line]\r\n      op1 = this._op(line, p1)\r\n      op2 = this._op(line, p2)\r\n      loc1 = 'west'\r\n      loc2 = 'east'\r\n      shift = 'yshift='\r\n    }\r\n    if (quantum) {\r\n      return `\\n\\\\draw (${op1}) edge[edgestyle] (${op2});`\r\n    } else {\r\n      if (p2 > p1) {\r\n        const tmp = loc1\r\n        loc1 = loc2\r\n        loc2 = tmp\r\n      }\r\n      const line_sep = this.settings.lines.double_lines_sep\r\n      const shift1 = `${shift}${line_sep / 2.0}cm`\r\n      const shift2 = `${shift}${-line_sep / 2.0}cm`\r\n      let edges_str = `\\n\\\\draw ([${shift1}]${op1}.${loc1}) edge[edgestyle] ([${shift2}]${op2}.${loc2});`\r\n      edges_str += `\\n\\\\draw ([${shift2}]${op1}.${loc1}) edge[edgestyle] ([${shift2}]${op2}.${loc2});`\r\n      return edges_str\r\n    }\r\n  }\r\n\r\n  /**\r\n  Draw a regular gate.\r\n\r\n    @param {BasicGate} gate Gate to draw.\r\n    @param {number[]} lines Lines the gate acts on.\r\n   @param {number[]} ctrl_lines Control lines.\r\n\r\n    @return {string} Latex string drawing a regular gate at the given location\r\n   */\r\n  _regular_gate(gate, lines, ctrl_lines) {\r\n    const [imin, imax] = minmax(lines)\r\n\r\n    const gate_lines = lines.concat(ctrl_lines)\r\n\r\n    const delta_pos = this._gate_offset(gate)\r\n    const gate_width = this._gate_width(gate)\r\n    const gate_height = this._gate_height(gate)\r\n\r\n    const name = this._gate_name(gate)\r\n\r\n    lines = []\r\n    for (let i = imin; i < imax + 1; ++i) {\r\n      lines.push(i)\r\n    }\r\n\r\n    let tex_str = ''\r\n    const pos = this.pos[lines[0]]\r\n\r\n    lines.forEach((l) => {\r\n      const node1 = `\\n\\\\node[none] (${this._op(l)}) at (${dts(pos)},-${l}) {};`\r\n      const at = pos.add(new Decimal(gate_width).div(2.0)).toString()\r\n      const node2 = `\\n\\\\node[none,minimum height=${gate_height}cm,outer sep=0] (${this._op(l, null, 1)}) at (${at},-${l}) {};`\r\n      const node3 = `\\n\\\\node[none] (${this._op(l, null, 2)}) at (${dts(pos.add(gate_width))},-${l}) {};`\r\n      tex_str += node1 + node2 + node3\r\n      if (!gate_lines.includes(l)) {\r\n        tex_str += this._line(this.op_count[l] - 1, this.op_count[l], l)\r\n      }\r\n    })\r\n\r\n    const half_height = 0.5 * gate_height\r\n    const op1 = this._op(imin)\r\n    const op2 = this._op(imax, null, 2)\r\n    tex_str += `\\n\\\\draw[operator,edgestyle,outer sep=${gate_width}cm] ([yshift=${half_height}cm]${op1}) rectangle ([yshift=-${half_height}cm]${op2}) node[pos=.5] {${name}};`\r\n\r\n    lines.forEach((l) => {\r\n      this.pos[l] = new Decimal(pos).add(new Decimal(gate_width).div(2.0))\r\n      this.op_count[l] += 1\r\n    })\r\n\r\n    ctrl_lines.forEach((ctrl) => {\r\n      if (!lines.includes(ctrl)) {\r\n        tex_str += this._phase(ctrl, pos.add(new Decimal(gate_width).div(2.0)))\r\n        let connect_to = imax\r\n        if (Math.abs(connect_to - ctrl) > Math.abs(imin - ctrl)) {\r\n          connect_to = imin\r\n        }\r\n        tex_str += this._line(ctrl, connect_to)\r\n        this.pos[ctrl] = new Decimal(pos).add(delta_pos).add(gate_width)\r\n        this.op_count[ctrl] += 1\r\n      }\r\n    })\r\n\r\n    lines.forEach(l => this.op_count[l] += 2)\r\n\r\n    const all = ctrl_lines.concat(lines)\r\n    const [min, max] = minmax(all)\r\n    for (let l = min; l < max + 1; ++l) {\r\n      this.pos[l] = pos.add(delta_pos).add(gate_width)\r\n    }\r\n    return tex_str\r\n  }\r\n}\r\n\r\nexport default _exports\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/backends/circuits/tolatex.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 72,
    "kind": "function",
    "name": "dts",
    "memberof": "src/backends/circuits/tolatex.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/backends/circuits/tolatex.js~dts",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/backends/circuits/tolatex.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "params": [
      {
        "name": "number",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 73,
    "kind": "function",
    "name": "minmax",
    "memberof": "src/backends/circuits/tolatex.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/backends/circuits/tolatex.js~minmax",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/backends/circuits/tolatex.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "params": [
      {
        "name": "array",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "undefined[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 74,
    "kind": "function",
    "name": "maxOfDecimals",
    "memberof": "src/backends/circuits/tolatex.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/backends/circuits/tolatex.js~maxOfDecimals",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/backends/circuits/tolatex.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "params": [
      {
        "name": "decimals",
        "optional": true,
        "types": [
          "*[]"
        ],
        "defaultRaw": [],
        "defaultValue": "[]"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 75,
    "kind": "variable",
    "name": "_exports",
    "memberof": "src/backends/circuits/tolatex.js",
    "static": true,
    "longname": "src/backends/circuits/tolatex.js~_exports",
    "access": "private",
    "export": true,
    "importPath": "projectq/src/backends/circuits/tolatex.js",
    "importStyle": "{_exports}",
    "description": null,
    "lineNumber": 47,
    "undocument": true,
    "type": {
      "types": [
        "{\"write_settings\": function, \"get_default_settings\": function, \"_header\": function, \"_body\": function, \"_footer\": function}"
      ]
    }
  },
  {
    "__docId__": 76,
    "kind": "function",
    "name": "toLatex",
    "memberof": "src/backends/circuits/tolatex.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/backends/circuits/tolatex.js~toLatex",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/backends/circuits/tolatex.js",
    "importStyle": null,
    "description": "Translates a given circuit to a TikZ picture in a Latex document.\n\nIt uses a json-configuration file which (if it does not exist) is created\nautomatically upon running this function for the first time. The config\nfile can be used to determine custom gate sizes, offsets, etc.\n\nNew gate options can be added under settings['gates'], using the gate\nclass name string as a key. Every gate can have its own width, height, pre\noffset and offset.",
    "examples": [
      "settings['gates']['HGate'] = {'width': .5, 'offset': .15}\n\nThe default settings can be acquired using the get_default_settings()\nfunction, and written using write_settings()."
    ],
    "lineNumber": 254,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array.<CircuitItem[]>"
        ],
        "spread": false,
        "optional": false,
        "name": "circuit",
        "description": "Each qubit line is a list of\nCircuitItem objects, i.e., in circuit[line]."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "Latex document string which can be compiled using, e.g., pdflatex."
    },
    "ignore": true
  },
  {
    "__docId__": 77,
    "kind": "class",
    "name": "_Circ2Tikz",
    "memberof": "src/backends/circuits/tolatex.js",
    "static": true,
    "longname": "src/backends/circuits/tolatex.js~_Circ2Tikz",
    "access": "private",
    "export": true,
    "importPath": "projectq/src/backends/circuits/tolatex.js",
    "importStyle": "{_Circ2Tikz}",
    "description": "The Circ2Tikz class takes a circuit (list of lists of CircuitItem objects)\nand turns them into Latex/TikZ code.\n\nIt uses the settings dictionary for gate offsets, sizes, spacing, ...",
    "lineNumber": 288,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "_Circ2Tikz"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 78,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/backends/circuits/tolatex.js~_Circ2Tikz",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/circuits/tolatex.js~_Circ2Tikz#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 297,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": "Initialize a circuit to latex converter object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "settings",
        "description": "Dictionary of settings to use for the TikZ image."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "num_lines",
        "description": "Number of qubit lines to use for the entire\ncircuit."
      }
    ]
  },
  {
    "__docId__": 79,
    "kind": "member",
    "name": "settings",
    "memberof": "src/backends/circuits/tolatex.js~_Circ2Tikz",
    "static": false,
    "longname": "src/backends/circuits/tolatex.js~_Circ2Tikz#settings",
    "access": "public",
    "description": null,
    "lineNumber": 298,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 80,
    "kind": "member",
    "name": "pos",
    "memberof": "src/backends/circuits/tolatex.js~_Circ2Tikz",
    "static": false,
    "longname": "src/backends/circuits/tolatex.js~_Circ2Tikz#pos",
    "access": "public",
    "description": null,
    "lineNumber": 299,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 81,
    "kind": "member",
    "name": "op_count",
    "memberof": "src/backends/circuits/tolatex.js~_Circ2Tikz",
    "static": false,
    "longname": "src/backends/circuits/tolatex.js~_Circ2Tikz#op_count",
    "access": "public",
    "description": null,
    "lineNumber": 300,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 82,
    "kind": "member",
    "name": "is_quantum",
    "memberof": "src/backends/circuits/tolatex.js~_Circ2Tikz",
    "static": false,
    "longname": "src/backends/circuits/tolatex.js~_Circ2Tikz#is_quantum",
    "access": "public",
    "description": null,
    "lineNumber": 301,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 83,
    "kind": "method",
    "name": "to_tikz",
    "memberof": "src/backends/circuits/tolatex.js~_Circ2Tikz",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/circuits/tolatex.js~_Circ2Tikz#to_tikz",
    "access": "public",
    "description": "Generate the TikZ code for one line of the circuit up to a certain\ngate.\n\nIt modifies the circuit to include only the gates which have not been\ndrawn. It automatically switches to other lines if the gates on those\nlines have to be drawn earlier.",
    "lineNumber": 320,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "line",
        "description": "Line to generate the TikZ code for."
      },
      {
        "nullable": null,
        "types": [
          "Array.<CircuitItem[]>"
        ],
        "spread": false,
        "optional": false,
        "name": "circuit",
        "description": "The circuit to draw."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "end",
        "description": "Gate index to stop at (for recursion)."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "TikZ code representing the current qubit line\nand, if it was necessary to draw other lines, those lines as\nwell."
    }
  },
  {
    "__docId__": 84,
    "kind": "method",
    "name": "_gate_name",
    "memberof": "src/backends/circuits/tolatex.js~_Circ2Tikz",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/circuits/tolatex.js~_Circ2Tikz#_gate_name",
    "access": "private",
    "description": "Return the string representation of the gate.\nTries to use gate.tex_str and, if that is not available, uses str(gate) instead.",
    "lineNumber": 445,
    "params": [
      {
        "nullable": null,
        "types": [
          "BasicGate"
        ],
        "spread": false,
        "optional": false,
        "name": "gate",
        "description": "Gate object of which to get the name / latex representation."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "Latex gate name."
    }
  },
  {
    "__docId__": 85,
    "kind": "method",
    "name": "_sqrtswap_gate",
    "memberof": "src/backends/circuits/tolatex.js~_Circ2Tikz",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/circuits/tolatex.js~_Circ2Tikz#_sqrtswap_gate",
    "access": "private",
    "description": "Return the TikZ code for a Square-root Swap-gate.",
    "lineNumber": 461,
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "lines",
        "description": "List of length 2 denoting the target qubit of the Swap gate."
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "ctrl_lines",
        "description": "List of qubit lines which act as controls."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "daggered",
        "description": "Show the daggered one if true."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 86,
    "kind": "method",
    "name": "_swap_gate",
    "memberof": "src/backends/circuits/tolatex.js~_Circ2Tikz",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/circuits/tolatex.js~_Circ2Tikz#_swap_gate",
    "access": "private",
    "description": "Return the TikZ code for a Swap-gate.",
    "lineNumber": 523,
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "lines",
        "description": "List of length 2 denoting the target qubit of the Swap gate."
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "ctrl_lines",
        "description": "List of qubit lines which act as controls."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 87,
    "kind": "method",
    "name": "_x_gate",
    "memberof": "src/backends/circuits/tolatex.js~_Circ2Tikz",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/circuits/tolatex.js~_Circ2Tikz#_x_gate",
    "access": "private",
    "description": "Return the TikZ code for a NOT-gate.",
    "lineNumber": 575,
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "lines",
        "description": "List of length 1 denoting the target qubit of the NOT / X gate."
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "ctrl_lines",
        "description": "List of qubit lines which act as controls."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 88,
    "kind": "method",
    "name": "_cz_gate",
    "memberof": "src/backends/circuits/tolatex.js~_Circ2Tikz",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/circuits/tolatex.js~_Circ2Tikz#_cz_gate",
    "access": "private",
    "description": "Return the TikZ code for an n-controlled Z-gate.",
    "lineNumber": 606,
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "lines",
        "description": "List of all qubits involved."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 89,
    "kind": "method",
    "name": "_gate_width",
    "memberof": "src/backends/circuits/tolatex.js~_Circ2Tikz",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/circuits/tolatex.js~_Circ2Tikz#_gate_width",
    "access": "private",
    "description": "Return the gate width, using the settings (if available).",
    "lineNumber": 632,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Width of the gate. (settings['gates'][gate_class_name]['width'])"
    },
    "params": [
      {
        "name": "gate",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 90,
    "kind": "method",
    "name": "_gate_pre_offset",
    "memberof": "src/backends/circuits/tolatex.js~_Circ2Tikz",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/circuits/tolatex.js~_Circ2Tikz#_gate_pre_offset",
    "access": "private",
    "description": "Return the offset to use before placing this gate.",
    "lineNumber": 647,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Offset to use before the gate. (settings['gates'][gate_class_name]['pre_offset'])"
    },
    "params": [
      {
        "name": "gate",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 91,
    "kind": "method",
    "name": "_gate_offset",
    "memberof": "src/backends/circuits/tolatex.js~_Circ2Tikz",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/circuits/tolatex.js~_Circ2Tikz#_gate_offset",
    "access": "private",
    "description": "Return the offset to use after placing this gate and, if no pre_offset\nis defined, the same offset is used in front of the gate.",
    "lineNumber": 662,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Offset. (settings['gates'][gate_class_name]['offset'])"
    },
    "params": [
      {
        "name": "gate",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 92,
    "kind": "method",
    "name": "_gate_height",
    "memberof": "src/backends/circuits/tolatex.js~_Circ2Tikz",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/circuits/tolatex.js~_Circ2Tikz#_gate_height",
    "access": "private",
    "description": "Return the height to use for this gate.",
    "lineNumber": 676,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Height of the gate. (settings['gates'][gate_class_name]['height'])"
    },
    "params": [
      {
        "name": "gate",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 93,
    "kind": "method",
    "name": "_phase",
    "memberof": "src/backends/circuits/tolatex.js~_Circ2Tikz",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/circuits/tolatex.js~_Circ2Tikz#_phase",
    "access": "private",
    "description": "Places a phase / control circle on a qubit line at a given position.",
    "lineNumber": 691,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "line",
        "description": "Qubit line at which to place the circle."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "pos",
        "description": "Position at which to place the circle."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "Latex string representing a control circle at the given position."
    }
  },
  {
    "__docId__": 94,
    "kind": "method",
    "name": "_op",
    "memberof": "src/backends/circuits/tolatex.js~_Circ2Tikz",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/circuits/tolatex.js~_Circ2Tikz#_op",
    "access": "private",
    "description": "Returns the gate name for placing a gate on a line.",
    "lineNumber": 703,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "line",
        "description": "Line number."
      },
      {
        "nullable": true,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "op",
        "description": "Operation number or, by default, uses the current op count."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "offset",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "Gate name."
    }
  },
  {
    "__docId__": 95,
    "kind": "method",
    "name": "_line",
    "memberof": "src/backends/circuits/tolatex.js~_Circ2Tikz",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/circuits/tolatex.js~_Circ2Tikz#_line",
    "access": "private",
    "description": "Connects p1 and p2, where p1 and p2 are either to qubit line indices,\nin which case the two most recent gates are connected, or two gate\nindices, in which case line denotes the line number and the two gates\nare connected on the given line.",
    "lineNumber": 722,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "p1",
        "description": "Index of the first object to connect."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "p2",
        "description": "Index of the second object to connect."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "line",
        "description": "(int or null) Line index - if provided, p1 and p2 are gate indices."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "Latex code to draw this / these line(s)."
    }
  },
  {
    "__docId__": 96,
    "kind": "method",
    "name": "_regular_gate",
    "memberof": "src/backends/circuits/tolatex.js~_Circ2Tikz",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/circuits/tolatex.js~_Circ2Tikz#_regular_gate",
    "access": "private",
    "description": "Draw a regular gate.",
    "lineNumber": 772,
    "params": [
      {
        "nullable": null,
        "types": [
          "BasicGate"
        ],
        "spread": false,
        "optional": false,
        "name": "gate",
        "description": "Gate to draw."
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "lines",
        "description": "Lines the gate acts on."
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "ctrl_lines",
        "description": "Control lines."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "Latex string drawing a regular gate at the given location"
    }
  },
  {
    "__docId__": 97,
    "kind": "file",
    "name": "src/backends/circuits/tolatex.spec.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nimport {expect} from 'chai'\r\nimport ToLatex from './tolatex'\r\nimport { CircuitDrawer } from './drawer'\r\nimport { tuple } from '../../libs/util'\r\nimport {\r\n  BasicGate, C, CNOT, H, Measure, SqrtSwap, SqrtX, Swap, X, Z\r\n} from '../../ops'\r\nimport MainEngine from '../../cengines/main'\r\nimport '../../libs/polyfill'\r\nimport {getInverse} from '../../ops/_cycle';\r\nimport {Control} from '../../meta';\r\n\r\ndescribe('tolatex test', () => {\r\n  it('should test_tolatex', () => {\r\n    const oldHeader = ToLatex._header\r\n    const oldBody = ToLatex._body\r\n    const oldFooter = ToLatex._footer\r\n\r\n    ToLatex._header = () => 'H'\r\n    ToLatex._body = (x, y) => x\r\n    ToLatex._footer = () => 'F'\r\n    const result = ToLatex.toLatex('B')\r\n\r\n    expect(result).to.equal('HBF')\r\n\r\n    ToLatex._header = oldHeader\r\n    ToLatex._body = oldBody\r\n    ToLatex._footer = oldFooter\r\n  });\r\n\r\n  it('should test_default_settings', () => {\r\n    const settings = ToLatex.get_default_settings()\r\n    expect(settings instanceof Object).to.equal(true)\r\n    expect('gate_shadow' in settings).to.equal(true)\r\n    expect('lines' in settings).to.equal(true)\r\n    expect('gates' in settings).to.equal(true)\r\n    expect('control' in settings).to.equal(true)\r\n  });\r\n\r\n  it('should test_header', () => {\r\n    const settings = {\r\n      'gate_shadow': false,\r\n      'control': {'shadow': false, 'size': 0},\r\n      'gates': {\r\n        'MeasureGate': {'height': 0, 'width': 0},\r\n        'XGate': {'height': 1, 'width': 0.5}\r\n      },\r\n      'lines': {'style': 'my_style'}\r\n    }\r\n    let header = ToLatex._header(settings)\r\n\r\n    expect(header.indexOf('minimum') !== -1).to.equal(true)\r\n    expect(header.indexOf('basicshadow') === -1).to.equal(true)\r\n    expect(header.indexOf('minimum height=0.5') !== -1).to.equal(true)\r\n    expect(header.indexOf('minimum height=1cm') === -1).to.equal(true)\r\n    expect(header.indexOf('minimum height=0cm') !== -1).to.equal(true)\r\n\r\n    settings.control.shadow = true\r\n    settings.gates.XGate.width = 1\r\n    header = ToLatex._header(settings)\r\n\r\n    expect(header.indexOf('minimum') !== -1).to.equal(true)\r\n    expect(header.indexOf('basicshadow') !== -1).to.equal(true)\r\n    expect(header.indexOf('minimum height=1cm') !== -1).to.equal(true)\r\n    expect(header.indexOf('minimum height=0cm') !== -1).to.equal(true)\r\n\r\n    settings.control.shadow = true\r\n    settings.gate_shadow = true\r\n    header = ToLatex._header(settings)\r\n\r\n    expect(header.indexOf('minimum') !== -1).to.equal(true)\r\n    expect(header.indexOf('white,basicshadow') !== -1).to.equal(true)\r\n    expect(header.indexOf('minimum height=1cm') !== -1).to.equal(true)\r\n    expect(header.indexOf('minimum height=0cm') !== -1).to.equal(true)\r\n  });\r\n\r\n  it('should test_large_gates', () => {\r\n    const drawer = new CircuitDrawer()\r\n    const eng = new MainEngine(drawer, [])\r\n    const old_tolatex = ToLatex.toLatex\r\n    ToLatex.toLatex = x => x\r\n\r\n    const qubit1 = eng.allocateQubit()\r\n    const qubit2 = eng.allocateQubit()\r\n    const qubit3 = eng.allocateQubit()\r\n\r\n    class MyLargeGate extends BasicGate {\r\n      toString() {\r\n        return 'large_gate'\r\n      }\r\n\r\n      equal(other) {\r\n        return other instanceof MyLargeGate\r\n      }\r\n    }\r\n\r\n    H.or(qubit2)\r\n    new MyLargeGate().or(tuple(qubit1, qubit3))\r\n    H.or(qubit2)\r\n    eng.flush()\r\n\r\n    const circuit_lines = drawer.getLatex()\r\n    ToLatex.toLatex = old_tolatex\r\n\r\n    const settings = ToLatex.get_default_settings()\r\n    settings.gates.AllocateQubitGate.draw_id = true\r\n    const code = ToLatex._body(circuit_lines, settings)\r\n\r\n    expect(code.count('large_gate')).to.equal(1) // 1 large gate was applied\r\n    // check that large gate draws lines, also for qubits it does not act upon\r\n    expect(code.count('edge\\\\[')).to.equal(5)\r\n    expect(code.count('{H};')).to.equal(2)\r\n  });\r\n\r\n  it('should test_body', () => {\r\n    const drawer = new CircuitDrawer()\r\n    const eng = new MainEngine(drawer, [])\r\n    const old_tolatex = ToLatex.toLatex\r\n    ToLatex.toLatex = x => x\r\n\r\n    const qubit1 = eng.allocateQubit()\r\n    const qubit2 = eng.allocateQubit()\r\n    const qubit3 = eng.allocateQubit()\r\n    H.or(qubit1)\r\n    H.or(qubit2)\r\n    CNOT.or(tuple(qubit1, qubit2))\r\n    X.or(qubit2)\r\n    Measure.or(qubit2)\r\n    CNOT.or(tuple(qubit2, qubit1))\r\n    Z.or(qubit2)\r\n    C(Z).or(tuple(qubit1, qubit2))\r\n    C(Swap).or(tuple(qubit1, qubit2, qubit3))\r\n    SqrtX.or(qubit1)\r\n    SqrtSwap.or(tuple(qubit1, qubit2))\r\n    getInverse(SqrtX).or(qubit1)\r\n    C(SqrtSwap).or(tuple(qubit1, qubit2, qubit3))\r\n    getInverse(SqrtSwap).or(tuple(qubit1, qubit2))\r\n    C(Swap).or(tuple(qubit3, qubit1, qubit2))\r\n    C(SqrtSwap).or(tuple(qubit3, qubit1, qubit2))\r\n\r\n    qubit1.deallocate()\r\n    eng.flush()\r\n\r\n    const circuit_lines = drawer.getLatex()\r\n    ToLatex.toLatex = old_tolatex\r\n\r\n    const settings = ToLatex.get_default_settings()\r\n    settings.gates.AllocateQubitGate.draw_id = true\r\n    const code = ToLatex._body(circuit_lines, settings)\r\n    console.log(code)\r\n    // swap draws 2 nodes + 2 lines each, so is sqrtswap gate, csqrtswap,\r\n    // inv(sqrt_swap), and cswap.\r\n    expect(code.count('swapstyle')).to.equal(36)\r\n    // CZ is two phases plus 2 from CNOTs + 2 from cswap + 2 from csqrtswap\r\n    expect(code.count('phase')).to.equal(8)\r\n    expect(code.count(`{${H.toString()}}`)).to.equal(2) // 2 hadamard gates\r\n    const exp = new RegExp(/\\{\\$\\\\Ket\\{0\\}/g)\r\n    const count = code.match(exp).length\r\n    expect(count).to.equal(3) // 3 qubits allocated\r\n    // 1 cnot, 1 not gate, 3 SqrtSwap, 1 inv(SqrtSwap)\r\n    expect(code.count('xstyle')).to.equal(7)\r\n    expect(code.count('measure')).to.equal(1) // 1 measurement\r\n    expect(code.count(`{${Z.toString()}}`)).to.equal(1) // 1 Z gate\r\n    expect(code.count('{red}')).to.equal(3)\r\n  });\r\n\r\n  it('should test_qubit_allocations_at_zero', () => {\r\n    function copyLines(linesMap) {\r\n      const copy = {}\r\n      Object.keys(linesMap).forEach((key) => {\r\n        const lines = linesMap[key]\r\n        copy[key] = lines.map(item => item.copy())\r\n      })\r\n      return copy\r\n    }\r\n\r\n    const drawer = new CircuitDrawer()\r\n    const eng = new MainEngine(drawer, [])\r\n    const old_tolatex = ToLatex.toLatex\r\n    ToLatex.toLatex = x => x\r\n\r\n    const a = eng.allocateQureg(4)\r\n\r\n    CNOT.or(tuple(a[0], a[2]))\r\n    CNOT.or(tuple(a[0], a[3]))\r\n    CNOT.or(tuple(a[0], a[2]))\r\n    CNOT.or(tuple(a[1], a[3]))\r\n\r\n    a.deallocate()\r\n    eng.flush()\r\n\r\n    const circuit_lines = drawer.getLatex()\r\n    ToLatex.toLatex = old_tolatex\r\n\r\n    const settings = ToLatex.get_default_settings()\r\n    settings.gates.AllocateQubitGate.allocate_at_zero = true\r\n    let code = ToLatex._body(copyLines(circuit_lines), settings)\r\n    expect(code.count('gate0\\\\) at \\\\(0')).to.equal(4)\r\n\r\n    settings.gates.AllocateQubitGate.allocate_at_zero = false\r\n    code = ToLatex._body(copyLines(circuit_lines), settings)\r\n    expect(code.count('gate0\\\\) at \\\\(0')).to.equal(3)\r\n\r\n    delete settings.gates.AllocateQubitGate.allocate_at_zero\r\n    code = ToLatex._body(copyLines(circuit_lines), settings)\r\n    expect(code.count('gate0\\\\) at \\\\(0')).to.equal(3)\r\n  });\r\n\r\n  it('should test_qubit_lines_classicalvsquantum1', () => {\r\n    const drawer = new CircuitDrawer()\r\n    const eng = new MainEngine(drawer, [])\r\n    const old_tolatex = ToLatex.toLatex\r\n    ToLatex.toLatex = x => x\r\n\r\n    const qubit1 = eng.allocateQubit()\r\n\r\n    H.or(qubit1)\r\n    Measure.or(qubit1)\r\n    X.or(qubit1)\r\n\r\n    const circuit_lines = drawer.getLatex()\r\n    ToLatex.toLatex = old_tolatex\r\n\r\n    const settings = ToLatex.get_default_settings()\r\n    const code = ToLatex._body(circuit_lines, settings)\r\n\r\n    expect(code.count('edge\\\\[')).to.equal(4)\r\n  });\r\n\r\n  it('should test_qubit_lines_classicalvsquantum2', () => {\r\n    const drawer = new CircuitDrawer()\r\n    const eng = new MainEngine(drawer, [])\r\n\r\n    const controls = eng.allocateQureg(3)\r\n    const action = eng.allocateQubit()\r\n\r\n    Control(eng, controls, () => H.or(action))\r\n\r\n    const code = drawer.getLatex()\r\n    expect(code.count(`{${H.toString()}`)).to.equal(1) // 1 Hadamard\r\n    expect(code.count('\\\\{\\\\$')).to.equal(4) // four allocate gates\r\n    expect(code.count('node\\\\[phase\\\\]')).to.equal(3) // 3 controls\r\n  });\r\n\r\n  it('should test_qubit_lines_classicalvsquantum3', () => {\r\n    const drawer = new CircuitDrawer()\r\n    const eng = new MainEngine(drawer, [])\r\n\r\n    const control0 = eng.allocateQureg(2)\r\n    const action1 = eng.allocateQubit()\r\n    const control1 = eng.allocateQureg(2)\r\n    const action2 = eng.allocateQubit()\r\n    const control2 = eng.allocateQubit()\r\n\r\n    Control(eng, control0.concat(control1).concat(control2), () => H.or(tuple(action1, action2)))\r\n\r\n    const code = drawer.getLatex()\r\n    expect(code.count(`{${H.toString()}}`)).to.equal(1) // 1 Hadamard\r\n    expect(code.count('\\\\{\\\\$')).to.equal(7) // 8 allocate gates\r\n    expect(code.count('node\\\\[phase\\\\]')).to.equal(3) // 1 control\r\n    // (other controls are within the gate -> are not drawn)\r\n    expect(code.count('edge\\\\[')).to.equal(10) // 7 qubit lines + 3 from controls\r\n  });\r\n\r\n  it('should test_quantum_lines_cnot', () => {\r\n    let drawer = new CircuitDrawer()\r\n    let eng = new MainEngine(drawer, [])\r\n\r\n    let qubit1 = eng.allocateQubit()\r\n    let qubit2 = eng.allocateQubit()\r\n\r\n    Measure.or(qubit1)\r\n    Measure.or(qubit2)\r\n\r\n    CNOT.or(tuple(qubit2, qubit1))\r\n\r\n    qubit1.deallocate()\r\n    qubit2.deallocate()\r\n    let code = drawer.getLatex()\r\n    expect(code.count('edge\\\\[')).to.equal(12) // all lines are classical\r\n\r\n    drawer = new CircuitDrawer()\r\n    eng = new MainEngine(drawer, [])\r\n\r\n    qubit1 = eng.allocateQubit()\r\n    qubit2 = eng.allocateQubit()\r\n\r\n    Measure.or(qubit1) // qubit1 is classical\r\n\r\n    CNOT.or(tuple(qubit2, qubit1)) // now it is quantum\r\n\r\n    qubit1.deallocate()\r\n    qubit2.deallocate()\r\n    code = drawer.getLatex()\r\n    expect(code.count('edge\\\\[')).to.equal(7) // all lines are quantum\r\n  });\r\n})\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/backends/circuits/tolatex.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 98,
    "kind": "file",
    "name": "src/backends/ibm/ibm.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport assert from 'assert'\r\nimport {BasicEngine} from '../../cengines/basics'\r\nimport Gates, {\r\n  Allocate, Barrier, Deallocate, FlushGate, H, Measure, NOT, Rx, Ry, Rz, S, T, Y, Z\r\n} from '../../ops/gates'\r\nimport {LogicalQubitIDTag} from '../../meta/tag';\r\nimport IBMHTTPClient from './ibmhttpclient'\r\nimport {instanceOf} from '../../libs/util'\r\nimport '../../ops/metagates'\r\n\r\nconst {Tdag, Sdag} = Gates\r\n/**\r\n * @class IBMBackend\r\n * @desc\r\nThe IBM Backend class, which stores the circuit, transforms it to JSON\r\nQASM, and sends the circuit through the IBM API.\r\n */\r\nexport default class IBMBackend extends BasicEngine {\r\n  /**\r\n   * @constructor\r\n  @param {{use_hardware: boolean, num_runs: number, verbose: boolean, user: string, password: string, device: string, retrieve_execution: ?string}} args\r\n    use_hardware: If true, the code is run on the IBM quantum chip (instead of using the IBM simulator)\r\n    num_runs: Number of runs to collect statistics. (default is 1024)\r\n    verbose: If true, statistics are printed, in addition to the measurement result being registered (at the end of the circuit).\r\n    user: IBM Quantum Experience user name\r\n    password: IBM Quantum Experience password\r\n    device: Device to use ('ibmqx4', or 'ibmqx5') if use_hardware is set to true. Default is ibmqx4.\r\n    retrieve_execution: Job ID to retrieve instead of re-running the circuit (e.g., if previous run timed out).\r\n  */\r\n  constructor(...args) {\r\n    super()\r\n    this._reset()\r\n    this._errors = []\r\n    let use_hardware = false\r\n    let num_runs = 1024\r\n    let verbose = false\r\n    let user = null\r\n    let password = null\r\n    let device = 'ibmqx4'\r\n    let retrieve_execution = null\r\n\r\n    if (typeof args[0] === 'object') {\r\n      const obj = args[0]\r\n      use_hardware = use_hardware || obj.use_hardware\r\n      num_runs = num_runs || obj.num_runs\r\n      verbose = verbose || obj.verbose\r\n      user = user || obj.user\r\n      password = password || obj.password\r\n      device = device || obj.device\r\n      retrieve_execution = retrieve_execution || obj.retrieve_execution\r\n    } else {\r\n      [use_hardware, num_runs, verbose, user, password, device, retrieve_execution] = args\r\n    }\r\n\r\n    num_runs = num_runs || 1024\r\n    device = device || 'ibmqx4'\r\n    if (use_hardware) {\r\n      this.device = device\r\n    } else {\r\n      this.device = 'simulator'\r\n    }\r\n    this._num_runs = num_runs\r\n    this._verbose = verbose\r\n    this._user = user\r\n    this._password = password\r\n    this._probabilities = {}\r\n    this.qasm = ''\r\n    this._measured_ids = []\r\n    this._allocated_qubits = new Set()\r\n    this._retrieve_execution = retrieve_execution\r\n  }\r\n\r\n  /**\r\n  Return true if the command can be executed.\r\n\r\n    The IBM quantum chip can do X, Y, Z, T, Tdag, S, Sdag,\r\n    rotation gates, barriers, and CX / CNOT.\r\n\r\n    @param {Command} cmd Command for which to check availability\r\n    @return {boolean}\r\n   */\r\n  isAvailable(cmd) {\r\n    const g = cmd.gate\r\n    const controlCount = cmd.controlCount\r\n    if (g.equal(NOT) && controlCount <= 1) {\r\n      return true\r\n    }\r\n    if (controlCount === 0) {\r\n      const set = [T, Tdag, S, Sdag, H, Y, Z]\r\n      if (set.includes(g)) {\r\n        return true\r\n      }\r\n      if (g instanceof Rx || g instanceof Ry || g instanceof Rz) {\r\n        return true\r\n      }\r\n    }\r\n    const set = [Measure, Allocate, Deallocate, Barrier]\r\n    if (set.includes(g)) {\r\n      return true\r\n    }\r\n    return false\r\n  }\r\n\r\n  // Reset all temporary variables (after flush gate).\r\n  _reset() {\r\n    this._clear = true\r\n    this._measured_ids = []\r\n  }\r\n\r\n  /**\r\nTemporarily store the command cmd.\r\n\r\n  Translates the command and stores it in a local variable (this._cmds).\r\n\r\n  @param {Command} cmd Command to store\r\n  */\r\n  _store(cmd) {\r\n    if (this._clear) {\r\n      this._probabilities = {}\r\n      this._clear = false\r\n      this.qasm = ''\r\n      this._allocated_qubits = new Set()\r\n    }\r\n\r\n    const {gate} = cmd\r\n\r\n    if (gate.equal(Allocate)) {\r\n      this._allocated_qubits.add(cmd.qubits[0][0].id)\r\n      return\r\n    }\r\n\r\n    if (gate.equal(Deallocate)) {\r\n      return\r\n    }\r\n\r\n    if (gate.equal(Measure)) {\r\n      assert(cmd.qubits.length === 1 && cmd.qubits[0].length === 1)\r\n      const qb_id = cmd.qubits[0][0].id\r\n      let logical_id\r\n      for (let i = 0; i < cmd.tags.length; ++i) {\r\n        const t = cmd.tags[i]\r\n        if (t instanceof LogicalQubitIDTag) {\r\n          logical_id = t.logical_qubit_id\r\n          break\r\n        }\r\n      }\r\n      assert(typeof logical_id !== 'undefined')\r\n      this._measured_ids.push(logical_id)\r\n    } else if (gate === NOT && cmd.controlCount === 1) {\r\n      const ctrl_pos = cmd.controlQubits[0].id\r\n      const qb_pos = cmd.qubits[0][0].id\r\n      this.qasm += `\\ncx q[${ctrl_pos}], q[${qb_pos}];`\r\n    } else if (gate === Barrier) {\r\n      const qb_pos = []\r\n      cmd.qubits.forEach(qr => qr.forEach(qb => qb_pos.push(qb.id)))\r\n      this.qasm += '\\nbarrier '\r\n      let qb_str = ''\r\n      qb_pos.forEach((pos) => {\r\n        qb_str += `q[${pos}]`\r\n      })\r\n\r\n      this.qasm += `${qb_str.substring(0, qb_str.length - 2)};`\r\n    } else if (instanceOf(gate, [Rx, Ry, Rz])) {\r\n      assert(cmd.controlCount === 0)\r\n      const qb_pos = cmd.qubits[0][0].id\r\n      const u_strs = {\r\n        Rx: a => `u3(${a}, -pi/2, pi/2)`,\r\n        Ry: a => `u3(${a}, 0, 0)`,\r\n        Rz: a => `u1(${a})`\r\n      }\r\n      const gateASM = u_strs[gate.toString().substring(0, 2)](gate.angle)\r\n      this.qasm += `\\n${gateASM} q[${qb_pos}];`\r\n    } else {\r\n      if (cmd.controlCount !== 0) {\r\n        console.log(187, cmd.toString())\r\n      }\r\n      assert(cmd.controlCount === 0)\r\n      const key = gate.toString()\r\n      const v = IBMBackend.gateNames[key]\r\n      let gate_str\r\n      if (typeof v !== 'undefined') {\r\n        gate_str = v\r\n      } else {\r\n        gate_str = key.toLowerCase()\r\n      }\r\n\r\n      const qb_pos = cmd.qubits[0][0].id\r\n      this.qasm += `\\n${gate_str} q[${qb_pos}];`\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n  Return the physical location of the qubit with the given logical id.\r\n\r\n    @param {number} qbID ID of the logical qubit whose position should be returned.\r\n   */\r\n  _logicalToPhysical(qbID) {\r\n    assert(!!this.main.mapper)\r\n    const mapping = this.main.mapper.currentMapping\r\n    const v = mapping[qbID]\r\n    if (typeof v === 'undefined') {\r\n      throw new Error(`Unknown qubit id ${qbID}. Please make sure \r\n      eng.flush() was called and that the qubit \r\n      was eliminated during optimization.`)\r\n    }\r\n    return v\r\n  }\r\n\r\n  /**\r\n  Return the list of basis states with corresponding probabilities.\r\n\r\n    The measured bits are ordered according to the supplied quantum\r\nregister, i.e., the left-most bit in the state-string corresponds to\r\nthe first qubit in the supplied quantum register.\r\n\r\n    Warning:\r\nOnly call this function after the circuit has been executed!\r\n\r\n    @param {Array.<Qubit>|Qureg} qureg Quantum register determining the order of the qubits.\r\n\r\n    @return {Object} Dictionary mapping n-bit strings to probabilities.\r\n\r\n    @throws {Error} If no data is available (i.e., if the circuit has\r\nnot been executed). Or if a qubit was supplied which was not\r\npresent in the circuit (might have gotten optimized away).\r\n   */\r\n  getProbabilities(qureg) {\r\n    if (Object.keys(this._probabilities).length === 0) {\r\n      throw new Error('Please, run the circuit first!')\r\n    }\r\n\r\n    const probability_dict = {}\r\n\r\n    this._probabilities.forEach((state) => {\r\n      const mapped_state = []\r\n      for (let i = 0; i < qureg.length; ++i) {\r\n        mapped_state.push('0')\r\n      }\r\n\r\n      for (let i = 0; i < qureg.length; ++i) {\r\n        mapped_state[i] = state[this._logicalToPhysical(qureg[i].id)]\r\n      }\r\n      const probability = this._probabilities[state]\r\n      probability_dict[mapped_state.join('')] = probability\r\n    })\r\n\r\n    return probability_dict\r\n  }\r\n\r\n  /**\r\n  Run the circuit.\r\n\r\n    Send the circuit via the IBM API (JSON QASM) using the provided user\r\ndata / ask for username & password.\r\n   */\r\n  async run() {\r\n    if (this.qasm.length === 0) {\r\n      return\r\n    }\r\n    // finally: add measurements (no intermediate measurements are allowed)\r\n    this._measured_ids.forEach((measured_id) => {\r\n      const qb_loc = this.main.mapper.currentMapping[measured_id]\r\n      this.qasm += `measure q[${qb_loc}] -> c[${qb_loc}];`\r\n    })\r\n    let max_qubit_id = -1\r\n    this._allocated_qubits.forEach((id) => {\r\n      if (id > max_qubit_id) {\r\n        max_qubit_id = id\r\n      }\r\n    })\r\n\r\n    const nq = max_qubit_id + 1\r\n    const qasm = `\\ninclude \\\"qelib1.inc\\\";\\nqreg q[${nq}];\\ncreg c[${nq}];${this.qasm}`\r\n    const info = {}\r\n    info.qasms = [{qasm}]\r\n    info.shots = this._num_runs\r\n    info.maxCredits = 5\r\n    info.backend = {'name': this.device}\r\n    const infoJSON = JSON.stringify(info)\r\n\r\n    try {\r\n      let res\r\n      if (!this._retrieve_execution) {\r\n        res = await IBMHTTPClient.send(infoJSON, this.device, this._user, this._password, this._num_runs, this._verbose)\r\n      } else {\r\n        res = await IBMHTTPClient.retrieve(this.device, this._user, this._password, this._retrieve_execution)\r\n      }\r\n      const {counts} = res.data\r\n      // Determine random outcome\r\n      const P = Math.random()\r\n      let p_sum = 0.0\r\n      let measured = ''\r\n      Object.keys(counts).forEach((state) => {\r\n        const probability = counts[state] * 1.0 / this._num_runs\r\n        if (Array.isArray(state)) {\r\n          state = state.slice(0).reverse()\r\n          state = ''.join(state)\r\n        }\r\n        p_sum += probability\r\n        let star = ''\r\n        if (p_sum >= P && measured === '') {\r\n          measured = state\r\n          star = '*'\r\n        }\r\n        this._probabilities[state] = probability\r\n        if (this._verbose && probability > 0) {\r\n          console.log(`${state.toString()} with p = ${probability.toString()}${star}`)\r\n        }\r\n      })\r\n\r\n      class QB {\r\n        constructor(ID) {\r\n          this.id = ID\r\n        }\r\n      }\r\n\r\n      // register measurement result\r\n      this._measured_ids.forEach((ID) => {\r\n        const location = this._logicalToPhysical(ID)\r\n        const result = measured[location]\r\n        this.main.setMeasurementResult(new QB(ID), result)\r\n      })\r\n      this._reset()\r\n    } catch (e) {\r\n      console.log(347, e)\r\n      throw new Error('Failed to run the circuit. Aborting.')\r\n    }\r\n  }\r\n\r\n  /**\r\n  Receives a command list and, for each command, stores it until\r\ncompletion.\r\n\r\n    @param {Command[]} commandList List of commands to execute\r\n   */\r\n  receive(commandList) {\r\n    commandList.forEach((cmd) => {\r\n      if (!(cmd.gate instanceof FlushGate)) {\r\n        this._store(cmd)\r\n      } else {\r\n        this.run()\r\n          .then(() => this._reset())\r\n          .catch((e) => {\r\n            console.log(e)\r\n            this.addError(e)\r\n          }).finally(() => {\r\n            if (this.didRunCallback) {\r\n              this.didRunCallback()\r\n            }\r\n          })\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * @return {Error[]}\r\n   */\r\n  get errors() {\r\n    return this._errors\r\n  }\r\n\r\n  addError(error) {\r\n    this._errors.push(error)\r\n  }\r\n\r\n  /**\r\n   * @return {function}\r\n   */\r\n  get didRunCallback() {\r\n    return this._didRunCallback\r\n  }\r\n\r\n  /**\r\n   * @param {function} callback\r\n   */\r\n  set didRunCallback(callback) {\r\n    this._didRunCallback = callback\r\n  }\r\n}\r\n\r\nIBMBackend.gateNames = {\r\n  [Tdag.toString()]: 'tdg',\r\n  [Sdag.toString()]: 'sdg'\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/backends/ibm/ibm.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 99,
    "kind": "variable",
    "name": "Tdag",
    "memberof": "src/backends/ibm/ibm.js",
    "static": true,
    "longname": "src/backends/ibm/ibm.js~Tdag",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/backends/ibm/ibm.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 100,
    "kind": "class",
    "name": "IBMBackend",
    "memberof": "src/backends/ibm/ibm.js",
    "static": true,
    "longname": "src/backends/ibm/ibm.js~IBMBackend",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/backends/ibm/ibm.js",
    "importStyle": "IBMBackend",
    "description": "The IBM Backend class, which stores the circuit, transforms it to JSON\nQASM, and sends the circuit through the IBM API.",
    "lineNumber": 34,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "IBMBackend"
      }
    ],
    "interface": false,
    "extends": [
      "src/cengines/basics.js~BasicEngine"
    ]
  },
  {
    "__docId__": 101,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/backends/ibm/ibm.js~IBMBackend",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/ibm/ibm.js~IBMBackend#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 46,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "{use_hardware: boolean, num_runs: number, verbose: boolean, user: string, password: string, device: string, retrieve_execution: ?string}"
        ],
        "spread": false,
        "optional": false,
        "name": "args",
        "description": "use_hardware: If true, the code is run on the IBM quantum chip (instead of using the IBM simulator)\nnum_runs: Number of runs to collect statistics. (default is 1024)\nverbose: If true, statistics are printed, in addition to the measurement result being registered (at the end of the circuit).\nuser: IBM Quantum Experience user name\npassword: IBM Quantum Experience password\ndevice: Device to use ('ibmqx4', or 'ibmqx5') if use_hardware is set to true. Default is ibmqx4.\nretrieve_execution: Job ID to retrieve instead of re-running the circuit (e.g., if previous run timed out)."
      }
    ]
  },
  {
    "__docId__": 102,
    "kind": "member",
    "name": "_errors",
    "memberof": "src/backends/ibm/ibm.js~IBMBackend",
    "static": false,
    "longname": "src/backends/ibm/ibm.js~IBMBackend#_errors",
    "access": "private",
    "description": null,
    "lineNumber": 49,
    "undocument": true,
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 103,
    "kind": "member",
    "name": "device",
    "memberof": "src/backends/ibm/ibm.js~IBMBackend",
    "static": false,
    "longname": "src/backends/ibm/ibm.js~IBMBackend#device",
    "access": "public",
    "description": null,
    "lineNumber": 74,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 105,
    "kind": "member",
    "name": "_num_runs",
    "memberof": "src/backends/ibm/ibm.js~IBMBackend",
    "static": false,
    "longname": "src/backends/ibm/ibm.js~IBMBackend#_num_runs",
    "access": "private",
    "description": null,
    "lineNumber": 78,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 106,
    "kind": "member",
    "name": "_verbose",
    "memberof": "src/backends/ibm/ibm.js~IBMBackend",
    "static": false,
    "longname": "src/backends/ibm/ibm.js~IBMBackend#_verbose",
    "access": "private",
    "description": null,
    "lineNumber": 79,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 107,
    "kind": "member",
    "name": "_user",
    "memberof": "src/backends/ibm/ibm.js~IBMBackend",
    "static": false,
    "longname": "src/backends/ibm/ibm.js~IBMBackend#_user",
    "access": "private",
    "description": null,
    "lineNumber": 80,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 108,
    "kind": "member",
    "name": "_password",
    "memberof": "src/backends/ibm/ibm.js~IBMBackend",
    "static": false,
    "longname": "src/backends/ibm/ibm.js~IBMBackend#_password",
    "access": "private",
    "description": null,
    "lineNumber": 81,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 109,
    "kind": "member",
    "name": "_probabilities",
    "memberof": "src/backends/ibm/ibm.js~IBMBackend",
    "static": false,
    "longname": "src/backends/ibm/ibm.js~IBMBackend#_probabilities",
    "access": "private",
    "description": null,
    "lineNumber": 82,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 110,
    "kind": "member",
    "name": "qasm",
    "memberof": "src/backends/ibm/ibm.js~IBMBackend",
    "static": false,
    "longname": "src/backends/ibm/ibm.js~IBMBackend#qasm",
    "access": "public",
    "description": null,
    "lineNumber": 83,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 111,
    "kind": "member",
    "name": "_measured_ids",
    "memberof": "src/backends/ibm/ibm.js~IBMBackend",
    "static": false,
    "longname": "src/backends/ibm/ibm.js~IBMBackend#_measured_ids",
    "access": "private",
    "description": null,
    "lineNumber": 84,
    "undocument": true,
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 112,
    "kind": "member",
    "name": "_allocated_qubits",
    "memberof": "src/backends/ibm/ibm.js~IBMBackend",
    "static": false,
    "longname": "src/backends/ibm/ibm.js~IBMBackend#_allocated_qubits",
    "access": "private",
    "description": null,
    "lineNumber": 85,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 113,
    "kind": "member",
    "name": "_retrieve_execution",
    "memberof": "src/backends/ibm/ibm.js~IBMBackend",
    "static": false,
    "longname": "src/backends/ibm/ibm.js~IBMBackend#_retrieve_execution",
    "access": "private",
    "description": null,
    "lineNumber": 86,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 114,
    "kind": "method",
    "name": "isAvailable",
    "memberof": "src/backends/ibm/ibm.js~IBMBackend",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/ibm/ibm.js~IBMBackend#isAvailable",
    "access": "public",
    "description": "Return true if the command can be executed.\n\nThe IBM quantum chip can do X, Y, Z, T, Tdag, S, Sdag,\nrotation gates, barriers, and CX / CNOT.",
    "lineNumber": 98,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": "Command for which to check availability"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 115,
    "kind": "method",
    "name": "_reset",
    "memberof": "src/backends/ibm/ibm.js~IBMBackend",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/ibm/ibm.js~IBMBackend#_reset",
    "access": "private",
    "description": null,
    "lineNumber": 121,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 116,
    "kind": "member",
    "name": "_clear",
    "memberof": "src/backends/ibm/ibm.js~IBMBackend",
    "static": false,
    "longname": "src/backends/ibm/ibm.js~IBMBackend#_clear",
    "access": "private",
    "description": null,
    "lineNumber": 122,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 118,
    "kind": "method",
    "name": "_store",
    "memberof": "src/backends/ibm/ibm.js~IBMBackend",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/ibm/ibm.js~IBMBackend#_store",
    "access": "private",
    "description": "Temporarily store the command cmd.\n\nTranslates the command and stores it in a local variable (this._cmds).",
    "lineNumber": 133,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": "Command to store"
      }
    ],
    "return": null
  },
  {
    "__docId__": 128,
    "kind": "method",
    "name": "_logicalToPhysical",
    "memberof": "src/backends/ibm/ibm.js~IBMBackend",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/ibm/ibm.js~IBMBackend#_logicalToPhysical",
    "access": "private",
    "description": "Return the physical location of the qubit with the given logical id.",
    "lineNumber": 214,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "qbID",
        "description": "ID of the logical qubit whose position should be returned."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 129,
    "kind": "method",
    "name": "getProbabilities",
    "memberof": "src/backends/ibm/ibm.js~IBMBackend",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/ibm/ibm.js~IBMBackend#getProbabilities",
    "access": "public",
    "description": "Return the list of basis states with corresponding probabilities.\n\nThe measured bits are ordered according to the supplied quantum\nregister, i.e., the left-most bit in the state-string corresponds to\nthe first qubit in the supplied quantum register.\n\nWarning:\nOnly call this function after the circuit has been executed!",
    "lineNumber": 244,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array.<Qubit>",
          "Qureg"
        ],
        "spread": false,
        "optional": false,
        "name": "qureg",
        "description": "Quantum register determining the order of the qubits."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Dictionary mapping n-bit strings to probabilities."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If no data is available (i.e., if the circuit has\nnot been executed). Or if a qubit was supplied which was not\npresent in the circuit (might have gotten optimized away)."
      }
    ]
  },
  {
    "__docId__": 130,
    "kind": "method",
    "name": "run",
    "memberof": "src/backends/ibm/ibm.js~IBMBackend",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/backends/ibm/ibm.js~IBMBackend#run",
    "access": "public",
    "description": "Run the circuit.\n\nSend the circuit via the IBM API (JSON QASM) using the provided user\ndata / ask for username & password.",
    "lineNumber": 273,
    "params": [],
    "return": null
  },
  {
    "__docId__": 132,
    "kind": "method",
    "name": "receive",
    "memberof": "src/backends/ibm/ibm.js~IBMBackend",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/ibm/ibm.js~IBMBackend#receive",
    "access": "public",
    "description": "Receives a command list and, for each command, stores it until\ncompletion.",
    "lineNumber": 353,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command[]"
        ],
        "spread": false,
        "optional": false,
        "name": "commandList",
        "description": "List of commands to execute"
      }
    ],
    "return": null
  },
  {
    "__docId__": 133,
    "kind": "get",
    "name": "errors",
    "memberof": "src/backends/ibm/ibm.js~IBMBackend",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/ibm/ibm.js~IBMBackend#errors",
    "access": "public",
    "description": "",
    "lineNumber": 375,
    "return": {
      "nullable": null,
      "types": [
        "Error[]"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 134,
    "kind": "method",
    "name": "addError",
    "memberof": "src/backends/ibm/ibm.js~IBMBackend",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/ibm/ibm.js~IBMBackend#addError",
    "access": "public",
    "description": null,
    "lineNumber": 379,
    "undocument": true,
    "params": [
      {
        "name": "error",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 135,
    "kind": "get",
    "name": "didRunCallback",
    "memberof": "src/backends/ibm/ibm.js~IBMBackend",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/ibm/ibm.js~IBMBackend#didRunCallback",
    "access": "public",
    "description": "",
    "lineNumber": 386,
    "return": {
      "nullable": null,
      "types": [
        "function"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 136,
    "kind": "set",
    "name": "didRunCallback",
    "memberof": "src/backends/ibm/ibm.js~IBMBackend",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/ibm/ibm.js~IBMBackend#didRunCallback",
    "access": "public",
    "description": "",
    "lineNumber": 393,
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 137,
    "kind": "member",
    "name": "_didRunCallback",
    "memberof": "src/backends/ibm/ibm.js~IBMBackend",
    "static": false,
    "longname": "src/backends/ibm/ibm.js~IBMBackend#_didRunCallback",
    "access": "private",
    "description": null,
    "lineNumber": 394,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 138,
    "kind": "file",
    "name": "src/backends/ibm/ibm.spec.js",
    "content": "\r\n/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n// Insure that no HTTP request can be made in all tests in this module\r\nimport {expect} from 'chai'\r\nimport Gates, {\r\n  Allocate, Barrier, Deallocate, Entangle, Measure, NOT, Rx, Ry, Rz, S, T, X, Y, Z\r\n} from '../../ops/gates';\r\nimport {DummyEngine} from '../../cengines/testengine';\r\nimport IBMBackend from './ibm';\r\nimport Command from '../../ops/command';\r\nimport {tuple} from '../../libs/util';\r\nimport MainEngine from '../../cengines/main';\r\nimport IBM5QubitMapper, {ibmqx4_connections} from '../../cengines/ibm5qubitmapper';\r\nimport SwapAndCNOTFlipper from '../../cengines/swapandcnotflipper'\r\nimport IBMHTTPClient from './ibmhttpclient'\r\nimport DecompositionRuleSet from '../../cengines/replacer/decompositionruleset'\r\nimport decompositions from '../../setups/decompositions'\r\nimport TagRemover from '../../cengines/tagremover';\r\nimport LocalOptimizer from '../../cengines/optimize';\r\nimport {AutoReplacer} from '../../cengines/replacer/replacer';\r\nimport {All} from '../../ops/metagates';\r\n\r\nconst {Tdag, Sdag} = Gates\r\n\r\nconst single_qubit_gates = [\r\n  X, Y, Z, T, Tdag, S, Sdag, Allocate, Deallocate, Measure, NOT, new Rx(0.5),\r\n  new Ry(0.5), new Rz(0.5), Barrier, Entangle\r\n]\r\nconst isAvailables = [\r\n  true, true, true, true, true, true, true, true, true, true, true, true,\r\n  true, true, true, false]\r\n\r\nconst OriginSend = IBMHTTPClient.send\r\nconst OriginRetrieve = IBMHTTPClient.retrieve\r\n\r\ndescribe('ibm test', () => {\r\n  beforeEach(() => {\r\n    IBMHTTPClient.send = OriginSend\r\n    IBMHTTPClient.retrieve = OriginRetrieve\r\n  })\r\n\r\n  it('should test_ibm_backend_is_available', () => {\r\n    single_qubit_gates.forEach((gate, idx) => {\r\n      const eng = new MainEngine(new DummyEngine(), [new DummyEngine()])\r\n      const qubit1 = eng.allocateQubit()\r\n      const ibm_backend = new IBMBackend()\r\n      const cmd = new Command(eng, gate, tuple(qubit1))\r\n\r\n      expect(ibm_backend.isAvailable(cmd)).to.equal(isAvailables[idx])\r\n    })\r\n  });\r\n\r\n  it('should test_ibm_backend_is_available_control_not', () => {\r\n    const numCtrlQubits = [0, 1, 2, 3]\r\n    const availables = [true, true, false, false]\r\n\r\n    numCtrlQubits.forEach((num, i) => {\r\n      const eng = new MainEngine(new DummyEngine(), [new DummyEngine()])\r\n      const qubit1 = eng.allocateQubit()\r\n      const qureg = eng.allocateQureg(num)\r\n      const ibm_backend = new IBMBackend()\r\n      const cmd = new Command(eng, NOT, tuple(qubit1), qureg)\r\n\r\n      expect(ibm_backend.isAvailable(cmd)).to.equal(availables[i])\r\n    })\r\n  });\r\n\r\n  it('should test_ibm_backend_init', () => {\r\n    const backend = new IBMBackend({verbose: true, user_hardware: true})\r\n    expect(backend.qasm).to.equal('')\r\n  });\r\n\r\n  it('should test_ibm_empty_circuit', () => {\r\n    const backend = new IBMBackend(false, 1024, true)\r\n    const eng = new MainEngine(backend)\r\n    eng.flush()\r\n  });\r\n\r\n  it('should test_ibm_sent_error', () => {\r\n    const mock_send = async () => {\r\n      throw new Error('')\r\n    }\r\n\r\n    IBMHTTPClient.send = mock_send\r\n\r\n    const backend = new IBMBackend({verbose: true})\r\n    backend.didRunCallback = () => expect(backend.errors.length).to.equal(1)\r\n    const eng = new MainEngine(backend, [new IBM5QubitMapper(), new SwapAndCNOTFlipper(new Set())])\r\n    const qubit = eng.allocateQubit()\r\n    X.or(qubit)\r\n\r\n    qubit[0].deallocate()\r\n    eng.flush()\r\n\r\n    // atexit sends another FlushGate, therefore we remove the backend:\r\n    const dummy = new DummyEngine()\r\n    dummy.isLastEngine = true\r\n    eng.next = dummy\r\n  });\r\n\r\n  it('should test_ibm_retrieve', () => {\r\n    IBMHTTPClient.retrieve = async () => {\r\n      return {\r\n        'date': '2017-01-19T14:28:47.622Z',\r\n        'data': {\r\n          'time': 14.429004907608032,\r\n          'counts': {\r\n            '00111': 396,\r\n            '00101': 27,\r\n            '00000': 601\r\n          },\r\n          'qasm': ('...')\r\n        }\r\n      }\r\n    }\r\n    const backend = new IBMBackend({retrieve_execution: 'ab1s2'})\r\n    const rule_set = new DecompositionRuleSet([...decompositions])\r\n    const connectivity = new Set([[1, 2], [2, 4], [0, 2], [3, 2], [4, 3], [0, 1]])\r\n    const engine_list = [new TagRemover(),\r\n      new LocalOptimizer(10),\r\n      new AutoReplacer(rule_set),\r\n      new TagRemover(),\r\n      new IBM5QubitMapper(),\r\n      new SwapAndCNOTFlipper(connectivity),\r\n      new LocalOptimizer(10)]\r\n    const eng = new MainEngine(backend, engine_list)\r\n    const unused_qubit = eng.allocateQubit()\r\n    const qureg = eng.allocateQureg(3)\r\n    // entangle the qureg\r\n    Entangle.or(qureg)\r\n    Tdag.or(qureg[0])\r\n    Sdag.or(qureg[0])\r\n    Barrier.or(qureg)\r\n    new Rx(0.2).or(qureg[0])\r\n\r\n    unused_qubit.deallocate()\r\n    // measure; should be all-0 or all-1\r\n    new All(Measure).or(qureg)\r\n    // run the circuit\r\n    eng.flush()\r\n    const prob_dict = eng.backend.getProbability([qureg[0], qureg[2], qureg[1]])\r\n    console.log(prob_dict)\r\n\r\n    expect(prob_dict['111']).to.be.closeTo(0.38671875, 1e-12)\r\n    expect(prob_dict['101']).to.be.closeTo(0.0263671875, 1e-12)\r\n  });\r\n\r\n  it('should test_ibm_backend_functional_test', () => {\r\n    const correct_info = ('{\"qasms\": [{\"qasm\": \"\\\\ninclude \\\\\"qelib1.inc\\\\\";'\r\n+ '\\\\nqreg q[3];\\\\ncreg c[3];\\\\nh q[2];\\\\ncx q[2], q[0];'\r\n        + '\\\\ncx q[2], q[1];\\\\ntdg q[2];\\\\nsdg q[2];'\r\n        + '\\\\nbarrier q[2], q[0], q[1];'\r\n        + '\\\\nu3(0.2, -pi/2, pi/2) q[2];\\\\nmeasure q[2] -> '\r\n        + 'c[2];\\\\nmeasure q[0] -> c[0];\\\\nmeasure q[1] -> c[1];\"}]'\r\n        + ', \"shots\": 1024, \"maxCredits\": 5, \"backend\": {\"name\": '\r\n        + '\"simulator\"}}')\r\n\r\n    const mock_send = async (args) => {\r\n      return {\r\n        'date': '2017-01-19T14:28:47.622Z',\r\n        'data': {\r\n          'time': 14.429004907608032,\r\n          'counts': {\r\n            '00111': 396,\r\n            '00101': 27,\r\n            '00000': 601\r\n          },\r\n          'qasm': ('...')\r\n        }\r\n      }\r\n    }\r\n\r\n    IBMHTTPClient.send = mock_send\r\n\r\n    const backend = new IBMBackend({verbose: true})\r\n    // no circuit has been executed -> raises exception\r\n    expect(() => backend.getProbabilities([])).to.throw()\r\n\r\n    const rule_set = new DecompositionRuleSet(decompositions)\r\n\r\n    const engine_list = [new TagRemover(),\r\n      new LocalOptimizer(10),\r\n      new AutoReplacer(rule_set),\r\n      new TagRemover(),\r\n      new IBM5QubitMapper(),\r\n      new SwapAndCNOTFlipper(ibmqx4_connections),\r\n      new LocalOptimizer(10)]\r\n    const eng = new MainEngine(backend, engine_list)\r\n    const unused_qubit = eng.allocateQubit()\r\n    const qureg = eng.allocateQureg(3)\r\n    // entangle the qureg\r\n    Entangle.or(qureg)\r\n    Tdag.or(qureg[0])\r\n    Sdag.or(qureg[0])\r\n    Barrier.or(qureg)\r\n    new Rx(0.2).or(qureg[0])\r\n\r\n    unused_qubit.deallocate()\r\n    // measure; should be all-0 or all-1\r\n    new All(Measure).or(qureg)\r\n    // run the circuit\r\n    eng.flush()\r\n    const prob_dict = eng.backend.getProbabilities([qureg[0], qureg[2], qureg[1]])\r\n    expect(prob_dict['111']).to.be.closeTo(0.38671875, 1e-12)\r\n    expect(prob_dict['101']).to.be.closeTo(0.0263671875, 1e-12)\r\n\r\n    expect(() => eng.backend.getProbabilities(eng.allocateQubit())).to.throw()\r\n  });\r\n})\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/backends/ibm/ibm.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 139,
    "kind": "variable",
    "name": "Tdag",
    "memberof": "src/backends/ibm/ibm.spec.js",
    "static": true,
    "longname": "src/backends/ibm/ibm.spec.js~Tdag",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/backends/ibm/ibm.spec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 38,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 140,
    "kind": "variable",
    "name": "single_qubit_gates",
    "memberof": "src/backends/ibm/ibm.spec.js",
    "static": true,
    "longname": "src/backends/ibm/ibm.spec.js~single_qubit_gates",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/backends/ibm/ibm.spec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 40,
    "undocument": true,
    "type": {
      "types": [
        "undefined[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 141,
    "kind": "variable",
    "name": "isAvailables",
    "memberof": "src/backends/ibm/ibm.spec.js",
    "static": true,
    "longname": "src/backends/ibm/ibm.spec.js~isAvailables",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/backends/ibm/ibm.spec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 44,
    "undocument": true,
    "type": {
      "types": [
        "boolean[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 142,
    "kind": "variable",
    "name": "OriginSend",
    "memberof": "src/backends/ibm/ibm.spec.js",
    "static": true,
    "longname": "src/backends/ibm/ibm.spec.js~OriginSend",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/backends/ibm/ibm.spec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 48,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 143,
    "kind": "variable",
    "name": "OriginRetrieve",
    "memberof": "src/backends/ibm/ibm.spec.js",
    "static": true,
    "longname": "src/backends/ibm/ibm.spec.js~OriginRetrieve",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/backends/ibm/ibm.spec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 49,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 144,
    "kind": "file",
    "name": "src/backends/ibm/ibmhttpclient.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport axios from 'axios'\r\nconst _api_url = 'https://quantumexperience.ng.bluemix.net/api/'\r\n/**\r\n * @class IBMHTTPClient\r\n */\r\nexport default class IBMHTTPClient {\r\n  static async isOnline(device) {\r\n    const url = `Backends/${device}/queue/status`\r\n    const result = await axios.get(`${_api_url}${url}`)\r\n    return result.state\r\n  }\r\n\r\n  /**\r\n  Retrieves a previously run job by its ID.\r\n\r\n    @param {string} device Device on which the code was run / is running.\r\n    @param {string} user IBM quantum experience user (e-mail)\r\n    @param {string} password IBM quantum experience password\r\n    @param {string} jobid Id of the job to retrieve\r\n  */\r\n  static async retrieve(device, user, password, jobid) {\r\n    const [user_id, access_token] = await IBMHTTPClient.authenticate(user, password)\r\n    return IBMHTTPClient.getResult(device, jobid, access_token)\r\n  }\r\n\r\n  static async sleep(interval) {\r\n    return new Promise((resolve) => {\r\n      setTimeout(resolve, interval)\r\n    })\r\n  }\r\n\r\n  /**\r\n  Sends QASM through the IBM API and runs the quantum circuit.\r\n\r\n   @param {string} info Contains QASM representation of the circuit to run.\r\n   @param {string} device Either 'simulator', 'ibmqx4', or 'ibmqx5'.\r\n   @param {string} user IBM quantum experience user.\r\n   @param {string} password IBM quantum experience user password.\r\n   @param {number} shots Number of runs of the same circuit to collect statistics.\r\n   @param {boolean} verbose If true, additional information is printed, such as\r\nmeasurement statistics. Otherwise, the backend simply registers\r\none measurement result (same behavior as the projectq Simulator).\r\n   */\r\n  static async send(info, device = 'sim_trivial_2', user = '', password = '', shots = 1, verbose = false) {\r\n    try {\r\n      // check if the device is online\r\n      if (['ibmqx4', 'ibmqx5'].includes(device)) {\r\n        const online = await IBMHTTPClient.isOnline(device)\r\n        if (!online) {\r\n          console.log('The device is offline (for maintenance?). Use the simulator instead or try again later.')\r\n          throw new Error('Device is offline')\r\n        }\r\n      }\r\n      if (verbose) {\r\n        console.log('- Authenticating...')\r\n      }\r\n      const [user_id, access_token] = await IBMHTTPClient.authenticate(user, password)\r\n      if (verbose) {\r\n        const obj = JSON.parse(info)\r\n        console.log(`- Running code: ${obj.qasms[0].qasm}`)\r\n      }\r\n      const execution_id = await IBMHTTPClient.run(info, device, user_id, access_token, shots)\r\n      if (verbose) {\r\n        console.log('- Waiting for results...')\r\n      }\r\n      const res = await IBMHTTPClient.getResult(device, execution_id, access_token)\r\n      if (verbose) {\r\n        console.log('- Done.')\r\n      }\r\n      return res\r\n    } catch (e) {\r\n      console.log(e)\r\n    }\r\n  }\r\n\r\n  static async authenticate(email = '', password = '') {\r\n    const result = await axios.post(`${_api_url}users/login`, {email, password})\r\n    const {userId, id} = result.data\r\n    return [userId, id]\r\n  }\r\n\r\n  static async run(qasm, device, user_id, access_token, shots) {\r\n    const suffix = 'Jobs'\r\n    const params = {\r\n      'access_token': access_token,\r\n      'deviceRunType': device,\r\n      'fromCache': 'false',\r\n      'shots': shots\r\n    }\r\n    const resp = await axios({\r\n      method: 'post',\r\n      url: `${_api_url}${suffix}`,\r\n      headers: {'Content-Type': 'application/json'},\r\n      data: qasm,\r\n      params\r\n    })\r\n\r\n    return resp.data.id\r\n  }\r\n\r\n  static async getResult(device, execution_id, access_token, num_retries = 3000,\r\n    interval = 1) {\r\n    const suffix = `Jobs/${execution_id}`\r\n    const status_url = `${_api_url}Backends/${device}/queue/status`\r\n\r\n    console.log(`Waiting for results. [Job ID: ${execution_id}]`)\r\n\r\n    for (let retries = 0; retries < num_retries; ++retries) {\r\n      const resp = await axios.get(`${_api_url}${suffix}`, {params: {access_token}})\r\n      const {data} = resp\r\n      const {qasms} = data\r\n      if (qasms) {\r\n        const {result} = qasms[0]\r\n        if (result) {\r\n          return result\r\n        }\r\n      }\r\n      await IBMHTTPClient.sleep(interval)\r\n      if (['ibmqx4', 'ibmqx5'].includes(device) && retries % 60 === 0) {\r\n        const stateResp = await axios.get(status_url)\r\n        const {state, lengthQueue} = stateResp.data\r\n        if (typeof state !== 'undefined' && !state) {\r\n          throw new Error(`Device went offline. The ID of your submitted job is ${execution_id}`)\r\n        }\r\n\r\n        if (lengthQueue) {\r\n          console.log(`Currently there are ${lengthQueue} jobs queued for execution on ${device}.`)\r\n        }\r\n      }\r\n    }\r\n    throw new Error(`Timeout. The ID of your submitted job is ${execution_id}.`)\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/backends/ibm/ibmhttpclient.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 145,
    "kind": "variable",
    "name": "_api_url",
    "memberof": "src/backends/ibm/ibmhttpclient.js",
    "static": true,
    "longname": "src/backends/ibm/ibmhttpclient.js~_api_url",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/backends/ibm/ibmhttpclient.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 146,
    "kind": "class",
    "name": "IBMHTTPClient",
    "memberof": "src/backends/ibm/ibmhttpclient.js",
    "static": true,
    "longname": "src/backends/ibm/ibmhttpclient.js~IBMHTTPClient",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/backends/ibm/ibmhttpclient.js",
    "importStyle": "IBMHTTPClient",
    "description": "",
    "lineNumber": 22,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "IBMHTTPClient"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 147,
    "kind": "method",
    "name": "isOnline",
    "memberof": "src/backends/ibm/ibmhttpclient.js~IBMHTTPClient",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/backends/ibm/ibmhttpclient.js~IBMHTTPClient.isOnline",
    "access": "public",
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "params": [
      {
        "name": "device",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 148,
    "kind": "method",
    "name": "retrieve",
    "memberof": "src/backends/ibm/ibmhttpclient.js~IBMHTTPClient",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/backends/ibm/ibmhttpclient.js~IBMHTTPClient.retrieve",
    "access": "public",
    "description": "Retrieves a previously run job by its ID.",
    "lineNumber": 37,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "device",
        "description": "Device on which the code was run / is running."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": "IBM quantum experience user (e-mail)"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "password",
        "description": "IBM quantum experience password"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "jobid",
        "description": "Id of the job to retrieve"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 149,
    "kind": "method",
    "name": "sleep",
    "memberof": "src/backends/ibm/ibmhttpclient.js~IBMHTTPClient",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/backends/ibm/ibmhttpclient.js~IBMHTTPClient.sleep",
    "access": "public",
    "description": null,
    "lineNumber": 42,
    "undocument": true,
    "params": [
      {
        "name": "interval",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 150,
    "kind": "method",
    "name": "send",
    "memberof": "src/backends/ibm/ibmhttpclient.js~IBMHTTPClient",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/backends/ibm/ibmhttpclient.js~IBMHTTPClient.send",
    "access": "public",
    "description": "Sends QASM through the IBM API and runs the quantum circuit.",
    "lineNumber": 60,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "info",
        "description": "Contains QASM representation of the circuit to run."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "device",
        "description": "Either 'simulator', 'ibmqx4', or 'ibmqx5'."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": "IBM quantum experience user."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "password",
        "description": "IBM quantum experience user password."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "shots",
        "description": "Number of runs of the same circuit to collect statistics."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "verbose",
        "description": "If true, additional information is printed, such as\nmeasurement statistics. Otherwise, the backend simply registers\none measurement result (same behavior as the projectq Simulator)."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 151,
    "kind": "method",
    "name": "authenticate",
    "memberof": "src/backends/ibm/ibmhttpclient.js~IBMHTTPClient",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/backends/ibm/ibmhttpclient.js~IBMHTTPClient.authenticate",
    "access": "public",
    "description": null,
    "lineNumber": 92,
    "undocument": true,
    "params": [
      {
        "name": "email",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": "",
        "defaultValue": ""
      },
      {
        "name": "password",
        "optional": true,
        "types": [
          "string"
        ],
        "defaultRaw": "",
        "defaultValue": ""
      }
    ],
    "return": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 152,
    "kind": "method",
    "name": "run",
    "memberof": "src/backends/ibm/ibmhttpclient.js~IBMHTTPClient",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/backends/ibm/ibmhttpclient.js~IBMHTTPClient.run",
    "access": "public",
    "description": null,
    "lineNumber": 98,
    "undocument": true,
    "params": [
      {
        "name": "qasm",
        "types": [
          "*"
        ]
      },
      {
        "name": "device",
        "types": [
          "*"
        ]
      },
      {
        "name": "user_id",
        "types": [
          "*"
        ]
      },
      {
        "name": "access_token",
        "types": [
          "*"
        ]
      },
      {
        "name": "shots",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 153,
    "kind": "method",
    "name": "getResult",
    "memberof": "src/backends/ibm/ibmhttpclient.js~IBMHTTPClient",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/backends/ibm/ibmhttpclient.js~IBMHTTPClient.getResult",
    "access": "public",
    "description": null,
    "lineNumber": 117,
    "undocument": true,
    "params": [
      {
        "name": "device",
        "types": [
          "*"
        ]
      },
      {
        "name": "execution_id",
        "types": [
          "*"
        ]
      },
      {
        "name": "access_token",
        "types": [
          "*"
        ]
      },
      {
        "name": "num_retries",
        "optional": true,
        "types": [
          "number"
        ],
        "defaultRaw": 3000,
        "defaultValue": "3000"
      },
      {
        "name": "interval",
        "optional": true,
        "types": [
          "number"
        ],
        "defaultRaw": 1,
        "defaultValue": "1"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 154,
    "kind": "file",
    "name": "src/backends/ibm/ibmhttpclient.spec.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport {expect} from 'chai'\r\n\r\nconst _api_url = 'https://quantumexperience.ng.bluemix.net/api/'\r\nconst _api_url_status = 'https://quantumexperience.ng.bluemix.net/api/'\r\n\r\ndescribe('ibm http client test', () => {\r\n  it('should test_send_real_device_online_verbose', () => {\r\n    const qasms = {'qasms': [{'qasm': 'my qasm'}]}\r\n    const json_qasm = JSON.stringify(qasms)\r\n    const name = 'projectq_test'\r\n    const access_token = 'access'\r\n    const user_id = 2016\r\n    const code_id = 11\r\n    const name_item = `\"name\":\"${name}\", \"jsonQASM\":`\r\n    const json_body = [name_item, json_qasm].join('')\r\n    const json_data = ['{', json_body, '}'].join('')\r\n    const shots = 1\r\n    const device = 'ibmqx4'\r\n    const json_data_run = ['{\"qasm\":', json_qasm, '}'].join('')\r\n    const execution_id = 3\r\n    const result_ready = [false]\r\n    const result = 'my_result'\r\n    const request_num = [0] // To assert correct order of calls\r\n  });\r\n})\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/backends/ibm/ibmhttpclient.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 155,
    "kind": "variable",
    "name": "_api_url",
    "memberof": "src/backends/ibm/ibmhttpclient.spec.js",
    "static": true,
    "longname": "src/backends/ibm/ibmhttpclient.spec.js~_api_url",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/backends/ibm/ibmhttpclient.spec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 156,
    "kind": "variable",
    "name": "_api_url_status",
    "memberof": "src/backends/ibm/ibmhttpclient.spec.js",
    "static": true,
    "longname": "src/backends/ibm/ibmhttpclient.spec.js~_api_url_status",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/backends/ibm/ibmhttpclient.spec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 157,
    "kind": "file",
    "name": "src/backends/printer.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/*\r\nContains a compiler engine which prints commands to stdout prior to sending\r\nthem on to the next engines (see CommandPrinter).\r\n*/\r\nimport assert from 'assert'\r\nimport {BasicEngine} from '../cengines/basics'\r\nimport {FlushGate, Measure} from '../ops/gates'\r\nimport {LogicalQubitIDTag} from '../meta/tag'\r\nimport {BasicQubit} from '../types/qubit'\r\nimport { LastEngineError } from '../meta/error'\r\n\r\n/**\r\n * @class CommandPrinter\r\n * @desc\r\n * CommandPrinter is a compiler engine which prints commands to stdout prior\r\n * to sending them on to the next compiler engine.\r\n */\r\nexport default class CommandPrinter extends BasicEngine {\r\n  /**\r\n   * @constructor\r\n  @param {boolean} acceptInput If accept_input is true, the printer queries\r\n  the user to input measurement results if the CommandPrinter is\r\n  the last engine. Otherwise, all measurements yield\r\n  @param {boolean} defaultMeasure Default measurement result (if accept_input is false).\r\n  @param {boolean} inPlace If in_place is true, all output is written on the same line of the terminal.\r\n  */\r\n  constructor(acceptInput = true, defaultMeasure = false, inPlace = false) {\r\n    super()\r\n    this._acceptInput = acceptInput\r\n    this._defaultMeasure = defaultMeasure\r\n    this._inPlace = inPlace\r\n  }\r\n\r\n  /**\r\n    Specialized implementation of isAvailable: Returns true if the\r\n    CommandPrinter is the last engine (since it can print any command).\r\n\r\n    @param {Command} cmd Command of which to check availability (all Commands can be printed).\r\n    @return {boolean} true, unless the next engine cannot handle the Command (if there is a next engine).\r\n   */\r\n  isAvailable(cmd) {\r\n    try {\r\n      return super.isAvailable(cmd)\r\n    } catch (e) {\r\n      if (e instanceof LastEngineError) {\r\n        return true\r\n      }\r\n    }\r\n    return false\r\n  }\r\n\r\n  /**\r\n    Print a command or, if the command is a measurement instruction and\r\n    the CommandPrinter is the last engine in the engine pipeline: Query\r\n    the user for the measurement result (if accept_input = true) / Set\r\n    the result to 0 (if it's false).\r\n\r\n    @param {Command} cmd Command to print.\r\n   */\r\n  printCMD(cmd) {\r\n    if (this.isLastEngine && cmd.gate.equal(Measure)) {\r\n      assert(cmd.controlCount === 0)\r\n      console.log(cmd.toString())\r\n      cmd.qubits.forEach((qureg) => {\r\n        qureg.forEach((qubit) => {\r\n          // ignore input\r\n          const m = this._defaultMeasure\r\n          let logicQubitTag\r\n          cmd.tags.forEach((tag) => {\r\n            if (tag instanceof LogicalQubitIDTag) {\r\n              logicQubitTag = tag\r\n            }\r\n          })\r\n\r\n          if (logicQubitTag) {\r\n            qubit = new BasicQubit(qubit.engine, logicQubitTag.logical_qubit_id)\r\n          }\r\n          this.main.setMeasurementResult(qubit, m)\r\n        })\r\n      })\r\n    } else if (this._inPlace) {\r\n      console.log(`\\0\\r\\t\\x1b[K${cmd.toString()}\\r`)\r\n    } else {\r\n      console.log(cmd.toString())\r\n    }\r\n  }\r\n\r\n  /**\r\n  Receive a list of commands from the previous engine, print the\r\ncommands, and then send them on to the next engine.\r\n\r\n    @param {Command[]} commandList List of Commands to print (and potentially send on to the next engine).\r\n   */\r\n  receive(commandList) {\r\n    commandList.forEach((cmd) => {\r\n      if (!(cmd.gate instanceof FlushGate)) {\r\n        this.printCMD(cmd)\r\n      }\r\n      if (!this.isLastEngine) {\r\n        this.send([cmd])\r\n      }\r\n    })\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/backends/printer.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 158,
    "kind": "class",
    "name": "CommandPrinter",
    "memberof": "src/backends/printer.js",
    "static": true,
    "longname": "src/backends/printer.js~CommandPrinter",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/backends/printer.js",
    "importStyle": "CommandPrinter",
    "description": "CommandPrinter is a compiler engine which prints commands to stdout prior\nto sending them on to the next compiler engine.",
    "lineNumber": 34,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "CommandPrinter"
      }
    ],
    "interface": false,
    "extends": [
      "src/cengines/basics.js~BasicEngine"
    ]
  },
  {
    "__docId__": 159,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/backends/printer.js~CommandPrinter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/printer.js~CommandPrinter#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 43,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "acceptInput",
        "description": "If accept_input is true, the printer queries\nthe user to input measurement results if the CommandPrinter is\nthe last engine. Otherwise, all measurements yield"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "defaultMeasure",
        "description": "Default measurement result (if accept_input is false)."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "inPlace",
        "description": "If in_place is true, all output is written on the same line of the terminal."
      }
    ]
  },
  {
    "__docId__": 160,
    "kind": "member",
    "name": "_acceptInput",
    "memberof": "src/backends/printer.js~CommandPrinter",
    "static": false,
    "longname": "src/backends/printer.js~CommandPrinter#_acceptInput",
    "access": "private",
    "description": null,
    "lineNumber": 45,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 161,
    "kind": "member",
    "name": "_defaultMeasure",
    "memberof": "src/backends/printer.js~CommandPrinter",
    "static": false,
    "longname": "src/backends/printer.js~CommandPrinter#_defaultMeasure",
    "access": "private",
    "description": null,
    "lineNumber": 46,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 162,
    "kind": "member",
    "name": "_inPlace",
    "memberof": "src/backends/printer.js~CommandPrinter",
    "static": false,
    "longname": "src/backends/printer.js~CommandPrinter#_inPlace",
    "access": "private",
    "description": null,
    "lineNumber": 47,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 163,
    "kind": "method",
    "name": "isAvailable",
    "memberof": "src/backends/printer.js~CommandPrinter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/printer.js~CommandPrinter#isAvailable",
    "access": "public",
    "description": "Specialized implementation of isAvailable: Returns true if the\nCommandPrinter is the last engine (since it can print any command).",
    "lineNumber": 57,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": "Command of which to check availability (all Commands can be printed)."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true, unless the next engine cannot handle the Command (if there is a next engine)."
    }
  },
  {
    "__docId__": 164,
    "kind": "method",
    "name": "printCMD",
    "memberof": "src/backends/printer.js~CommandPrinter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/printer.js~CommandPrinter#printCMD",
    "access": "public",
    "description": "Print a command or, if the command is a measurement instruction and\nthe CommandPrinter is the last engine in the engine pipeline: Query\nthe user for the measurement result (if accept_input = true) / Set\nthe result to 0 (if it's false).",
    "lineNumber": 76,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": "Command to print."
      }
    ],
    "return": null
  },
  {
    "__docId__": 165,
    "kind": "method",
    "name": "receive",
    "memberof": "src/backends/printer.js~CommandPrinter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/printer.js~CommandPrinter#receive",
    "access": "public",
    "description": "Receive a list of commands from the previous engine, print the\ncommands, and then send them on to the next engine.",
    "lineNumber": 110,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command[]"
        ],
        "spread": false,
        "optional": false,
        "name": "commandList",
        "description": "List of Commands to print (and potentially send on to the next engine)."
      }
    ],
    "return": null
  },
  {
    "__docId__": 166,
    "kind": "file",
    "name": "src/backends/printer.spec.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport {expect} from 'chai'\r\nimport CommandPrinter from './printer'\r\nimport {InstructionFilter} from '../cengines/replacer/replacer'\r\nimport MainEngine from '../cengines/main'\r\nimport {DummyEngine} from '../cengines/testengine'\r\nimport Command from '../ops/command'\r\nimport { tuple } from '../libs/util'\r\nimport {\n  H, T, Measure, NOT, Allocate\n} from '../ops/gates'\r\nimport { BasicQubit } from '../types/qubit'\r\nimport {LogicalQubitIDTag} from '../meta/tag'\r\n\r\ndescribe('printer test', () => {\n  it('should test_command_printer_is_available', () => {\r\n    const inline_cmd_printer = new CommandPrinter()\r\n    const cmd_printer = new CommandPrinter()\r\n\r\n    const available_cmd = function (eng, cmd) {\r\n      return cmd.gate.equal(H)\r\n    }\r\n\r\n    const filter = new InstructionFilter(available_cmd)\r\n    const eng = new MainEngine(cmd_printer, [inline_cmd_printer, filter])\r\n    const qubit = eng.allocateQubit()\r\n    const cmd0 = new Command(eng, H, tuple(qubit))\r\n    const cmd1 = new Command(eng, T, tuple(qubit))\r\n\r\n    expect(inline_cmd_printer.isAvailable(cmd0)).to.equal(true)\r\n    expect(inline_cmd_printer.isAvailable(cmd1)).to.equal(false)\r\n    expect(cmd_printer.isAvailable(cmd0)).to.equal(true)\r\n    expect(cmd_printer.isAvailable(cmd1)).to.equal(true)\r\n  });\r\n\r\n  it('should test_command_printer_no_input_default_measure', () => {\r\n    const cmd_printer = new CommandPrinter(false)\r\n    const eng = new MainEngine(cmd_printer, [new DummyEngine()])\r\n    const qubit = eng.allocateQubit()\r\n    NOT.or(qubit)\r\n    Measure.or(qubit)\r\n    expect(qubit.toNumber()).to.equal(0)\r\n  });\r\n\r\n  it('should test_command_printer_measure_mapped_qubit', () => {\r\n    const eng = new MainEngine(new CommandPrinter(false), [])\r\n    const qb1 = new BasicQubit(eng, 1)\r\n    const qb2 = new BasicQubit(eng, 2)\r\n    const cmd0 = new Command(eng, Allocate, tuple([qb1]))\r\n    const cmd1 = new Command(eng, Measure, tuple([qb1]), [], [new LogicalQubitIDTag(2)])\r\n\r\n    expect(() => qb1.toNumber()).to.throw()\r\n    expect(() => qb2.toNumber()).to.throw()\r\n\r\n    eng.send([cmd0, cmd1])\r\n    eng.flush()\r\n\r\n    expect(() => qb1.toNumber()).to.throw()\r\n    expect(qb2.toNumber()).to.equal(0)\r\n  });\r\n})\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/backends/printer.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 167,
    "kind": "file",
    "name": "src/backends/resource.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport { BasicEngine } from '../cengines/basics'\r\nimport { LastEngineError } from '../meta/error'\r\nimport {\r\n  Allocate, Deallocate, FlushGate, Measure\r\n} from '../ops/gates'\r\nimport { LogicalQubitIDTag } from '../meta/tag'\r\nimport { BasicQubit } from '../types/qubit'\r\n\r\nimport {genString} from '../libs/util'\r\n\r\nfunction parseStringKey(key) {\r\n  return key.split(',')\r\n}\r\n\r\n/**\r\n * @class ResourceCounter\r\n * @desc\r\nResourceCounter is a compiler engine which counts the number of gates and\r\nmax. number of active qubits.\r\n\r\n  Attributes:\r\ngate_counts (dict): Dictionary of gate counts.\r\n  The keys are tuples of the form (cmd.gate, ctrl_cnt), where\r\nctrl_cnt is the number of control qubits.\r\ngate_class_counts (dict): Dictionary of gate class counts.\r\nThe keys are tuples of the form (cmd.gate.__class__, ctrl_cnt),\r\n  where ctrl_cnt is the number of control qubits.\r\nmax_width (int): Maximal width (=max. number of active qubits at any\r\ngiven point).\r\nProperties:\r\n  depth_of_dag (int): It is the longest path in the directed\r\nacyclic graph (DAG) of the program.\r\n */\r\nexport default class ResourceCounter extends BasicEngine {\r\n  /**\r\n   * @constructor\r\n   */\r\n  constructor() {\r\n    super()\r\n    this.gate_counts = {}\r\n    this.gate_class_counts = {}\r\n    this._active_qubits = 0\r\n    this.max_width = 0\r\n    // key: qubit id, depth of this qubit\r\n    this._depth_of_qubit = {}\r\n    this._previous_max_depth = 0\r\n  }\r\n\r\n  /**\r\n    Specialized implementation of isAvailable: Returns true if the\r\n    ResourceCounter is the last engine (since it can count any command).\r\n\r\n    @param {Command} cmd Command for which to check availability (all Commands can be counted).\r\n    @return {boolean} true, unless the next engine cannot handle the Command (if there is a next engine).\r\n   */\r\n  isAvailable(cmd) {\r\n    try {\r\n      return super.isAvailable(cmd)\r\n    } catch (e) {\r\n      if (e instanceof LastEngineError) {\r\n        return true\r\n      }\r\n      return false\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @return {number}\r\n   */\r\n  get depthOfDag() {\r\n    if (this._depth_of_qubit) {\r\n      const current_max = Math.max(...Object.values(this._depth_of_qubit))\r\n      return Math.max(current_max, this._previous_max_depth)\r\n    } else {\r\n      return this._previous_max_depth\r\n    }\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {Command} cmd\r\n   */\r\n  addCMD(cmd) {\r\n    const qid = cmd.qubits[0][0].id\r\n    if (cmd.gate.equal(Allocate)) {\r\n      this._active_qubits += 1\r\n      this._depth_of_qubit[qid] = 0\r\n    } else if (cmd.gate.equal(Deallocate)) {\r\n      this._active_qubits -= 1\r\n      const depth = this._depth_of_qubit[qid]\r\n      this._previous_max_depth = Math.max(this._previous_max_depth, depth)\r\n      delete this._depth_of_qubit[qid]\r\n    } else if (this.isLastEngine && cmd.gate.equal(Measure)) {\r\n      cmd.qubits.forEach((qureg) => {\r\n        qureg.forEach((qubit) => {\r\n          this._depth_of_qubit[qubit.id] += 1\r\n          //  Check if a mapper assigned a different logical id\r\n          let logical_id_tag\r\n          cmd.tags.forEach((tag) => {\r\n            if (tag instanceof LogicalQubitIDTag) {\r\n              logical_id_tag = tag\r\n            }\r\n          })\r\n          if (logical_id_tag) {\r\n            qubit = new BasicQubit(qubit.engine, logical_id_tag.logical_qubit_id)\r\n          }\r\n          this.main.setMeasurementResult(qubit, 0)\r\n        })\r\n      })\r\n    } else {\r\n      const qubit_ids = new Set()\r\n      cmd.allQubits.forEach((qureg) => {\r\n        qureg.forEach((qubit) => {\r\n          qubit_ids.add(qubit.id)\r\n        })\r\n      })\r\n      if (qubit_ids.size === 1) {\r\n        const list = [...qubit_ids]\r\n        this._depth_of_qubit[list[0]] += 1\r\n      } else {\r\n        let max_depth = 0\r\n        qubit_ids.forEach((qubit_id) => {\r\n          max_depth = Math.max(max_depth, this._depth_of_qubit[qubit_id])\r\n        })\r\n\r\n        qubit_ids.forEach(qubit_id => this._depth_of_qubit[qubit_id] = max_depth + 1)\r\n      }\r\n    }\r\n\r\n    this.max_width = Math.max(this.max_width, this._active_qubits)\r\n\r\n    const ctrl_cnt = cmd.controlCount\r\n    const gate_description = [cmd.gate, ctrl_cnt]\r\n    const gate_class_description = [cmd.gate.constructor.name, ctrl_cnt]\r\n\r\n    try {\r\n      const v = this.gate_counts[gate_description] || 0\r\n      this.gate_counts[gate_description] = v + 1\r\n    } catch (e) {\r\n      console.log(e)\r\n      this.gate_counts[gate_description] = 1\r\n    }\r\n\r\n    try {\r\n      const v = this.gate_class_counts[gate_class_description] || 0\r\n      this.gate_class_counts[gate_class_description] = v + 1\r\n    } catch (e) {\r\n      console.log(e)\r\n      this.gate_class_counts[gate_class_description] = 1\r\n    }\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {Command[]} commandList\r\n   */\r\n  receive(commandList) {\r\n    commandList.forEach((cmd) => {\r\n      if (!(cmd.gate instanceof FlushGate)) {\r\n        this.addCMD(cmd)\r\n      }\r\n      if (!this.isLastEngine) {\r\n        this.send([cmd])\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n  Return the string representation of this ResourceCounter.\r\n\r\n  @return {string}\r\n    A summary (string) of resources used, including gates, number of\r\n    calls, and max. number of qubits that were active at the same time.\r\n   */\r\n  toString() {\r\n    if (Object.keys(this.gate_counts).length > 0) {\r\n      const gate_class_list = []\r\n      Object.keys(this.gate_class_counts).forEach((gate_class_description) => {\r\n        const num = this.gate_class_counts[gate_class_description]\r\n        const [gate_class, ctrl_cnt] = parseStringKey(gate_class_description)\r\n        const name = genString('C', ctrl_cnt) + gate_class\r\n        gate_class_list.push(`${name} : ${num}`)\r\n      })\r\n\r\n      const gate_list = []\r\n      Object.keys(this.gate_counts).forEach((gate_description) => {\r\n        const num = this.gate_counts[gate_description]\r\n        const [gate, ctrl_cnt] = parseStringKey(gate_description)\r\n        const name = genString('C', ctrl_cnt) + gate.toString()\r\n        gate_list.push(`${name} : ${num}`)\r\n      })\r\n\r\n      return `Gate class counts:\\n    ${gate_class_list.join('\\n    ')}\\n\\nGate counts:\\n    ${gate_list.join('\\n    ')}\\n\\nMax. width (number of qubits) : ${this.max_width}.`\r\n    } else {\r\n      return '(No quantum resources used)'\r\n    }\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/backends/resource.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 168,
    "kind": "function",
    "name": "parseStringKey",
    "memberof": "src/backends/resource.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/backends/resource.js~parseStringKey",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/backends/resource.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 169,
    "kind": "class",
    "name": "ResourceCounter",
    "memberof": "src/backends/resource.js",
    "static": true,
    "longname": "src/backends/resource.js~ResourceCounter",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/backends/resource.js",
    "importStyle": "ResourceCounter",
    "description": "ResourceCounter is a compiler engine which counts the number of gates and\nmax. number of active qubits.\n\nAttributes:\ngate_counts (dict): Dictionary of gate counts.\nThe keys are tuples of the form (cmd.gate, ctrl_cnt), where\nctrl_cnt is the number of control qubits.\ngate_class_counts (dict): Dictionary of gate class counts.\nThe keys are tuples of the form (cmd.gate.__class__, ctrl_cnt),\nwhere ctrl_cnt is the number of control qubits.\nmax_width (int): Maximal width (=max. number of active qubits at any\ngiven point).\nProperties:\ndepth_of_dag (int): It is the longest path in the directed\nacyclic graph (DAG) of the program.",
    "lineNumber": 50,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "ResourceCounter"
      }
    ],
    "interface": false,
    "extends": [
      "src/cengines/basics.js~BasicEngine"
    ]
  },
  {
    "__docId__": 170,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/backends/resource.js~ResourceCounter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/resource.js~ResourceCounter#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 54,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ]
  },
  {
    "__docId__": 171,
    "kind": "member",
    "name": "gate_counts",
    "memberof": "src/backends/resource.js~ResourceCounter",
    "static": false,
    "longname": "src/backends/resource.js~ResourceCounter#gate_counts",
    "access": "public",
    "description": null,
    "lineNumber": 56,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 172,
    "kind": "member",
    "name": "gate_class_counts",
    "memberof": "src/backends/resource.js~ResourceCounter",
    "static": false,
    "longname": "src/backends/resource.js~ResourceCounter#gate_class_counts",
    "access": "public",
    "description": null,
    "lineNumber": 57,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 173,
    "kind": "member",
    "name": "_active_qubits",
    "memberof": "src/backends/resource.js~ResourceCounter",
    "static": false,
    "longname": "src/backends/resource.js~ResourceCounter#_active_qubits",
    "access": "private",
    "description": null,
    "lineNumber": 58,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 174,
    "kind": "member",
    "name": "max_width",
    "memberof": "src/backends/resource.js~ResourceCounter",
    "static": false,
    "longname": "src/backends/resource.js~ResourceCounter#max_width",
    "access": "public",
    "description": null,
    "lineNumber": 59,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 175,
    "kind": "member",
    "name": "_depth_of_qubit",
    "memberof": "src/backends/resource.js~ResourceCounter",
    "static": false,
    "longname": "src/backends/resource.js~ResourceCounter#_depth_of_qubit",
    "access": "private",
    "description": null,
    "lineNumber": 61,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 176,
    "kind": "member",
    "name": "_previous_max_depth",
    "memberof": "src/backends/resource.js~ResourceCounter",
    "static": false,
    "longname": "src/backends/resource.js~ResourceCounter#_previous_max_depth",
    "access": "private",
    "description": null,
    "lineNumber": 62,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 177,
    "kind": "method",
    "name": "isAvailable",
    "memberof": "src/backends/resource.js~ResourceCounter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/resource.js~ResourceCounter#isAvailable",
    "access": "public",
    "description": "Specialized implementation of isAvailable: Returns true if the\nResourceCounter is the last engine (since it can count any command).",
    "lineNumber": 72,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": "Command for which to check availability (all Commands can be counted)."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true, unless the next engine cannot handle the Command (if there is a next engine)."
    }
  },
  {
    "__docId__": 178,
    "kind": "get",
    "name": "depthOfDag",
    "memberof": "src/backends/resource.js~ResourceCounter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/resource.js~ResourceCounter#depthOfDag",
    "access": "public",
    "description": "",
    "lineNumber": 86,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 179,
    "kind": "method",
    "name": "addCMD",
    "memberof": "src/backends/resource.js~ResourceCounter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/resource.js~ResourceCounter#addCMD",
    "access": "public",
    "description": "",
    "lineNumber": 99,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 184,
    "kind": "method",
    "name": "receive",
    "memberof": "src/backends/resource.js~ResourceCounter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/resource.js~ResourceCounter#receive",
    "access": "public",
    "description": "",
    "lineNumber": 173,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command[]"
        ],
        "spread": false,
        "optional": false,
        "name": "commandList",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 185,
    "kind": "method",
    "name": "toString",
    "memberof": "src/backends/resource.js~ResourceCounter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/resource.js~ResourceCounter#toString",
    "access": "public",
    "description": "Return the string representation of this ResourceCounter.",
    "lineNumber": 191,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "A summary (string) of resources used, including gates, number of\ncalls, and max. number of qubits that were active at the same time."
    },
    "params": []
  },
  {
    "__docId__": 186,
    "kind": "file",
    "name": "src/backends/resource.spec.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport {expect} from 'chai'\r\nimport ResourceCounter from './resource'\r\nimport {BasicQubit} from '../types/qubit';\r\nimport {instanceOf, tuple} from '../libs/util';\r\nimport MainEngine from '../cengines/main'\r\nimport {\r\n  Allocate, H, Measure, Rz, X\r\n} from '../ops/gates';\r\nimport Command from '../ops/command';\r\nimport {LogicalQubitIDTag} from '../meta/tag';\r\nimport {DummyEngine} from '../cengines/testengine';\r\nimport {CNOT} from '../ops/shortcuts';\r\nimport {All} from '../ops/metagates';\r\nimport {NotYetMeasuredError} from '../meta/error';\r\nimport {QFT} from '../ops/qftgate';\r\n\r\nclass MockEngine {\r\n  isAvailable(cmd) {\r\n    return false\r\n  }\r\n}\r\n\r\ndescribe('resource test', () => {\r\n  it('should test_resource_counter_isavailable', () => {\r\n    const resource_counter = new ResourceCounter()\r\n    resource_counter.next = new MockEngine()\r\n\r\n    expect(resource_counter.isAvailable('test')).to.equal(false)\r\n    resource_counter.next = null\r\n    resource_counter.isLastEngine = true\r\n\r\n    expect(resource_counter.isAvailable('test')).to.equal(true)\r\n  });\r\n\r\n  it('should test_resource_counter_measurement', () => {\r\n    const eng = new MainEngine(new ResourceCounter(), [])\r\n    const qb1 = new BasicQubit(eng, 1)\r\n    const qb2 = new BasicQubit(eng, 2)\r\n    const cmd0 = new Command(eng, Allocate, tuple([qb1]))\r\n    const cmd1 = new Command(eng, Measure, tuple([qb1]), [], [new LogicalQubitIDTag(2)])\r\n\r\n    expect(() => qb1.toNumber()).to.throw()\r\n    expect(() => qb2.toNumber()).to.throw()\r\n\r\n    eng.send([cmd0, cmd1])\r\n    eng.flush()\r\n    expect(() => qb1.toNumber()).to.throw()\r\n    expect(qb2.toNumber()).to.equal(0)\r\n  });\r\n\r\n  it('should test_resource_counter', () => {\r\n    const resource_counter = new ResourceCounter()\r\n    const backend = new DummyEngine(true)\r\n    const eng = new MainEngine(backend, [resource_counter])\r\n\r\n    const qubit1 = eng.allocateQubit()\r\n    const qubit2 = eng.allocateQubit()\r\n    H.or(qubit1)\r\n    X.or(qubit2)\r\n\r\n    qubit2.deallocate()\r\n\r\n    const qubit3 = eng.allocateQubit()\r\n    CNOT.or(tuple(qubit1, qubit3))\r\n    new Rz(0.1).or(qubit1)\r\n    new Rz(0.3).or(qubit1)\r\n\r\n    new All(Measure).or(qubit1.concat(qubit3))\r\n\r\n    expect(() => qubit1.toNumber()).to.throw(NotYetMeasuredError)\r\n\r\n    expect(resource_counter.max_width).to.equal(2)\r\n    expect(resource_counter.depthOfDag).to.equal(5)\r\n\r\n    const str_repr = resource_counter.toString()\r\n    console.log(str_repr)\r\n    const m = str_repr.match(/\\sHGate\\s:\\s1/g)\r\n    expect(m.length).to.equal(1)\r\n    expect(str_repr.match(/\\sXGate\\s:\\s1/g).length).to.equal(1)\r\n    expect(str_repr.match(/\\sCXGate\\s:\\s1/g).length).to.equal(1)\r\n    expect(str_repr.match(/\\sRz\\s:\\s2/g).length).to.equal(1)\r\n    expect(str_repr.match(/\\sAllocateQubitGate\\s:\\s3/g).length).to.equal(1)\r\n    expect(str_repr.match(/\\sDeallocateQubitGate\\s:\\s1/g).length).to.equal(1)\r\n\r\n    expect(str_repr.match(/\\sH\\s:\\s1/g).length).to.equal(1)\r\n    expect(str_repr.match(/\\sX\\s:\\s1/g).length).to.equal(1)\r\n    expect(str_repr.match(/\\sCX\\s:\\s1/g).length).to.equal(1)\r\n    expect(str_repr.match(/\\sRz\\(0.1\\)\\s:\\s1/g).length).to.equal(1)\r\n    expect(str_repr.match(/\\sRz\\(0.3\\)\\s:\\s1/g).length).to.equal(1)\r\n    expect(str_repr.match(/\\sAllocate\\s:\\s3/g).length).to.equal(1)\r\n    expect(str_repr.match(/\\sDeallocate\\s:\\s1/g).length).to.equal(1)\r\n\r\n    backend.receivedCommands.forEach(cmd => console.log(cmd.toString()))\r\n    const cmds = backend.receivedCommands\r\n    expect(cmds.filter(cmd => cmd.gate.equal(H)).length).to.equal(1)\r\n    expect(cmds.filter(cmd => cmd.gate.equal(X)).length).to.equal(2)\r\n    expect(cmds.filter(cmd => cmd.gate.equal(Measure)).length).to.equal(2)\r\n  })\r\n\r\n  it('should test_resource_counter_str_when_empty', () => {\r\n    expect(instanceOf(new ResourceCounter().toString(), String)).to.equal(true)\r\n  });\r\n\r\n  it('should test_resource_counter_depth_of_dag', () => {\r\n    const resource_counter = new ResourceCounter()\r\n    const eng = new MainEngine(resource_counter, [])\r\n    expect(resource_counter.depthOfDag).to.equal(0)\r\n\r\n    const qb0 = eng.allocateQubit()\r\n    const qb1 = eng.allocateQubit()\r\n    const qb2 = eng.allocateQubit()\r\n    QFT.or(qb0.concat(qb1, qb2))\r\n\r\n    expect(resource_counter.depthOfDag).to.equal(1)\r\n\r\n    H.or(qb0)\r\n    H.or(qb0)\r\n    expect(resource_counter.depthOfDag).to.equal(3)\r\n\r\n    CNOT.or(tuple(qb0, qb1))\r\n    X.or(qb1)\r\n    expect(resource_counter.depthOfDag).to.equal(5)\r\n    Measure.or(qb1)\r\n    Measure.or(qb1)\r\n    expect(resource_counter.depthOfDag).to.equal(7)\r\n\r\n    CNOT.or(tuple(qb1, qb2))\r\n    Measure.or(qb2)\r\n    expect(resource_counter.depthOfDag).to.equal(9)\r\n\r\n    qb1[0].deallocate()\r\n    qb2[0].deallocate()\r\n\r\n    expect(resource_counter.depthOfDag).to.equal(9)\r\n\r\n    qb0[0].deallocate()\r\n    expect(resource_counter.depthOfDag).to.equal(9)\r\n  });\r\n})\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/backends/resource.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 187,
    "kind": "class",
    "name": "MockEngine",
    "memberof": "src/backends/resource.spec.js",
    "static": true,
    "longname": "src/backends/resource.spec.js~MockEngine",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/backends/resource.spec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 188,
    "kind": "method",
    "name": "isAvailable",
    "memberof": "src/backends/resource.spec.js~MockEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/resource.spec.js~MockEngine#isAvailable",
    "access": "public",
    "description": null,
    "lineNumber": 34,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 189,
    "kind": "file",
    "name": "src/backends/simulators/classicalsimulator.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport assert from 'assert'\r\nimport bigInt from 'big-integer'\r\nimport { BasicEngine } from '../../cengines/basics'\r\nimport { BasicQubit } from '../../types/qubit'\r\nimport {\r\n  Allocate,\r\n  AllocateQubitGate, Deallocate,\r\n  DeallocateQubitGate,\r\n  FlushGate,\r\n  Measure,\r\n  MeasureGate,\r\n  XGate\r\n} from '../../ops/gates'\r\nimport { BasicMathGate } from '../../ops/basics'\r\nimport { LogicalQubitIDTag } from '../../meta/tag'\r\nimport { instanceOf } from '../../libs/util'\r\n\r\n/**\r\n * @class ClassicalSimulator\r\n * @desc\r\nA simple introspective simulator that only permits classical operations.\r\n\r\n  Allows allocation, deallocation, measuring (no-op), flushing (no-op),\r\n  controls, NOTs, and any BasicMathGate. Supports reading/writing directly\r\nfrom/to bits and registers of bits.\r\n */\r\nexport default class ClassicalSimulator extends BasicEngine {\r\n  /**\r\n   * @constructor\r\n   */\r\n  constructor() {\r\n    super();\r\n    this._state = bigInt(0)\r\n    this._bit_positions = {}\r\n  }\r\n\r\n  /**\r\n  Converts a qubit from a logical to a mapped qubit if there is a mapper.\r\n\r\n  @param {Qubit} qubit Logical quantum bit\r\n   */\r\n  convertLogicalToMappedQubit(qubit) {\r\n    const {mapper} = this.main\r\n    if (mapper) {\r\n      const v = mapper.currentMapping[qubit.id]\r\n      if (typeof v === 'undefined') {\r\n        throw new Error('Unknown qubit id. '\r\n        + 'Please make sure you have called '\r\n        + 'eng.flush().')\r\n      }\r\n      return new BasicQubit(qubit.engine, v)\r\n    } else {\r\n      return qubit\r\n    }\r\n  }\r\n\r\n  /**\r\n  Reads a bit.\r\n\r\n  Note:\r\nIf there is a mapper present in the compiler, this function\r\nautomatically converts from logical qubits to mapped qubits for\r\n  the qureg argument.\r\n\r\n  @param {Qubit} qubit The bit to read.\r\n\r\n  @return {number} 0 if the target bit is off, 1 if it's on.\r\n   */\r\n  readBit(qubit) {\r\n    qubit = this.convertLogicalToMappedQubit(qubit)\r\n    return this.readMappedBit(qubit)\r\n  }\r\n\r\n  // Internal use only. Does not change logical to mapped qubits.\r\n  readMappedBit(mappedQubit) {\r\n    const p = this._bit_positions[mappedQubit.id]\r\n    return this._state.shiftRight(p).and(1).toJSNumber()\r\n  }\r\n\r\n  /**\r\n  Resets/sets a bit to the given value.\r\n\r\n  Note:\r\nIf there is a mapper present in the compiler, this function\r\nautomatically converts from logical qubits to mapped qubits for\r\n  the qureg argument.\r\n\r\n    @param {Qubit} qubit The bit to write.\r\n    @param {boolean|number} value Writes 1 if this value is truthy, else 0.\r\n  */\r\n  writeBit(qubit, value) {\r\n    qubit = this.convertLogicalToMappedQubit(qubit)\r\n    this.writeMappedBit(qubit, value)\r\n  }\r\n\r\n  // Internal use only. Does not change logical to mapped qubits.\r\n  writeMappedBit(mappedQubit, value) {\r\n    const p = this._bit_positions[mappedQubit.id]\r\n    if (value) {\r\n      this._state = this._state.or(bigInt(1).shiftLeft(p))\r\n    } else {\r\n      const temp = bigInt(1).shiftLeft(p).not()\r\n      this._state = this._state.and(temp)\r\n    }\r\n  }\r\n\r\n  /**\r\n  Returns a mask, to compare against the state, with bits from the\r\nregister set to 1 and other bits set to 0.\r\n\r\n@param {Qureg} qureg The bits whose positions should be set.\r\n\r\n  @return {number} The mask.\r\n   */\r\n  mask(qureg) {\r\n    let t = 0\r\n    qureg.forEach(q => t |= 1 << this._bit_positions[q.id])\r\n    return t\r\n  }\r\n\r\n  /**\r\n  Reads a group of bits as a little-endian integer.\r\n\r\n  Note:\r\nIf there is a mapper present in the compiler, this function\r\nautomatically converts from logical qubits to mapped qubits for\r\n  the qureg argument.\r\n\r\n  @param {Qureg} qureg The group of bits to read, in little-endian order.\r\n\r\n  @return {number} Little-endian register value.\r\n   */\r\n  readRegister(qureg) {\r\n    const new_qureg = []\r\n    qureg.forEach(qubit => new_qureg.push(this.convertLogicalToMappedQubit(qubit)))\r\n    return this.readMappedRegister(new_qureg)\r\n  }\r\n\r\n  readMappedRegister(mappedQureg) {\r\n    let t = 0\r\n    mappedQureg.forEach((_, i) => t |= this.readMappedBit(mappedQureg[i]) << i)\r\n    return t\r\n  }\r\n\r\n  /**\r\n  Sets a group of bits to store a little-endian integer value.\r\n\r\n  Note:\r\nIf there is a mapper present in the compiler, this function\r\nautomatically converts from logical qubits to mapped qubits for\r\n  the qureg argument.\r\n\r\n   @param {Qureg} qureg  The bits to write, in little-endian order.\r\n   @param {number} value  The integer value to store. Must fit in the register.\r\n   */\r\n  writeRegister(qureg, value) {\r\n    const new_qureg = []\r\n    qureg.forEach(qubit => new_qureg.push(this.convertLogicalToMappedQubit(qubit)))\r\n    this.writeMappedRegister(new_qureg, value)\r\n  }\r\n\r\n  writeMappedRegister(mappedQureg, value) {\r\n    if (value < 0 || value >= (2 ** mappedQureg.length)) {\r\n      throw new Error(\"Value won't fit in register.\")\r\n    }\r\n    mappedQureg.forEach((_, i) => this.writeMappedBit(mappedQureg[i], (value >> i) & 1))\r\n  }\r\n\r\n  isAvailable(cmd) {\r\n    return instanceOf(cmd.gate, [MeasureGate, AllocateQubitGate, DeallocateQubitGate, BasicMathGate, FlushGate, XGate])\r\n  }\r\n\r\n  receive(commandList) {\r\n    commandList.forEach((cmd) => {\r\n      this.handle(cmd)\r\n    })\r\n    if (!this.isLastEngine) {\r\n      this.send(commandList)\r\n    }\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {Command} cmd\r\n   */\r\n  handle(cmd) {\r\n    if (cmd.gate instanceof FlushGate) {\r\n      return\r\n    }\r\n\r\n    if (cmd.gate.equal(Measure)) {\r\n      cmd.qubits.forEach(qr => qr.forEach((qb) => {\r\n        // Check if a mapper assigned a different logical id\r\n        let logical_id_tag\r\n        cmd.tags.forEach((tag) => {\r\n          if (tag instanceof LogicalQubitIDTag) {\r\n            logical_id_tag = tag\r\n          }\r\n        })\r\n        let log_qb = qb\r\n        if (logical_id_tag) {\r\n          log_qb = new BasicQubit(qb.engine, logical_id_tag.logical_qubit_id)\r\n        }\r\n        this.main.setMeasurementResult(log_qb, this.readMappedBit(qb))\r\n      }))\r\n      return\r\n    }\r\n\r\n    if (cmd.gate.equal(Allocate)) {\r\n      const newID = cmd.qubits[0][0].id\r\n      this._bit_positions[newID] = Object.keys(this._bit_positions).length\r\n      return\r\n    }\r\n    if (cmd.gate.equal(Deallocate)) {\r\n      const old_id = cmd.qubits[0][0].id\r\n      const pos = this._bit_positions[old_id]\r\n      const low = (1 << pos) - 1\r\n      this._state = this._state.and(low).or(this._state.shiftRight(1).and(~low))\r\n      const newpos = {}\r\n      Object.keys(this._bit_positions).forEach((k) => {\r\n        const b = this._bit_positions[k]\r\n        if (b < pos) {\r\n          newpos[k] = b\r\n        } else {\r\n          newpos[k] = b - 1\r\n        }\r\n      })\r\n      this._bit_positions = newpos\r\n      return\r\n    }\r\n\r\n    const controls_mask = this.mask(cmd.controlQubits)\r\n    const meets_controls = this._state.and(controls_mask).eq(bigInt(controls_mask))\r\n\r\n    if (cmd.gate instanceof XGate) {\r\n      assert(cmd.qubits.length === 1 && cmd.qubits[0].length === 1)\r\n      const target = cmd.qubits[0][0]\r\n      if (meets_controls) {\r\n        this.writeMappedBit(target, !this.readMappedBit(target))\r\n      }\r\n      return\r\n    }\r\n\r\n    if (cmd.gate instanceof BasicMathGate) {\r\n      if (meets_controls) {\r\n        const ins = cmd.qubits.map(reg => this.readMappedRegister(reg))\r\n        const outs = cmd.gate.getMathFunction(cmd.qubits)(ins)\r\n        cmd.qubits.forEach((reg, index) => {\r\n          const out = outs[index]\r\n          this.writeMappedRegister(reg, out & ((1 << reg.length) - 1))\r\n        })\r\n      }\r\n      return\r\n    }\r\n    throw new Error('Only support alloc/dealloc/measure/not/math ops.')\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/backends/simulators/classicalsimulator.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 190,
    "kind": "class",
    "name": "ClassicalSimulator",
    "memberof": "src/backends/simulators/classicalsimulator.js",
    "static": true,
    "longname": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/backends/simulators/classicalsimulator.js",
    "importStyle": "ClassicalSimulator",
    "description": "A simple introspective simulator that only permits classical operations.\n\nAllows allocation, deallocation, measuring (no-op), flushing (no-op),\ncontrols, NOTs, and any BasicMathGate. Supports reading/writing directly\nfrom/to bits and registers of bits.",
    "lineNumber": 43,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "ClassicalSimulator"
      }
    ],
    "interface": false,
    "extends": [
      "src/cengines/basics.js~BasicEngine"
    ]
  },
  {
    "__docId__": 191,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 47,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ]
  },
  {
    "__docId__": 192,
    "kind": "member",
    "name": "_state",
    "memberof": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator",
    "static": false,
    "longname": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator#_state",
    "access": "private",
    "description": null,
    "lineNumber": 49,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 193,
    "kind": "member",
    "name": "_bit_positions",
    "memberof": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator",
    "static": false,
    "longname": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator#_bit_positions",
    "access": "private",
    "description": null,
    "lineNumber": 50,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 194,
    "kind": "method",
    "name": "convertLogicalToMappedQubit",
    "memberof": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator#convertLogicalToMappedQubit",
    "access": "public",
    "description": "Converts a qubit from a logical to a mapped qubit if there is a mapper.",
    "lineNumber": 58,
    "params": [
      {
        "nullable": null,
        "types": [
          "Qubit"
        ],
        "spread": false,
        "optional": false,
        "name": "qubit",
        "description": "Logical quantum bit"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 195,
    "kind": "method",
    "name": "readBit",
    "memberof": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator#readBit",
    "access": "public",
    "description": "Reads a bit.\n\nNote:\nIf there is a mapper present in the compiler, this function\nautomatically converts from logical qubits to mapped qubits for\nthe qureg argument.",
    "lineNumber": 85,
    "params": [
      {
        "nullable": null,
        "types": [
          "Qubit"
        ],
        "spread": false,
        "optional": false,
        "name": "qubit",
        "description": "The bit to read."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "0 if the target bit is off, 1 if it's on."
    }
  },
  {
    "__docId__": 196,
    "kind": "method",
    "name": "readMappedBit",
    "memberof": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator#readMappedBit",
    "access": "public",
    "description": null,
    "lineNumber": 91,
    "undocument": true,
    "params": [
      {
        "name": "mappedQubit",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 197,
    "kind": "method",
    "name": "writeBit",
    "memberof": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator#writeBit",
    "access": "public",
    "description": "Resets/sets a bit to the given value.\n\nNote:\nIf there is a mapper present in the compiler, this function\nautomatically converts from logical qubits to mapped qubits for\nthe qureg argument.",
    "lineNumber": 107,
    "params": [
      {
        "nullable": null,
        "types": [
          "Qubit"
        ],
        "spread": false,
        "optional": false,
        "name": "qubit",
        "description": "The bit to write."
      },
      {
        "nullable": null,
        "types": [
          "boolean",
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "Writes 1 if this value is truthy, else 0."
      }
    ],
    "return": null
  },
  {
    "__docId__": 198,
    "kind": "method",
    "name": "writeMappedBit",
    "memberof": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator#writeMappedBit",
    "access": "public",
    "description": null,
    "lineNumber": 113,
    "undocument": true,
    "params": [
      {
        "name": "mappedQubit",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 201,
    "kind": "method",
    "name": "mask",
    "memberof": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator#mask",
    "access": "public",
    "description": "Returns a mask, to compare against the state, with bits from the\nregister set to 1 and other bits set to 0.",
    "lineNumber": 131,
    "params": [
      {
        "nullable": null,
        "types": [
          "Qureg"
        ],
        "spread": false,
        "optional": false,
        "name": "qureg",
        "description": "The bits whose positions should be set."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "The mask."
    }
  },
  {
    "__docId__": 202,
    "kind": "method",
    "name": "readRegister",
    "memberof": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator#readRegister",
    "access": "public",
    "description": "Reads a group of bits as a little-endian integer.\n\nNote:\nIf there is a mapper present in the compiler, this function\nautomatically converts from logical qubits to mapped qubits for\nthe qureg argument.",
    "lineNumber": 149,
    "params": [
      {
        "nullable": null,
        "types": [
          "Qureg"
        ],
        "spread": false,
        "optional": false,
        "name": "qureg",
        "description": "The group of bits to read, in little-endian order."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Little-endian register value."
    }
  },
  {
    "__docId__": 203,
    "kind": "method",
    "name": "readMappedRegister",
    "memberof": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator#readMappedRegister",
    "access": "public",
    "description": null,
    "lineNumber": 155,
    "undocument": true,
    "params": [
      {
        "name": "mappedQureg",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 204,
    "kind": "method",
    "name": "writeRegister",
    "memberof": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator#writeRegister",
    "access": "public",
    "description": "Sets a group of bits to store a little-endian integer value.\n\nNote:\nIf there is a mapper present in the compiler, this function\nautomatically converts from logical qubits to mapped qubits for\nthe qureg argument.",
    "lineNumber": 172,
    "params": [
      {
        "nullable": null,
        "types": [
          "Qureg"
        ],
        "spread": false,
        "optional": false,
        "name": "qureg",
        "description": "The bits to write, in little-endian order."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "The integer value to store. Must fit in the register."
      }
    ],
    "return": null
  },
  {
    "__docId__": 205,
    "kind": "method",
    "name": "writeMappedRegister",
    "memberof": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator#writeMappedRegister",
    "access": "public",
    "description": null,
    "lineNumber": 178,
    "undocument": true,
    "params": [
      {
        "name": "mappedQureg",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 206,
    "kind": "method",
    "name": "isAvailable",
    "memberof": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator#isAvailable",
    "access": "public",
    "description": null,
    "lineNumber": 185,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 207,
    "kind": "method",
    "name": "receive",
    "memberof": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator#receive",
    "access": "public",
    "description": null,
    "lineNumber": 189,
    "undocument": true,
    "params": [
      {
        "name": "commandList",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 208,
    "kind": "method",
    "name": "handle",
    "memberof": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/classicalsimulator.js~ClassicalSimulator#handle",
    "access": "public",
    "description": "",
    "lineNumber": 202,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 211,
    "kind": "file",
    "name": "src/backends/simulators/classicalsimulator.spec.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport {expect} from 'chai'\r\nimport BasicMapperEngine from '../../cengines/basicmapper'\r\nimport MainEngine from '../../cengines/main'\r\nimport ClassicalSimulator from './classicalsimulator'\r\nimport { tuple } from '../../libs/util'\r\nimport {\r\n  Measure, NOT, X, Y\r\n} from '../../ops/gates'\r\nimport { All, C } from '../../ops/metagates'\r\nimport { BasicMathGate } from '../../ops/basics'\r\nimport { AutoReplacer } from '../../cengines/replacer/replacer'\r\nimport DecompositionRuleSet from '../../cengines/replacer/decompositionruleset'\r\nimport { BasicQubit } from '../../types/qubit'\r\nimport { DummyEngine } from '../../cengines/testengine'\r\nimport {TrivialMapper} from './shared.spec'\r\n\r\ndescribe('classical simulator test', () => {\r\n  const mapper = new TrivialMapper()\r\n  it('should test_simulator_read_write', () => {\r\n    const engine_list = []\r\n\r\n    if (mapper) {\r\n      engine_list.push(mapper)\r\n    }\r\n    const sim = new ClassicalSimulator()\r\n    const eng = new MainEngine(sim, engine_list)\r\n    const a = eng.allocateQureg(32)\r\n    const b = eng.allocateQureg(32)\r\n\r\n    expect(sim.readRegister(a)).to.equal(0)\r\n    expect(sim.readRegister(b)).to.equal(0)\r\n    expect(sim.readBit(a[0]).toString()).to.equal('0')\r\n    expect(sim.readBit(b[0]).toString()).to.equal('0')\r\n\r\n    sim.writeRegister(a, 123)\r\n    sim.writeRegister(b, 456)\r\n    expect(sim.readRegister(a)).to.equal(123)\r\n    expect(sim.readRegister(b)).to.equal(456)\r\n    expect(sim.readBit(a[0])).to.equal(1)\r\n    expect(sim.readBit(b[0])).to.equal(0)\r\n\r\n    sim.writeBit(b[0], 1)\r\n    expect(sim.readRegister(a)).to.equal(123)\r\n    expect(sim.readRegister(b)).to.equal(457)\r\n    expect(sim.readBit(a[0])).to.equal(1)\r\n    expect(sim.readBit(b[0])).to.equal(1)\r\n  });\r\n\r\n  it('should test_simulator_triangle_increment_cycle', () => {\r\n    const engine_list = []\r\n    if (mapper) {\r\n      engine_list.push(mapper)\r\n    }\r\n    const sim = new ClassicalSimulator()\r\n    const eng = new MainEngine(sim, engine_list)\r\n\r\n    const a = eng.allocateQureg(6)\r\n    for (let t = 0; t < 1 << 6; ++t) {\r\n      expect(sim.readRegister(a)).to.equal(t)\r\n      for (let i = 5; i >= 0; --i) {\r\n        C(X, i).or(tuple(a.slice(0, i), a[i]))\r\n      }\r\n    }\r\n    expect(sim.readRegister(a)).to.equal(0)\r\n  });\r\n\r\n  it('should test_simulator_bit_repositioning', () => {\r\n    const engine_list = []\r\n    if (mapper) {\r\n      engine_list.push(mapper)\r\n    }\r\n    const sim = new ClassicalSimulator()\r\n    const eng = new MainEngine(sim, engine_list)\r\n    const a = eng.allocateQureg(4)\r\n    const b = eng.allocateQureg(5)\r\n    const c = eng.allocateQureg(6)\r\n    sim.writeRegister(a, 9)\r\n    sim.writeRegister(b, 17)\r\n    sim.writeRegister(c, 33)\r\n    b.forEach(q => eng.deallocateQubit(q))\r\n    expect(sim.readRegister(a)).to.equal(9)\r\n    expect(sim.readRegister(c)).to.equal(33)\r\n  });\r\n\r\n  it('should test_simulator_arithmetic', () => {\r\n    class Offset extends BasicMathGate {\r\n      constructor(amount) {\r\n        super(x => [x + amount])\r\n      }\r\n    }\r\n\r\n    class Sub extends BasicMathGate {\r\n      constructor() {\r\n        super((x, y) => [x, y - x])\r\n      }\r\n    }\r\n\r\n    const engine_list = []\r\n    if (mapper) {\r\n      engine_list.push(mapper)\r\n    }\r\n    const sim = new ClassicalSimulator()\r\n    const eng = new MainEngine(sim, engine_list)\r\n    const a = eng.allocateQureg(4)\r\n    const b = eng.allocateQureg(5)\r\n    sim.writeRegister(a, 9)\r\n    sim.writeRegister(b, 17)\r\n\r\n    new Offset(2).or(a)\r\n    expect(sim.readRegister(a)).to.equal(11)\r\n    expect(sim.readRegister(b)).to.equal(17)\r\n\r\n    new Offset(3).or(b)\r\n    expect(sim.readRegister(a)).to.equal(11)\r\n    expect(sim.readRegister(b)).to.equal(20)\r\n\r\n    new Offset(32 + 5).or(b)\r\n    expect(sim.readRegister(a)).to.equal(11)\r\n    expect(sim.readRegister(b)).to.equal(25)\r\n\r\n    new Sub().or(tuple(a, b))\r\n    expect(sim.readRegister(a)).to.equal(11)\r\n    expect(sim.readRegister(b)).to.equal(14)\r\n\r\n    new Sub().or(tuple(a, b))\r\n    new Sub().or(tuple(a, b))\r\n    expect(sim.readRegister(a)).to.equal(11)\r\n    expect(sim.readRegister(b)).to.equal(24)\r\n\r\n    // also test via measurement:\r\n    new All(Measure).or(a.concat(b))\r\n    eng.flush()\r\n\r\n    for (let i = 0; i < a.length; ++i) {\r\n      expect(a[i].toNumber()).to.equal((11 >> i) & 1)\r\n    }\r\n    for (let i = 0; i < b.length; ++i) {\r\n      expect(b[i].toNumber()).to.equal((24 >> i) & 1)\r\n    }\r\n  });\r\n\r\n  it('should test_writeRegister_value_error_exception', () => {\r\n    const engine_list = []\r\n    if (mapper) {\r\n      engine_list.push(mapper)\r\n    }\r\n\r\n    const sim = new ClassicalSimulator()\r\n    const eng = new MainEngine(sim, engine_list)\r\n    const a = eng.allocateQureg(3)\r\n    expect(() => {\r\n      sim.writeRegister(a, -2)\r\n    }).to.throw()\r\n\r\n    sim.writeRegister(a, 7)\r\n    expect(() => sim.writeRegister(a, 8)).to.throw()\r\n  });\r\n\r\n  it('should test_available_gates', () => {\r\n    const sim = new ClassicalSimulator()\r\n    const eng = new MainEngine(sim, [new AutoReplacer(new DecompositionRuleSet())])\r\n    const a = eng.allocateQubit()\r\n    X.or(a)\r\n    NOT.or(a)\r\n    Measure.or(a)\r\n    eng.flush()\r\n  })\r\n\r\n  it('should test_gates_are_forwarded_to_next_engine', () => {\r\n    const sim = new ClassicalSimulator()\r\n    const saving_eng = new DummyEngine(true)\r\n    const eng = new MainEngine(saving_eng, [sim])\r\n    const a = eng.allocateQubit()\r\n    X.or(a)\r\n    a[0].deallocate()\r\n    expect(saving_eng.receivedCommands.length).to.equal(3)\r\n  })\r\n\r\n  it('should test_wrong_gate', () => {\r\n    const sim = new ClassicalSimulator()\r\n    const eng = new MainEngine(sim, [])\r\n    const a = eng.allocateQubit()\r\n    expect(() => Y.or(a)).to.throw()\r\n  });\r\n\r\n  it('should test_runtime_error', () => {\r\n    const sim = new ClassicalSimulator()\r\n    const mapperEngine = new BasicMapperEngine()\r\n    mapperEngine.currentMapping = {}\r\n    const eng = new MainEngine(sim, [mapperEngine])\r\n    expect(() => eng.backend.readBit(new BasicQubit(null, 1))).to.throw()\r\n  });\r\n})\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/backends/simulators/classicalsimulator.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 212,
    "kind": "file",
    "name": "src/backends/simulators/cppsim.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nconst ext = require('../../../scripts/extensions')\r\nconst path = ext.getBinaryPath()\r\n\r\nconst All = require(path)\r\n\r\nexport default All\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/backends/simulators/cppsim.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 213,
    "kind": "variable",
    "name": "ext",
    "memberof": "src/backends/simulators/cppsim.js",
    "static": true,
    "longname": "src/backends/simulators/cppsim.js~ext",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/backends/simulators/cppsim.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 214,
    "kind": "variable",
    "name": "path",
    "memberof": "src/backends/simulators/cppsim.js",
    "static": true,
    "longname": "src/backends/simulators/cppsim.js~path",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/backends/simulators/cppsim.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 215,
    "kind": "variable",
    "name": "All",
    "memberof": "src/backends/simulators/cppsim.js",
    "static": true,
    "longname": "src/backends/simulators/cppsim.js~All",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/backends/simulators/cppsim.js",
    "importStyle": "All",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 216,
    "kind": "file",
    "name": "src/backends/simulators/jssim.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/*\r\nContains a (slow) JavaScript simulator.\r\n\r\n    Please compile the c++ simulator for large-scale simulations.\r\n*/\r\nimport assert from 'assert'\r\nimport math from 'mathjs'\r\nimport {\r\n  matrixDot,\r\n  matrixRangeAssign,\r\n  matrixRangeIndicesAssign,\r\n  zeros\r\n} from '../../libs/util'\r\nimport {\r\n  len, setEqual, complexVectorDot\r\n} from '../../libs/polyfill'\r\nimport { stringToArray } from '../../ops/qubitoperator'\r\n\r\n/**\r\n * @class JSSimulator\r\n * @desc\r\nNodeJS implementation of a quantum computer simulator.\r\n\r\n    This Simulator can be used as a backup if compiling the c++ simulator is\r\nnot an option (for some reason). It has the same features but is much\r\nslower, so please consider building the c++ version for larger experiments.\r\n */\r\nexport default class Simulator {\r\n  /**\r\n   * @constructor\r\n   */\r\n  constructor() {\r\n    // ignore seed\r\n    this._state = math.ones(1)\r\n    this._map = {}\r\n    this._numQubits = 0\r\n  }\r\n\r\n  /**\r\n  Return the qubit index to bit location map and the corresponding state\r\nvector.\r\n\r\n    This function can be used to measure expectation values more efficiently (emulation).\r\n\r\n    @return {Array}\r\nA tuple where the first entry is a dictionary mapping qubit indices\r\nto bit-locations and the second entry is the corresponding state\r\nvector\r\n   */\r\n  cheat() {\r\n    return [this._map, this._state._data.slice(0)]\r\n  }\r\n\r\n  /**\r\n  Measure the qubits with IDs ids and return a list of measurement\r\noutcomes (true/false).\r\n\r\n    @param {number[]} ids List of qubit IDs to measure.\r\n\r\n    @return {boolean[]} List of measurement results (containing either true or false).\r\n   */\r\n  measureQubits(ids) {\r\n    const P = Math.random()\r\n    let val = 0.0\r\n    let i_picked = 0\r\n    while (val < P && i_picked < len(this._state)) {\r\n      val = math.add(val, math.abs(this._getState(i_picked) || math.complex(0, 0)) ** 2)\r\n      i_picked += 1\r\n    }\r\n\r\n    i_picked -= 1\r\n\r\n    const res = []\r\n    const pos = ids.map((ID) => {\r\n      res.push(false)\r\n      return this._map[ID]\r\n    })\r\n\r\n    let mask = 0\r\n    val = 0\r\n\r\n    pos.forEach((looper, i) => {\r\n      res[i] = ((i_picked >> looper) & 1) === 1\r\n      mask |= (1 << looper)\r\n      val |= ((res[i] & 1) << looper)\r\n    })\r\n\r\n    let nrm = 0.0\r\n    this._state.forEach((looper, _i) => {\r\n      const i = _i[0]\r\n      if ((mask & i) !== val) {\r\n        this._setState(i, 0.0)\r\n      } else {\r\n        const tmp = math.abs(looper)\r\n        nrm = math.add(nrm, math.multiply(tmp, tmp))\r\n      }\r\n    })\r\n    // normalize\r\n    const scale = 1.0 / Math.sqrt(nrm)\r\n    this._state = math.multiply(this._state, scale)\r\n    return res\r\n  }\r\n\r\n  /**\r\n  Allocate a qubit.\r\n\r\n    @param {number} ID ID of the qubit which is being allocated.\r\n   */\r\n  allocateQubit(ID) {\r\n    this._map[ID] = this._numQubits\r\n    this._numQubits += 1\r\n    this._state.resize([1 << this._numQubits], 0)\r\n  }\r\n\r\n  /**\r\n  Return the classical value of a classical bit (i.e., a qubit which has\r\nbeen measured / uncomputed).\r\n\r\n   @param {number} ID ID of the qubit of which to get the classical value.\r\n   @param {number} tolerance Tolerance for numerical errors when determining\r\nwhether the qubit is indeed classical.\r\n\r\n    @throws {Error} If the qubit is in a superposition, i.e., has not been measured / uncomputed.\r\n*/\r\n  getClassicalValue(ID, tolerance = 1.e-10) {\r\n    const pos = this._map[ID]\r\n    let up = false\r\n    let down = false\r\n\r\n    for (let i = 0; i < len(this._state); i += (1 << (pos + 1))) {\r\n      for (let j = 0; j < (1 << pos); ++j) {\r\n        if (math.abs(this._getState(i + j)) > tolerance) {\r\n          up = true\r\n        }\r\n\r\n        if (math.abs(this._getState(i + j + (1 << pos)) || 0) > tolerance) {\r\n          down = true\r\n        }\r\n\r\n        if (up && down) {\r\n          throw new Error('Qubit has not been measured / '\r\n          + 'uncomputed. Cannot access its '\r\n          + 'classical value and/or deallocate a '\r\n          + 'qubit in superposition!')\r\n        }\r\n      }\r\n    }\r\n\r\n    return down\r\n  }\r\n\r\n  /**\r\n  Deallocate a qubit (if it has been measured / uncomputed).\r\n\r\n   @param {number} ID ID of the qubit to deallocate.\r\n\r\n   @throws {Error} If the qubit is in a superposition, i.e., has not been measured / uncomputed.\r\n   */\r\n  deallocateQubit(ID) {\r\n    const pos = this._map[ID]\r\n    const cv = this.getClassicalValue(ID)\r\n    const newstate = math.zeros(1 << (this._numQubits - 1))\r\n    let k = 0\r\n    for (let i = (1 << pos) * cv; i < len(this._state); i += 1 << (pos + 1)) {\r\n      matrixRangeIndicesAssign(newstate, k, k + (1 << pos), this._state, i)\r\n      k += (1 << pos)\r\n    }\r\n\r\n    const newmap = {}\r\n    Object.keys(this._map).forEach((key) => {\r\n      const value = this._map[key]\r\n      if (value > pos) {\r\n        newmap[key] = value - 1\r\n      } else if (parseInt(key, 10) !== ID) {\r\n        newmap[key] = value\r\n      }\r\n    })\r\n\r\n    this._map = newmap\r\n    this._state = newstate\r\n    this._numQubits -= 1\r\n  }\r\n\r\n  /**\r\n  Get control mask from list of control qubit IDs.\r\n\r\n    @return {number} A mask which represents the control qubits in binary.\r\n   */\r\n  getControlMask(ctrlids) {\r\n    let mask = 0\r\n    ctrlids.forEach((ctrlid) => {\r\n      const ctrlpos = this._map[ctrlid]\r\n      mask |= (1 << ctrlpos)\r\n    })\r\n    return mask\r\n  }\r\n\r\n  /**\r\n  Emulate a math function (e.g., BasicMathGate).\r\n\r\n    @param {function} f Function executing the operation to emulate.\r\n    @param {Array.<number[]>} qubitIDs List of lists of qubit IDs to which\r\n        the gate is being applied. Every gate is applied to a tuple of\r\n        quantum registers, which corresponds to this 'list of lists'.\r\n    @param {number[]} ctrlQubitIDs List of control qubit ids.\r\n   */\r\n  emulateMath(f, qubitIDs, ctrlQubitIDs) {\r\n    const mask = this.getControlMask(ctrlQubitIDs)\r\n    // determine qubit locations from their IDs\r\n    const qb_locs = []\r\n    qubitIDs.forEach((qureg) => {\r\n      qb_locs.push([])\r\n      qureg.forEach((qubitID) => {\r\n        qb_locs[qb_locs.length - 1].push(this._map[qubitID])\r\n      })\r\n    })\r\n\r\n    const newstate = math.zeros(len(this._state))\r\n\r\n    this._state.forEach((looper, _i) => {\r\n      const i = _i[0]\r\n      if ((mask & i) === mask) {\r\n        const argList = zeros(qb_locs.length)\r\n        qb_locs.forEach((qb, qri) => {\r\n          qb.forEach((il, qi) => {\r\n            argList[qri] |= (((i >> il) & 1) << qi)\r\n          })\r\n        })\r\n\r\n        const res = f(argList)\r\n        let newI = i\r\n\r\n        qb_locs.forEach((qb, qri) => {\r\n          qb.forEach((il, qi) => {\r\n            if (!(((newI >> il) & 1) == ((res[qri] >> qi) & 1))) {\r\n              newI ^= (1 << il)\r\n            }\r\n          })\r\n        })\r\n        newstate.subset(math.index(newI), looper)\r\n      } else {\r\n        newstate.subset(math.index(i), looper)\r\n      }\r\n    })\r\n\r\n    this._state = newstate\r\n  }\r\n\r\n  /**\r\n  Return the expectation value of a qubit operator w.r.t. qubit ids.\r\n\r\n    @param {Array.<Array>} termsArray Operator Array (see QubitOperator.terms)\r\n    @param {number[]} IDs List of qubit ids upon which the operator acts.\r\n\r\n    @return Expectation value\r\n   */\r\n  getExpectationValue(termsArray, IDs) {\r\n    let expectation = 0.0\r\n    const current_state = math.clone(this._state)\r\n    termsArray.forEach(([term, coefficient]) => {\r\n      this.applyTerm(term, IDs)\r\n      const tmp = complexVectorDot(current_state, this._state)\r\n      const delta = math.multiply(coefficient, tmp)\r\n      expectation = math.add(expectation, delta)\r\n      this._state = math.clone(current_state)\r\n    })\r\n    if (math.im(expectation) === 0) {\r\n      return math.re(expectation)\r\n    }\r\n    return expectation\r\n  }\r\n\r\n  /**\r\n  Apply a (possibly non-unitary) qubit operator to qubits.\r\n\r\n    @param {Array.<Array>} termsArray Operator array (see QubitOperator.terms)\r\n    @param {number[]} IDs List of qubit ids upon which the operator acts.\r\n  */\r\n  applyQubitOperator(termsArray, IDs) {\r\n    let new_state = math.zeros(len(this._state))\r\n    const current_state = math.clone(this._state)\r\n    termsArray.forEach(([term, coefficient]) => {\r\n      this.applyTerm(term, IDs)\r\n      const temp = math.multiply(this._state, coefficient)\r\n      new_state = math.add(new_state, temp)\r\n      this._state = math.clone(current_state)\r\n    })\r\n    this._state = new_state\r\n  }\r\n\r\n  /**\r\n  Return the probability of the outcome `bit_string` when measuring\r\nthe qubits given by the list of ids.\r\n\r\n    @param {boolean[]|number[]} bitString Measurement outcome.\r\n    @param {number[]} IDs List of qubit ids determining the ordering.\r\n\r\n    @return Probability of measuring the provided bit string.\r\n\r\n    @throws {Error} if an unknown qubit id was provided.\r\n   */\r\n  getProbability(bitString, IDs) {\r\n    const n = IDs.length\r\n    for (let i = 0; i < n; ++i) {\r\n      const id = IDs[i]\r\n      const v = this._map[id]\r\n      if (typeof v === 'undefined') {\r\n        throw new Error('get_probability(): Unknown qubit id. '\r\n        + 'Please make sure you have called '\r\n        + 'eng.flush().')\r\n      }\r\n    }\r\n    let mask = 0\r\n    let bit_str = 0\r\n    for (let i = 0; i < n; ++i) {\r\n      mask |= (1 << this._map[IDs[i]])\r\n      bit_str |= (bitString[i] << this._map[IDs[i]])\r\n    }\r\n\r\n    let probability = 0.0\r\n\r\n    this._state.forEach((val, _i) => {\r\n      const i = _i[0]\r\n      if ((i & mask) === bit_str) {\r\n        const e = val\r\n        probability += math.re(e) ** 2 + math.im(e) ** 2\r\n      }\r\n    })\r\n    return probability\r\n  }\r\n\r\n  _getState(i) {\r\n    return this._state.subset(math.index(i))\r\n  }\r\n\r\n  _setState(i, value) {\r\n    this._state.subset(math.index(i), value)\r\n  }\r\n\r\n  /**\r\n  Return the probability amplitude of the supplied `bit_string`.\r\n    The ordering is given by the list of qubit ids.\r\n\r\n   @param {boolean[]|number[]} bitString Computational basis state\r\n   @param {number[]} IDs List of qubit ids determining the ordering. Must contain all allocated qubits.\r\n\r\n    @return Probability amplitude of the provided bit string.\r\n\r\n    @throws {Error} if the second argument is not a permutation of all allocated qubits.\r\n   */\r\n  getAmplitude(bitString, IDs) {\r\n    const s1 = new Set(IDs)\r\n    const s2 = new Set(Object.keys(this._map).map(k => parseInt(k, 10)))\r\n    if (!setEqual(s1, s2)) {\r\n      throw new Error('The second argument to get_amplitude() must'\r\n      + ' be a permutation of all allocated qubits. '\r\n      + 'Please make sure you have called '\r\n      + 'eng.flush().')\r\n    }\r\n    let index = 0\r\n    IDs.forEach((item, i) => {\r\n      item = parseInt(item, 10)\r\n      index |= (bitString[i] << this._map[item])\r\n    })\r\n    const ret = this._getState(index)\r\n    return ret\r\n  }\r\n\r\n  /**\r\nApplies exp(-i*time*H) to the wave function, i.e., evolves under\r\nthe Hamiltonian H for a given time. The terms in the Hamiltonian\r\nare not required to commute.\r\n\r\n    This function computes the action of the matrix exponential using\r\nideas from Al-Mohy and Higham, 2011.\r\nTODO: Implement better estimates for s.\r\n\r\n   @param {Array.<Array>} terms_dict Operator dictionary (see QubitOperator.terms) defining the Hamiltonian.\r\n   @param {number} time Time to evolve for\r\n   @param {number[]} ids A list of qubit IDs to which to apply the evolution.\r\n   @param {number[]} ctrlids A list of control qubit IDs.\r\n  */\r\n  emulateTimeEvolution(terms_dict, time, ids, ctrlids) {\r\n    // Determine the (normalized) trace, which is nonzero only for identity\r\n  // terms:\r\n    let tr = 0\r\n    let sum = 0\r\n    const newTerms = []\r\n    terms_dict.forEach(([t, c]) => {\r\n      if (t.length === 0) {\r\n        tr += c\r\n      } else {\r\n        newTerms.push([t, c])\r\n        sum += Math.abs(c)\r\n      }\r\n    })\r\n\r\n    terms_dict = newTerms\r\n    const op_nrm = math.abs(time) * sum\r\n    // rescale the operator by s:\r\n    const s = Math.floor(op_nrm + 1)\r\n    const correction = math.exp(math.complex(0, -time * tr / (s * 1.0)))\r\n    const output_state = math.clone(this._state)\r\n    const mask = this.getControlMask(ctrlids)\r\n\r\n    for (let i = 0; i < s; ++i) {\r\n      let j = 0\r\n      let nrm_change = 1.0\r\n      let update\r\n      while (nrm_change > 1.e-12) {\r\n        const coeff = math.divide(math.complex(0, -time), s * (j + 1))\r\n        const current_state = math.clone(this._state)\r\n        update = 0\r\n        terms_dict.forEach(([t, c]) => {\r\n          this.applyTerm(t, ids)\r\n          this._state = math.multiply(this._state, c)\r\n\r\n          update = math.add(this._state, update)\r\n          // update += this._state\r\n          this._state = math.clone(current_state)\r\n        })\r\n        update = math.multiply(update, coeff)\r\n        this._state = update\r\n        for (let i = 0; i < update.length; ++i) {\r\n          if ((i & mask) === mask) {\r\n            output_state[i] = math.add(output_state[i], update[i])\r\n          }\r\n        }\r\n        nrm_change = math.norm(update)\r\n        j += 1\r\n      }\r\n      for (let i = 0; i < update.length; ++i) {\r\n        if ((i & mask) === mask) {\r\n          output_state[i] *= correction\r\n        }\r\n      }\r\n      this._state = math.clone(output_state)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * leave it empty to keep same API with cpp simulator\r\n   */\r\n  run() {\r\n    //\r\n  }\r\n\r\n  /**\r\n  Applies a QubitOperator term to the state vector. (Helper function for time evolution & expectation)\r\n\r\n    @param {Array} term One term of QubitOperator.terms\r\n    @param {number[]} ids Term index to Qubit ID mapping\r\n    @param {number[]} controlIDs Control qubit IDs\r\n  */\r\n  applyTerm(term, ids, controlIDs = []) {\r\n    const X = [[0.0, 1.0], [1.0, 0.0]]\r\n    const Y = [[0.0, math.complex(0, -1)], [math.complex(0, 1), 0.0]]\r\n    const Z = [[1.0, 0.0], [0.0, -1.0]]\r\n    const gates = {X, Y, Z}\r\n    term.forEach((local_op) => {\r\n      const qb_id = ids[local_op[0]]\r\n      this.applyControlledGate(gates[local_op[1]], [qb_id], controlIDs)\r\n    })\r\n  }\r\n\r\n  /**\r\n  Applies the k-qubit gate matrix m to the qubits with indices ids,\r\n    using ctrlids as control qubits.\r\n\r\n    @param {Array.<Array.<number>>} m 2^k x 2^k complex matrix describing the k-qubit gate.\r\n    @param {number[]} ids A list containing the qubit IDs to which to apply the gate.\r\n    @param {number[]} ctrlids A list of control qubit IDs (i.e., the gate is only applied where these qubits are 1).\r\n   */\r\n  applyControlledGate(m, ids, ctrlids) {\r\n    const mask = this.getControlMask(ctrlids)\r\n    if (len(m) === 2) {\r\n      const k = ids[0]\r\n      const pos = this._map[k] || this._map[k.toString()]\r\n      this._singleQubitGate(m, pos, mask)\r\n    } else {\r\n      const pos = ids.map(ID => this._map[ID])\r\n      this._multiQubitGate(m, pos, mask)\r\n    }\r\n  }\r\n\r\n  /**\r\n  Applies the single qubit gate matrix m to the qubit at position `pos`\r\nusing `mask` to identify control qubits.\r\n\r\n   @param {Array.<Array.<number>>} m 2x2 complex matrix describing the single-qubit gate.\r\n    @param {number} pos Bit-position of the qubit.\r\n    @param {number} mask Bit-mask where set bits indicate control qubits.\r\n   */\r\n  _singleQubitGate(m, pos, mask) {\r\n    const kernel = (u, d, m) => {\r\n      const ma = math.add\r\n      const mm = math.multiply\r\n      d = d || math.complex(0, 0)\r\n      u = u || math.complex(0, 0)\r\n      const r1 = ma(mm(u, m[0][0]), mm(d, m[0][1]))\r\n      const r2 = ma(mm(u, m[1][0]), mm(d, m[1][1]))\r\n      return [r1, r2]\r\n    }\r\n\r\n    const step = 1 << (pos + 1)\r\n    for (let i = 0; i < len(this._state); i += step) {\r\n      for (let j = 0; j < (1 << pos); ++j) {\r\n        if (((i + j) & mask) === mask) {\r\n          const id1 = i + j\r\n          const id2 = id1 + (1 << pos)\r\n          const [r1, r2] = kernel(this._getState(id1), this._getState(id2), m)\r\n          this._setState(id1, r1)\r\n          this._setState(id2, r2)\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n  Applies the k-qubit gate matrix m to the qubits at `pos`\r\nusing `mask` to identify control qubits.\r\n\r\n   @param {Array.<number[]>} m 2^k x 2^k complex matrix describing the k-qubit gate.\r\n   @param {number[]} pos List of bit-positions of the qubits.\r\n   @param {number} mask Bit-mask where set bits indicate control qubits.\r\n   see follows the description in https://arxiv.org/abs/1704.01127\r\n   */\r\n  _multiQubitGate(m, pos, mask) {\r\n    const inactive = Object.keys(this._map).map(k => parseInt(k, 10)).filter(p => !pos.includes(p))\r\n\r\n    const matrix = math.matrix(m)\r\n    const subvec = zeros(1 << pos.length)\r\n    const subvec_idx = zeros(subvec.length)\r\n    for (let c = 0; c < (1 << inactive.length); ++c) {\r\n      // determine base index (state of inactive qubits)\r\n      let base = 0\r\n      for (let i = 0; i < inactive.length; ++i) {\r\n        base |= ((c >> i) & 1) << inactive[i]\r\n      }\r\n\r\n      // check the control mask\r\n      if (mask !== (base & mask)) {\r\n        continue\r\n      }\r\n      // now gather all elements involved in mat-vec mul\r\n      for (let x = 0; x < subvec_idx.length; ++x) {\r\n        let offset = 0\r\n        for (let i = 0; i < pos.length; ++i) {\r\n          offset |= ((x >> i) & 1) << pos[i]\r\n        }\r\n        subvec_idx[x] = base | offset\r\n        subvec[x] = this._getState(subvec_idx[x]) || math.complex(0, 0)\r\n      }\r\n\r\n      // perform mat-vec mul\r\n      matrixRangeAssign(this._state, subvec_idx, matrixDot(matrix, subvec))\r\n    }\r\n  }\r\n\r\n  /**\r\n  Set wavefunction and qubit ordering.\r\n\r\n    @param {Complex[]} wavefunction Array of complex amplitudes describing the wavefunction (must be normalized).\r\n    @param {Array} ordering List of ids describing the new ordering of qubits\r\n(i.e., the ordering of the provided wavefunction).\r\n   */\r\n  setWavefunction(wavefunction, ordering) {\r\n    // wavefunction contains 2^n values for n qubits\r\n    assert(wavefunction.length === (1 << ordering.length))\r\n\r\n    // all qubits must have been allocated before\r\n    const f1 = ordering.filter((Id) => {\r\n      const v = this._map[Id]\r\n      return typeof v !== 'undefined'\r\n    }).length === ordering.length\r\n    const f2 = len(this._map) === ordering.length\r\n    if (!f1 || !f2) {\r\n      throw new Error('set_wavefunction(): Invalid mapping provided.'\r\n      + ' Please make sure all qubits have been '\r\n      + 'allocated previously (call eng.flush()).')\r\n    }\r\n\r\n    this._state = math.matrix(wavefunction)\r\n    const map = {}\r\n    for (let i = 0; i < ordering.length; ++i) {\r\n      map[ordering[i]] = i\r\n    }\r\n    this._map = map\r\n  }\r\n\r\n  /**\r\n  Collapse a quantum register onto a classical basis state.\r\n\r\n    @param {number[]} ids Qubit IDs to collapse.\r\n    @param {boolean[]} values Measurement outcome for each of the qubit IDs in `ids`.\r\n    @throws {Error} If probability of outcome is ~0 or unknown qubits are provided.\r\n   */\r\n  collapseWavefunction(ids, values) {\r\n    assert(ids.length === values.length)\r\n\r\n    // all qubits must have been allocated before\r\n    const f1 = ids.filter(Id => typeof this._map[Id] !== 'undefined').length === ids.length\r\n    if (!f1) {\r\n      throw new Error('collapse_wavefunction(): Unknown qubit id(s)'\r\n        + ' provided. Try calling eng.flush() before '\r\n        + 'invoking this function.')\r\n    }\r\n\r\n    let mask = 0\r\n    let val = 0\r\n    ids.forEach((looper, i) => {\r\n      const pos = this._map[looper]\r\n      mask |= (1 << pos)\r\n      val |= (Math.floor(values[i]) << pos)\r\n    })\r\n\r\n    let nrm = 0.0\r\n    this._state.forEach((looper, _i) => {\r\n      const i = _i[0]\r\n      if ((mask & i) === val) {\r\n        nrm += math.abs(this._getState(i)) ** 2\r\n      }\r\n    })\r\n\r\n    if (nrm < 1.e-12) {\r\n      throw new Error('collapse_wavefunction(): Invalid collapse! Probability is ~0.')\r\n    }\r\n    const inv_nrm = 1.0 / math.sqrt(nrm)\r\n    this._state.forEach((looper, _i) => {\r\n      const i = _i[0]\r\n      if ((mask & i) !== val) {\r\n        this._setState(i, 0)\r\n      } else {\r\n        this._setState(i, math.multiply(looper, inv_nrm))\r\n      }\r\n    })\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/backends/simulators/jssim.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 217,
    "kind": "class",
    "name": "Simulator",
    "memberof": "src/backends/simulators/jssim.js",
    "static": true,
    "longname": "src/backends/simulators/jssim.js~Simulator",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/backends/simulators/jssim.js",
    "importStyle": "Simulator",
    "description": "NodeJS implementation of a quantum computer simulator.\n\nThis Simulator can be used as a backup if compiling the c++ simulator is\nnot an option (for some reason). It has the same features but is much\nslower, so please consider building the c++ version for larger experiments.",
    "lineNumber": 44,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "JSSimulator"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 218,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/backends/simulators/jssim.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/jssim.js~Simulator#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 48,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ]
  },
  {
    "__docId__": 219,
    "kind": "member",
    "name": "_state",
    "memberof": "src/backends/simulators/jssim.js~Simulator",
    "static": false,
    "longname": "src/backends/simulators/jssim.js~Simulator#_state",
    "access": "private",
    "description": null,
    "lineNumber": 50,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 220,
    "kind": "member",
    "name": "_map",
    "memberof": "src/backends/simulators/jssim.js~Simulator",
    "static": false,
    "longname": "src/backends/simulators/jssim.js~Simulator#_map",
    "access": "private",
    "description": null,
    "lineNumber": 51,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 221,
    "kind": "member",
    "name": "_numQubits",
    "memberof": "src/backends/simulators/jssim.js~Simulator",
    "static": false,
    "longname": "src/backends/simulators/jssim.js~Simulator#_numQubits",
    "access": "private",
    "description": null,
    "lineNumber": 52,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 222,
    "kind": "method",
    "name": "cheat",
    "memberof": "src/backends/simulators/jssim.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/jssim.js~Simulator#cheat",
    "access": "public",
    "description": "Return the qubit index to bit location map and the corresponding state\nvector.\n\nThis function can be used to measure expectation values more efficiently (emulation).",
    "lineNumber": 66,
    "return": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": "A tuple where the first entry is a dictionary mapping qubit indices\nto bit-locations and the second entry is the corresponding state\nvector"
    },
    "params": []
  },
  {
    "__docId__": 223,
    "kind": "method",
    "name": "measureQubits",
    "memberof": "src/backends/simulators/jssim.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/jssim.js~Simulator#measureQubits",
    "access": "public",
    "description": "Measure the qubits with IDs ids and return a list of measurement\noutcomes (true/false).",
    "lineNumber": 78,
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "ids",
        "description": "List of qubit IDs to measure."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean[]"
      ],
      "spread": false,
      "description": "List of measurement results (containing either true or false)."
    }
  },
  {
    "__docId__": 225,
    "kind": "method",
    "name": "allocateQubit",
    "memberof": "src/backends/simulators/jssim.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/jssim.js~Simulator#allocateQubit",
    "access": "public",
    "description": "Allocate a qubit.",
    "lineNumber": 125,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "ID",
        "description": "ID of the qubit which is being allocated."
      }
    ],
    "return": null
  },
  {
    "__docId__": 227,
    "kind": "method",
    "name": "getClassicalValue",
    "memberof": "src/backends/simulators/jssim.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/jssim.js~Simulator#getClassicalValue",
    "access": "public",
    "description": "Return the classical value of a classical bit (i.e., a qubit which has\nbeen measured / uncomputed).",
    "lineNumber": 141,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "ID",
        "description": "ID of the qubit of which to get the classical value."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "tolerance",
        "description": "Tolerance for numerical errors when determining\nwhether the qubit is indeed classical."
      }
    ],
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If the qubit is in a superposition, i.e., has not been measured / uncomputed."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 228,
    "kind": "method",
    "name": "deallocateQubit",
    "memberof": "src/backends/simulators/jssim.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/jssim.js~Simulator#deallocateQubit",
    "access": "public",
    "description": "Deallocate a qubit (if it has been measured / uncomputed).",
    "lineNumber": 175,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "ID",
        "description": "ID of the qubit to deallocate."
      }
    ],
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If the qubit is in a superposition, i.e., has not been measured / uncomputed."
      }
    ],
    "return": null
  },
  {
    "__docId__": 232,
    "kind": "method",
    "name": "getControlMask",
    "memberof": "src/backends/simulators/jssim.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/jssim.js~Simulator#getControlMask",
    "access": "public",
    "description": "Get control mask from list of control qubit IDs.",
    "lineNumber": 205,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "A mask which represents the control qubits in binary."
    },
    "params": [
      {
        "name": "ctrlids",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 233,
    "kind": "method",
    "name": "emulateMath",
    "memberof": "src/backends/simulators/jssim.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/jssim.js~Simulator#emulateMath",
    "access": "public",
    "description": "Emulate a math function (e.g., BasicMathGate).",
    "lineNumber": 223,
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "f",
        "description": "Function executing the operation to emulate."
      },
      {
        "nullable": null,
        "types": [
          "Array.<number[]>"
        ],
        "spread": false,
        "optional": false,
        "name": "qubitIDs",
        "description": "List of lists of qubit IDs to which\nthe gate is being applied. Every gate is applied to a tuple of\nquantum registers, which corresponds to this 'list of lists'."
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "ctrlQubitIDs",
        "description": "List of control qubit ids."
      }
    ],
    "return": null
  },
  {
    "__docId__": 235,
    "kind": "method",
    "name": "getExpectationValue",
    "memberof": "src/backends/simulators/jssim.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/jssim.js~Simulator#getExpectationValue",
    "access": "public",
    "description": "Return the expectation value of a qubit operator w.r.t. qubit ids.",
    "lineNumber": 273,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array.<Array>"
        ],
        "spread": false,
        "optional": false,
        "name": "termsArray",
        "description": "Operator Array (see QubitOperator.terms)"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "IDs",
        "description": "List of qubit ids upon which the operator acts."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "Expectation value"
    }
  },
  {
    "__docId__": 237,
    "kind": "method",
    "name": "applyQubitOperator",
    "memberof": "src/backends/simulators/jssim.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/jssim.js~Simulator#applyQubitOperator",
    "access": "public",
    "description": "Apply a (possibly non-unitary) qubit operator to qubits.",
    "lineNumber": 295,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array.<Array>"
        ],
        "spread": false,
        "optional": false,
        "name": "termsArray",
        "description": "Operator array (see QubitOperator.terms)"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "IDs",
        "description": "List of qubit ids upon which the operator acts."
      }
    ],
    "return": null
  },
  {
    "__docId__": 240,
    "kind": "method",
    "name": "getProbability",
    "memberof": "src/backends/simulators/jssim.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/jssim.js~Simulator#getProbability",
    "access": "public",
    "description": "Return the probability of the outcome `bit_string` when measuring\nthe qubits given by the list of ids.",
    "lineNumber": 318,
    "params": [
      {
        "nullable": null,
        "types": [
          "boolean[]",
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "bitString",
        "description": "Measurement outcome."
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "IDs",
        "description": "List of qubit ids determining the ordering."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "Probability of measuring the provided bit string."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "if an unknown qubit id was provided."
      }
    ]
  },
  {
    "__docId__": 241,
    "kind": "method",
    "name": "_getState",
    "memberof": "src/backends/simulators/jssim.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/jssim.js~Simulator#_getState",
    "access": "private",
    "description": null,
    "lineNumber": 348,
    "undocument": true,
    "params": [
      {
        "name": "i",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 242,
    "kind": "method",
    "name": "_setState",
    "memberof": "src/backends/simulators/jssim.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/jssim.js~Simulator#_setState",
    "access": "private",
    "description": null,
    "lineNumber": 352,
    "undocument": true,
    "params": [
      {
        "name": "i",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 243,
    "kind": "method",
    "name": "getAmplitude",
    "memberof": "src/backends/simulators/jssim.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/jssim.js~Simulator#getAmplitude",
    "access": "public",
    "description": "Return the probability amplitude of the supplied `bit_string`.\nThe ordering is given by the list of qubit ids.",
    "lineNumber": 367,
    "params": [
      {
        "nullable": null,
        "types": [
          "boolean[]",
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "bitString",
        "description": "Computational basis state"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "IDs",
        "description": "List of qubit ids determining the ordering. Must contain all allocated qubits."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "Probability amplitude of the provided bit string."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "if the second argument is not a permutation of all allocated qubits."
      }
    ]
  },
  {
    "__docId__": 244,
    "kind": "method",
    "name": "emulateTimeEvolution",
    "memberof": "src/backends/simulators/jssim.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/jssim.js~Simulator#emulateTimeEvolution",
    "access": "public",
    "description": "Applies exp(-i*time*H) to the wave function, i.e., evolves under\nthe Hamiltonian H for a given time. The terms in the Hamiltonian\nare not required to commute.\n\nThis function computes the action of the matrix exponential using\nideas from Al-Mohy and Higham, 2011.\nTODO: Implement better estimates for s.",
    "lineNumber": 399,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array.<Array>"
        ],
        "spread": false,
        "optional": false,
        "name": "terms_dict",
        "description": "Operator dictionary (see QubitOperator.terms) defining the Hamiltonian."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "time",
        "description": "Time to evolve for"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "ids",
        "description": "A list of qubit IDs to which to apply the evolution."
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "ctrlids",
        "description": "A list of control qubit IDs."
      }
    ],
    "return": null
  },
  {
    "__docId__": 249,
    "kind": "method",
    "name": "run",
    "memberof": "src/backends/simulators/jssim.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/jssim.js~Simulator#run",
    "access": "public",
    "description": "leave it empty to keep same API with cpp simulator",
    "lineNumber": 460,
    "params": [],
    "return": null
  },
  {
    "__docId__": 250,
    "kind": "method",
    "name": "applyTerm",
    "memberof": "src/backends/simulators/jssim.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/jssim.js~Simulator#applyTerm",
    "access": "public",
    "description": "Applies a QubitOperator term to the state vector. (Helper function for time evolution & expectation)",
    "lineNumber": 471,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "term",
        "description": "One term of QubitOperator.terms"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "ids",
        "description": "Term index to Qubit ID mapping"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "controlIDs",
        "description": "Control qubit IDs"
      }
    ],
    "return": null
  },
  {
    "__docId__": 251,
    "kind": "method",
    "name": "applyControlledGate",
    "memberof": "src/backends/simulators/jssim.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/jssim.js~Simulator#applyControlledGate",
    "access": "public",
    "description": "Applies the k-qubit gate matrix m to the qubits with indices ids,\nusing ctrlids as control qubits.",
    "lineNumber": 490,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array.<Array.<number>>"
        ],
        "spread": false,
        "optional": false,
        "name": "m",
        "description": "2^k x 2^k complex matrix describing the k-qubit gate."
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "ids",
        "description": "A list containing the qubit IDs to which to apply the gate."
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "ctrlids",
        "description": "A list of control qubit IDs (i.e., the gate is only applied where these qubits are 1)."
      }
    ],
    "return": null
  },
  {
    "__docId__": 252,
    "kind": "method",
    "name": "_singleQubitGate",
    "memberof": "src/backends/simulators/jssim.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/jssim.js~Simulator#_singleQubitGate",
    "access": "private",
    "description": "Applies the single qubit gate matrix m to the qubit at position `pos`\nusing `mask` to identify control qubits.",
    "lineNumber": 510,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array.<Array.<number>>"
        ],
        "spread": false,
        "optional": false,
        "name": "m",
        "description": "2x2 complex matrix describing the single-qubit gate."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "pos",
        "description": "Bit-position of the qubit."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "mask",
        "description": "Bit-mask where set bits indicate control qubits."
      }
    ],
    "return": null
  },
  {
    "__docId__": 253,
    "kind": "method",
    "name": "_multiQubitGate",
    "memberof": "src/backends/simulators/jssim.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/jssim.js~Simulator#_multiQubitGate",
    "access": "private",
    "description": "Applies the k-qubit gate matrix m to the qubits at `pos`\nusing `mask` to identify control qubits.",
    "lineNumber": 544,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array.<number[]>"
        ],
        "spread": false,
        "optional": false,
        "name": "m",
        "description": "2^k x 2^k complex matrix describing the k-qubit gate."
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "pos",
        "description": "List of bit-positions of the qubits."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "mask",
        "description": "Bit-mask where set bits indicate control qubits.\nsee follows the description in https://arxiv.org/abs/1704.01127"
      }
    ],
    "return": null
  },
  {
    "__docId__": 254,
    "kind": "method",
    "name": "setWavefunction",
    "memberof": "src/backends/simulators/jssim.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/jssim.js~Simulator#setWavefunction",
    "access": "public",
    "description": "Set wavefunction and qubit ordering.",
    "lineNumber": 583,
    "params": [
      {
        "nullable": null,
        "types": [
          "Complex[]"
        ],
        "spread": false,
        "optional": false,
        "name": "wavefunction",
        "description": "Array of complex amplitudes describing the wavefunction (must be normalized)."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "ordering",
        "description": "List of ids describing the new ordering of qubits\n(i.e., the ordering of the provided wavefunction)."
      }
    ],
    "return": null
  },
  {
    "__docId__": 257,
    "kind": "method",
    "name": "collapseWavefunction",
    "memberof": "src/backends/simulators/jssim.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/jssim.js~Simulator#collapseWavefunction",
    "access": "public",
    "description": "Collapse a quantum register onto a classical basis state.",
    "lineNumber": 614,
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "ids",
        "description": "Qubit IDs to collapse."
      },
      {
        "nullable": null,
        "types": [
          "boolean[]"
        ],
        "spread": false,
        "optional": false,
        "name": "values",
        "description": "Measurement outcome for each of the qubit IDs in `ids`."
      }
    ],
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If probability of outcome is ~0 or unknown qubits are provided."
      }
    ],
    "return": null
  },
  {
    "__docId__": 258,
    "kind": "file",
    "name": "src/backends/simulators/shared.spec.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport BasicMapperEngine from '../../cengines/basicmapper';\r\n\r\nexport class TrivialMapper extends BasicMapperEngine {\r\n  constructor() {\r\n    super()\r\n    this.currentMapping = {}\r\n  }\r\n\r\n  receive(command_list) {\r\n    command_list.forEach((cmd) => {\r\n      cmd.allQubits.forEach((qureg) => {\r\n        qureg.forEach((qubit) => {\r\n          if (qubit.id !== -1) {\r\n            const v = this.currentMapping[qubit.id]\r\n            if (typeof v === 'undefined') {\r\n              const previous_map = this.currentMapping\r\n              previous_map[qubit.id] = qubit.id + 1\r\n              this.currentMapping = previous_map\r\n            }\r\n          }\r\n        })\r\n      })\r\n      this.sendCMDWithMappedIDs(cmd)\r\n    })\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/backends/simulators/shared.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 259,
    "kind": "class",
    "name": "TrivialMapper",
    "memberof": "src/backends/simulators/shared.spec.js",
    "static": true,
    "longname": "src/backends/simulators/shared.spec.js~TrivialMapper",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/backends/simulators/shared.spec.js",
    "importStyle": "{TrivialMapper}",
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/cengines/basicmapper.js~BasicMapperEngine"
    ]
  },
  {
    "__docId__": 260,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/backends/simulators/shared.spec.js~TrivialMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/shared.spec.js~TrivialMapper#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 20,
    "undocument": true
  },
  {
    "__docId__": 261,
    "kind": "member",
    "name": "currentMapping",
    "memberof": "src/backends/simulators/shared.spec.js~TrivialMapper",
    "static": false,
    "longname": "src/backends/simulators/shared.spec.js~TrivialMapper#currentMapping",
    "access": "public",
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 262,
    "kind": "method",
    "name": "receive",
    "memberof": "src/backends/simulators/shared.spec.js~TrivialMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/shared.spec.js~TrivialMapper#receive",
    "access": "public",
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "params": [
      {
        "name": "command_list",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 264,
    "kind": "file",
    "name": "src/backends/simulators/simulator.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport assert from 'assert'\r\nimport math from 'mathjs'\r\nimport {BasicEngine} from '../../cengines/basics'\r\nimport SimulatorBackend from './jssim'\r\nimport CPPSimulatorBackend from './cppsim'\r\n\r\nimport {\r\n  Allocate, AllocateQubitGate, Deallocate, DeallocateQubitGate, FlushGate, Measure, MeasureGate\r\n} from '../../ops/gates';\r\nimport {BasicMathGate} from '../../ops/basics';\r\nimport TimeEvolution from '../../ops/timeevolution';\r\nimport { BasicQubit } from '../../types/qubit'\r\nimport { stringToArray } from '../../ops/qubitoperator'\r\nimport { LogicalQubitIDTag } from '../../meta/tag'\r\nimport {instanceOf} from '../../libs/util';\r\nimport {len, stringToBitArray} from '../../libs/polyfill';\r\n\r\n/**\r\n * @class Simulator\r\n * @desc\r\nSimulator is a compiler engine which simulates a quantum computer using\r\nC++-based kernels.\r\n\r\n    OpenMP is enabled and the number of threads can be controlled using the\r\nOMP_NUM_THREADS environment variable, i.e.\r\n\r\n    @example\r\n\r\nexport OMP_NUM_THREADS=4 # use 4 threads\r\nexport OMP_PROC_BIND=spread # bind threads to processors by spreading\r\n */\r\nexport default class Simulator extends BasicEngine {\r\n  /**\r\n   * @constructor\r\n  Construct the C++/JavaScript-simulator object and initialize it with a\r\n  random seed.\r\n\r\n    @param {boolean} gate_fusion If true, gates are cached and only executed\r\nonce a certain gate-size has been reached (only has an effect\r\nfor the c++ simulator).\r\n    @param {number} rnd_seed Random seed (uses random.randint(0, 4294967295) by default). Ignored currently!!!\r\n    @param {boolean} forceSimulation if true, will force use cpp simulator\r\n\r\nExample of gate_fusion Instead of applying a Hadamard gate to 5\r\nqubits, the simulator calculates the kronecker product of the 1-qubit\r\ngate matrices and then applies one 5-qubit gate. This increases\r\noperational intensity and keeps the simulator from having to iterate\r\nthrough the state vector multiple times. Depending on the system (and,\r\n    especially, number of threads), this may or may not be beneficial.\r\n\r\n    Note:\r\nIf the C++ Simulator extension was not built or cannot be found,\r\n    the Simulator defaults to a Javascript implementation of the kernels.\r\n    While this is much slower, it is still good enough to run basic\r\nquantum algorithms.\r\n\r\n    If you need to run large simulations, check out the tutorial in\r\nthe docs which gives futher hints on how to build the C++\r\nextension.\r\n   */\r\n  constructor(gate_fusion = false, rnd_seed = null, forceSimulation = false) {\r\n    super()\r\n    if (!rnd_seed) {\r\n      rnd_seed = Math.random()\r\n    }\r\n\r\n    if (!forceSimulation && CPPSimulatorBackend) {\r\n      const S = CPPSimulatorBackend.Simulator\r\n      this._simulator = new S(rnd_seed)\r\n    } else {\r\n      this._simulator = new SimulatorBackend(rnd_seed)\r\n    }\r\n    this._gate_fusion = gate_fusion\r\n  }\r\n\r\n  /**\r\n  Specialized implementation of isAvailable: The simulator can deal\r\nwith all arbitrarily-controlled gates which provide a\r\ngate-matrix (via gate.matrix) and acts on 5 or less qubits (not\r\ncounting the control qubits).\r\n\r\n  @param {Command} cmd Command for which to check availability (single-qubit gate, arbitrary controls)\r\n\r\n  @return {boolean} true if it can be simulated and false otherwise.\r\n  */\r\n  isAvailable(cmd) {\r\n    if (instanceOf(cmd.gate, [MeasureGate, AllocateQubitGate, DeallocateQubitGate, BasicMathGate, TimeEvolution])) {\r\n      return true\r\n    }\r\n    try {\r\n      const m = cmd.gate.matrix\r\n      // Allow up to 5-qubit gates\r\n      const [row, col] = m.size()\r\n      if (row > 2 ** 5 || col > 2 ** 5) return false\r\n      return true\r\n    } catch (e) {\r\n      return false\r\n    }\r\n  }\r\n\r\n  /**\r\n    Converts a qureg from logical to mapped qubits if there is a mapper.\r\n    @param {Array.<Qubit>|Qureg} qureg Logical quantum bits\r\n  */\r\n  convertLogicalToMappedQureg(qureg) {\r\n    const {mapper} = this.main\r\n    if (mapper) {\r\n      const mapped_qureg = []\r\n      qureg.forEach((qubit) => {\r\n        const v = mapper.currentMapping[qubit.id]\r\n        if (typeof v === 'undefined') {\r\n          throw new Error('Unknown qubit id. '\r\n          + 'Please make sure you have called '\r\n          + 'eng.flush().')\r\n        }\r\n        const new_qubit = new BasicQubit(qubit.engine, mapper.currentMapping[qubit.id])\r\n        mapped_qureg.push(new_qubit)\r\n      })\r\n      return mapped_qureg\r\n    }\r\n    return qureg\r\n  }\r\n\r\n  /**\r\n  Get the expectation value of qubit_operator w.r.t. the current wave\r\nfunction represented by the supplied quantum register.\r\n\r\n    @param {QubitOperator} qubitOperator  Operator to measure.\r\n    @param {Array.<Qubit>|Qureg} qureg  Quantum bits to measure.\r\n\r\n    @return Expectation value\r\n\r\nNote:\r\n    Make sure all previous commands (especially allocations) have\r\npassed through the compilation chain (call main.flush() to\r\nmake sure).\r\n\r\nNote:\r\n    If there is a mapper present in the compiler, this function\r\nautomatically converts from logical qubits to mapped qubits for\r\n    the qureg argument.\r\n\r\n    @throws {Error} If `qubit_operator` acts on more qubits than present in the `qureg` argument.\r\n   */\r\n  getExpectationValue(qubitOperator, qureg) {\r\n    qureg = this.convertLogicalToMappedQureg(qureg)\r\n    const operator = []\r\n    const num_qubits = qureg.length\r\n    Object.keys(qubitOperator.terms).forEach((term) => {\r\n      const keys = stringToArray(term)\r\n      if (term !== '' && keys[keys.length - 1][0] >= num_qubits) {\r\n        throw new Error('qubit_operator acts on more qubits than contained in the qureg.')\r\n      }\r\n      operator.push([keys, qubitOperator.terms[term]])\r\n    })\r\n    return this._simulator.getExpectationValue(operator, qureg.map(qb => qb.id))\r\n  }\r\n\r\n  /**\r\n  Apply a (possibly non-unitary) qubit_operator to the current wave\r\nfunction represented by the supplied quantum register.\r\n\r\n    @param {QubitOperator} qubitOperator  Operator to apply.\r\n    @param {Array.<Qubit>|Qureg} qureg Quantum bits to which to apply the\r\noperator.\r\n\r\n    @throws {Error} If `qubit_operator` acts on more qubits than present in the `qureg` argument.\r\n\r\n    Warning:\r\nThis function allows applying non-unitary gates and it will not\r\nre-normalize the wave function! It is for numerical experiments\r\nonly and should not be used for other purposes.\r\n\r\n    Note:\r\nMake sure all previous commands (especially allocations) have\r\npassed through the compilation chain (call main.flush() to\r\nmake sure).\r\n\r\nNote:\r\n    If there is a mapper present in the compiler, this function\r\nautomatically converts from logical qubits to mapped qubits for\r\n    the qureg argument.\r\n   */\r\n  applyQubitOperator(qubitOperator, qureg) {\r\n    qureg = this.convertLogicalToMappedQureg(qureg)\r\n    const num_qubits = qureg.length\r\n    const operator = []\r\n    Object.keys(qubitOperator.terms).forEach((term) => {\r\n      const keys = stringToArray(term)\r\n      if (term !== '' && keys[keys.length - 1][0] >= num_qubits) {\r\n        throw new Error('qubit_operator acts on more qubits than contained in the qureg.')\r\n      }\r\n      operator.push([keys, qubitOperator.terms[term]])\r\n    })\r\n    return this._simulator.applyQubitOperator(operator, qureg.map(qb => qb.id))\r\n  }\r\n\r\n  /**\r\n  Return the probability of the outcome `bit_string` when measuring\r\nthe quantum register `qureg`.\r\n\r\n    @param {number[]|string} bitString  Measurement outcome.\r\n    @param {Qureg|Array.<Qubit>} qureg Quantum register.\r\n\r\n    @returns {number} Probability of measuring the provided bit string.\r\n\r\n    Note:\r\nMake sure all previous commands (especially allocations) have\r\npassed through the compilation chain (call main.flush() to\r\nmake sure).\r\n\r\nNote:\r\n    If there is a mapper present in the compiler, this function\r\nautomatically converts from logical qubits to mapped qubits for\r\n    the qureg argument.\r\n   */\r\n  getProbability(bitString, qureg) {\r\n    qureg = this.convertLogicalToMappedQureg(qureg)\r\n    const bit_string = stringToBitArray(bitString)\r\n    return this._simulator.getProbability(bit_string, qureg.map(qb => qb.id))\r\n  }\r\n\r\n  /**\r\n  Return the probability amplitude of the supplied `bit_string`.\r\n    The ordering is given by the quantum register `qureg`, which must\r\ncontain all allocated qubits.\r\n\r\n   @param {number[]|string} bitString Computational basis state\r\n   @param {Qureg|Array.<Qubit>} qureg Quantum register determining the\r\nordering. Must contain all allocated qubits.\r\n\r\n    @returns {number}\r\nProbability amplitude of the provided bit string.\r\n\r\n    Note:\r\nMake sure all previous commands (especially allocations) have\r\npassed through the compilation chain (call main.flush() to\r\nmake sure).\r\n\r\nNote:\r\n    If there is a mapper present in the compiler, this function\r\nautomatically converts from logical qubits to mapped qubits for\r\n    the qureg argument.\r\n   */\r\n  getAmplitude(bitString, qureg) {\r\n    qureg = this.convertLogicalToMappedQureg(qureg)\r\n    const bit_string = stringToBitArray(bitString)\r\n    return this._simulator.getAmplitude(bit_string, qureg.map(qb => qb.id))\r\n  }\r\n\r\n  /**\r\n  Set the wavefunction and the qubit ordering of the simulator.\r\n\r\n    The simulator will adopt the ordering of qureg (instead of reordering\r\nthe wavefunction).\r\n\r\n  @param {Complex[]} wavefunction  Array of complex amplitudes describing the wavefunction (must be normalized).\r\n  @param {Qureg|Array.<Qubit>} qureg  Quantum register determining the ordering. Must contain all allocated qubits.\r\n\r\n    Note:\r\nMake sure all previous commands (especially allocations) have\r\npassed through the compilation chain (call main.flush() to\r\nmake sure).\r\n\r\nNote:\r\n    If there is a mapper present in the compiler, this function\r\nautomatically converts from logical qubits to mapped qubits for\r\n    the qureg argument.\r\n   */\r\n  setWavefunction(wavefunction, qureg) {\r\n    qureg = this.convertLogicalToMappedQureg(qureg)\r\n    this._simulator.setWavefunction(wavefunction, qureg.map(qb => qb.id))\r\n  }\r\n\r\n  /**\r\n  Collapse a quantum register onto a classical basis state.\r\n\r\n    @param {Qureg|Array.<Qubit>} qureg Qubits to collapse.\r\n    @param {boolean[]} values  Measurement outcome for each of the qubits\r\nin `qureg`.\r\n\r\n    @throws {Error} If an outcome has probability (approximately) 0 or\r\nif unknown qubits are provided (see note).\r\n\r\nNote:\r\n    Make sure all previous commands have passed through the\r\ncompilation chain (call main.flush() to make sure).\r\n\r\nNote:\r\n    If there is a mapper present in the compiler, this function\r\nautomatically converts from logical qubits to mapped qubits for\r\n    the qureg argument.\r\n   */\r\n  collapseWavefunction(qureg, values) {\r\n    qureg = this.convertLogicalToMappedQureg(qureg)\r\n    return this._simulator.collapseWavefunction(qureg.map(qb => qb.id), values)\r\n  }\r\n\r\n  /**\r\n  Access the ordering of the qubits and the state vector directly.\r\n\r\n    This is a cheat function which enables, e.g., more efficient\r\nevaluation of expectation values and debugging.\r\n\r\n    @return {Array}\r\nA tuple where the first entry is a dictionary mapping qubit\r\nindices to bit-locations and the second entry is the corresponding\r\nstate vector.\r\n\r\n    Note:\r\nMake sure all previous commands have passed through the\r\ncompilation chain (call main.flush() to make sure).\r\n\r\nNote:\r\n    If there is a mapper present in the compiler, this function\r\nDOES NOT automatically convert from logical qubits to mapped\r\nqubits.\r\n   */\r\n  cheat() {\r\n    return this._simulator.cheat()\r\n  }\r\n\r\n  /**\r\n  Handle all commands, i.e., call the member functions of the C++-\r\nsimulator object corresponding to measurement, allocation/\r\ndeallocation, and (controlled) single-qubit gate.\r\n\r\n    @param {Command} cmd Command to handle.\r\n\r\n    @throws Error If a non-single-qubit gate needs to be processed (which should never happen due to isAvailable).\r\n   */\r\n  handle(cmd) {\r\n    if (cmd.gate instanceof TimeEvolution) {\r\n      const {terms} = cmd.gate.hamiltonian\r\n      const op = []\r\n      Object.keys(terms).forEach(k => {\r\n        const v = terms[k]\r\n        op.push([stringToArray(k), v])\r\n      })\r\n      const t = cmd.gate.time\r\n      const qubitids = cmd.qubits[0].map(qb => qb.id)\r\n      const ctrlids = cmd.controlQubits.map(qb => qb.id)\r\n      this._simulator.emulateTimeEvolution(op, t, qubitids, ctrlids)\r\n    } else if (cmd.gate.equal(Measure)) {\r\n      assert(cmd.controlCount === 0)\r\n      const ids = []\r\n      cmd.qubits.forEach(qr => qr.forEach(qb => ids.push(qb.id)))\r\n      const out = this._simulator.measureQubits(ids)\r\n      let i = 0\r\n      cmd.qubits.forEach((qr) => {\r\n        qr.forEach((qb) => {\r\n          // Check if a mapper assigned a different logical id\r\n          let logical_id_tag\r\n          cmd.tags.forEach((tag) => {\r\n            if (tag instanceof LogicalQubitIDTag) {\r\n              logical_id_tag = tag\r\n            }\r\n          })\r\n          if (logical_id_tag) {\r\n            qb = new BasicQubit(qb.engine, logical_id_tag.logical_qubit_id)\r\n          }\r\n          this.main.setMeasurementResult(qb, out[i])\r\n          i += 1\r\n        })\r\n      })\r\n    } else if (cmd.gate.equal(Allocate)) {\r\n      const ID = cmd.qubits[0][0].id\r\n      this._simulator.allocateQubit(ID)\r\n    } else if (cmd.gate.equal(Deallocate)) {\r\n      const ID = cmd.qubits[0][0].id\r\n      this._simulator.deallocateQubit(ID)\r\n    } else if (cmd.gate instanceof BasicMathGate) {\r\n      const qubitids = []\r\n      cmd.qubits.forEach((qr) => {\r\n        const latest = []\r\n        qubitids.push(latest)\r\n        qr.forEach((qb) => {\r\n          latest.push(qb.id)\r\n        })\r\n      })\r\n\r\n      const math_fun = cmd.gate.getMathFunction(cmd.qubits)\r\n      this._simulator.emulateMath(math_fun, qubitids, cmd.controlQubits.map(qb => qb.id))\r\n    } else if (len(cmd.gate.matrix) <= 2 ** 5) {\r\n      const matrix = cmd.gate.matrix\r\n      const ids = []\r\n      cmd.qubits.forEach(qr => qr.forEach(qb => ids.push(qb.id)))\r\n      if (2 ** ids.length !== len(matrix)) {\r\n        throw new Error(`Simulator: Error applying ${cmd.gate.toString()} gate: ${math.log(len(cmd.gate.matrix), 2)}-qubit gate applied to ${ids.length} qubits.`)\r\n      }\r\n      const m = math.clone(matrix)._data\r\n      const ctrls = cmd.controlQubits.map(qb => qb.id)\r\n      this._simulator.applyControlledGate(m, ids, ctrls)\r\n      if (!this._gate_fusion) {\r\n        this._simulator.run()\r\n      }\r\n    } else {\r\n      throw new Error('This simulator only supports controlled k-qubit'\r\n      + ' gates with k < 6!\\nPlease add an auto-replacer'\r\n      + ' engine to your list of compiler engines.')\r\n    }\r\n  }\r\n\r\n  /**\r\n  Receive a list of commands from the previous engine and handle them\r\n(simulate them classically) prior to sending them on to the next\r\nengine.\r\n\r\n    @param {Command[]} commandList List of commands to execute on the simulator.\r\n   */\r\n  receive(commandList) {\r\n    commandList.forEach((cmd) => {\r\n      if (!(cmd.gate instanceof FlushGate)) {\r\n        this.handle(cmd)\r\n      } else {\r\n        this._simulator.run()\r\n      }\r\n      if (!this.isLastEngine) {\r\n        this.send([cmd])\r\n      }\r\n    })\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/backends/simulators/simulator.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 265,
    "kind": "class",
    "name": "Simulator",
    "memberof": "src/backends/simulators/simulator.js",
    "static": true,
    "longname": "src/backends/simulators/simulator.js~Simulator",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/backends/simulators/simulator.js",
    "importStyle": "Simulator",
    "description": "Simulator is a compiler engine which simulates a quantum computer using\nC++-based kernels.\n\nOpenMP is enabled and the number of threads can be controlled using the\nOMP_NUM_THREADS environment variable, i.e.",
    "examples": [
      "\nexport OMP_NUM_THREADS=4 # use 4 threads\nexport OMP_PROC_BIND=spread # bind threads to processors by spreading"
    ],
    "lineNumber": 48,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "Simulator"
      }
    ],
    "interface": false,
    "extends": [
      "src/cengines/basics.js~BasicEngine"
    ]
  },
  {
    "__docId__": 266,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/backends/simulators/simulator.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/simulator.js~Simulator#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 77,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": "Construct the C++/JavaScript-simulator object and initialize it with a\nrandom seed."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "gate_fusion",
        "description": "If true, gates are cached and only executed\nonce a certain gate-size has been reached (only has an effect\nfor the c++ simulator)."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "rnd_seed",
        "description": "Random seed (uses random.randint(0, 4294967295) by default). Ignored currently!!!"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "forceSimulation",
        "description": "if true, will force use cpp simulator\n\nExample of gate_fusion Instead of applying a Hadamard gate to 5\nqubits, the simulator calculates the kronecker product of the 1-qubit\ngate matrices and then applies one 5-qubit gate. This increases\noperational intensity and keeps the simulator from having to iterate\nthrough the state vector multiple times. Depending on the system (and,\nespecially, number of threads), this may or may not be beneficial.\n\nNote:\nIf the C++ Simulator extension was not built or cannot be found,\nthe Simulator defaults to a Javascript implementation of the kernels.\nWhile this is much slower, it is still good enough to run basic\nquantum algorithms.\n\nIf you need to run large simulations, check out the tutorial in\nthe docs which gives futher hints on how to build the C++\nextension."
      }
    ]
  },
  {
    "__docId__": 267,
    "kind": "member",
    "name": "_simulator",
    "memberof": "src/backends/simulators/simulator.js~Simulator",
    "static": false,
    "longname": "src/backends/simulators/simulator.js~Simulator#_simulator",
    "access": "private",
    "description": null,
    "lineNumber": 85,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 269,
    "kind": "member",
    "name": "_gate_fusion",
    "memberof": "src/backends/simulators/simulator.js~Simulator",
    "static": false,
    "longname": "src/backends/simulators/simulator.js~Simulator#_gate_fusion",
    "access": "private",
    "description": null,
    "lineNumber": 89,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 270,
    "kind": "method",
    "name": "isAvailable",
    "memberof": "src/backends/simulators/simulator.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/simulator.js~Simulator#isAvailable",
    "access": "public",
    "description": "Specialized implementation of isAvailable: The simulator can deal\nwith all arbitrarily-controlled gates which provide a\ngate-matrix (via gate.matrix) and acts on 5 or less qubits (not\ncounting the control qubits).",
    "lineNumber": 102,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": "Command for which to check availability (single-qubit gate, arbitrary controls)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if it can be simulated and false otherwise."
    }
  },
  {
    "__docId__": 271,
    "kind": "method",
    "name": "convertLogicalToMappedQureg",
    "memberof": "src/backends/simulators/simulator.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/simulator.js~Simulator#convertLogicalToMappedQureg",
    "access": "public",
    "description": "Converts a qureg from logical to mapped qubits if there is a mapper.",
    "lineNumber": 121,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array.<Qubit>",
          "Qureg"
        ],
        "spread": false,
        "optional": false,
        "name": "qureg",
        "description": "Logical quantum bits"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 272,
    "kind": "method",
    "name": "getExpectationValue",
    "memberof": "src/backends/simulators/simulator.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/simulator.js~Simulator#getExpectationValue",
    "access": "public",
    "description": "Get the expectation value of qubit_operator w.r.t. the current wave\nfunction represented by the supplied quantum register.",
    "lineNumber": 161,
    "params": [
      {
        "nullable": null,
        "types": [
          "QubitOperator"
        ],
        "spread": false,
        "optional": false,
        "name": "qubitOperator",
        "description": "Operator to measure."
      },
      {
        "nullable": null,
        "types": [
          "Array.<Qubit>",
          "Qureg"
        ],
        "spread": false,
        "optional": false,
        "name": "qureg",
        "description": "Quantum bits to measure."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "Expectation value\n\nNote:\nMake sure all previous commands (especially allocations) have\npassed through the compilation chain (call main.flush() to\nmake sure).\n\nNote:\nIf there is a mapper present in the compiler, this function\nautomatically converts from logical qubits to mapped qubits for\nthe qureg argument."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If `qubit_operator` acts on more qubits than present in the `qureg` argument."
      }
    ]
  },
  {
    "__docId__": 273,
    "kind": "method",
    "name": "applyQubitOperator",
    "memberof": "src/backends/simulators/simulator.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/simulator.js~Simulator#applyQubitOperator",
    "access": "public",
    "description": "Apply a (possibly non-unitary) qubit_operator to the current wave\nfunction represented by the supplied quantum register.",
    "lineNumber": 200,
    "params": [
      {
        "nullable": null,
        "types": [
          "QubitOperator"
        ],
        "spread": false,
        "optional": false,
        "name": "qubitOperator",
        "description": "Operator to apply."
      },
      {
        "nullable": null,
        "types": [
          "Array.<Qubit>",
          "Qureg"
        ],
        "spread": false,
        "optional": false,
        "name": "qureg",
        "description": "Quantum bits to which to apply the\noperator."
      }
    ],
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If `qubit_operator` acts on more qubits than present in the `qureg` argument.\n\nWarning:\nThis function allows applying non-unitary gates and it will not\nre-normalize the wave function! It is for numerical experiments\nonly and should not be used for other purposes.\n\nNote:\nMake sure all previous commands (especially allocations) have\npassed through the compilation chain (call main.flush() to\nmake sure).\n\nNote:\nIf there is a mapper present in the compiler, this function\nautomatically converts from logical qubits to mapped qubits for\nthe qureg argument."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 274,
    "kind": "method",
    "name": "getProbability",
    "memberof": "src/backends/simulators/simulator.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/simulator.js~Simulator#getProbability",
    "access": "public",
    "description": "Return the probability of the outcome `bit_string` when measuring\nthe quantum register `qureg`.",
    "lineNumber": 233,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} Probability of measuring the provided bit string.\n\nNote:\nMake sure all previous commands (especially allocations) have\npassed through the compilation chain (call main.flush() to\nmake sure).\n\nNote:\nIf there is a mapper present in the compiler, this function\nautomatically converts from logical qubits to mapped qubits for\nthe qureg argument."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]",
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "bitString",
        "description": "Measurement outcome."
      },
      {
        "nullable": null,
        "types": [
          "Qureg",
          "Array.<Qubit>"
        ],
        "spread": false,
        "optional": false,
        "name": "qureg",
        "description": "Quantum register."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Probability of measuring the provided bit string.\n\nNote:\nMake sure all previous commands (especially allocations) have\npassed through the compilation chain (call main.flush() to\nmake sure).\n\nNote:\nIf there is a mapper present in the compiler, this function\nautomatically converts from logical qubits to mapped qubits for\nthe qureg argument."
    }
  },
  {
    "__docId__": 275,
    "kind": "method",
    "name": "getAmplitude",
    "memberof": "src/backends/simulators/simulator.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/simulator.js~Simulator#getAmplitude",
    "access": "public",
    "description": "Return the probability amplitude of the supplied `bit_string`.\nThe ordering is given by the quantum register `qureg`, which must\ncontain all allocated qubits.",
    "lineNumber": 261,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}\nProbability amplitude of the provided bit string.\n\nNote:\nMake sure all previous commands (especially allocations) have\npassed through the compilation chain (call main.flush() to\nmake sure).\n\nNote:\nIf there is a mapper present in the compiler, this function\nautomatically converts from logical qubits to mapped qubits for\nthe qureg argument."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number[]",
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "bitString",
        "description": "Computational basis state"
      },
      {
        "nullable": null,
        "types": [
          "Qureg",
          "Array.<Qubit>"
        ],
        "spread": false,
        "optional": false,
        "name": "qureg",
        "description": "Quantum register determining the\nordering. Must contain all allocated qubits."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Probability amplitude of the provided bit string.\n\nNote:\nMake sure all previous commands (especially allocations) have\npassed through the compilation chain (call main.flush() to\nmake sure).\n\nNote:\nIf there is a mapper present in the compiler, this function\nautomatically converts from logical qubits to mapped qubits for\nthe qureg argument."
    }
  },
  {
    "__docId__": 276,
    "kind": "method",
    "name": "setWavefunction",
    "memberof": "src/backends/simulators/simulator.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/simulator.js~Simulator#setWavefunction",
    "access": "public",
    "description": "Set the wavefunction and the qubit ordering of the simulator.\n\nThe simulator will adopt the ordering of qureg (instead of reordering\nthe wavefunction).",
    "lineNumber": 286,
    "params": [
      {
        "nullable": null,
        "types": [
          "Complex[]"
        ],
        "spread": false,
        "optional": false,
        "name": "wavefunction",
        "description": "Array of complex amplitudes describing the wavefunction (must be normalized)."
      },
      {
        "nullable": null,
        "types": [
          "Qureg",
          "Array.<Qubit>"
        ],
        "spread": false,
        "optional": false,
        "name": "qureg",
        "description": "Quantum register determining the ordering. Must contain all allocated qubits.\n\nNote:\nMake sure all previous commands (especially allocations) have\npassed through the compilation chain (call main.flush() to\nmake sure).\n\nNote:\nIf there is a mapper present in the compiler, this function\nautomatically converts from logical qubits to mapped qubits for\nthe qureg argument."
      }
    ],
    "return": null
  },
  {
    "__docId__": 277,
    "kind": "method",
    "name": "collapseWavefunction",
    "memberof": "src/backends/simulators/simulator.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/simulator.js~Simulator#collapseWavefunction",
    "access": "public",
    "description": "Collapse a quantum register onto a classical basis state.",
    "lineNumber": 310,
    "params": [
      {
        "nullable": null,
        "types": [
          "Qureg",
          "Array.<Qubit>"
        ],
        "spread": false,
        "optional": false,
        "name": "qureg",
        "description": "Qubits to collapse."
      },
      {
        "nullable": null,
        "types": [
          "boolean[]"
        ],
        "spread": false,
        "optional": false,
        "name": "values",
        "description": "Measurement outcome for each of the qubits\nin `qureg`."
      }
    ],
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If an outcome has probability (approximately) 0 or\nif unknown qubits are provided (see note).\n\nNote:\nMake sure all previous commands have passed through the\ncompilation chain (call main.flush() to make sure).\n\nNote:\nIf there is a mapper present in the compiler, this function\nautomatically converts from logical qubits to mapped qubits for\nthe qureg argument."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 278,
    "kind": "method",
    "name": "cheat",
    "memberof": "src/backends/simulators/simulator.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/simulator.js~Simulator#cheat",
    "access": "public",
    "description": "Access the ordering of the qubits and the state vector directly.\n\nThis is a cheat function which enables, e.g., more efficient\nevaluation of expectation values and debugging.",
    "lineNumber": 335,
    "return": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": "A tuple where the first entry is a dictionary mapping qubit\nindices to bit-locations and the second entry is the corresponding\nstate vector.\n\nNote:\nMake sure all previous commands have passed through the\ncompilation chain (call main.flush() to make sure).\n\nNote:\nIf there is a mapper present in the compiler, this function\nDOES NOT automatically convert from logical qubits to mapped\nqubits."
    },
    "params": []
  },
  {
    "__docId__": 279,
    "kind": "method",
    "name": "handle",
    "memberof": "src/backends/simulators/simulator.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/simulator.js~Simulator#handle",
    "access": "public",
    "description": "Handle all commands, i.e., call the member functions of the C++-\nsimulator object corresponding to measurement, allocation/\ndeallocation, and (controlled) single-qubit gate.",
    "lineNumber": 348,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": "Command to handle."
      }
    ],
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "Error If a non-single-qubit gate needs to be processed (which should never happen due to isAvailable)."
      }
    ],
    "return": null
  },
  {
    "__docId__": 280,
    "kind": "method",
    "name": "receive",
    "memberof": "src/backends/simulators/simulator.js~Simulator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/simulator.js~Simulator#receive",
    "access": "public",
    "description": "Receive a list of commands from the previous engine and handle them\n(simulate them classically) prior to sending them on to the next\nengine.",
    "lineNumber": 427,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command[]"
        ],
        "spread": false,
        "optional": false,
        "name": "commandList",
        "description": "List of commands to execute on the simulator."
      }
    ],
    "return": null
  },
  {
    "__docId__": 281,
    "kind": "file",
    "name": "src/backends/simulators/simulator.spec.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport {expect} from 'chai'\r\nimport math from 'mathjs'\r\nimport {TrivialMapper} from './shared.spec'\r\nimport {BasicGate, BasicMathGate} from '../../ops/basics'\r\nimport {DummyEngine} from '../../cengines/testengine';\r\nimport MainEngine from '../../cengines/main';\r\nimport {\r\n  Allocate, H, Measure, X, Y, Rx, Ry, Rz, Z, S\r\n} from '../../ops/gates';\r\nimport Simulator from './simulator'\r\nimport {len} from '../../libs/polyfill';\r\nimport { CNOT, Toffoli } from '../../ops/shortcuts';\r\nimport {tuple} from '../../libs/util';\r\nimport {All} from '../../ops/metagates';\r\nimport {BasicQubit} from '../../types/qubit';\r\nimport Command from '../../ops/command';\r\nimport {LogicalQubitIDTag} from '../../meta/tag';\r\nimport {NotYetMeasuredError} from '../../meta/error';\r\nimport {Control} from '../../meta/control';\r\nimport {Dagger} from '../../meta/dagger';\r\nimport LocalOptimizer from '../../cengines/optimize';\r\nimport QubitOperator, {stringToArray} from '../../ops/qubitoperator';\r\nimport BasicMapperEngine from '../../cengines/basicmapper'\r\nimport TimeEvolution from '../../ops/timeevolution';\r\n\r\n/**\r\n *\r\n * @param m {Matrix}\r\n * @param idx {number}\r\n * @return {Complex}\r\n */\r\nfunction getMatrixValue(m, idx) {\r\n  let v\r\n  if (m.subset) {\r\n    v = m.subset(math.index(idx))\r\n  } else {\r\n    v = m[idx]\r\n  }\r\n  if (typeof v === 'number') {\r\n    v = math.complex(v, 0)\r\n  }\r\n  return v\r\n}\r\n\r\nclass Mock1QubitGate extends BasicGate {\r\n  constructor() {\r\n    super()\r\n    this.cnt = 0\r\n  }\r\n\r\n  get matrix() {\r\n    this.cnt += 1\r\n    return math.matrix([[0, 1], [1, 0]])\r\n  }\r\n}\r\n\r\nclass Mock6QubitGate extends BasicGate {\r\n  constructor() {\r\n    super()\r\n    this.cnt = 0\r\n  }\r\n\r\n  get matrix() {\r\n    this.cnt += 1\r\n    return math.identity(2 ** 6)\r\n  }\r\n}\r\n\r\nclass MockNoMatrixGate extends BasicGate {\r\n  constructor() {\r\n    super()\r\n    this.cnt = 0\r\n  }\r\n\r\n  get matrix() {\r\n    this.cnt += 1\r\n    throw new Error('AttributeError')\r\n  }\r\n}\r\n\r\nclass Plus2Gate extends BasicMathGate {\r\n  constructor() {\r\n    super((x) => {\r\n      return [x + 2]\r\n    })\r\n  }\r\n}\r\n\r\nfunction convertNativeMatrix(vec) {\r\n  const m = math.zeros(vec.length)\r\n  vec.forEach((val, idx) => {\r\n    m.subset(math.index(idx), math.complex(val.re, val.im))\r\n  })\r\n  return m\r\n}\r\n\r\nconst settings = [\r\n  ['CPP Simulator Test', false, null, false],\r\n  ['JS Simulator Test', false, null, true]\r\n]\r\n\r\nsettings.forEach(([testName, gate_fusion, rndSeed, forceSimulation]) => {\r\n  describe(testName, () => {\r\n    // it('should test_simulator_is_available', () => {\r\n    //   const sim = new Simulator(gate_fusion, rndSeed, forceSimulation)\r\n    //\r\n    //   const backend = new DummyEngine(true)\r\n    //   const eng = new MainEngine(backend, [])\r\n    //   const qubit = eng.allocateQubit()\r\n    //   Measure.or(qubit)\r\n    //   new BasicMathGate(x => x).or(qubit)\r\n    //   qubit[0].deallocate()\r\n    //\r\n    //   expect(backend.receivedCommands.length).to.equal(4)\r\n    //\r\n    //   // Test that allocate, measure, basic math, and deallocate are available.\r\n    //   backend.receivedCommands.forEach(cmd => sim.isAvailable(cmd))\r\n    //\r\n    //   const new_cmd = backend.receivedCommands[backend.receivedCommands.length - 1]\r\n    //\r\n    //   new_cmd.gate = new Mock1QubitGate()\r\n    //   expect(sim.isAvailable(new_cmd)).to.equal(true)\r\n    //   expect(new_cmd.gate.cnt).to.equal(1)\r\n    //\r\n    //   new_cmd.gate = new Mock6QubitGate()\r\n    //   expect(sim.isAvailable(new_cmd)).to.equal(false)\r\n    //   expect(new_cmd.gate.cnt).to.equal(1)\r\n    //\r\n    //   new_cmd.gate = new MockNoMatrixGate()\r\n    //\r\n    //   expect(sim.isAvailable(new_cmd)).to.equal(false)\r\n    //   expect(new_cmd.gate.cnt).to.equal(1)\r\n    // });\r\n    //\r\n    // it('should test_simulator_cheat', () => {\r\n    //   const sim = new Simulator(gate_fusion, rndSeed, forceSimulation)\r\n    //\r\n    //   // cheat function should return a tuple\r\n    //   expect(Array.isArray(sim.cheat())).to.equal(true)\r\n    //   // first entry is the qubit mapping.\r\n    //   // should be empty:\r\n    //\r\n    //   expect(Object.keys(sim.cheat()[0]).length).to.equal(0)\r\n    //   // state vector should only have 1 entry:\r\n    //   expect(len(sim.cheat()[1])).to.equal(1)\r\n    //   const eng = new MainEngine(sim, [])\r\n    //   const qubit = eng.allocateQubit()\r\n    //\r\n    //   // one qubit has been allocated\r\n    //   expect(len(sim.cheat()[0])).to.equal(1)\r\n    //   expect(sim.cheat()[0][0]).to.equal(0)\r\n    //\r\n    //   expect(len(sim.cheat()[1])).to.equal(2)\r\n    //   const v = getMatrixValue(sim.cheat()[1], 0)\r\n    //\r\n    //   expect(v.re).to.equal(1)\r\n    //   expect(v.im).to.equal(0)\r\n    //\r\n    //   qubit[0].deallocate()\r\n    //   // should be empty:\r\n    //   expect(Object.keys(sim.cheat()[0]).length).to.equal(0)\r\n    //   // state vector should only have 1 entry:\r\n    //   expect(len(sim.cheat()[1])).to.equal(1)\r\n    // });\r\n    //\r\n    // it('should test_simulator_functional_measurement', () => {\r\n    //   const sim = new Simulator(gate_fusion, rndSeed, forceSimulation)\r\n    //\r\n    //   const eng = new MainEngine(sim, [])\r\n    //   const qubits = eng.allocateQureg(5)\r\n    //   // entangle all qubits:\r\n    //   H.or(qubits[0])\r\n    //   qubits.slice(1).forEach((qb) => {\r\n    //     CNOT.or(tuple(qubits[0], qb))\r\n    //   })\r\n    //\r\n    //   new All(Measure).or(qubits)\r\n    //\r\n    //   qubits.forEach(q => console.log(q.toNumber()))\r\n    //   const bit_value_sum = qubits.reduce((accu, current) => accu + current.toNumber(), 0)\r\n    //   expect(bit_value_sum === 0 || bit_value_sum === 5).to.equal(true)\r\n    // });\r\n    //\r\n    // it('should test_simulator_measure_mapped_qubit', () => {\r\n    //   const sim = new Simulator(gate_fusion, rndSeed, forceSimulation)\r\n    //\r\n    //   const eng = new MainEngine(sim, [])\r\n    //   const qb1 = new BasicQubit(eng, 1)\r\n    //   const qb2 = new BasicQubit(eng, 2)\r\n    //   const cmd0 = new Command(eng, Allocate, tuple([qb1]))\r\n    //   const cmd1 = new Command(eng, X, tuple([qb1]))\r\n    //   const cmd2 = new Command(eng, Measure, tuple([qb1]), [], [new LogicalQubitIDTag(2)])\r\n    //\r\n    //   expect(() => qb1.toNumber()).to.throw(NotYetMeasuredError)\r\n    //   expect(() => qb2.toNumber()).to.throw(NotYetMeasuredError)\r\n    //   eng.send([cmd0, cmd1, cmd2])\r\n    //   eng.flush()\r\n    //\r\n    //   expect(() => qb1.toNumber()).to.throw(NotYetMeasuredError)\r\n    //   expect(qb2.toNumber()).to.equal(1)\r\n    // });\r\n    //\r\n    // it('should test_simulator_emulation', () => {\r\n    //   const sim = new Simulator(gate_fusion, rndSeed, forceSimulation)\r\n    //\r\n    //   const eng = new MainEngine(sim, [])\r\n    //   const qubit1 = eng.allocateQubit()\r\n    //   const qubit2 = eng.allocateQubit()\r\n    //   const qubit3 = eng.allocateQubit()\r\n    //\r\n    //   Control(eng, qubit3, () => new Plus2Gate().or(tuple(qubit1.concat(qubit2))))\r\n    //\r\n    //   let v = getMatrixValue(sim.cheat()[1], 0)\r\n    //   expect(v.re).to.equal(1)\r\n    //   X.or(qubit3)\r\n    //   Control(eng, qubit3, () => new Plus2Gate().or(tuple(qubit1.concat(qubit2))))\r\n    //   v = getMatrixValue(sim.cheat()[1], 6)\r\n    //   expect(v.re).to.equal(1)\r\n    //   expect(v.im).to.equal(0)\r\n    //\r\n    //   new All(Measure).or(tuple(qubit1.concat(qubit2).concat(qubit3)))\r\n    // });\r\n    //\r\n    // it('should test_simulator_kqubit_gate', () => {\r\n    //   const sim = new Simulator(gate_fusion, rndSeed, forceSimulation)\r\n    //   const m1 = new Rx(0.3).matrix\r\n    //   const m2 = new Rx(0.8).matrix\r\n    //   const m3 = new Ry(0.1).matrix\r\n    //   const m4 = math.multiply(new Rz(0.9).matrix, new Ry(-0.1).matrix)\r\n    //   const m = math.kron(m4, math.kron(m3, math.kron(m2, m1)))\r\n    //\r\n    //   class KQubitGate extends BasicGate {\r\n    //     get matrix() {\r\n    //       return m\r\n    //     }\r\n    //   }\r\n    //\r\n    //   const eng = new MainEngine(sim, [])\r\n    //   const qureg = eng.allocateQureg(4)\r\n    //   const qubit = eng.allocateQubit()\r\n    //   new Rx(-0.3).or(qureg[0])\r\n    //   new Rx(-0.8).or(qureg[1])\r\n    //   new Ry(-0.1).or(qureg[2])\r\n    //   new Rz(-0.9).or(qureg[3])\r\n    //   new Ry(0.1).or(qureg[3])\r\n    //\r\n    //   X.or(qubit)\r\n    //   console.log('-------------------------------------------------')\r\n    //   Control(eng, qubit, () => new KQubitGate().or(qureg))\r\n    //   console.log('-------------------------------------------------')\r\n    //\r\n    //   X.or(qubit)\r\n    //\r\n    //   Control(eng, qubit, () => Dagger(eng, () => new KQubitGate().or(qureg)))\r\n    //\r\n    //   expect(sim.getAmplitude('00000', qubit.concat(qureg)).re).to.be.closeTo(1, 1e-12)\r\n    //\r\n    //   class LargerGate extends BasicGate {\r\n    //     get matrix() {\r\n    //       return math.identiy(2 ** 6)\r\n    //     }\r\n    //   }\r\n    //\r\n    //   expect(() => new LargerGate().or(tuple(qureg.concat(qubit)))).to.throw()\r\n    // });\r\n    //\r\n    // it('should test_simulator_kqubit_exception', () => {\r\n    //   const sim = new Simulator(gate_fusion, rndSeed, forceSimulation)\r\n    //\r\n    //   const m1 = new Rx(0.3).matrix\r\n    //   const m2 = new Rx(0.8).matrix\r\n    //   const m3 = new Ry(0.1).matrix\r\n    //   const m4 = math.multiply(new Rz(0.9).matrix, new Ry(-0.1).matrix)\r\n    //   const m = math.kron(m4, math.kron(m3, math.kron(m2, m1)))\r\n    //\r\n    //   class KQubitGate extends BasicGate {\r\n    //     get matrix() {\r\n    //       return m\r\n    //     }\r\n    //   }\r\n    //\r\n    //   const eng = new MainEngine(sim, [])\r\n    //   const qureg = eng.allocateQureg(3)\r\n    //   expect(() => new KQubitGate().or(qureg)).to.throw()\r\n    //   expect(() => H.or(qureg)).to.throw()\r\n    // });\r\n    //\r\n    // it('should test_simulator_probability', () => {\r\n    //   const mp = new TrivialMapper()\r\n    //\r\n    //   const test = (mapper) => {\r\n    //     const sim = new Simulator(gate_fusion, rndSeed, forceSimulation)\r\n    //\r\n    //     const engine_list = [new LocalOptimizer()]\r\n    //     if (mapper) {\r\n    //       engine_list.push(mapper)\r\n    //     }\r\n    //\r\n    //     const eng = new MainEngine(sim, engine_list)\r\n    //     const qubits = eng.allocateQureg(6)\r\n    //     new All(H).or(qubits)\r\n    //     eng.flush()\r\n    //     const bits = [0, 0, 1, 0, 1, 0]\r\n    //     for (let i = 0; i < 6; ++i) {\r\n    //       expect(eng.backend.getProbability(bits.slice(0, i), qubits.slice(0, i))).to.be.closeTo(0.5 ** i, 1e-12)\r\n    //     }\r\n    //\r\n    //     const extra_qubit = eng.allocateQubit()\r\n    //     expect(() => eng.backend.getProbability([0], extra_qubit)).to.throw()\r\n    //\r\n    //     extra_qubit.deallocate()\r\n    //     new All(H).or(qubits)\r\n    //     new Ry(2 * math.acos(math.sqrt(0.3))).or(qubits[0])\r\n    //     eng.flush()\r\n    //     expect(eng.backend.getProbability([0], [qubits[0]])).to.be.closeTo(0.3, 1e-12)\r\n    //\r\n    //     new Ry(2 * math.acos(math.sqrt(0.4))).or(qubits[2])\r\n    //     eng.flush()\r\n    //     expect(eng.backend.getProbability([0], [qubits[2]])).to.be.closeTo(0.4, 1e-12)\r\n    //\r\n    //     expect(eng.backend.getProbability([0, 0], [qubits[0], qubits[2]])).to.be.closeTo(0.12, 1e-12)\r\n    //     expect(eng.backend.getProbability([0, 1], [qubits[0], qubits[2]])).to.be.closeTo(0.18, 1e-12)\r\n    //     expect(eng.backend.getProbability([1, 0], [qubits[0], qubits[2]])).to.be.closeTo(0.28, 1e-12)\r\n    //     new All(Measure).or(qubits)\r\n    //   }\r\n    //\r\n    //   test(mp)\r\n    //   test()\r\n    // });\r\n    //\r\n    // it('should test_simulator_amplitude', () => {\r\n    //   const mp = new TrivialMapper()\r\n    //   const test = (mapper) => {\r\n    //     const engine_list = [new LocalOptimizer()]\r\n    //     if (mapper) {\r\n    //       engine_list.push(mapper)\r\n    //     }\r\n    //\r\n    //     const eng = new MainEngine(new Simulator(gate_fusion, rndSeed, forceSimulation), engine_list)\r\n    //     const qubits = eng.allocateQureg(6)\r\n    //     new All(X).or(qubits)\r\n    //     new All(H).or(qubits)\r\n    //     eng.flush()\r\n    //     let bits = [0, 0, 1, 0, 1, 0]\r\n    //     expect(eng.backend.getAmplitude(bits, qubits).re).to.be.closeTo(1.0 / 8, 1e-12)\r\n    //     bits = [0, 0, 0, 0, 1, 0]\r\n    //\r\n    //     expect(eng.backend.getAmplitude(bits, qubits).re).to.be.closeTo(-1.0 / 8, 1e-12)\r\n    //     bits = [0, 1, 1, 0, 1, 0]\r\n    //     expect(eng.backend.getAmplitude(bits, qubits).re).to.be.closeTo(-1.0 / 8, 1e-12)\r\n    //     new All(H).or(qubits)\r\n    //     new All(X).or(qubits)\r\n    //     new Ry(2 * math.acos(0.3)).or(qubits[0])\r\n    //     eng.flush()\r\n    //     bits = [0, 0, 0, 0, 0, 0]\r\n    //     expect(eng.backend.getAmplitude(bits, qubits).re).to.be.closeTo(0.3, 1e-12)\r\n    //     bits[0] = 1\r\n    //     expect(eng.backend.getAmplitude(bits, qubits).re).to.be.closeTo(math.sqrt(0.91), 1e-12)\r\n    //\r\n    //     new All(Measure).or(qubits)\r\n    //     // raises if not all qubits are in the list:\r\n    //     expect(() => eng.backend.getAmplitude(bits, qubits.slice(0, qubits.length - 1))).to.throw()\r\n    //\r\n    //     // doesn't just check for length:\r\n    //     expect(() => eng.backend.getAmplitude(bits, qubits.slice(0, qubits.length - 1).concat(qubits[0]))).to.throw()\r\n    //     const extra_qubit = eng.allocateQubit()\r\n    //     eng.flush()\r\n    //     // there is a new qubit now!\r\n    //     expect(() => eng.backend.getAmplitude(bits, qubits)).to.throw()\r\n    //   }\r\n    //   test(mp)\r\n    //   test()\r\n    // });\r\n    //\r\n    // it('should test_simulator_expectation', () => {\r\n    //   const mp = new TrivialMapper()\r\n    //\r\n    //   const test = (mapper) => {\r\n    //     const sim = new Simulator(gate_fusion, rndSeed, forceSimulation)\r\n    //     const engine_list = mapper ? [mapper] : []\r\n    //\r\n    //     const eng = new MainEngine(sim, engine_list)\r\n    //     const qureg = eng.allocateQureg(3)\r\n    //     const op0 = new QubitOperator('Z0')\r\n    //     let expectation = sim.getExpectationValue(op0, qureg)\r\n    //     expect(math.re(expectation)).to.equal(1)\r\n    //\r\n    //     X.or(qureg[0])\r\n    //     expectation = sim.getExpectationValue(op0, qureg)\r\n    //     expect(expectation).to.equal(-1)\r\n    //\r\n    //     H.or(qureg[0])\r\n    //     const op1 = new QubitOperator('X0')\r\n    //     expectation = sim.getExpectationValue(op1, qureg)\r\n    //     expect(expectation).to.be.closeTo(-1, 1e-12)\r\n    //\r\n    //     Z.or(qureg[0])\r\n    //     expectation = sim.getExpectationValue(op1, qureg)\r\n    //     expect(expectation).to.be.closeTo(1, 1e-12)\r\n    //\r\n    //     X.or(qureg[0])\r\n    //     S.or(qureg[0])\r\n    //     Z.or(qureg[0])\r\n    //     X.or(qureg[0])\r\n    //\r\n    //     const op2 = new QubitOperator('Y0')\r\n    //     expectation = sim.getExpectationValue(op2, qureg)\r\n    //     expect(expectation).to.be.closeTo(1, 1e-12)\r\n    //\r\n    //     Z.or(qureg[0])\r\n    //     expectation = sim.getExpectationValue(op2, qureg)\r\n    //     expect(expectation).to.be.closeTo(-1, 1e-12)\r\n    //\r\n    //     let op_sum = new QubitOperator('Y0 X1 Z2').add(new QubitOperator('X1'))\r\n    //     H.or(qureg[1])\r\n    //     X.or(qureg[2])\r\n    //     expectation = sim.getExpectationValue(op_sum, qureg)\r\n    //\r\n    //     expect(expectation).to.be.closeTo(2, 1e-12)\r\n    //\r\n    //     op_sum = new QubitOperator('Y0 X1 Z2').add(new QubitOperator('X1'))\r\n    //     X.or(qureg[2])\r\n    //     expectation = sim.getExpectationValue(op_sum, qureg)\r\n    //\r\n    //     expect(expectation).to.be.closeTo(0, 1e-12)\r\n    //\r\n    //     const op_id = new QubitOperator([]).mul(0.4)\r\n    //     expectation = sim.getExpectationValue(op_id, qureg)\r\n    //     expect(expectation).to.be.closeTo(0.4, 1e-12)\r\n    //   }\r\n    //   test(mp)\r\n    //   test()\r\n    // });\r\n    //\r\n    // it('should test_simulator_expectation_exception', () => {\r\n    //   const sim = new Simulator(gate_fusion, rndSeed, forceSimulation)\r\n    //   const eng = new MainEngine(sim, [])\r\n    //   const qureg = eng.allocateQureg(3)\r\n    //   const op = new QubitOperator('Z2')\r\n    //   sim.getExpectationValue(op, qureg)\r\n    //   const op2 = new QubitOperator('Z3')\r\n    //   expect(() => sim.getExpectationValue(op2, qureg)).to.throw()\r\n    //   const op3 = new QubitOperator('Z1').add(new QubitOperator('X1 Y3'))\r\n    //   expect(() => sim.getExpectationValue(op3, qureg)).to.throw()\r\n    // });\r\n    //\r\n    // it('should test_simulator_applyqubitoperator_exception', () => {\r\n    //   const sim = new Simulator(gate_fusion, rndSeed, forceSimulation)\r\n    //   const eng = new MainEngine(sim, [])\r\n    //   const qureg = eng.allocateQureg(3)\r\n    //   const op = new QubitOperator('Z2')\r\n    //   sim.applyQubitOperator(op, qureg)\r\n    //   const op2 = new QubitOperator('Z3')\r\n    //   expect(() => sim.applyQubitOperator(op2, qureg)).to.throw()\r\n    //   const op3 = new QubitOperator('Z1').add(new QubitOperator('X1 Y3'))\r\n    //   expect(() => sim.applyQubitOperator(op3, qureg)).to.throw()\r\n    // });\r\n    //\r\n    // it('should test_simulator_applyqubitoperator', () => {\r\n    //   const mp = new TrivialMapper()\r\n    //\r\n    //   const test = (mapper) => {\r\n    //     const sim = new Simulator(gate_fusion, rndSeed, forceSimulation)\r\n    //     const engine_list = mapper ? [mapper] : []\r\n    //\r\n    //     const eng = new MainEngine(sim, engine_list)\r\n    //     const qureg = eng.allocateQureg(3)\r\n    //     let v = sim.cheat()\r\n    //     const op = new QubitOperator('X0 Y1 Z2')\r\n    //     sim.applyQubitOperator(op, qureg)\r\n    //     v = sim.cheat()\r\n    //     X.or(qureg[0])\r\n    //     v = sim.cheat()\r\n    //     Y.or(qureg[1])\r\n    //     v = sim.cheat()\r\n    //     Z.or(qureg[2])\r\n    //     v = sim.cheat()\r\n    //     let ret = sim.getAmplitude('000', qureg)\r\n    //     v = sim.cheat()\r\n    //     expect(ret.re).to.be.closeTo(1, 1e-12)\r\n    //\r\n    //     H.or(qureg[0])\r\n    //     const op_H = (new QubitOperator('X0').add(new QubitOperator('Z0'))).mul(1.0 / math.sqrt(2.0))\r\n    //     sim.applyQubitOperator(op_H, [qureg[0]])\r\n    //\r\n    //     ret = sim.getAmplitude('000', qureg)\r\n    //     expect(ret.re).to.be.closeTo(1, 1e-12)\r\n    //\r\n    //     const op_Proj0 = new QubitOperator('').add(new QubitOperator('Z0')).mul(0.5)\r\n    //     const op_Proj1 = new QubitOperator('').sub(new QubitOperator('Z0')).mul(0.5)\r\n    //     H.or(qureg[0])\r\n    //     sim.applyQubitOperator(op_Proj0, [qureg[0]])\r\n    //\r\n    //     ret = sim.getAmplitude('000', qureg)\r\n    //     expect(ret.re).to.be.closeTo(1.0 / math.sqrt(2.0), 1e-12)\r\n    //     sim.applyQubitOperator(op_Proj1, [qureg[0]])\r\n    //\r\n    //     ret = sim.getAmplitude('000', qureg)\r\n    //     expect(ret.re).to.be.closeTo(0, 1e-12)\r\n    //   }\r\n    //\r\n    //   test(mp)\r\n    //   test()\r\n    // });\r\n    //\r\n    it('should test_simulator_time_evolution', function () {\r\n      this.timeout(600 * 1000)\r\n\r\n      console.log('start time evolution', Date.now())\r\n\r\n      const sim = new Simulator(gate_fusion, rndSeed, forceSimulation)\r\n      const N = 8 // number of qubits\r\n      const time_to_evolve = 1.1 // time to evolve for\r\n      const eng = new MainEngine(sim, [])\r\n      const qureg = eng.allocateQureg(N)\r\n      // initialize in random wavefunction by applying some gates:\r\n      qureg.forEach((qb) => {\r\n        new Rx(Math.random()).or(qb)\r\n        new Ry(Math.random()).or(qb)\r\n      })\r\n      eng.flush()\r\n      // Use cheat to get initial start wavefunction:\r\n      let [_, init_wavefunction] = eng.backend.cheat()\r\n      init_wavefunction = math.clone(init_wavefunction)\r\n      const Qop = QubitOperator\r\n      const op = new Qop('X0 Y1 Z2 Y3 X4').mul(0.3)\r\n      op.iadd(new Qop([]).mul(1.1))\r\n      op.iadd(new Qop('Y0 Z1 X3 Y5').mul(-1.4))\r\n      op.iadd(new Qop('Y1 X2 X3 Y4').mul(-1.1))\r\n      const ctrl_qubit = eng.allocateQubit()\r\n      H.or(ctrl_qubit)\r\n      Control(eng, ctrl_qubit, () => new TimeEvolution(time_to_evolve, op).or(qureg))\r\n      eng.flush()\r\n      let [qbit_to_bit_map2, final_wavefunction] = eng.backend.cheat()\r\n      final_wavefunction = math.clone(final_wavefunction)\r\n      const map = {}\r\n      Object.assign(map, qbit_to_bit_map2)\r\n      qbit_to_bit_map2 = map\r\n      new All(Measure).or(qureg.concat(ctrl_qubit))\r\n\r\n      console.log('end time evolution', Date.now())\r\n      // Check manually:\r\n\r\n      const build_matrix = (list_single_matrices) => {\r\n        let res = list_single_matrices[0]\r\n        for (let i = 1; i < len(list_single_matrices); ++i) {\r\n          res = math.kron(res, list_single_matrices[i])\r\n        }\r\n        return res\r\n      }\r\n      const mc = math.complex\r\n      const id_sp = math.identity(2, 'sparse')\r\n      const x_sp = math.sparse([[0.0, 1.0], [1.0, 0.0]])\r\n      const y_sp = math.sparse([[0.0, mc(0, -1.0)], [mc(0, 1.0), 0.0]])\r\n      const z_sp = math.sparse([[1.0, 0.0], [0.0, -1.0]])\r\n      const gates = {X: x_sp, Y: y_sp, Z: z_sp}\r\n\r\n      let res_matrix = 0\r\n      Object.keys(op.terms).forEach((k) => {\r\n        // id_sp * N\r\n        const matrix = [id_sp, id_sp, id_sp, id_sp, id_sp, id_sp, id_sp, id_sp]\r\n        const t = stringToArray(k)\r\n        const c = op.terms[k]\r\n        t.forEach(([idx, gate]) => {\r\n          matrix[qbit_to_bit_map2[qureg[idx].id]] = gates[gate]\r\n        })\r\n        matrix.reverse()\r\n        res_matrix = math.add(res_matrix, math.multiply(build_matrix(matrix), c))\r\n      })\r\n\r\n      res_matrix = math.multiply(res_matrix, mc(0, -time_to_evolve))\r\n\r\n      init_wavefunction = math.flatten(init_wavefunction)\r\n      init_wavefunction = convertNativeMatrix(init_wavefunction)\r\n      final_wavefunction = math.flatten(final_wavefunction)\r\n      final_wavefunction = convertNativeMatrix(final_wavefunction)\r\n\r\n      console.log('tick', Date.now())\r\n      const res = math.multiply(math.expm(res_matrix), init_wavefunction)\r\n      console.log('tick', Date.now())\r\n\r\n      const count = len(final_wavefunction)\r\n      const half = Math.floor(count / 2)\r\n      const hadamard_f = 1.0 / math.sqrt(2.0)\r\n      // check evolution and control\r\n      const tail = getMatrixValue(final_wavefunction, math.range(half, count))\r\n      const head = getMatrixValue(final_wavefunction, math.range(0, half))\r\n      const ra = math.multiply(hadamard_f, res)\r\n      console.log(ra, tail)\r\n      expect(math.deepEqual(ra, tail)).to.equal(true)\r\n      expect(math.deepEqual(head, math.multiply(hadamard_f, init_wavefunction))).to.equal(true)\r\n    });\r\n    //\r\n    // it('should test_simulator_set_wavefunction', () => {\r\n    //   const mp = new TrivialMapper()\r\n    //\r\n    //   const test = (mapper) => {\r\n    //     const sim = new Simulator(gate_fusion, rndSeed, forceSimulation)\r\n    //     const engine_list = [new LocalOptimizer()]\r\n    //     if (mapper) {\r\n    //       engine_list.push(mapper)\r\n    //     }\r\n    //\r\n    //     const eng = new MainEngine(sim, engine_list)\r\n    //     const qubits = eng.allocateQureg(2)\r\n    //     const wf = [0.0, 0.0, math.sqrt(0.2), math.sqrt(0.8)]\r\n    //     expect(() => eng.backend.setWavefunction(wf, qubits)).to.throw()\r\n    //     eng.flush()\r\n    //     eng.backend.setWavefunction(wf, qubits)\r\n    //\r\n    //     expect(eng.backend.getProbability('1', [qubits[0]])).to.be.closeTo(0.8, 1e-12)\r\n    //     expect(eng.backend.getProbability('01', qubits)).to.be.closeTo(0.2, 1e-12)\r\n    //     expect(eng.backend.getProbability('1', [qubits[1]])).to.be.closeTo(1, 1e-12)\r\n    //     new All(Measure).or(qubits)\r\n    //   }\r\n    //\r\n    //   test(mp)\r\n    //   test()\r\n    // });\r\n    //\r\n    // it('should test_simulator_set_wavefunction_always_complex', () => {\r\n    //   const sim = new Simulator(gate_fusion, rndSeed, forceSimulation)\r\n    //   const eng = new MainEngine(sim)\r\n    //   const qubit = eng.allocateQubit()\r\n    //   eng.flush()\r\n    //   const wf = [1.0, 0]\r\n    //   eng.backend.setWavefunction(wf, qubit)\r\n    //   Y.or(qubit)\r\n    //   eng.flush()\r\n    //   const c = eng.backend.getAmplitude('1', qubit)\r\n    //   expect(math.abs(math.complex(c.re, c.im))).to.be.closeTo(1, 1e-12)\r\n    // });\r\n    //\r\n    // it('should test_simulator_collapse_wavefunction', () => {\r\n    //   const mp = new TrivialMapper()\r\n    //   const test = (mapper) => {\r\n    //     const sim = new Simulator(gate_fusion, rndSeed, forceSimulation)\r\n    //     const engine_list = [new LocalOptimizer()]\r\n    //     if (mapper) {\r\n    //       engine_list.push(mapper)\r\n    //     }\r\n    //\r\n    //     const eng = new MainEngine(sim, engine_list)\r\n    //     const qubits = eng.allocateQureg(4)\r\n    //     // unknown qubits: raises\r\n    //     expect(() => eng.backend.collapseWavefunction(qubits, [0, 0, 0, 0])).to.throw()\r\n    //     eng.flush()\r\n    //     eng.backend.collapseWavefunction(qubits, [0, 0, 0, 0])\r\n    //     const v = eng.backend.getProbability([0, 0, 0, 0], qubits)\r\n    //     console.log(544, v)\r\n    //     expect(v).to.be.closeTo(1, 1e-12)\r\n    //     new All(H).or(qubits.slice(1))\r\n    //     eng.flush()\r\n    //     expect(eng.backend.getProbability([0, 0, 0, 0], qubits)).to.be.closeTo(0.125, 1e-12)\r\n    //\r\n    //     // impossible outcome: raises\r\n    //     expect(() => eng.backend.collapseWavefunction(qubits, [1, 0, 0, 0])).to.throw()\r\n    //     eng.backend.collapseWavefunction(qubits.slice(0, qubits.length - 1), [0, 1, 0])\r\n    //     let probability = eng.backend.getProbability([0, 1, 0, 1], qubits)\r\n    //     expect(probability).to.be.closeTo(0.5, 1e-12)\r\n    //\r\n    //     eng.backend.setWavefunction([1.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], qubits)\r\n    //     H.or(qubits[0])\r\n    //     CNOT.or(tuple(qubits[0], qubits[1]))\r\n    //     eng.flush()\r\n    //     eng.backend.collapseWavefunction([qubits[0]], [1])\r\n    //     probability = eng.backend.getProbability([1, 1], qubits.slice(0, 2))\r\n    //     expect(probability).to.be.closeTo(1, 1e-12)\r\n    //   }\r\n    //   test(mp)\r\n    //   test()\r\n    // });\r\n    //\r\n    // it('should test_simulator_no_uncompute_exception', () => {\r\n    //   const sim = new Simulator(gate_fusion, rndSeed, forceSimulation)\r\n    //   const eng = new MainEngine(sim, [])\r\n    //   const qubit = eng.allocateQubit()\r\n    //   H.or(qubit)\r\n    //   expect(() => qubit[0].deallocate()).to.throw()\r\n    //\r\n    //   // If you wanted to keep using the qubit, you shouldn't have deleted it.\r\n    //   expect(qubit[0].id).to.equal(-1)\r\n    // });\r\n    //\r\n    // it('should test_simulator_flush', () => {\r\n    //   class MockSimulatorBackend {\r\n    //     constructor() {\r\n    //       this.run_cnt = 0\r\n    //     }\r\n    //\r\n    //     run() {\r\n    //       this.run_cnt += 1\r\n    //     }\r\n    //   }\r\n    //\r\n    //   const sim = new Simulator(gate_fusion, rndSeed, forceSimulation)\r\n    //   sim._simulator = new MockSimulatorBackend()\r\n    //\r\n    //   const eng = new MainEngine(sim)\r\n    //   eng.flush()\r\n    //\r\n    //   expect(sim._simulator.run_cnt).to.equal(1)\r\n    // });\r\n    //\r\n    // it('should test_simulator_send', () => {\r\n    //   const sim = new Simulator(gate_fusion, rndSeed, forceSimulation)\r\n    //   const backend = new DummyEngine(true)\r\n    //\r\n    //   const eng = new MainEngine(backend, [sim])\r\n    //\r\n    //   const qubit = eng.allocateQubit()\r\n    //   H.or(qubit)\r\n    //   Measure.or(qubit)\r\n    //   qubit.deallocate()\r\n    //   eng.flush()\r\n    //\r\n    //   expect(len(backend.receivedCommands)).to.equal(5)\r\n    // });\r\n    //\r\n    // it('should test_simulator_functional_entangle', () => {\r\n    //   const sim = new Simulator(gate_fusion, rndSeed, forceSimulation)\r\n    //   const eng = new MainEngine(sim, [])\r\n    //   const qubits = eng.allocateQureg(5)\r\n    //   // entangle all qubits:\r\n    //   H.or(qubits[0])\r\n    //   qubits.slice(1).forEach(qb => CNOT.or(tuple(qubits[0], qb)))\r\n    //\r\n    //   // check the state vector:\r\n    //   let m = sim.cheat()[1]\r\n    //   m = convertNativeMatrix(m)\r\n    //   expect(math.abs(getMatrixValue(m, 0)) ** 2).to.be.closeTo(0.5, 1e-12)\r\n    //   expect(math.abs(getMatrixValue(m, 31)) ** 2).to.be.closeTo(0.5, 1e-12)\r\n    //\r\n    //   for (let i = 1; i < 31; ++i) {\r\n    //     let v = sim.cheat()[1][i]\r\n    //     v = math.complex(v.re, v.im)\r\n    //     expect(math.abs(v)).to.be.closeTo(0, 1e-12)\r\n    //   }\r\n    //\r\n    //   // unentangle all except the first 2\r\n    //   qubits.slice(2).forEach(qb => CNOT.or(tuple(qubits[0], qb)))\r\n    //\r\n    //   // entangle using Toffolis\r\n    //   qubits.slice(2).forEach(qb => Toffoli.or(tuple(qubits[0], qubits[1], qb)))\r\n    //\r\n    //   // check the state vector:\r\n    //   console.log(sim.cheat()[1][0], sim.cheat()[1][31])\r\n    //\r\n    //   m = sim.cheat()[1]\r\n    //   m = convertNativeMatrix(m)\r\n    //   const v31 = math.re(math.abs(getMatrixValue(m, 31)))\r\n    //   expect(math.re(math.abs(getMatrixValue(m, 0)))).to.be.closeTo(Math.SQRT1_2, 1e-12)\r\n    //   expect(v31).to.be.closeTo(Math.SQRT1_2, 1e-12)\r\n    //\r\n    //   for (let i = 1; i < 31; ++i) {\r\n    //     let v = sim.cheat()[1][i]\r\n    //     v = math.complex(v.re, v.im)\r\n    //     expect(math.abs(v)).to.be.closeTo(0, 1e-12)\r\n    //   }\r\n    //\r\n    //   // uncompute using multi-controlled NOTs\r\n    //   Control(eng, qubits.slice(0, qubits.length - 1), () => X.or(qubits[qubits.length - 1]))\r\n    //   Control(eng, qubits.slice(0, qubits.length - 2), () => X.or(qubits[qubits.length - 2]))\r\n    //   Control(eng, qubits.slice(0, qubits.length - 3), () => X.or(qubits[qubits.length - 3]))\r\n    //   CNOT.or(tuple(qubits[0], qubits[1]))\r\n    //   H.or(qubits[0])\r\n    //\r\n    //   // check the state vector:\r\n    //   const mm = sim.cheat()[1]\r\n    //   let v0 = getMatrixValue(mm, 0)\r\n    //   v0 = math.complex(v0.re, v0.im)\r\n    //   expect(math.re(math.abs(v0))).to.be.closeTo(1, 1e-12)\r\n    //   for (let i = 1; i < 32; ++i) {\r\n    //     let v = sim.cheat()[1][i]\r\n    //     v = math.complex(v.re, v.im)\r\n    //     expect(math.re(math.abs(v))).to.be.closeTo(0, 1e-12)\r\n    //   }\r\n    //\r\n    //   new All(Measure).or(qubits)\r\n    // });\r\n    //\r\n    // it('should test_simulator_convert_logical_to_mapped_qubits', () => {\r\n    //   const sim = new Simulator(gate_fusion, rndSeed, forceSimulation)\r\n    //   const mapper = new BasicMapperEngine()\r\n    //\r\n    //   const receive = (command_list) => { }\r\n    //\r\n    //   mapper.receive = receive\r\n    //   const eng = new MainEngine(sim, [mapper])\r\n    //   const qubit0 = eng.allocateQubit()\r\n    //   const qubit1 = eng.allocateQubit()\r\n    //   mapper.currentMapping = {\r\n    //     [qubit0[0].id]: qubit1[0].id,\r\n    //     [qubit1[0].id]: qubit0[0].id\r\n    //   }\r\n    //   expect(sim.convertLogicalToMappedQureg(qubit0.concat(qubit1))).to.deep.equal(qubit1.concat(qubit0))\r\n    // });\r\n  })\r\n})\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/backends/simulators/simulator.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 282,
    "kind": "function",
    "name": "getMatrixValue",
    "memberof": "src/backends/simulators/simulator.spec.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/backends/simulators/simulator.spec.js~getMatrixValue",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/backends/simulators/simulator.spec.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 48,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "m",
        "description": "{Matrix}"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "idx",
        "description": "{number}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Complex"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 283,
    "kind": "class",
    "name": "Mock1QubitGate",
    "memberof": "src/backends/simulators/simulator.spec.js",
    "static": true,
    "longname": "src/backends/simulators/simulator.spec.js~Mock1QubitGate",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/backends/simulators/simulator.spec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 61,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/ops/basics.js~BasicGate"
    ],
    "ignore": true
  },
  {
    "__docId__": 284,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/backends/simulators/simulator.spec.js~Mock1QubitGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/simulator.spec.js~Mock1QubitGate#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 62,
    "undocument": true
  },
  {
    "__docId__": 285,
    "kind": "member",
    "name": "cnt",
    "memberof": "src/backends/simulators/simulator.spec.js~Mock1QubitGate",
    "static": false,
    "longname": "src/backends/simulators/simulator.spec.js~Mock1QubitGate#cnt",
    "access": "public",
    "description": null,
    "lineNumber": 64,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 286,
    "kind": "get",
    "name": "matrix",
    "memberof": "src/backends/simulators/simulator.spec.js~Mock1QubitGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/simulator.spec.js~Mock1QubitGate#matrix",
    "access": "public",
    "description": null,
    "lineNumber": 67,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 288,
    "kind": "class",
    "name": "Mock6QubitGate",
    "memberof": "src/backends/simulators/simulator.spec.js",
    "static": true,
    "longname": "src/backends/simulators/simulator.spec.js~Mock6QubitGate",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/backends/simulators/simulator.spec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 73,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/ops/basics.js~BasicGate"
    ],
    "ignore": true
  },
  {
    "__docId__": 289,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/backends/simulators/simulator.spec.js~Mock6QubitGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/simulator.spec.js~Mock6QubitGate#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 74,
    "undocument": true
  },
  {
    "__docId__": 290,
    "kind": "member",
    "name": "cnt",
    "memberof": "src/backends/simulators/simulator.spec.js~Mock6QubitGate",
    "static": false,
    "longname": "src/backends/simulators/simulator.spec.js~Mock6QubitGate#cnt",
    "access": "public",
    "description": null,
    "lineNumber": 76,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 291,
    "kind": "get",
    "name": "matrix",
    "memberof": "src/backends/simulators/simulator.spec.js~Mock6QubitGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/simulator.spec.js~Mock6QubitGate#matrix",
    "access": "public",
    "description": null,
    "lineNumber": 79,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 293,
    "kind": "class",
    "name": "MockNoMatrixGate",
    "memberof": "src/backends/simulators/simulator.spec.js",
    "static": true,
    "longname": "src/backends/simulators/simulator.spec.js~MockNoMatrixGate",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/backends/simulators/simulator.spec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 85,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/ops/basics.js~BasicGate"
    ],
    "ignore": true
  },
  {
    "__docId__": 294,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/backends/simulators/simulator.spec.js~MockNoMatrixGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/simulator.spec.js~MockNoMatrixGate#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 86,
    "undocument": true
  },
  {
    "__docId__": 295,
    "kind": "member",
    "name": "cnt",
    "memberof": "src/backends/simulators/simulator.spec.js~MockNoMatrixGate",
    "static": false,
    "longname": "src/backends/simulators/simulator.spec.js~MockNoMatrixGate#cnt",
    "access": "public",
    "description": null,
    "lineNumber": 88,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 296,
    "kind": "get",
    "name": "matrix",
    "memberof": "src/backends/simulators/simulator.spec.js~MockNoMatrixGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/simulator.spec.js~MockNoMatrixGate#matrix",
    "access": "public",
    "description": null,
    "lineNumber": 91,
    "undocument": true,
    "type": null
  },
  {
    "__docId__": 298,
    "kind": "class",
    "name": "Plus2Gate",
    "memberof": "src/backends/simulators/simulator.spec.js",
    "static": true,
    "longname": "src/backends/simulators/simulator.spec.js~Plus2Gate",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/backends/simulators/simulator.spec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 97,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/ops/basics.js~BasicMathGate"
    ],
    "ignore": true
  },
  {
    "__docId__": 299,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/backends/simulators/simulator.spec.js~Plus2Gate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/backends/simulators/simulator.spec.js~Plus2Gate#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 98,
    "undocument": true
  },
  {
    "__docId__": 300,
    "kind": "function",
    "name": "convertNativeMatrix",
    "memberof": "src/backends/simulators/simulator.spec.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/backends/simulators/simulator.spec.js~convertNativeMatrix",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/backends/simulators/simulator.spec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 105,
    "undocument": true,
    "params": [
      {
        "name": "vec",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 301,
    "kind": "variable",
    "name": "settings",
    "memberof": "src/backends/simulators/simulator.spec.js",
    "static": true,
    "longname": "src/backends/simulators/simulator.spec.js~settings",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/backends/simulators/simulator.spec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 113,
    "undocument": true,
    "type": {
      "types": [
        "undefined[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 302,
    "kind": "file",
    "name": "src/cengines/basicmapper.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n\r\nimport {BasicEngine} from './basics'\r\nimport {LogicalQubitIDTag} from '../meta/tag'\r\nimport {dropEngineAfter, insertEngine} from '../meta/util'\r\nimport {MeasureGate} from '../ops/gates'\r\nimport CommandModifier from './cmdmodifier'\r\n\r\n/**\r\n * @class BasicMapperEngine\r\n * @desc\r\nDefines the parent class from which all mappers should be derived.\r\n\r\n    There is only one engine currently allowed to be derived from\r\nBasicMapperEngine. This allows the simulator to automatically translate\r\nlogical qubit ids to mapped ids.\r\n*/\r\nexport default class BasicMapperEngine extends BasicEngine {\r\n  /**\r\n   * @constructor\r\n  Parent class for all Mappers.\r\n\r\nthis.current_mapping (dict): Keys are the logical qubit ids and values\r\nare the mapped qubit ids.\r\n   */\r\n  constructor() {\r\n    super()\r\n    this._currentMapping = null\r\n  }\r\n\r\n  get currentMapping() {\r\n    return Object.assign({}, this._currentMapping)\r\n  }\r\n\r\n  set currentMapping(newMap) {\r\n    this._currentMapping = newMap\r\n  }\r\n\r\n  /**\r\n  Send this Command using the mapped qubit ids of this.current_mapping.\r\n\r\n    If it is a Measurement gate, then it adds a LogicalQubitID tag.\r\n\r\n    @param {Command} cmd Command object with logical qubit ids.\r\n   */\r\n  sendCMDWithMappedIDs(cmd) {\r\n    const newCMD = cmd.copy()\r\n    const qubits = newCMD.qubits\r\n    qubits.forEach((qureg) => {\r\n      qureg.forEach((qubit) => {\r\n        if (qubit.id !== -1) {\r\n          qubit.id = this._currentMapping[qubit.id]\r\n        }\r\n      })\r\n    })\r\n    const controlQubits = newCMD.controlQubits\r\n    controlQubits.forEach((qubit) => {\r\n      qubit.id = this._currentMapping[qubit.id]\r\n    })\r\n    if (newCMD.gate instanceof MeasureGate) {\r\n      if (!(newCMD.qubits.length === 1 && newCMD.qubits[0].length === 1)) {\r\n        throw new Error('assert error')\r\n      }\r\n      // Add LogicalQubitIDTag to MeasureGate\r\n      const add_logical_id = function (command, old_tags = cmd.tags.slice(0)) {\r\n        old_tags.push(new LogicalQubitIDTag(cmd.qubits[0][0].id))\r\n        command.tags = old_tags\r\n        return command\r\n      }\r\n\r\n      const tagger_eng = new CommandModifier(add_logical_id)\r\n      insertEngine(this, tagger_eng)\r\n      this.send([newCMD])\r\n      dropEngineAfter(this)\r\n    } else {\r\n      this.send([newCMD])\r\n    }\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/cengines/basicmapper.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 303,
    "kind": "class",
    "name": "BasicMapperEngine",
    "memberof": "src/cengines/basicmapper.js",
    "static": true,
    "longname": "src/cengines/basicmapper.js~BasicMapperEngine",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/cengines/basicmapper.js",
    "importStyle": "BasicMapperEngine",
    "description": "Defines the parent class from which all mappers should be derived.\n\nThere is only one engine currently allowed to be derived from\nBasicMapperEngine. This allows the simulator to automatically translate\nlogical qubit ids to mapped ids.",
    "lineNumber": 33,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "BasicMapperEngine"
      }
    ],
    "interface": false,
    "extends": [
      "src/cengines/basics.js~BasicEngine"
    ]
  },
  {
    "__docId__": 304,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/cengines/basicmapper.js~BasicMapperEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/basicmapper.js~BasicMapperEngine#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 41,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": "Parent class for all Mappers.\n\nthis.current_mapping (dict): Keys are the logical qubit ids and values\nare the mapped qubit ids."
      }
    ]
  },
  {
    "__docId__": 305,
    "kind": "member",
    "name": "_currentMapping",
    "memberof": "src/cengines/basicmapper.js~BasicMapperEngine",
    "static": false,
    "longname": "src/cengines/basicmapper.js~BasicMapperEngine#_currentMapping",
    "access": "private",
    "description": null,
    "lineNumber": 43,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 306,
    "kind": "get",
    "name": "currentMapping",
    "memberof": "src/cengines/basicmapper.js~BasicMapperEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/basicmapper.js~BasicMapperEngine#currentMapping",
    "access": "public",
    "description": null,
    "lineNumber": 46,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 307,
    "kind": "set",
    "name": "currentMapping",
    "memberof": "src/cengines/basicmapper.js~BasicMapperEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/basicmapper.js~BasicMapperEngine#currentMapping",
    "access": "public",
    "description": null,
    "lineNumber": 50,
    "undocument": true
  },
  {
    "__docId__": 309,
    "kind": "method",
    "name": "sendCMDWithMappedIDs",
    "memberof": "src/cengines/basicmapper.js~BasicMapperEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/basicmapper.js~BasicMapperEngine#sendCMDWithMappedIDs",
    "access": "public",
    "description": "Send this Command using the mapped qubit ids of this.current_mapping.\n\nIf it is a Measurement gate, then it adds a LogicalQubitID tag.",
    "lineNumber": 61,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": "Command object with logical qubit ids."
      }
    ],
    "return": null
  },
  {
    "__docId__": 310,
    "kind": "file",
    "name": "src/cengines/basicmapper.spec.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport {expect} from 'chai'\r\nimport BasicMapperEngine from './basicmapper'\r\nimport {DummyEngine} from './testengine'\r\nimport { BasicQubit } from '../types/qubit'\r\nimport Command from '../ops/command'\r\nimport {\r\n  Allocate, Deallocate, Measure, FlushGate\r\n} from '../ops/gates'\r\nimport {BasicGate} from '../ops/basics'\r\nimport { tuple } from '../libs/util'\r\nimport {LogicalQubitIDTag} from '../meta/tag'\r\n\r\ndescribe('basic mapper test', () => {\r\n  it('should test basic_mapper_engine_send_cmd_with_mapped_ids', () => {\r\n    const mapper = new BasicMapperEngine()\r\n    mapper.currentMapping = {\r\n      0: 3, 1: 2, 2: 1, 3: 0\r\n    }\r\n    const backend = new DummyEngine(true)\r\n    backend.isLastEngine = true\r\n    mapper.next = backend\r\n    // generate a few commands\r\n    const qb0 = new BasicQubit(null, 0)\r\n    const qb1 = new BasicQubit(null, 1)\r\n    const qb2 = new BasicQubit(null, 2)\r\n    const qb3 = new BasicQubit(null, 3)\r\n\r\n    const cmd0 = new Command(null, Allocate, tuple([qb0]), [], [])\r\n    const cmd1 = new Command(null, Deallocate, tuple([qb1]), [], [])\r\n    const cmd2 = new Command(null, Measure, tuple([qb2]), [], ['SomeTag'])\r\n    const cmd3 = new Command(null, new BasicGate(), tuple([qb0, qb1], [qb2]), [qb3], [])\r\n    const cmd4 = new Command(null, new FlushGate(), tuple([new BasicQubit(null, -1)]))\r\n    mapper.sendCMDWithMappedIDs(cmd0)\r\n    mapper.sendCMDWithMappedIDs(cmd1)\r\n    mapper.sendCMDWithMappedIDs(cmd2)\r\n    mapper.sendCMDWithMappedIDs(cmd3)\r\n    mapper.sendCMDWithMappedIDs(cmd4)\r\n\r\n    const rcmd0 = backend.receivedCommands[0]\r\n    const rcmd1 = backend.receivedCommands[1]\r\n    const rcmd2 = backend.receivedCommands[2]\r\n    const rcmd3 = backend.receivedCommands[3]\r\n    const rcmd4 = backend.receivedCommands[4]\r\n\r\n    expect(rcmd0.gate.equal(Allocate)).to.equal(true)\r\n    expect(rcmd0.qubits).to.deep.equal(tuple([qb3]))\r\n    expect(rcmd1.gate.equal(Deallocate)).to.equal(true)\r\n    expect(rcmd1.qubits).to.deep.equal(tuple([qb2]))\r\n    expect(rcmd2.gate.equal(Measure)).to.equal(true)\r\n    expect(rcmd2.qubits).to.deep.equal(tuple([qb1]))\r\n    expect(rcmd2.tags).to.deep.equal(['SomeTag', new LogicalQubitIDTag(2)])\r\n\r\n    expect(rcmd3.gate.equal(new BasicGate())).to.equal(true)\r\n    expect(rcmd3.qubits).to.deep.equal(tuple([qb3, qb2], [qb1]))\r\n    expect(rcmd3.controlQubits).to.deep.equal([qb0])\r\n\r\n    expect(rcmd4.qubits.length).to.equal(1)\r\n    expect(rcmd4.qubits[0].length).to.equal(1)\r\n    expect(rcmd4.qubits[0][0].id).to.equal(-1)\r\n  });\r\n})\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/cengines/basicmapper.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 311,
    "kind": "file",
    "name": "src/cengines/basics.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n\r\nimport {Qureg, Qubit} from '../types/qubit'\r\nimport Command from '../ops/command'\r\nimport {Allocate, Deallocate} from '../ops/gates'\r\nimport {DirtyQubitTag} from '../meta/tag'\r\nimport { LastEngineError } from '../meta/error'\r\n\r\n/**\r\n * @class BasicEngine\r\n * @desc\r\nBasic compiler engine: All compiler engines are derived from this class.\r\nIt provides basic functionality such as qubit allocation/deallocation and\r\nfunctions that provide information about the engine's position (e.g., next\r\nengine).\r\n\r\nThis information is provided by the MainEngine, which initializes all\r\nfurther engines.\r\n\r\n    Attributes:\r\nnext_engine (BasicEngine): Next compiler engine (or the back-end).\r\nmain_engine (MainEngine): Reference to the main compiler engine.\r\nis_last_engine (bool): true for the last engine, which is the back-end.\r\n */\r\nexport class BasicEngine {\r\n  /**\r\n   * @constructor\r\n   Initialize the basic engine.\r\n\r\n    Initializes local variables such as _next_engine, _main_engine, etc. to None.\r\n  */\r\n  constructor() {\r\n    this.isLastEngine = false\r\n  }\r\n\r\n  /**\r\n    Default implementation of isAvailable:\r\n    Ask the next engine whether a command is available, i.e.,\r\n    whether it can be executed by the next engine(s).\r\n\r\n    @param {Command} cmd Command for which to check availability.\r\n\r\n    @return {boolean} true if the command can be executed.\r\n\r\n    @throws {LastEngineError} If is_last_engine is true but isAvailable is not implemented.\r\n     */\r\n  isAvailable(cmd) {\r\n    if (!this.isLastEngine) {\r\n      return this.next.isAvailable(cmd)\r\n    }\r\n    throw new LastEngineError('Should not be last!')\r\n  }\r\n\r\n  /**\r\n    Return a new qubit as a list containing 1 qubit object (quantum\r\nregister of size 1).\r\n\r\nAllocates a new qubit by getting a (new) qubit id from the MainEngine,\r\n    creating the qubit object, and then sending an AllocateQubit command\r\ndown the pipeline. If dirty=true, the fresh qubit can be replaced by\r\na pre-allocated one (in an unknown, dirty, initial state). Dirty qubits\r\nmust be returned to their initial states before they are deallocated /\r\nfreed.\r\n\r\n    All allocated qubits are added to the MainEngine's set of active\r\nqubits as weak references. This allows proper clean-up at the end of\r\nthe JavaScript program (using atexit), deallocating all qubits which are\r\nstill alive. Qubit ids of dirty qubits are registered in MainEngine's\r\ndirty_qubits set.\r\n\r\n    @param {boolean} dirty If true, indicates that the allocated qubit may be\r\n    dirty (i.e., in an arbitrary initial state).\r\n\r\n    @return {Qureg} Qureg of length 1, where the first entry is the allocated qubit.\r\n  */\r\n  allocateQubit(dirty = false) {\r\n    const new_id = this.main.getNewQubitID()\r\n    const qubit = new Qubit(this, new_id)\r\n    const qb = new Qureg(qubit)\r\n    const cmd = new Command(this, Allocate, [qb])\r\n    if (dirty) {\r\n      if (this.isMetaTagSupported(DirtyQubitTag)) {\r\n        cmd.tags.push(new DirtyQubitTag())\r\n        this.main.dirtyQubits.add(qubit.id)\r\n      }\r\n    }\r\n    this.main.activeQubits.add(qubit)\r\n    this.send([cmd])\r\n    return qb\r\n  }\r\n\r\n  /**\r\n    Allocate n qubits and return them as a quantum register, which is a\r\nlist of qubit objects.\r\n\r\n    @param {number} n Number of qubits to allocate\r\n    @return {Qureg} Qureg of length n, a list of n newly allocated qubits.\r\n  */\r\n  allocateQureg(n) {\r\n    const array = []\r\n    for (let i = 0; i < n; ++i) {\r\n      const q = this.allocateQubit()[0]\r\n      array.push(q)\r\n    }\r\n    return new Qureg(array)\r\n  }\r\n\r\n  /**\r\n    Deallocate a qubit (and sends the deallocation command down the\r\npipeline). If the qubit was allocated as a dirty qubit, add\r\nDirtyQubitTag() to Deallocate command.\r\n\r\n    @param {BasicQubit} qubit Qubit to deallocate.\r\n    @throws {Error} Qubit already deallocated. Caller likely has a bug.\r\n  */\r\n  deallocateQubit(qubit) {\r\n    if (qubit.id === -1) {\r\n      throw new Error('Already deallocated.')\r\n    }\r\n    const is_dirty = this.main.dirtyQubits.has(qubit.id)\r\n    const cmds = [new Command(this, Deallocate, [new Qureg([qubit])], [], is_dirty ? [new DirtyQubitTag()] : [])]\r\n    this.send(cmds)\r\n  }\r\n\r\n  /**\r\n    Check if there is a compiler engine handling the meta tag\r\n\r\n    @param {function} metaTag Meta tag class for which to check support\r\n\r\n    @return {boolean} true if one of the further compiler engines is a\r\nmeta tag handler, i.e., engine.is_meta_tag_handler(meta_tag)\r\nreturns true.\r\n     */\r\n  isMetaTagSupported(metaTag) {\r\n    let engine = this\r\n    try {\r\n      while (true) {\r\n        if (typeof engine.isMetaTagHandler === 'function' && engine.isMetaTagHandler(metaTag)) {\r\n          return true\r\n        }\r\n        engine = engine.next\r\n      }\r\n    } catch (e) {\r\n      return false\r\n    }\r\n  }\r\n\r\n  /**\r\n    Forward the list of commands to the next engine in the pipeline.\r\n   @param {Command[]} commandList\r\n  */\r\n  send(commandList) {\r\n    this.next.receive(commandList)\r\n  }\r\n\r\n  receive() {\r\n    // do nothing\r\n  }\r\n}\r\n\r\n/**\r\n * @class ForwarderEngine\r\n * @desc\r\n    A ForwarderEngine is a trivial engine which forwards all commands to the next engine.\r\n\r\n    It is mainly used as a substitute for the MainEngine at lower levels such\r\nthat meta operations still work (e.g., with Compute).\r\n */\r\nexport class ForwarderEngine extends BasicEngine {\r\n  /**\r\n   * @constructor\r\n\r\n    @param {BasicEngine} engine Engine to forward all commands to.\r\n    @param {function} cmdModFunc Function which is called before sending a\r\ncommand. Each command cmd is replaced by the command it\r\nreturns when getting called with cmd.\r\n     */\r\n  constructor(engine, cmdModFunc) {\r\n    super()\r\n    this.main = engine.main\r\n    this.next = engine\r\n    if (!cmdModFunc) {\r\n      cmdModFunc = x => x\r\n    }\r\n    this.cmdModFunc = cmdModFunc\r\n  }\r\n\r\n  receive(commandList) {\r\n    const newCommandList = commandList.map(cmd => this.cmdModFunc(cmd))\r\n    this.send(newCommandList)\r\n  }\r\n\r\n  /**\r\n   * internal usaged for deallocate qubits after `Uncompute`\r\n   */\r\n  autoDeallocateQubits() {\r\n    const copy = new Set(this.main.activeQubits)\r\n    copy.forEach((qb) => {\r\n      if (qb.engine === this) {\r\n        // need to\r\n        qb.deallocate()\r\n      }\r\n    })\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/cengines/basics.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 312,
    "kind": "class",
    "name": "BasicEngine",
    "memberof": "src/cengines/basics.js",
    "static": true,
    "longname": "src/cengines/basics.js~BasicEngine",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/cengines/basics.js",
    "importStyle": "{BasicEngine}",
    "description": "Basic compiler engine: All compiler engines are derived from this class.\nIt provides basic functionality such as qubit allocation/deallocation and\nfunctions that provide information about the engine's position (e.g., next\nengine).\n\nThis information is provided by the MainEngine, which initializes all\nfurther engines.\n\nAttributes:\nnext_engine (BasicEngine): Next compiler engine (or the back-end).\nmain_engine (MainEngine): Reference to the main compiler engine.\nis_last_engine (bool): true for the last engine, which is the back-end.",
    "lineNumber": 40,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "BasicEngine"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 313,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/cengines/basics.js~BasicEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/basics.js~BasicEngine#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 47,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": "Initialize the basic engine.\n\nInitializes local variables such as _next_engine, _main_engine, etc. to None."
      }
    ]
  },
  {
    "__docId__": 314,
    "kind": "member",
    "name": "isLastEngine",
    "memberof": "src/cengines/basics.js~BasicEngine",
    "static": false,
    "longname": "src/cengines/basics.js~BasicEngine#isLastEngine",
    "access": "public",
    "description": null,
    "lineNumber": 48,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 315,
    "kind": "method",
    "name": "isAvailable",
    "memberof": "src/cengines/basics.js~BasicEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/basics.js~BasicEngine#isAvailable",
    "access": "public",
    "description": "Default implementation of isAvailable:\nAsk the next engine whether a command is available, i.e.,\nwhether it can be executed by the next engine(s).",
    "lineNumber": 62,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": "Command for which to check availability."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if the command can be executed."
    },
    "throws": [
      {
        "types": [
          "LastEngineError"
        ],
        "description": "If is_last_engine is true but isAvailable is not implemented."
      }
    ]
  },
  {
    "__docId__": 316,
    "kind": "method",
    "name": "allocateQubit",
    "memberof": "src/cengines/basics.js~BasicEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/basics.js~BasicEngine#allocateQubit",
    "access": "public",
    "description": "Return a new qubit as a list containing 1 qubit object (quantum\nregister of size 1).\n\nAllocates a new qubit by getting a (new) qubit id from the MainEngine,\ncreating the qubit object, and then sending an AllocateQubit command\ndown the pipeline. If dirty=true, the fresh qubit can be replaced by\na pre-allocated one (in an unknown, dirty, initial state). Dirty qubits\nmust be returned to their initial states before they are deallocated /\nfreed.\n\nAll allocated qubits are added to the MainEngine's set of active\nqubits as weak references. This allows proper clean-up at the end of\nthe JavaScript program (using atexit), deallocating all qubits which are\nstill alive. Qubit ids of dirty qubits are registered in MainEngine's\ndirty_qubits set.",
    "lineNumber": 91,
    "params": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "dirty",
        "description": "If true, indicates that the allocated qubit may be\ndirty (i.e., in an arbitrary initial state)."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Qureg"
      ],
      "spread": false,
      "description": "Qureg of length 1, where the first entry is the allocated qubit."
    }
  },
  {
    "__docId__": 317,
    "kind": "method",
    "name": "allocateQureg",
    "memberof": "src/cengines/basics.js~BasicEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/basics.js~BasicEngine#allocateQureg",
    "access": "public",
    "description": "Allocate n qubits and return them as a quantum register, which is a\nlist of qubit objects.",
    "lineNumber": 114,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "n",
        "description": "Number of qubits to allocate"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Qureg"
      ],
      "spread": false,
      "description": "Qureg of length n, a list of n newly allocated qubits."
    }
  },
  {
    "__docId__": 318,
    "kind": "method",
    "name": "deallocateQubit",
    "memberof": "src/cengines/basics.js~BasicEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/basics.js~BasicEngine#deallocateQubit",
    "access": "public",
    "description": "Deallocate a qubit (and sends the deallocation command down the\npipeline). If the qubit was allocated as a dirty qubit, add\nDirtyQubitTag() to Deallocate command.",
    "lineNumber": 131,
    "params": [
      {
        "nullable": null,
        "types": [
          "BasicQubit"
        ],
        "spread": false,
        "optional": false,
        "name": "qubit",
        "description": "Qubit to deallocate."
      }
    ],
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Qubit already deallocated. Caller likely has a bug."
      }
    ],
    "return": null
  },
  {
    "__docId__": 319,
    "kind": "method",
    "name": "isMetaTagSupported",
    "memberof": "src/cengines/basics.js~BasicEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/basics.js~BasicEngine#isMetaTagSupported",
    "access": "public",
    "description": "Check if there is a compiler engine handling the meta tag",
    "lineNumber": 149,
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "metaTag",
        "description": "Meta tag class for which to check support"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if one of the further compiler engines is a\nmeta tag handler, i.e., engine.is_meta_tag_handler(meta_tag)\nreturns true."
    }
  },
  {
    "__docId__": 320,
    "kind": "method",
    "name": "send",
    "memberof": "src/cengines/basics.js~BasicEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/basics.js~BasicEngine#send",
    "access": "public",
    "description": "Forward the list of commands to the next engine in the pipeline.",
    "lineNumber": 167,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command[]"
        ],
        "spread": false,
        "optional": false,
        "name": "commandList",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 321,
    "kind": "method",
    "name": "receive",
    "memberof": "src/cengines/basics.js~BasicEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/basics.js~BasicEngine#receive",
    "access": "public",
    "description": null,
    "lineNumber": 171,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 322,
    "kind": "class",
    "name": "ForwarderEngine",
    "memberof": "src/cengines/basics.js",
    "static": true,
    "longname": "src/cengines/basics.js~ForwarderEngine",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/cengines/basics.js",
    "importStyle": "{ForwarderEngine}",
    "description": "A ForwarderEngine is a trivial engine which forwards all commands to the next engine.\n\nIt is mainly used as a substitute for the MainEngine at lower levels such\nthat meta operations still work (e.g., with Compute).",
    "lineNumber": 184,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "ForwarderEngine"
      }
    ],
    "interface": false,
    "extends": [
      "BasicEngine"
    ]
  },
  {
    "__docId__": 323,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/cengines/basics.js~ForwarderEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/basics.js~ForwarderEngine#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 193,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "BasicEngine"
        ],
        "spread": false,
        "optional": false,
        "name": "engine",
        "description": "Engine to forward all commands to."
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "cmdModFunc",
        "description": "Function which is called before sending a\ncommand. Each command cmd is replaced by the command it\nreturns when getting called with cmd."
      }
    ]
  },
  {
    "__docId__": 324,
    "kind": "member",
    "name": "main",
    "memberof": "src/cengines/basics.js~ForwarderEngine",
    "static": false,
    "longname": "src/cengines/basics.js~ForwarderEngine#main",
    "access": "public",
    "description": null,
    "lineNumber": 195,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 325,
    "kind": "member",
    "name": "next",
    "memberof": "src/cengines/basics.js~ForwarderEngine",
    "static": false,
    "longname": "src/cengines/basics.js~ForwarderEngine#next",
    "access": "public",
    "description": null,
    "lineNumber": 196,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 326,
    "kind": "member",
    "name": "cmdModFunc",
    "memberof": "src/cengines/basics.js~ForwarderEngine",
    "static": false,
    "longname": "src/cengines/basics.js~ForwarderEngine#cmdModFunc",
    "access": "public",
    "description": null,
    "lineNumber": 200,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 327,
    "kind": "method",
    "name": "receive",
    "memberof": "src/cengines/basics.js~ForwarderEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/basics.js~ForwarderEngine#receive",
    "access": "public",
    "description": null,
    "lineNumber": 203,
    "undocument": true,
    "params": [
      {
        "name": "commandList",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 328,
    "kind": "method",
    "name": "autoDeallocateQubits",
    "memberof": "src/cengines/basics.js~ForwarderEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/basics.js~ForwarderEngine#autoDeallocateQubits",
    "access": "public",
    "description": "internal usaged for deallocate qubits after `Uncompute`",
    "lineNumber": 211,
    "params": [],
    "return": null
  },
  {
    "__docId__": 329,
    "kind": "file",
    "name": "src/cengines/basics.spec.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport {expect} from 'chai'\r\nimport {BasicEngine, ForwarderEngine} from './basics'\r\nimport {InstructionFilter} from './replacer/replacer'\r\nimport {DirtyQubitTag} from '../meta/tag'\r\nimport {H, AllocateQubitGate, DeallocateQubitGate} from '../ops/gates'\r\nimport {DummyEngine} from './testengine'\r\nimport MainEngine from './main'\r\nimport {Qubit} from '../types/qubit'\r\nimport {ClassicalInstructionGate, FastForwardingGate} from '../ops/basics';\r\n\r\ndescribe('basics test', () => {\r\n  it('should test_basic_engine_init', () => {\r\n    const eng = new BasicEngine()\r\n    expect(typeof eng.main).to.equal('undefined')\r\n    expect(typeof eng.next).to.equal('undefined')\r\n    expect(eng.isLastEngine).to.equal(false)\r\n  });\r\n\r\n  it('should test_basic_engine_is_available', () => {\r\n    const eng = new BasicEngine()\r\n    expect(() => {\r\n      eng.isLastEngine = true\r\n      eng.isAvailable('FakeCommand')\r\n    }).to.throw()\r\n\r\n\r\n    const filter = (eng, cmd) => (cmd === 'supported')\r\n\r\n    const filter_eng = new InstructionFilter(filter)\r\n    eng.next = filter_eng\r\n    eng.isLastEngine = false\r\n\r\n    expect(eng.isAvailable('supported')).to.equal(true)\r\n    expect(eng.isAvailable('something else')).to.equal(false)\r\n  });\r\n\r\n  it('should test_basic_engine_allocate_and_deallocate_qubit_and_qureg', () => {\r\n    const eng = new BasicEngine()\r\n    // custom receive function which checks that main_engine does not send\r\n    // any allocate or deallocate gates\r\n    let cmd_sent_by_main_engine = []\r\n\r\n    const receive = cmd_list => cmd_sent_by_main_engine = cmd_sent_by_main_engine.concat(cmd_list)\r\n\r\n    eng.receive = receive.bind(eng)\r\n    // Create test engines:\r\n    const saving_backend = new DummyEngine(true)\r\n    const main = new MainEngine(saving_backend, [eng, new DummyEngine()])\r\n    // Allocate and deallocate qubits\r\n    const qubit = eng.allocateQubit()\r\n    // Try to allocate dirty qubit but it should give a non dirty qubit\r\n    const not_dirty_qubit = eng.allocateQubit(true)\r\n\r\n    // Allocate an actual dirty qubit\r\n    const allow_dirty_qubits = meta_tag => meta_tag === DirtyQubitTag\r\n\r\n    saving_backend.isMetaTagHandler = allow_dirty_qubits.bind(saving_backend)\r\n    const dirty_qubit = eng.allocateQubit(true)\r\n    const qureg = eng.allocateQureg(2)\r\n\r\n    // Test qubit allocation\r\n    expect(Array.isArray(qubit)).to.equal(true)\r\n    expect(qubit.length === 1 && qubit[0] instanceof Qubit).to.equal(true)\r\n    expect(main.activeQubits.has(qubit[0])).to.equal(true)\r\n    expect(qubit[0].engine === eng).to.equal(true)\r\n\r\n    // Test non dirty qubit allocation\r\n    expect(Array.isArray(not_dirty_qubit)).to.equal(true)\r\n    expect(not_dirty_qubit.length === 1 && not_dirty_qubit[0] instanceof Qubit).to.equal(true)\r\n    expect(main.activeQubits.has(not_dirty_qubit[0])).to.equal(true)\r\n    expect(not_dirty_qubit[0].engine === eng).to.equal(true)\r\n\r\n    // Test dirty_qubit allocation\r\n    expect(Array.isArray(dirty_qubit)).to.equal(true)\r\n    expect(dirty_qubit.length === 1 && dirty_qubit[0] instanceof Qubit).to.equal(true)\r\n    expect(main.activeQubits.has(dirty_qubit[0])).to.equal(true)\r\n    expect(main.dirtyQubits.has(dirty_qubit[0].id)).to.equal(true)\r\n    expect(dirty_qubit[0].engine === eng).to.equal(true)\r\n\r\n    // Test qureg allocation\r\n    expect(Array.isArray(qureg)).to.equal(true)\r\n    expect(qureg.length).to.equal(2)\r\n\r\n    qureg.forEach((tmp_qubit) => {\r\n      expect(main.activeQubits.has(tmp_qubit)).to.equal(true)\r\n      expect(tmp_qubit.engine === eng).to.equal(true)\r\n    })\r\n\r\n    // Test uniqueness of ids\r\n    expect(new Set([qubit[0].id, not_dirty_qubit[0].id, dirty_qubit[0].id,\r\n      qureg[0].id, qureg[1].id]).size).to.equal(5)\r\n\r\n    // Test allocate gates were sent\r\n    expect(cmd_sent_by_main_engine.length).to.equal(0)\r\n    expect(saving_backend.receivedCommands.length).to.equal(5)\r\n\r\n    saving_backend.receivedCommands.forEach((cmd) => {\r\n      expect(cmd.gate.equal(new AllocateQubitGate())).to.equal(true)\r\n    })\r\n\r\n    expect(saving_backend.receivedCommands[2].tags).to.deep.equal([new DirtyQubitTag()])\r\n\r\n    // Test deallocate gates were sent\r\n    eng.deallocateQubit(qubit[0])\r\n    eng.deallocateQubit(not_dirty_qubit[0])\r\n    eng.deallocateQubit(dirty_qubit[0])\r\n    eng.deallocateQubit(qureg[0])\r\n    eng.deallocateQubit(qureg[1])\r\n\r\n    expect(cmd_sent_by_main_engine.length).to.equal(0)\r\n    expect(saving_backend.receivedCommands.length).to.equal(10)\r\n    const rest = saving_backend.receivedCommands.slice(5, 10)\r\n    rest.forEach((cmd) => {\r\n      expect(cmd.gate.equal(new DeallocateQubitGate())).to.equal(true)\r\n    })\r\n\r\n    expect(saving_backend.receivedCommands[7].tags).to.deep.equal([new DirtyQubitTag()])\r\n  });\r\n\r\n  it('should test_deallocate_qubit_exception', () => {\r\n    const eng = new BasicEngine()\r\n    const qubit = new Qubit(eng, -1)\r\n    expect(() => eng.deallocateQubit(qubit)).to.throw()\r\n  });\r\n\r\n  it('should test_basic_engine_is_meta_tag_supported', () => {\r\n    const eng = new BasicEngine()\r\n    // BasicEngine needs receive function to function so let's add it:\r\n\r\n    const receive = function (cmd_list) {\r\n      this.send(cmd_list)\r\n    }\r\n\r\n    eng.receive = receive.bind(eng)\r\n\r\n    const backend = new DummyEngine()\r\n    const engine0 = new DummyEngine()\r\n    const engine1 = new DummyEngine()\r\n    const engine2 = new DummyEngine()\r\n\r\n    const allow_dirty_qubits = meta_tag => (meta_tag === DirtyQubitTag)\r\n\r\n    engine2.isMetaTagHandler = allow_dirty_qubits.bind(engine2)\r\n    const main_engine = new MainEngine(backend, [engine0, engine1, engine2])\r\n    expect(main_engine.isMetaTagSupported('NotSupported')).to.equal(false)\r\n    expect(main_engine.isMetaTagSupported(DirtyQubitTag)).to.equal(true)\r\n  });\r\n\r\n  it('should test forward engine', () => {\r\n    const backend = new DummyEngine(true)\r\n    const engine0 = new DummyEngine()\r\n    const main_engine = new MainEngine(backend, [engine0])\r\n\r\n    const cmd_mod_fun = (cmd) => {\r\n      cmd.tags = 'NewTag'\r\n      return cmd\r\n    }\r\n\r\n    const forwarder_eng = new ForwarderEngine(backend, cmd_mod_fun)\r\n    engine0.next = forwarder_eng\r\n    const forwarder_eng2 = new ForwarderEngine(engine0)\r\n    main_engine.next = forwarder_eng2\r\n    const qubit = main_engine.allocateQubit()\r\n    H.or(qubit)\r\n    // Test if H gate was sent through forwarder_eng and tag was added\r\n    const received_commands = []\r\n    // Remove Allocate and Deallocate gates\r\n    backend.receivedCommands.forEach((cmd) => {\r\n      if (!(cmd.gate instanceof FastForwardingGate || cmd.gate instanceof ClassicalInstructionGate)) {\r\n        received_commands.push(cmd)\r\n      }\r\n    })\r\n\r\n    expect(received_commands.length).to.equal(1)\r\n    expect(received_commands[0].gate.equal(H)).to.equal(true)\r\n    expect(received_commands[0].tags).to.deep.equal('NewTag')\r\n  });\r\n})\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/cengines/basics.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 330,
    "kind": "file",
    "name": "src/cengines/cmdmodifier.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/**\r\nContains a CommandModifier engine, which can be used to, e.g., modify the tags\r\nof all commands which pass by (see the AutoReplacer for an example).\r\n*/\r\n\r\nimport {BasicEngine} from './basics'\r\n\r\n/**\r\n * @class CommandModifier\r\n * @desc\r\nCommandModifier is a compiler engine which applies a function to all\r\nincoming commands, sending on the resulting command instead of the original one.\r\n */\r\nexport default class CommandModifier extends BasicEngine {\r\n  /**\r\n   * @constructor\r\n  Initialize the CommandModifier.\r\n\r\n    @param {function} cmdModFunc Function which, given a command cmd,\r\n    returns the command it should send instead.\r\n\r\n    @example\r\n\r\nfunction cmd_mod_fun(cmd)\r\ncmd.tags += [new MyOwnTag()]\r\ncompiler_engine = new CommandModifier(cmd_mod_fun)\r\n   */\r\n  constructor(cmdModFunc) {\r\n    super()\r\n    this._cmdModFunc = cmdModFunc\r\n  }\r\n\r\n  /**\r\n  Receive a list of commands from the previous engine, modify all\r\n   commands, and send them on to the next engine.\r\n\r\n    @param {Command[]} cmdList List of commands to receive and then (after modification) send on.\r\n   */\r\n  receive(cmdList) {\r\n    const newList = cmdList.map(cmd => this._cmdModFunc(cmd))\r\n    this.send(newList)\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/cengines/cmdmodifier.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 331,
    "kind": "class",
    "name": "CommandModifier",
    "memberof": "src/cengines/cmdmodifier.js",
    "static": true,
    "longname": "src/cengines/cmdmodifier.js~CommandModifier",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/cengines/cmdmodifier.js",
    "importStyle": "CommandModifier",
    "description": "CommandModifier is a compiler engine which applies a function to all\nincoming commands, sending on the resulting command instead of the original one.",
    "lineNumber": 30,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "CommandModifier"
      }
    ],
    "interface": false,
    "extends": [
      "src/cengines/basics.js~BasicEngine"
    ]
  },
  {
    "__docId__": 332,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/cengines/cmdmodifier.js~CommandModifier",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/cmdmodifier.js~CommandModifier#constructor",
    "access": "public",
    "description": "",
    "examples": [
      "\nfunction cmd_mod_fun(cmd)\ncmd.tags += [new MyOwnTag()]\ncompiler_engine = new CommandModifier(cmd_mod_fun)"
    ],
    "lineNumber": 44,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": "Initialize the CommandModifier."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "cmdModFunc",
        "description": "Function which, given a command cmd,\nreturns the command it should send instead."
      }
    ]
  },
  {
    "__docId__": 333,
    "kind": "member",
    "name": "_cmdModFunc",
    "memberof": "src/cengines/cmdmodifier.js~CommandModifier",
    "static": false,
    "longname": "src/cengines/cmdmodifier.js~CommandModifier#_cmdModFunc",
    "access": "private",
    "description": null,
    "lineNumber": 46,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 334,
    "kind": "method",
    "name": "receive",
    "memberof": "src/cengines/cmdmodifier.js~CommandModifier",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/cmdmodifier.js~CommandModifier#receive",
    "access": "public",
    "description": "Receive a list of commands from the previous engine, modify all\ncommands, and send them on to the next engine.",
    "lineNumber": 55,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command[]"
        ],
        "spread": false,
        "optional": false,
        "name": "cmdList",
        "description": "List of commands to receive and then (after modification) send on."
      }
    ],
    "return": null
  },
  {
    "__docId__": 335,
    "kind": "file",
    "name": "src/cengines/cmdmodifier.spec.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport {expect} from 'chai'\r\nimport { ClassicalInstructionGate, FastForwardingGate } from '../ops/basics'\r\nimport {H} from '../ops/gates'\r\nimport {DummyEngine} from './testengine'\r\nimport MainEngine from './main'\r\nimport CommandModifier from './cmdmodifier'\r\n\r\ndescribe('cmdmodifier test', () => {\r\n  it('should test_command_modifier', () => {\r\n    const cmd_mod_fun = (cmd) => {\r\n      cmd.tags = 'NewTag'\r\n      return cmd\r\n    }\r\n\r\n    const backend = new DummyEngine(true)\r\n    const cmd_modifier = new CommandModifier(cmd_mod_fun)\r\n    const main_engine = new MainEngine(backend, [cmd_modifier])\r\n    const qubit = main_engine.allocateQubit()\r\n    H.or(qubit)\r\n    // Test if H gate was sent through forwarder_eng and tag was added\r\n    const received_commands = []\r\n    // Remove Allocate and Deallocate gates\r\n    backend.receivedCommands.forEach((cmd) => {\r\n      if (!(cmd.gate instanceof FastForwardingGate || cmd.gate instanceof ClassicalInstructionGate)) {\r\n        received_commands.push(cmd)\r\n      }\r\n    })\r\n\r\n    expect(received_commands.length).to.equal(1)\r\n    expect(received_commands[0].gate.equal(H)).to.equal(true)\r\n    expect(received_commands[0].tags).to.equal('NewTag')\r\n  });\r\n})\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/cengines/cmdmodifier.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 336,
    "kind": "file",
    "name": "src/cengines/ibm5qubitmapper.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport {permutations} from 'itertools'\r\nimport BasicMapperEngine from './basicmapper'\r\nimport { Allocate, FlushGate, NOT } from '../ops/gates'\r\n\r\nimport IBMBackend from '../backends/ibm/ibm'\r\n\r\nfunction stringKeyToIntArray(key) {\r\n  return key.split(',').map(i => parseInt(i, 10))\r\n}\r\n\r\n// export const ibmqx4_connections = new Set([2, 1], [4, 2], [2, 0], [3, 2], [3, 4], [1, 0])\r\nexport const ibmqx4_connections = new Set(['2,1', '4,2', '2,0', '3,2', '3,4', '1,0'])\r\n\r\n/**\r\n * @class IBM5QubitMapper\r\n * @desc\r\nMapper for the 5-qubit IBM backend.\r\n\r\n  Maps a given circuit to the IBM Quantum Experience chip.\r\n\r\n  Note:\r\nThe mapper has to be run once on the entire circuit.\r\n\r\n  Warning:\r\nIf the provided circuit cannot be mapped to the hardware layout\r\nwithout performing Swaps, the mapping procedure\r\n**raises an Exception**.\r\n */\r\nexport default class IBM5QubitMapper extends BasicMapperEngine {\r\n  /**\r\n   * @constructor\r\nInitialize an IBM 5-qubit mapper compiler engine.\r\n\r\n  Resets the mapping.\r\n   */\r\n  constructor() {\r\n    super();\r\n    this.currentMapping = {}\r\n    this._reset()\r\n  }\r\n\r\n  /**\r\n  Check if the IBM backend can perform the Command cmd and return true\r\nif so.\r\n\r\n  @param {Command} cmd The command to check\r\n   */\r\n  isAvailable(cmd) {\r\n    return new IBMBackend().isAvailable(cmd)\r\n  }\r\n\r\n  // Reset the mapping parameters so the next circuit can be mapped.\r\n  _reset() {\r\n    this._cmds = []\r\n    this._interactions = {}\r\n  }\r\n\r\n  /**\r\n  Check if the command corresponds to a CNOT (controlled NOT gate).\r\n\r\n  @param {Command} cmd Command to check whether it is a controlled NOT gate.\r\n  */\r\n  _isCNOT(cmd) {\r\n    return (cmd.gate instanceof NOT.constructor && cmd.controlCount === 1)\r\n  }\r\n\r\n  /**\r\n  Determines the cost of the circuit with the given mapping.\r\n\r\n  @param {Object} mapping Dictionary with key, value pairs where keys are\r\n    logical qubit ids and the corresponding value is the physical\r\n    location on the IBM Q chip.\r\n  @return {number} Cost measure taking into account CNOT directionality or None\r\n    if the circuit cannot be executed given the mapping.\r\n  */\r\n  determineCost(mapping) {\r\n    let cost = 0\r\n    const connections = ibmqx4_connections\r\n    const keys = Object.keys(this._interactions)\r\n    for (let i = 0; i < keys.length; ++i) {\r\n      const tpl = stringKeyToIntArray(keys[i])\r\n      const ctrl_id = tpl[0]\r\n      const target_id = tpl[1]\r\n      const ctrl_pos = mapping[ctrl_id]\r\n      const target_pos = mapping[target_id]\r\n      let k = `${ctrl_pos},${target_pos}`\r\n      let v = connections.has(k)\r\n      if (!v) {\r\n        k = `${target_pos},${ctrl_pos}`\r\n        v = connections.has(k)\r\n        if (v) {\r\n          cost += this._interactions[tpl]\r\n        } else {\r\n          return undefined\r\n        }\r\n      }\r\n    }\r\n    return cost\r\n  }\r\n\r\n  /**\r\n  Runs all stored gates.\r\n\r\n  @throws {Error}\r\n  If the mapping to the IBM backend cannot be performed or if\r\n  the mapping was already determined but more CNOTs get sent\r\ndown the pipeline.\r\n   */\r\n  run() {\r\n    if (Object.keys(this._currentMapping).length > 0 && Math.max(...Object.values(this._currentMapping)) > 4) {\r\n      throw new Error('Too many qubits allocated. The IBM Q '\r\n      + 'device supports at most 5 qubits and no '\r\n      + 'intermediate measurements / '\r\n      + 'reallocations.')\r\n    }\r\n    if (Object.keys(this._interactions).length > 0) {\r\n      const logical_ids = Object.keys(this._currentMapping).map(k => parseInt(k, 10))\r\n      let best_mapping = this._currentMapping\r\n      let best_cost\r\n\r\n      for (const physical_ids of permutations([0, 1, 2, 3, 4], logical_ids.length)) {\r\n        const mapping = {}\r\n        physical_ids.forEach((looper, i) => mapping[logical_ids[i]] = looper)\r\n        const new_cost = this.determineCost(mapping)\r\n        if (new_cost) {\r\n          if (!best_cost || new_cost < best_cost) {\r\n            best_cost = new_cost\r\n            best_mapping = mapping\r\n          }\r\n        }\r\n      }\r\n\r\n      if (!best_cost) {\r\n        throw new Error('Circuit cannot be mapped without using Swaps. Mapping failed.')\r\n      }\r\n      this._interactions = {}\r\n      this.currentMapping = best_mapping\r\n    }\r\n\r\n    this._cmds.forEach(cmd => this.sendCMDWithMappedIDs(cmd))\r\n\r\n    this._cmds = []\r\n  }\r\n\r\n  /**\r\n  Store a command and handle CNOTs.\r\n\r\n  @param {Command} cmd A command to store\r\n   */\r\n  _store(cmd) {\r\n    let target\r\n    if (!(cmd.gate instanceof FlushGate)) {\r\n      target = cmd.qubits[0][0].id\r\n    }\r\n\r\n    if (this._isCNOT(cmd)) {\r\n      // CNOT encountered\r\n      const ctrl = cmd.controlQubits[0].id\r\n      const key = [ctrl, target]\r\n      const v = this._interactions[key]\r\n      if (typeof v === 'undefined') {\r\n        this._interactions[key] = 0\r\n      }\r\n      this._interactions[key] += 1\r\n    } else if (cmd.gate.equal(Allocate)) {\r\n      const v = this._currentMapping[target]\r\n      if (typeof v === 'undefined') {\r\n        let newMax = 0\r\n        if (Object.keys(this._currentMapping).length > 0) {\r\n          newMax = Math.max(...Object.values(this._currentMapping)) + 1\r\n        }\r\n        this._currentMapping[target] = newMax\r\n      }\r\n    }\r\n    this._cmds.push(cmd)\r\n  }\r\n\r\n  /**\r\n  Receives a command list and, for each command, stores it until\r\ncompletion.\r\n\r\n  @param {Command[]} commandList list of commands to receive.\r\n\r\n  @throws {Error} If mapping the CNOT gates to 1 qubit would require\r\nSwaps. The current version only supports remapping of CNOT\r\ngates without performing any Swaps due to the large costs\r\nassociated with Swapping given the CNOT constraints.\r\n   */\r\n  receive(commandList) {\r\n    commandList.forEach((cmd) => {\r\n      this._store(cmd)\r\n      if (cmd.gate instanceof FlushGate) {\r\n        this.run()\r\n        this._reset()\r\n      }\r\n    })\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/cengines/ibm5qubitmapper.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 337,
    "kind": "function",
    "name": "stringKeyToIntArray",
    "memberof": "src/cengines/ibm5qubitmapper.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/cengines/ibm5qubitmapper.js~stringKeyToIntArray",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/cengines/ibm5qubitmapper.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 338,
    "kind": "variable",
    "name": "ibmqx4_connections",
    "memberof": "src/cengines/ibm5qubitmapper.js",
    "static": true,
    "longname": "src/cengines/ibm5qubitmapper.js~ibmqx4_connections",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/cengines/ibm5qubitmapper.js",
    "importStyle": "{ibmqx4_connections}",
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 339,
    "kind": "class",
    "name": "IBM5QubitMapper",
    "memberof": "src/cengines/ibm5qubitmapper.js",
    "static": true,
    "longname": "src/cengines/ibm5qubitmapper.js~IBM5QubitMapper",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/cengines/ibm5qubitmapper.js",
    "importStyle": "IBM5QubitMapper",
    "description": "Mapper for the 5-qubit IBM backend.\n\nMaps a given circuit to the IBM Quantum Experience chip.\n\nNote:\nThe mapper has to be run once on the entire circuit.\n\nWarning:\nIf the provided circuit cannot be mapped to the hardware layout\nwithout performing Swaps, the mapping procedure\n*raises an Exception**.",
    "lineNumber": 45,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "IBM5QubitMapper"
      }
    ],
    "interface": false,
    "extends": [
      "src/cengines/basicmapper.js~BasicMapperEngine"
    ]
  },
  {
    "__docId__": 340,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/cengines/ibm5qubitmapper.js~IBM5QubitMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/ibm5qubitmapper.js~IBM5QubitMapper#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 52,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": "Initialize an IBM 5-qubit mapper compiler engine.\n\nResets the mapping."
      }
    ]
  },
  {
    "__docId__": 341,
    "kind": "member",
    "name": "currentMapping",
    "memberof": "src/cengines/ibm5qubitmapper.js~IBM5QubitMapper",
    "static": false,
    "longname": "src/cengines/ibm5qubitmapper.js~IBM5QubitMapper#currentMapping",
    "access": "public",
    "description": null,
    "lineNumber": 54,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 342,
    "kind": "method",
    "name": "isAvailable",
    "memberof": "src/cengines/ibm5qubitmapper.js~IBM5QubitMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/ibm5qubitmapper.js~IBM5QubitMapper#isAvailable",
    "access": "public",
    "description": "Check if the IBM backend can perform the Command cmd and return true\nif so.",
    "lineNumber": 64,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": "The command to check"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 343,
    "kind": "method",
    "name": "_reset",
    "memberof": "src/cengines/ibm5qubitmapper.js~IBM5QubitMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/ibm5qubitmapper.js~IBM5QubitMapper#_reset",
    "access": "private",
    "description": null,
    "lineNumber": 69,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 344,
    "kind": "member",
    "name": "_cmds",
    "memberof": "src/cengines/ibm5qubitmapper.js~IBM5QubitMapper",
    "static": false,
    "longname": "src/cengines/ibm5qubitmapper.js~IBM5QubitMapper#_cmds",
    "access": "private",
    "description": null,
    "lineNumber": 70,
    "undocument": true,
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 345,
    "kind": "member",
    "name": "_interactions",
    "memberof": "src/cengines/ibm5qubitmapper.js~IBM5QubitMapper",
    "static": false,
    "longname": "src/cengines/ibm5qubitmapper.js~IBM5QubitMapper#_interactions",
    "access": "private",
    "description": null,
    "lineNumber": 71,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 346,
    "kind": "method",
    "name": "_isCNOT",
    "memberof": "src/cengines/ibm5qubitmapper.js~IBM5QubitMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/ibm5qubitmapper.js~IBM5QubitMapper#_isCNOT",
    "access": "private",
    "description": "Check if the command corresponds to a CNOT (controlled NOT gate).",
    "lineNumber": 79,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": "Command to check whether it is a controlled NOT gate."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 347,
    "kind": "method",
    "name": "determineCost",
    "memberof": "src/cengines/ibm5qubitmapper.js~IBM5QubitMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/ibm5qubitmapper.js~IBM5QubitMapper#determineCost",
    "access": "public",
    "description": "Determines the cost of the circuit with the given mapping.",
    "lineNumber": 92,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "mapping",
        "description": "Dictionary with key, value pairs where keys are\nlogical qubit ids and the corresponding value is the physical\nlocation on the IBM Q chip."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Cost measure taking into account CNOT directionality or None\nif the circuit cannot be executed given the mapping."
    }
  },
  {
    "__docId__": 348,
    "kind": "method",
    "name": "run",
    "memberof": "src/cengines/ibm5qubitmapper.js~IBM5QubitMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/ibm5qubitmapper.js~IBM5QubitMapper#run",
    "access": "public",
    "description": "Runs all stored gates.",
    "lineNumber": 125,
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If the mapping to the IBM backend cannot be performed or if\nthe mapping was already determined but more CNOTs get sent\ndown the pipeline."
      }
    ],
    "params": [],
    "return": null
  },
  {
    "__docId__": 352,
    "kind": "method",
    "name": "_store",
    "memberof": "src/cengines/ibm5qubitmapper.js~IBM5QubitMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/ibm5qubitmapper.js~IBM5QubitMapper#_store",
    "access": "private",
    "description": "Store a command and handle CNOTs.",
    "lineNumber": 166,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": "A command to store"
      }
    ],
    "return": null
  },
  {
    "__docId__": 353,
    "kind": "method",
    "name": "receive",
    "memberof": "src/cengines/ibm5qubitmapper.js~IBM5QubitMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/ibm5qubitmapper.js~IBM5QubitMapper#receive",
    "access": "public",
    "description": "Receives a command list and, for each command, stores it until\ncompletion.",
    "lineNumber": 205,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command[]"
        ],
        "spread": false,
        "optional": false,
        "name": "commandList",
        "description": "list of commands to receive."
      }
    ],
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If mapping the CNOT gates to 1 qubit would require\nSwaps. The current version only supports remapping of CNOT\ngates without performing any Swaps due to the large costs\nassociated with Swapping given the CNOT constraints."
      }
    ],
    "return": null
  },
  {
    "__docId__": 354,
    "kind": "file",
    "name": "src/cengines/ibm5qubitmapper.spec.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nimport {expect} from 'chai'\r\nimport { DummyEngine } from './testengine'\r\nimport MainEngine from './main'\r\nimport IBM5QubitMapper from './ibm5qubitmapper'\r\nimport { CNOT } from '../ops/shortcuts'\r\nimport { tuple } from '../libs/util'\r\nimport IBMBackend from '../backends/ibm/ibm'\r\nimport SwapAndCNOTFlipper from './swapandcnotflipper'\r\nimport { H } from '../ops/gates'\r\nimport { All } from '../ops/metagates'\r\n\r\ndescribe('ibm 5qubit mapper test', () => {\r\n  it('should test_ibm5qubitmapper_invalid_circuit', () => {\r\n    const backend = new DummyEngine(true)\r\n    const eng = new MainEngine(backend, [new IBM5QubitMapper()])\r\n    const qb0 = eng.allocateQubit()\r\n    const qb1 = eng.allocateQubit()\r\n    const qb2 = eng.allocateQubit()\r\n    const qb3 = eng.allocateQubit()\r\n    CNOT.or(tuple(qb1, qb2))\r\n    CNOT.or(tuple(qb0, qb1))\r\n    CNOT.or(tuple(qb0, qb2))\r\n    CNOT.or(tuple(qb3, qb1))\r\n    expect(() => {\r\n      CNOT.or(tuple(qb3, qb2))\r\n      eng.flush()\r\n    }).to.throw()\r\n  });\r\n\r\n  it('should test_ibm5qubitmapper_valid_circuit1', () => {\r\n    const backend = new DummyEngine(true)\r\n    const eng = new MainEngine(backend, [new IBM5QubitMapper()])\r\n    const qb0 = eng.allocateQubit()\r\n    const qb1 = eng.allocateQubit()\r\n    const qb2 = eng.allocateQubit()\r\n    const qb3 = eng.allocateQubit()\r\n    const qb4 = eng.allocateQubit()\r\n    CNOT.or(tuple(qb0, qb1))\r\n    CNOT.or(tuple(qb0, qb2))\r\n    CNOT.or(tuple(qb0, qb3))\r\n    CNOT.or(tuple(qb0, qb4))\r\n    CNOT.or(tuple(qb1, qb2))\r\n    CNOT.or(tuple(qb3, qb4))\r\n    CNOT.or(tuple(qb4, qb3))\r\n    eng.flush()\r\n  });\r\n\r\n  it('should test_ibm5qubitmapper_valid_circuit2', () => {\r\n    const backend = new DummyEngine(true)\r\n    const eng = new MainEngine(backend, [new IBM5QubitMapper()])\r\n    const qb0 = eng.allocateQubit()\r\n    const qb1 = eng.allocateQubit()\r\n    const qb2 = eng.allocateQubit()\r\n    const qb3 = eng.allocateQubit()\r\n    const qb4 = eng.allocateQubit()\r\n    CNOT.or(tuple(qb3, qb1))\r\n    CNOT.or(tuple(qb3, qb2))\r\n    CNOT.or(tuple(qb3, qb0))\r\n    CNOT.or(tuple(qb3, qb4))\r\n    CNOT.or(tuple(qb1, qb2))\r\n    CNOT.or(tuple(qb0, qb4))\r\n    CNOT.or(tuple(qb2, qb1))\r\n    eng.flush()\r\n  });\r\n\r\n  it('should test_ibm5qubitmapper_valid_circuit2_ibmqx4', () => {\r\n    const backend = new DummyEngine(true)\r\n\r\n    class FakeIBMBackend extends IBMBackend {\r\n\r\n    }\r\n\r\n    const fake = new FakeIBMBackend('ibmqx4', true)\r\n    fake.receive = backend.receive\r\n    fake.isAvailable = backend.isAvailable\r\n    backend.isLastEngine = true\r\n\r\n    const eng = new MainEngine(fake, [new IBM5QubitMapper()])\r\n    const qb0 = eng.allocateQubit()\r\n    const qb1 = eng.allocateQubit()\r\n    const qb2 = eng.allocateQubit()\r\n    const qb3 = eng.allocateQubit()\r\n    const qb4 = eng.allocateQubit()\r\n    CNOT.or(tuple(qb3, qb1))\r\n    CNOT.or(tuple(qb3, qb2))\r\n    CNOT.or(tuple(qb3, qb0))\r\n    CNOT.or(tuple(qb3, qb4))\r\n    CNOT.or(tuple(qb1, qb2))\r\n    CNOT.or(tuple(qb0, qb4))\r\n    CNOT.or(tuple(qb2, qb1))\r\n    eng.flush()\r\n  });\r\n\r\n  it('should test_ibm5qubitmapper_optimizeifpossible', () => {\r\n    const backend = new DummyEngine(true)\r\n    const connectivity = new Set([[2, 1], [4, 2], [2, 0], [3, 2], [3, 4], [1, 0]])\r\n    const eng = new MainEngine(backend, [new IBM5QubitMapper(), new SwapAndCNOTFlipper(connectivity)])\r\n    const qb0 = eng.allocateQubit()\r\n    const qb1 = eng.allocateQubit()\r\n    const qb2 = eng.allocateQubit()\r\n    const qb3 = eng.allocateQubit()\r\n    CNOT.or(tuple(qb1, qb2))\r\n    CNOT.or(tuple(qb2, qb1))\r\n    CNOT.or(tuple(qb1, qb2))\r\n\r\n    eng.flush()\r\n\r\n    let hadamard_count = backend.receivedCommands.filter(cmd => cmd.gate.equal(H)).length\r\n\r\n    expect(hadamard_count).to.equal(4)\r\n    backend.receivedCommands = []\r\n\r\n    CNOT.or(tuple(qb2, qb1))\r\n    CNOT.or(tuple(qb1, qb2))\r\n    CNOT.or(tuple(qb2, qb1))\r\n\r\n    eng.flush()\r\n\r\n    hadamard_count = backend.receivedCommands.filter(cmd => cmd.gate.equal(H)).length\r\n    expect(hadamard_count).to.equal(4)\r\n  });\r\n\r\n  it('should test_ibm5qubitmapper_toomanyqubits', () => {\r\n    const backend = new DummyEngine(true)\r\n    const connectivity = new Set([[2, 1], [4, 2], [2, 0], [3, 2], [3, 4], [1, 0]])\r\n    const eng = new MainEngine(backend, [new IBM5QubitMapper(), new SwapAndCNOTFlipper(connectivity)])\r\n    const qubits = eng.allocateQureg(6)\r\n    new All(H).or(qubits)\r\n    CNOT.or(tuple(qubits[0], qubits[1]))\r\n    expect(() => eng.flush()).to.throw()\r\n  });\r\n})\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/cengines/ibm5qubitmapper.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 355,
    "kind": "file",
    "name": "src/cengines/linearmapper.js",
    "content": "\r\n/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/*\r\nMapper for a quantum circuit to a linear chain of qubits.\r\n\r\n    Input: Quantum circuit with 1 and 2 qubit gates on n qubits. Gates are assumed\r\nto be applied in parallel if they act on disjoint qubit(s) and any pair\r\nof qubits can perform a 2 qubit gate (all-to-all connectivity)\r\nOutput: Quantum circuit in which qubits are placed in 1-D chain in which only\r\nnearest neighbour qubits can perform a 2 qubit gate. The mapper uses\r\nSwap gates in order to move qubits next to each other.\r\n*/\r\n\r\n\r\nimport assert from 'assert'\r\nimport BasicMapperEngine from './basicmapper'\r\nimport {\r\n  intersection, len, setDifference, setFromRange\r\n} from '../libs/polyfill'\r\nimport {\r\n  Allocate,\r\n  AllocateQubitGate, Deallocate, DeallocateQubitGate, FlushGate, Swap\r\n} from '../ops/gates'\r\nimport {BasicQubit} from '../types/qubit'\r\nimport {tuple} from '../libs/util'\r\nimport Command from '../ops/command'\r\nimport {LogicalQubitIDTag} from '../meta'\r\n\r\n/**\r\n Returns the circuit depth to execute these swaps.\r\n\r\n @param {Array.<Array>} swaps Each tuple contains two integers representing the two IDs of the qubits involved in the\r\n    Swap operation\r\n @returns {number} Circuit depth to execute these swaps.\r\n */\r\nexport function return_swap_depth(swaps) {\r\n  const depth_of_qubits = {}\r\n  swaps.forEach(([qb0_id, qb1_id]) => {\r\n    if (!(qb0_id in depth_of_qubits)) {\r\n      depth_of_qubits[qb0_id] = 0\r\n    }\r\n    if (!(qb1_id in depth_of_qubits)) {\r\n      depth_of_qubits[qb1_id] = 0\r\n    }\r\n    const max_depth = Math.max(depth_of_qubits[qb0_id], depth_of_qubits[qb1_id])\r\n    depth_of_qubits[qb0_id] = max_depth + 1\r\n    depth_of_qubits[qb1_id] = max_depth + 1\r\n  })\r\n  const values = Object.values(depth_of_qubits)\r\n  values.push(0)\r\n  return Math.max(...values)\r\n}\r\n\r\n/**\r\n * @class LinearMapper\r\n * @desc\r\nMaps a quantum circuit to a linear chain of nearest neighbour interactions.\r\n\r\n    Maps a quantum circuit to a linear chain of qubits with nearest neighbour\r\ninteractions using Swap gates. It supports open or cyclic boundary\r\nconditions.\r\n\r\n    Attributes:\r\ncurrent_mapping:  Stores the mapping: key is logical qubit id, value\r\nis mapped qubit id from 0,...,this.num_qubits\r\ncyclic (Bool): If chain is cyclic or not\r\nstorage (int): Number of gate it caches before mapping.\r\nnum_mappings (int): Number of times the mapper changed the mapping\r\ndepth_of_swaps (dict): Key are circuit depth of swaps, value is the\r\nnumber of such mappings which have been\r\napplied\r\nnum_of_swaps_per_mapping (dict): Key are the number of swaps per\r\nmapping, value is the number of such\r\nmappings which have been applied\r\n\r\nNote:\r\n    1) Gates are cached and only mapped from time to time. A\r\nFastForwarding gate doesn't empty the cache, only a FlushGate does.\r\n2) Only 1 and two qubit gates allowed.\r\n3) Does not optimize for dirty qubits.\r\n */\r\nexport default class LinearMapper extends BasicMapperEngine {\r\n  /**\r\n   * @constructor\r\n  Initialize a LinearMapper compiler engine.\r\n\r\n    @param {number} num_qubits Number of physical qubits in the linear chain\r\n    @param {boolean} cyclic If 1D chain is a cycle. Default is false.\r\n    @param {number} storage Number of gates to temporarily store, default is 1000\r\n  */\r\n  constructor(num_qubits, cyclic = false, storage = 1000) {\r\n    super()\r\n\r\n    this.num_qubits = num_qubits\r\n    this.cyclic = cyclic\r\n    this.storage = storage\r\n    // Storing commands\r\n    this._stored_commands = []\r\n    // Logical qubit ids for which the Allocate gate has already been\r\n    // processed and sent to the next engine but which are not yet\r\n    // deallocated:\r\n    this._currently_allocated_ids = new Set()\r\n    // Statistics:\r\n    this.num_mappings = 0\r\n    this.depth_of_swaps = {}\r\n    this.num_of_swaps_per_mapping = {}\r\n  }\r\n\r\n  // Only allows 1 or two qubit gates.\r\n  isAvailable(cmd) {\r\n    let num_qubits = 0\r\n    cmd.allQubits.forEach(qureg => num_qubits += len(qureg))\r\n    return num_qubits <= 2\r\n  }\r\n\r\n  /**\r\n   * @static\r\n  Builds a mapping of qubits to a linear chain.\r\n\r\n    It goes through stored_commands and tries to find a mapping to apply these gates\r\n    on a first come first served basis. More compilicated scheme could try to optimize to apply\r\n   as many gates as possible between the Swaps.\r\n\r\n    @param {number} num_qubits Total number of qubits in the linear chain\r\n    @param {boolean} cyclic If linear chain is a cycle.\r\n    @param {Set<Number>} currently_allocated_ids Logical qubit ids for which\r\n      the Allocate gate has already been processed and sent to the next engine but which are\r\n      not yet deallocated and hence need to be included in the new mapping.\r\n    @param {Command[]} stored_commands Future commands which should be applied next.\r\n    @param {Object} current_mapping A current mapping as a dict. key is logical qubit id, value is placement id.\r\n      If there are different possible maps, this current mapping is used to minimize the swaps\r\n      to go to the new mapping by a heuristic.\r\n\r\n    @return {Object} A new mapping as a dict. key is logical qubit id, value is placement id\r\n   */\r\n  static returnNewMapping(num_qubits, cyclic, currently_allocated_ids, stored_commands, current_mapping) {\r\n    // allocated_qubits is used as this mapper currently does not reassign\r\n    // a qubit placement to a new qubit if the previous qubit at that\r\n    // location has been deallocated. This is done after the next swaps.\r\n    const allocated_qubits = new Set(currently_allocated_ids)\r\n    const active_qubits = new Set(currently_allocated_ids)\r\n    // Segments contains a list of segments. A segment is a list of\r\n    // neighouring qubit ids\r\n    const segments = []\r\n    // neighbour_ids only used to speedup the lookup process if qubits\r\n    // are already connected. key: qubit_id, value: set of neighbour ids\r\n    const neighbour_ids = {}\r\n    active_qubits.forEach(qubit_id => neighbour_ids[qubit_id] = new Set())\r\n\r\n    for (let i = 0; i < stored_commands.length; ++i) {\r\n      const cmd = stored_commands[i]\r\n      if (len(allocated_qubits) === num_qubits && len(active_qubits) === 0) {\r\n        break\r\n      }\r\n\r\n      const qubit_ids = []\r\n      cmd.allQubits.forEach(qureg => qureg.forEach(qubit => qubit_ids.push(qubit.id)))\r\n\r\n      if (len(qubit_ids) > 2 || len(qubit_ids) === 0) {\r\n        throw new Error(`Invalid command (number of qubits): ${cmd.toString()}`)\r\n      } else if (cmd.gate instanceof AllocateQubitGate) {\r\n        const qubit_id = cmd.qubits[0][0].id\r\n        if (len(allocated_qubits) < num_qubits) {\r\n          allocated_qubits.add(qubit_id)\r\n          active_qubits.add(qubit_id)\r\n          neighbour_ids[qubit_id] = new Set()\r\n        }\r\n      } else if (cmd.gate instanceof DeallocateQubitGate) {\r\n        const qubit_id = cmd.qubits[0][0].id\r\n        if (active_qubits.has(qubit_id)) {\r\n          active_qubits.delete(qubit_id)\r\n        }\r\n        // Do not remove from allocated_qubits as this would\r\n        // allow the mapper to add a new qubit to this location\r\n        // before the next swaps which is currently not supported\r\n      } else if (len(qubit_ids) === 1) {\r\n        continue\r\n      } else {\r\n        // Process a two qubit gate:\r\n\r\n        LinearMapper._processTwoQubitGate(\r\n          num_qubits,\r\n          cyclic,\r\n          qubit_ids[0],\r\n          qubit_ids[1],\r\n          active_qubits,\r\n          segments,\r\n          neighbour_ids\r\n        )\r\n      }\r\n    }\r\n\r\n    return LinearMapper._returnNewMappingFromSegments(\r\n      num_qubits,\r\n      segments,\r\n      allocated_qubits,\r\n      current_mapping\r\n    )\r\n  }\r\n\r\n  /**\r\n  Processes a two qubit gate.\r\n\r\n    It either removes the two qubits from active_qubits if the gate is not\r\npossible or updates the segements such that the gate is possible.\r\n\r\n   @param {number} num_qubits Total number of qubits in the chain\r\n   @param {boolean} cyclic If linear chain is a cycle\r\n   @param {number} qubit0 qubit.id of one of the qubits\r\n   @param {number} qubit1 qubit.id of the other qubit\r\n   @param {Set<Number>} active_qubits contains all qubit ids which for which gates can be applied in this cycle before the swaps\r\n   @param {Array} segments List of segments. A segment is a list of neighbouring qubits.\r\n   @param {Object} neighbour_ids Key: qubit.id Value: qubit.id of neighbours\r\n   */\r\n  static _processTwoQubitGate(num_qubits, cyclic, qubit0, qubit1, active_qubits, segments, neighbour_ids) {\r\n    // already connected\r\n    if (qubit1 in neighbour_ids && neighbour_ids[qubit1].has(qubit0)) {\r\n      // do nothing\r\n\r\n    }\r\n    // at least one qubit is not an active qubit:\r\n    else if (!active_qubits.has(qubit0) || !active_qubits.has(qubit1)) {\r\n      active_qubits.delete(qubit0)\r\n      active_qubits.delete(qubit1)\r\n    }\r\n    // at least one qubit is in the inside of a segment:\r\n    else if (len(neighbour_ids[qubit0]) > 1 || len(neighbour_ids[qubit1]) > 1) {\r\n      active_qubits.delete(qubit0)\r\n      active_qubits.delete(qubit1)\r\n    }\r\n    // qubits are both active and either not yet in a segment or at\r\n    // the end of segement:\r\n    else {\r\n      let segment_index_qb0\r\n      let qb0_is_left_end\r\n      let segment_index_qb1\r\n      let qb1_is_left_end\r\n\r\n      segments.forEach((segment, index) => {\r\n        if (qubit0 === segment[0]) {\r\n          segment_index_qb0 = index\r\n          qb0_is_left_end = true\r\n        } else if (qubit0 === segment[segment.length - 1]) {\r\n          segment_index_qb0 = index\r\n          qb0_is_left_end = false\r\n        }\r\n        if (qubit1 === segment[0]) {\r\n          segment_index_qb1 = index\r\n          qb1_is_left_end = true\r\n        } else if (qubit1 === segment[segment.length - 1]) {\r\n          segment_index_qb1 = index\r\n          qb1_is_left_end = false\r\n        }\r\n      })\r\n      // Both qubits are not yet assigned to a segment:\r\n      if (typeof segment_index_qb0 === 'undefined' && typeof segment_index_qb1 === 'undefined') {\r\n        segments.push([qubit0, qubit1])\r\n        neighbour_ids[qubit0].add(qubit1)\r\n        neighbour_ids[qubit1].add(qubit0)\r\n      }\r\n      // if qubits are in the same segment, then the gate is not\r\n      // possible. Note that if this.cyclic==true, we have\r\n      // added that connection already to neighbour_ids and wouldn't be\r\n      // in this branch.\r\n      else if (segment_index_qb0 === segment_index_qb1) {\r\n        active_qubits.delete(qubit0)\r\n        active_qubits.delete(qubit1)\r\n        // qubit0 not yet assigned to a segment:\r\n      } else if (typeof segment_index_qb0 === 'undefined') {\r\n        if (qb1_is_left_end) {\r\n          segments[segment_index_qb1].splice(0, 0, qubit0)\r\n        } else {\r\n          segments[segment_index_qb1].push(qubit0)\r\n        }\r\n        neighbour_ids[qubit0].add(qubit1)\r\n        neighbour_ids[qubit1].add(qubit0)\r\n        if (cyclic && len(segments[0]) === num_qubits) {\r\n          const tmp = segments[0]\r\n          neighbour_ids[tmp[0]].add(tmp[tmp.length - 1])\r\n          neighbour_ids[tmp[tmp.length - 1]].add(tmp[0])\r\n        }\r\n      }\r\n      // qubit1 not yet assigned to a segment:\r\n      else if (typeof segment_index_qb1 === 'undefined') {\r\n        if (qb0_is_left_end) {\r\n          segments[segment_index_qb0].splice(0, 0, qubit1)\r\n        } else {\r\n          segments[segment_index_qb0].push(qubit1)\r\n        }\r\n        neighbour_ids[qubit0].add(qubit1)\r\n        neighbour_ids[qubit1].add(qubit0)\r\n        if (cyclic && len(segments[0]) === num_qubits) {\r\n          const tmp = segments[0]\r\n          neighbour_ids[tmp[0]].add(tmp[tmp.length - 1])\r\n          neighbour_ids[tmp[tmp.length - 1]].add(tmp[0])\r\n        }\r\n      }\r\n      // both qubits are at the end of different segments -> combine them\r\n      else {\r\n        if (!qb0_is_left_end && qb1_is_left_end) {\r\n          segments[segment_index_qb0] = segments[segment_index_qb0].concat(segments[segment_index_qb1])\r\n          segments.splice(segment_index_qb1, 1)\r\n        } else if (!qb0_is_left_end && !qb1_is_left_end) {\r\n          const rev = segments[segment_index_qb1].slice(0).reverse()\r\n          segments[segment_index_qb0] = segments[segment_index_qb0].concat(rev)\r\n          segments.splice(segment_index_qb1, 1)\r\n        } else if (qb0_is_left_end && qb1_is_left_end) {\r\n          segments[segment_index_qb0].reverse()\r\n          segments[segment_index_qb0] = segments[segment_index_qb0].concat(segments[segment_index_qb1])\r\n          segments.splice(segment_index_qb1, 1)\r\n        } else {\r\n          segments[segment_index_qb1] = segments[segment_index_qb1].concat(segments[segment_index_qb0])\r\n          segments.splice(segment_index_qb0, 1)\r\n        }\r\n\r\n        // Add new neighbour ids && make sure to check cyclic\r\n        neighbour_ids[qubit0].add(qubit1)\r\n        neighbour_ids[qubit1].add(qubit0)\r\n        if (cyclic && len(segments[0]) === num_qubits) {\r\n          const tmp = segments[0]\r\n          neighbour_ids[tmp[0]].add(tmp[tmp.length - 1])\r\n          neighbour_ids[tmp[tmp.length - 1]].add(tmp[0])\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n  Returns the swap operation for an odd-even transposition sort.\r\n\r\n  @see https://en.wikipedia.org/wiki/Odd-even_sort\r\n\r\n  @param {Object} old_mapping keys are logical ids and values are mapped qubit ids\r\n  @param {Object} new_mapping dict: keys are logical ids and values are mapped qubit ids\r\n  @return {Array} List of tuples. Each tuple is a swap operation which needs to be\r\n  applied. Tuple contains the two MappedQubit ids for the Swap.\r\n  */\r\n  _oddEvenTranspositionSortSwaps(old_mapping, new_mapping) {\r\n    const final_positions = new Array(this.num_qubits)\r\n    // move qubits which are in both mappings\r\n    Object.keys(old_mapping).forEach((logical_id) => {\r\n      if (logical_id in new_mapping) {\r\n        final_positions[old_mapping[logical_id]] = new_mapping[logical_id]\r\n      }\r\n    })\r\n    // exchange all remaining None with the not yet used mapped ids\r\n    const used_mapped_ids = new Set(final_positions)\r\n    used_mapped_ids.delete(undefined)\r\n    const all_ids = setFromRange(this.num_qubits)\r\n    let not_used_mapped_ids = Array.from(setDifference(all_ids, used_mapped_ids))\r\n    not_used_mapped_ids = not_used_mapped_ids.sort().reverse()\r\n    for (let i = 0; i < final_positions.length; ++i) {\r\n      const looper = final_positions[i]\r\n      if (typeof looper === 'undefined') {\r\n        final_positions[i] = not_used_mapped_ids.pop()\r\n      }\r\n    }\r\n    assert(len(not_used_mapped_ids) === 0)\r\n    // Start sorting:\r\n    const swap_operations = []\r\n    let finished_sorting = false\r\n    while (!finished_sorting) {\r\n      finished_sorting = true\r\n      for (let i = 1; i < len(final_positions); i += 2) {\r\n        if (final_positions[i] > final_positions[i + 1]) {\r\n          swap_operations.push(tuple(i, i + 1))\r\n          const tmp = final_positions[i]\r\n          final_positions[i] = final_positions[i + 1]\r\n          final_positions[i + 1] = tmp\r\n          finished_sorting = false\r\n        }\r\n      }\r\n      for (let i = 0; i < len(final_positions) - 1; i += 2) {\r\n        if (final_positions[i] > final_positions[i + 1]) {\r\n          swap_operations.push(tuple(i, i + 1))\r\n          const tmp = final_positions[i]\r\n          final_positions[i] = final_positions[i + 1]\r\n          final_positions[i + 1] = tmp\r\n          finished_sorting = false\r\n        }\r\n      }\r\n    }\r\n    return swap_operations\r\n  }\r\n\r\n\r\n  /**\r\n  Sends the stored commands possible without changing the mapping.\r\n\r\n  Note: this.currentMapping must exist already\r\n   */\r\n  _sendPossibleCommands() {\r\n    const active_ids = new Set(this._currently_allocated_ids)\r\n    Object.keys(this._currentMapping).forEach(logical_id => active_ids.add(parseInt(logical_id, 10)))\r\n\r\n    let new_stored_commands = []\r\n    for (let i = 0; i < this._stored_commands.length; ++i) {\r\n      const cmd = this._stored_commands[i]\r\n      if (len(active_ids) === 0) {\r\n        new_stored_commands = new_stored_commands.concat(this._stored_commands.slice(i))\r\n        break\r\n      }\r\n      if (cmd.gate instanceof AllocateQubitGate) {\r\n        const qid = cmd.qubits[0][0].id\r\n        if (qid in this._currentMapping) {\r\n          this._currently_allocated_ids.add(qid)\r\n          const qb = new BasicQubit(this, this._currentMapping[qid])\r\n          const new_cmd = new Command(this, new AllocateQubitGate(), tuple([qb]), [], [new LogicalQubitIDTag(qid)])\r\n          this.send([new_cmd])\r\n        } else {\r\n          new_stored_commands.push(cmd)\r\n        }\r\n      } else if (cmd.gate instanceof DeallocateQubitGate) {\r\n        const qid = cmd.qubits[0][0].id\r\n        if (active_ids.has(qid)) {\r\n          const qb = new BasicQubit(this, this._currentMapping[qid])\r\n          const new_cmd = new Command(this, new DeallocateQubitGate(), tuple([qb]), [], [new LogicalQubitIDTag(qid)])\r\n          this._currently_allocated_ids.delete(qid)\r\n          active_ids.delete(qid)\r\n          delete this._currentMapping[qid]\r\n          this.send([new_cmd])\r\n        } else {\r\n          new_stored_commands.push(cmd)\r\n        }\r\n      } else {\r\n        let send_gate = true\r\n        let mapped_ids = new Set()\r\n        for (let i = 0; i < cmd.allQubits.length; ++i) {\r\n          const qureg = cmd.allQubits[i]\r\n          for (let j = 0; j < qureg.length; ++j) {\r\n            const qubit = qureg[j]\r\n            if (!(active_ids.has(qubit.id))) {\r\n              send_gate = false\r\n              break\r\n            }\r\n            mapped_ids.add(this._currentMapping[qubit.id])\r\n          }\r\n        }\r\n\r\n        // Check that mapped ids are nearest neighbour\r\n        if (len(mapped_ids) === 2) {\r\n          mapped_ids = Array.from(mapped_ids)\r\n          const diff = Math.abs(mapped_ids[0] - mapped_ids[1])\r\n          if (this.cyclic) {\r\n            if (diff !== 1 && diff !== this.num_qubits - 1) {\r\n              send_gate = false\r\n            }\r\n          } else if (diff !== 1) {\r\n            send_gate = false\r\n          }\r\n        }\r\n        if (send_gate) {\r\n          this.sendCMDWithMappedIDs(cmd)\r\n        } else {\r\n          cmd.allQubits.forEach(qureg => qureg.forEach(qubit => active_ids.delete(qubit.id)))\r\n          new_stored_commands.push(cmd)\r\n        }\r\n      }\r\n    }\r\n    this._stored_commands = new_stored_commands\r\n  }\r\n\r\n  /**\r\n    Creates a new mapping and executes possible gates.\r\n\r\n  It first allocates all 0, ..., this.num_qubits-1 mapped qubit ids, if\r\n  they are not already used because we might need them all for the\r\n  swaps. Then it creates a new map, swaps all the qubits to the new map,\r\n  executes all possible gates, and finally deallocates mapped qubit ids\r\n  which don't store any information.\r\n   */\r\n  _run() {\r\n    const num_of_stored_commands_before = len(this._stored_commands)\r\n    if (!this._currentMapping) {\r\n      this.currentMapping = {}\r\n    } else {\r\n      this._sendPossibleCommands()\r\n      if (len(this._stored_commands) === 0) {\r\n        return\r\n      }\r\n    }\r\n    const new_mapping = LinearMapper.returnNewMapping(this.num_qubits,\r\n      this.cyclic,\r\n      this._currently_allocated_ids,\r\n      this._stored_commands,\r\n      this.currentMapping)\r\n    const swaps = this._oddEvenTranspositionSortSwaps(this._currentMapping, new_mapping)\r\n    if (swaps.length > 0) { // first mapping requires no swaps\r\n      // Allocate all mapped qubit ids (which are not already allocated,\r\n      // i.e., contained in this._currently_allocated_ids)\r\n      let mapped_ids_used = new Set()\r\n      for (const logical_id of this._currently_allocated_ids) {\r\n        mapped_ids_used.add(this._currentMapping[logical_id])\r\n      }\r\n      const tmpSet = setFromRange(this.num_qubits)\r\n      const not_allocated_ids = setDifference(tmpSet, mapped_ids_used)\r\n      for (const mapped_id of not_allocated_ids) {\r\n        const qb = new BasicQubit(this, mapped_id)\r\n        const cmd = new Command(this, Allocate, tuple([qb]))\r\n        this.send([cmd])\r\n      }\r\n      // Send swap operations to arrive at new_mapping:\r\n      swaps.forEach(([qubit_id0, qubit_id1]) => {\r\n        const q0 = new BasicQubit(this, qubit_id0)\r\n        const q1 = new BasicQubit(this, qubit_id1)\r\n        const cmd = new Command(this, Swap, tuple([q0], [q1]))\r\n        this.send([cmd])\r\n      })\r\n      // Register statistics:\r\n      this.num_mappings += 1\r\n      const depth = return_swap_depth(swaps)\r\n      if (!(depth in this.depth_of_swaps)) {\r\n        this.depth_of_swaps[depth] = 1\r\n      } else {\r\n        this.depth_of_swaps[depth] += 1\r\n      }\r\n      if (!(len(swaps) in this.num_of_swaps_per_mapping)) {\r\n        this.num_of_swaps_per_mapping[len(swaps)] = 1\r\n      } else {\r\n        this.num_of_swaps_per_mapping[len(swaps)] += 1\r\n      }\r\n      // Deallocate all previously mapped ids which we only needed for the\r\n      // swaps:\r\n      mapped_ids_used = new Set()\r\n      for (const logical_id of this._currently_allocated_ids) {\r\n        mapped_ids_used.add(new_mapping[logical_id])\r\n      }\r\n      const not_needed_anymore = setDifference(setFromRange(this.num_qubits), mapped_ids_used)\r\n      for (const mapped_id of not_needed_anymore) {\r\n        const qb = new BasicQubit(this, mapped_id)\r\n        const cmd = new Command(this, Deallocate, tuple([qb]))\r\n        this.send([cmd])\r\n      }\r\n    }\r\n\r\n    // Change to new map:\r\n    this.currentMapping = new_mapping\r\n    // Send possible gates:\r\n    this._sendPossibleCommands()\r\n    // Check that mapper actually made progress\r\n    if (len(this._stored_commands) === num_of_stored_commands_before) {\r\n      throw new Error('Mapper is potentially in an infinite loop. '\r\n      + 'It is likely that the algorithm requires '\r\n      + 'too many qubits. Increase the number of '\r\n      + 'qubits for this mapper.')\r\n    }\r\n  }\r\n\r\n  /**\r\n  Receives a command list and, for each command, stores it until\r\n  we do a mapping (FlushGate or Cache of stored commands is full).\r\n\r\n  @param {Command[]} command_list list of commands to receive.\r\n  */\r\n  receive(command_list) {\r\n    command_list.forEach((cmd) => {\r\n      if (cmd.gate instanceof FlushGate) {\r\n        while (this._stored_commands.length > 0) {\r\n          this._run()\r\n        }\r\n        this.send([cmd])\r\n      } else {\r\n        this._stored_commands.push(cmd)\r\n      }\r\n    })\r\n\r\n    // Storage is full: Create new map and send some gates away:\r\n    if (this._stored_commands.length >= this.storage) {\r\n      this._run()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @static\r\n  Combines the individual segments into a new mapping.\r\n\r\n  It tries to minimize the number of swaps to go from the old mapping\r\n  in this.currentMapping to the new mapping which it returns. The\r\n  strategy is to map a segment to the same region where most of the\r\n  qubits are already. Note that this is not a global optimal strategy\r\n  but helps if currently the qubits can be divided into independent\r\n  groups without interactions between the groups.\r\n\r\n   @param {number} num_qubits Total number of qubits in the linear chain\r\n   @param {Array} segments List of segments. A segment is a list of qubit ids which\r\n    should be nearest neighbour in the new map. Individual qubits are in allocated_qubits\r\n    but not in any segment\r\n   @param {Object} allocated_qubits A set of all qubit ids which need to be present in the new map\r\n   @param {Object} current_mapping A current mapping as a dict. key is logical qubit\r\n  id, value is placement id. If there are different possible maps, this current mapping is used to\r\n  minimize the swaps to go to the new mapping by a heuristic.\r\n  @returns\r\n      A new mapping as a dict. key is logical qubit id, value is placement id\r\n   */\r\n  static _returnNewMappingFromSegments(num_qubits, segments, allocated_qubits, current_mapping) {\r\n    const remaining_segments = segments.slice(0)\r\n    const individual_qubits = new Set(allocated_qubits)\r\n    let num_unused_qubits = num_qubits - len(allocated_qubits)\r\n    // Create a segment out of individual qubits and add to segments\r\n    segments.forEach((segment) => {\r\n      segment.forEach((qubit_id) => {\r\n        individual_qubits.delete(qubit_id)\r\n      })\r\n    })\r\n\r\n    for (const individual_qubit_id of individual_qubits) {\r\n      remaining_segments.push([individual_qubit_id])\r\n    }\r\n\r\n    const previous_chain = new Array(num_qubits)\r\n    if (current_mapping) {\r\n      Object.keys(current_mapping).forEach(key => previous_chain[current_mapping[key]] = parseInt(key, 10))\r\n    }\r\n\r\n    // Note: previous_chain potentially has some None elements\r\n    const new_chain = new Array(num_qubits)\r\n\r\n    let current_position_to_fill = 0\r\n    while (len(remaining_segments)) {\r\n      let best_segment = []\r\n      let best_padding = num_qubits\r\n      let highest_overlap_fraction = 0\r\n      remaining_segments.forEach((segment) => {\r\n        for (let padding = 0; padding < num_unused_qubits + 1; ++padding) {\r\n          const idx0 = current_position_to_fill + padding\r\n          const idx1 = idx0 + len(segment)\r\n\r\n          const previous_chain_ids = new Set(previous_chain.slice(idx0, idx1))\r\n          previous_chain_ids.delete(undefined)\r\n          const segment_ids = new Set(segment)\r\n          segment_ids.delete(undefined)\r\n\r\n          const overlap = len(intersection(previous_chain_ids, segment_ids)) + previous_chain.slice(idx0, idx1).count(undefined)\r\n          let overlap_fraction\r\n          if (overlap === 0) {\r\n            overlap_fraction = 0\r\n          } else if (overlap === len(segment)) {\r\n            overlap_fraction = 1\r\n          } else {\r\n            overlap_fraction = overlap / (len(segment) * 1.0)\r\n          }\r\n          if ((overlap_fraction === 1 && padding < best_padding)\r\n          || overlap_fraction > highest_overlap_fraction\r\n          || highest_overlap_fraction === 0) {\r\n            best_segment = segment\r\n            best_padding = padding\r\n            highest_overlap_fraction = overlap_fraction\r\n          }\r\n        }\r\n      })\r\n\r\n      // Add best segment and padding to new_chain\r\n      const start = current_position_to_fill + best_padding\r\n      for (let i = 0; i < len(best_segment); ++i) {\r\n        new_chain[start + i] = best_segment[i]\r\n      }\r\n\r\n      remaining_segments.remove(best_segment)\r\n      current_position_to_fill += best_padding + len(best_segment)\r\n      num_unused_qubits -= best_padding\r\n    }\r\n    // Create mapping\r\n    const new_mapping = {}\r\n    Object.keys(new_chain).forEach((pos) => {\r\n      const logical_id = new_chain[pos]\r\n      if (typeof logical_id !== 'undefined') {\r\n        new_mapping[logical_id] = parseInt(pos, 10)\r\n      }\r\n    })\r\n    return new_mapping\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/cengines/linearmapper.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 356,
    "kind": "function",
    "name": "return_swap_depth",
    "memberof": "src/cengines/linearmapper.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/cengines/linearmapper.js~return_swap_depth",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/cengines/linearmapper.js",
    "importStyle": "{return_swap_depth}",
    "description": "Returns the circuit depth to execute these swaps.",
    "lineNumber": 51,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} Circuit depth to execute these swaps."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Array.<Array>"
        ],
        "spread": false,
        "optional": false,
        "name": "swaps",
        "description": "Each tuple contains two integers representing the two IDs of the qubits involved in the\nSwap operation"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Circuit depth to execute these swaps."
    }
  },
  {
    "__docId__": 357,
    "kind": "class",
    "name": "LinearMapper",
    "memberof": "src/cengines/linearmapper.js",
    "static": true,
    "longname": "src/cengines/linearmapper.js~LinearMapper",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/cengines/linearmapper.js",
    "importStyle": "LinearMapper",
    "description": "Maps a quantum circuit to a linear chain of nearest neighbour interactions.\n\nMaps a quantum circuit to a linear chain of qubits with nearest neighbour\ninteractions using Swap gates. It supports open or cyclic boundary\nconditions.\n\nAttributes:\ncurrent_mapping:  Stores the mapping: key is logical qubit id, value\nis mapped qubit id from 0,...,this.num_qubits\ncyclic (Bool): If chain is cyclic or not\nstorage (int): Number of gate it caches before mapping.\nnum_mappings (int): Number of times the mapper changed the mapping\ndepth_of_swaps (dict): Key are circuit depth of swaps, value is the\nnumber of such mappings which have been\napplied\nnum_of_swaps_per_mapping (dict): Key are the number of swaps per\nmapping, value is the number of such\nmappings which have been applied\n\nNote:\n1) Gates are cached and only mapped from time to time. A\nFastForwarding gate doesn't empty the cache, only a FlushGate does.\n2) Only 1 and two qubit gates allowed.\n3) Does not optimize for dirty qubits.",
    "lineNumber": 97,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "LinearMapper"
      }
    ],
    "interface": false,
    "extends": [
      "src/cengines/basicmapper.js~BasicMapperEngine"
    ]
  },
  {
    "__docId__": 358,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/cengines/linearmapper.js~LinearMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/linearmapper.js~LinearMapper#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 106,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": "Initialize a LinearMapper compiler engine."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "num_qubits",
        "description": "Number of physical qubits in the linear chain"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "cyclic",
        "description": "If 1D chain is a cycle. Default is false."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "storage",
        "description": "Number of gates to temporarily store, default is 1000"
      }
    ]
  },
  {
    "__docId__": 359,
    "kind": "member",
    "name": "num_qubits",
    "memberof": "src/cengines/linearmapper.js~LinearMapper",
    "static": false,
    "longname": "src/cengines/linearmapper.js~LinearMapper#num_qubits",
    "access": "public",
    "description": null,
    "lineNumber": 109,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 360,
    "kind": "member",
    "name": "cyclic",
    "memberof": "src/cengines/linearmapper.js~LinearMapper",
    "static": false,
    "longname": "src/cengines/linearmapper.js~LinearMapper#cyclic",
    "access": "public",
    "description": null,
    "lineNumber": 110,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 361,
    "kind": "member",
    "name": "storage",
    "memberof": "src/cengines/linearmapper.js~LinearMapper",
    "static": false,
    "longname": "src/cengines/linearmapper.js~LinearMapper#storage",
    "access": "public",
    "description": null,
    "lineNumber": 111,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 362,
    "kind": "member",
    "name": "_stored_commands",
    "memberof": "src/cengines/linearmapper.js~LinearMapper",
    "static": false,
    "longname": "src/cengines/linearmapper.js~LinearMapper#_stored_commands",
    "access": "private",
    "description": null,
    "lineNumber": 113,
    "undocument": true,
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 363,
    "kind": "member",
    "name": "_currently_allocated_ids",
    "memberof": "src/cengines/linearmapper.js~LinearMapper",
    "static": false,
    "longname": "src/cengines/linearmapper.js~LinearMapper#_currently_allocated_ids",
    "access": "private",
    "description": null,
    "lineNumber": 117,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 364,
    "kind": "member",
    "name": "num_mappings",
    "memberof": "src/cengines/linearmapper.js~LinearMapper",
    "static": false,
    "longname": "src/cengines/linearmapper.js~LinearMapper#num_mappings",
    "access": "public",
    "description": null,
    "lineNumber": 119,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 365,
    "kind": "member",
    "name": "depth_of_swaps",
    "memberof": "src/cengines/linearmapper.js~LinearMapper",
    "static": false,
    "longname": "src/cengines/linearmapper.js~LinearMapper#depth_of_swaps",
    "access": "public",
    "description": null,
    "lineNumber": 120,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 366,
    "kind": "member",
    "name": "num_of_swaps_per_mapping",
    "memberof": "src/cengines/linearmapper.js~LinearMapper",
    "static": false,
    "longname": "src/cengines/linearmapper.js~LinearMapper#num_of_swaps_per_mapping",
    "access": "public",
    "description": null,
    "lineNumber": 121,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 367,
    "kind": "method",
    "name": "isAvailable",
    "memberof": "src/cengines/linearmapper.js~LinearMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/linearmapper.js~LinearMapper#isAvailable",
    "access": "public",
    "description": null,
    "lineNumber": 125,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 368,
    "kind": "method",
    "name": "returnNewMapping",
    "memberof": "src/cengines/linearmapper.js~LinearMapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/cengines/linearmapper.js~LinearMapper.returnNewMapping",
    "access": "public",
    "description": "",
    "lineNumber": 151,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "num_qubits",
        "description": "Total number of qubits in the linear chain"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "cyclic",
        "description": "If linear chain is a cycle."
      },
      {
        "nullable": null,
        "types": [
          "Set<Number>"
        ],
        "spread": false,
        "optional": false,
        "name": "currently_allocated_ids",
        "description": "Logical qubit ids for which\nthe Allocate gate has already been processed and sent to the next engine but which are\nnot yet deallocated and hence need to be included in the new mapping."
      },
      {
        "nullable": null,
        "types": [
          "Command[]"
        ],
        "spread": false,
        "optional": false,
        "name": "stored_commands",
        "description": "Future commands which should be applied next."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "current_mapping",
        "description": "A current mapping as a dict. key is logical qubit id, value is placement id.\nIf there are different possible maps, this current mapping is used to minimize the swaps\nto go to the new mapping by a heuristic."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "A new mapping as a dict. key is logical qubit id, value is placement id"
    }
  },
  {
    "__docId__": 369,
    "kind": "method",
    "name": "_processTwoQubitGate",
    "memberof": "src/cengines/linearmapper.js~LinearMapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/cengines/linearmapper.js~LinearMapper._processTwoQubitGate",
    "access": "private",
    "description": "Processes a two qubit gate.\n\nIt either removes the two qubits from active_qubits if the gate is not\npossible or updates the segements such that the gate is possible.",
    "lineNumber": 230,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "num_qubits",
        "description": "Total number of qubits in the chain"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "cyclic",
        "description": "If linear chain is a cycle"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "qubit0",
        "description": "qubit.id of one of the qubits"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "qubit1",
        "description": "qubit.id of the other qubit"
      },
      {
        "nullable": null,
        "types": [
          "Set<Number>"
        ],
        "spread": false,
        "optional": false,
        "name": "active_qubits",
        "description": "contains all qubit ids which for which gates can be applied in this cycle before the swaps"
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "segments",
        "description": "List of segments. A segment is a list of neighbouring qubits."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "neighbour_ids",
        "description": "Key: qubit.id Value: qubit.id of neighbours"
      }
    ],
    "return": null
  },
  {
    "__docId__": 370,
    "kind": "method",
    "name": "_oddEvenTranspositionSortSwaps",
    "memberof": "src/cengines/linearmapper.js~LinearMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/linearmapper.js~LinearMapper#_oddEvenTranspositionSortSwaps",
    "access": "private",
    "description": "Returns the swap operation for an odd-even transposition sort.",
    "see": [
      "https://en.wikipedia.org/wiki/Odd-even_sort"
    ],
    "lineNumber": 353,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "old_mapping",
        "description": "keys are logical ids and values are mapped qubit ids"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "new_mapping",
        "description": "dict: keys are logical ids and values are mapped qubit ids"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": "List of tuples. Each tuple is a swap operation which needs to be\napplied. Tuple contains the two MappedQubit ids for the Swap."
    }
  },
  {
    "__docId__": 371,
    "kind": "method",
    "name": "_sendPossibleCommands",
    "memberof": "src/cengines/linearmapper.js~LinearMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/linearmapper.js~LinearMapper#_sendPossibleCommands",
    "access": "private",
    "description": "Sends the stored commands possible without changing the mapping.\n\nNote: this.currentMapping must exist already",
    "lineNumber": 407,
    "params": [],
    "return": null
  },
  {
    "__docId__": 373,
    "kind": "method",
    "name": "_run",
    "memberof": "src/cengines/linearmapper.js~LinearMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/linearmapper.js~LinearMapper#_run",
    "access": "private",
    "description": "Creates a new mapping and executes possible gates.\n\nIt first allocates all 0, ..., this.num_qubits-1 mapped qubit ids, if\nthey are not already used because we might need them all for the\nswaps. Then it creates a new map, swaps all the qubits to the new map,\nexecutes all possible gates, and finally deallocates mapped qubit ids\nwhich don't store any information.",
    "lineNumber": 487,
    "params": [],
    "return": null
  },
  {
    "__docId__": 374,
    "kind": "member",
    "name": "currentMapping",
    "memberof": "src/cengines/linearmapper.js~LinearMapper",
    "static": false,
    "longname": "src/cengines/linearmapper.js~LinearMapper#currentMapping",
    "access": "public",
    "description": null,
    "lineNumber": 490,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 377,
    "kind": "method",
    "name": "receive",
    "memberof": "src/cengines/linearmapper.js~LinearMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/linearmapper.js~LinearMapper#receive",
    "access": "public",
    "description": "Receives a command list and, for each command, stores it until\nwe do a mapping (FlushGate or Cache of stored commands is full).",
    "lineNumber": 570,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command[]"
        ],
        "spread": false,
        "optional": false,
        "name": "command_list",
        "description": "list of commands to receive."
      }
    ],
    "return": null
  },
  {
    "__docId__": 378,
    "kind": "method",
    "name": "_returnNewMappingFromSegments",
    "memberof": "src/cengines/linearmapper.js~LinearMapper",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/cengines/linearmapper.js~LinearMapper._returnNewMappingFromSegments",
    "access": "private",
    "description": "",
    "lineNumber": 610,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "A new mapping as a dict. key is logical qubit id, value is placement id"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "num_qubits",
        "description": "Total number of qubits in the linear chain"
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "segments",
        "description": "List of segments. A segment is a list of qubit ids which\nshould be nearest neighbour in the new map. Individual qubits are in allocated_qubits\nbut not in any segment"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "allocated_qubits",
        "description": "A set of all qubit ids which need to be present in the new map"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "current_mapping",
        "description": "A current mapping as a dict. key is logical qubit\nid, value is placement id. If there are different possible maps, this current mapping is used to\nminimize the swaps to go to the new mapping by a heuristic."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "A new mapping as a dict. key is logical qubit id, value is placement id"
    }
  },
  {
    "__docId__": 379,
    "kind": "file",
    "name": "src/cengines/linearmapper.spec.js",
    "content": "import {expect} from 'chai'\r\nimport deepEqual from 'deep-eql'\r\nimport {return_swap_depth} from './linearmapper'\r\nimport LinearMapper from './linearmapper';\r\nimport {BasicQubit} from '../types/qubit';\r\nimport Command from '../ops/command';\r\nimport {tuple} from '../libs/util';\r\nimport {\r\n  Allocate, BasicGate, CNOT, Deallocate, FlushGate, QFT, X\r\n} from '../ops';\r\nimport {len, setEqual} from '../libs/polyfill';\r\nimport {DummyEngine} from './testengine';\r\nimport {LogicalQubitIDTag} from '../meta';\r\n\r\ndescribe('linearmapper test', () => {\r\n  it('should test_return_swap_depth', () => {\r\n    let swaps = []\r\n    expect(return_swap_depth(swaps)).to.equal(0)\r\n    swaps = [[0, 1], [0, 1], [1, 2]]\r\n    expect(return_swap_depth(swaps)).to.equal(3)\r\n    swaps.push([2, 3])\r\n    expect(return_swap_depth(swaps)).to.equal(4)\r\n  });\r\n\r\n  it('should test_is_available', () => {\r\n    const mapper = new LinearMapper(5, false)\r\n    const qb0 = new BasicQubit(null, 0)\r\n    const qb1 = new BasicQubit(null, 1)\r\n    const qb2 = new BasicQubit(null, 2)\r\n    const cmd0 = new Command(null, new BasicGate(), tuple([qb0]))\r\n    expect(mapper.isAvailable(cmd0)).to.equal(true)\r\n    const cmd1 = new Command(null, new BasicGate(), tuple([qb0]), [qb1])\r\n    expect(mapper.isAvailable(cmd1)).to.equal(true)\r\n    const cmd2 = new Command(null, new BasicGate(), tuple([qb0], [qb1, qb2]))\r\n    expect(mapper.isAvailable(cmd2)).to.equal(false)\r\n    const cmd3 = new Command(null, new BasicGate(), tuple([qb0], [qb1]), [qb2])\r\n    expect(mapper.isAvailable(cmd3)).to.equal(false)\r\n  });\r\n\r\n  it('should test_returnNewMapping_too_many_qubits', () => {\r\n    const mapper = new LinearMapper(3, false)\r\n    const qb0 = new BasicQubit(null, 0)\r\n    const qb1 = new BasicQubit(null, 1)\r\n    const qb2 = new BasicQubit(null, 2)\r\n    const cmd0 = new Command(null, QFT, tuple([qb0], [qb1, qb2]))\r\n    mapper._stored_commands = [cmd0]\r\n\r\n    expect(() => LinearMapper.returnNewMapping(\r\n      mapper.num_qubits,\r\n      mapper.cyclic,\r\n      mapper._currently_allocated_ids,\r\n      mapper._stored_commands,\r\n      mapper.currentMapping\r\n    )).to.throw()\r\n    const cmd1 = new Command(null, new BasicGate(), tuple([]))\r\n    mapper._stored_commands = [cmd1]\r\n\r\n    expect(() => LinearMapper.returnNewMapping(\r\n      mapper.num_qubits,\r\n      mapper.cyclic,\r\n      mapper._currently_allocated_ids,\r\n      mapper._stored_commands,\r\n      mapper.currentMapping\r\n    )).to.throw()\r\n  });\r\n\r\n  it('should test_return_new_mapping_allocate_qubits', () => {\r\n    const mapper = new LinearMapper(2, false)\r\n    const qb0 = new BasicQubit(null, 0)\r\n    const qb1 = new BasicQubit(null, 1)\r\n    mapper._currently_allocated_ids = new Set([4])\r\n    const cmd0 = new Command(null, Allocate, tuple([qb0]))\r\n    const cmd1 = new Command(null, Allocate, tuple([qb1]))\r\n    mapper._stored_commands = [cmd0, cmd1]\r\n    const new_mapping = LinearMapper.returnNewMapping(\r\n      mapper.num_qubits,\r\n      mapper.cyclic,\r\n      mapper._currently_allocated_ids,\r\n      mapper._stored_commands,\r\n      mapper.currentMapping\r\n    )\r\n    expect(setEqual(mapper._currently_allocated_ids, new Set([4]))).to.equal(true)\r\n    expect(mapper._stored_commands).to.deep.equal([cmd0, cmd1])\r\n    expect(len(new_mapping)).to.equal(2)\r\n    expect(4 in new_mapping && 0 in new_mapping).to.equal(true)\r\n  });\r\n\r\n  it('should test_return_new_mapping_allocate_only_once', () => {\r\n    const mapper = new LinearMapper(1, false)\r\n    const qb0 = new BasicQubit(null, 0)\r\n    const qb1 = new BasicQubit(null, 1)\r\n    mapper._currently_allocated_ids = new Set()\r\n    const cmd0 = new Command(null, Allocate, tuple([qb0]))\r\n    const cmd1 = new Command(null, Deallocate, tuple([qb0]))\r\n    // Test if loop stops after deallocate gate has been used.\r\n    // This would otherwise trigger an error (test by 2)\r\n    const cmd2 = null\r\n    mapper._stored_commands = [cmd0, cmd1, cmd2]\r\n    const new_mapping = LinearMapper.returnNewMapping(\r\n      mapper.num_qubits,\r\n      mapper.cyclic,\r\n      mapper._currently_allocated_ids,\r\n      mapper._stored_commands,\r\n      mapper.currentMapping\r\n    )\r\n  });\r\n\r\n  it('should test_return_new_mapping_possible_map', () => {\r\n    const mapper = new LinearMapper(3, false)\r\n    const qb0 = new BasicQubit(null, 0)\r\n    const qb1 = new BasicQubit(null, 1)\r\n    const qb2 = new BasicQubit(null, 2)\r\n    const cmd0 = new Command(null, Allocate, tuple([qb0]))\r\n    const cmd1 = new Command(null, Allocate, tuple([qb1]))\r\n    const cmd2 = new Command(null, Allocate, tuple([qb2]))\r\n    const cmd3 = new Command(null, CNOT, tuple([qb0]), [qb1])\r\n    const cmd4 = new Command(null, CNOT, tuple([qb2]), [qb1])\r\n    const cmd5 = new Command(null, X, tuple([qb0]))\r\n    mapper._stored_commands = [cmd0, cmd1, cmd2, cmd3, cmd4, cmd5]\r\n    const new_mapping = LinearMapper.returnNewMapping(\r\n      mapper.num_qubits,\r\n      mapper.cyclic,\r\n      mapper._currently_allocated_ids,\r\n      mapper._stored_commands,\r\n      mapper.currentMapping\r\n    )\r\n    const array = [{0: 2, 1: 1, 2: 0}, {0: 0, 1: 1, 2: 2}]\r\n    const idx = array.findIndex(item => deepEqual(item, new_mapping))\r\n    expect(idx).to.not.equal(-1)\r\n  });\r\n\r\n  it('should test_return_new_mapping_previous_error', () => {\r\n    const mapper = new LinearMapper(2, false)\r\n    const qb0 = new BasicQubit(null, 0)\r\n    const qb1 = new BasicQubit(null, 1)\r\n    const qb2 = new BasicQubit(null, 2)\r\n    const qb3 = new BasicQubit(null, 3)\r\n    const cmd0 = new Command(null, Allocate, tuple([qb0]))\r\n    const cmd1 = new Command(null, Allocate, tuple([qb1]))\r\n    const cmd2 = new Command(null, Allocate, tuple([qb2]))\r\n    const cmd3 = new Command(null, Allocate, tuple([qb3]))\r\n    const cmd4 = new Command(null, CNOT, tuple([qb2]), [qb3])\r\n    mapper._stored_commands = [cmd0, cmd1, cmd2, cmd3, cmd4]\r\n    const new_mapping = LinearMapper.returnNewMapping(\r\n      mapper.num_qubits,\r\n      mapper.cyclic,\r\n      mapper._currently_allocated_ids,\r\n      mapper._stored_commands,\r\n      mapper.currentMapping\r\n    )\r\n  });\r\n\r\n  it('should test_process_two_qubit_gate_not_in_segments_test0', () => {\r\n    const mapper = new LinearMapper(5, false)\r\n    const segments = [[0, 1]]\r\n    const active_qubits = new Set([0, 1, 4, 6])\r\n    const neighbour_ids = {\r\n      0: new Set([1]), 1: new Set([0]), 4: new Set(), 6: new Set()\r\n    }\r\n    LinearMapper._processTwoQubitGate(mapper.num_qubits,\r\n      mapper.cyclic,\r\n      4,\r\n      6,\r\n      active_qubits,\r\n      segments,\r\n      neighbour_ids)\r\n    expect(len(segments)).to.equal(2)\r\n    expect(segments[0]).to.deep.equal([0, 1])\r\n    expect(segments[1]).to.deep.equal([4, 6])\r\n    expect(neighbour_ids[4]).to.deep.equal(new Set([6]))\r\n    expect(neighbour_ids[6]).to.deep.equal(new Set([4]))\r\n    expect(active_qubits).to.deep.equal(new Set([0, 1, 4, 6]))\r\n  });\r\n\r\n  it('should test_process_two_qubit_gate_not_in_segments_test1', () => {\r\n    const mapper = new LinearMapper(5, false)\r\n    const segments = []\r\n    const active_qubits = new Set([4, 6])\r\n    const neighbour_ids = {4: new Set(), 6: new Set()}\r\n    LinearMapper._processTwoQubitGate(mapper.num_qubits,\r\n      mapper.cyclic,\r\n      5,\r\n      6,\r\n      active_qubits,\r\n      segments,\r\n      neighbour_ids)\r\n    expect(len(segments)).to.equal(0)\r\n    expect(active_qubits).to.deep.equal(new Set([4]))\r\n  });\r\n\r\n  it('should test_process_two_qubit_gate_one_qb_free_one_qb_in_segment', () => {\r\n    const qubits = [[1, 2], [2, 1]]\r\n    qubits.forEach(([qb0, qb1]) => {\r\n      // add on the right to segment\r\n      const mapper = new LinearMapper(3, false)\r\n      const segments = [[0, 1]]\r\n      const active_qubits = new Set([0, 1, 2])\r\n      const neighbour_ids = {0: new Set([1]), 1: new Set([0]), 2: new Set()}\r\n      LinearMapper._processTwoQubitGate(mapper.num_qubits,\r\n        mapper.cyclic,\r\n        qb0,\r\n        qb1,\r\n        active_qubits,\r\n        segments,\r\n        neighbour_ids)\r\n      expect(segments).to.deep.equal([[0, 1, 2]])\r\n      expect(active_qubits).to.deep.equal(new Set([0, 1, 2]))\r\n      expect(neighbour_ids[1]).to.deep.equal(new Set([0, 2]))\r\n      expect(neighbour_ids[2]).to.deep.equal(new Set([1]))\r\n    })\r\n  });\r\n\r\n  it('should test_process_two_qubit_gate_one_qb_free_one_qb_in_segment2', () => {\r\n    const qubits = [[0, 1], [1, 0]]\r\n\r\n    qubits.forEach(([qb0, qb1]) => {\r\n    // add on the left to segment\r\n      const mapper = new LinearMapper(3, false)\r\n      const segments = [[1, 2]]\r\n      const active_qubits = new Set([0, 1, 2])\r\n      const neighbour_ids = {0: new Set([]), 1: new Set([2]), 2: new Set([1])}\r\n      LinearMapper._processTwoQubitGate(mapper.num_qubits,\r\n        mapper.cyclic,\r\n        qb0,\r\n        qb1,\r\n        active_qubits,\r\n        segments,\r\n        neighbour_ids)\r\n      expect(segments).to.deep.equal([[0, 1, 2]])\r\n      expect(active_qubits).to.deep.equal(new Set([0, 1, 2]))\r\n      expect(neighbour_ids[1]).to.deep.equal(new Set([0, 2]))\r\n      expect(neighbour_ids[0]).to.deep.equal(new Set([1]))\r\n    })\r\n  });\r\n\r\n  it('should test_process_two_qubit_gate_one_qb_free_one_qb_in_segment_cycle', () => {\r\n    const qubits = [[1, 2], [2, 1]]\r\n    qubits.forEach(([qb0, qb1]) => {\r\n      const mapper = new LinearMapper(3, true)\r\n      const segments = [[0, 1]]\r\n      const active_qubits = new Set([0, 1, 2])\r\n      const neighbour_ids = {0: new Set([1]), 1: new Set([0]), 2: new Set()}\r\n      LinearMapper._processTwoQubitGate(mapper.num_qubits,\r\n        mapper.cyclic,\r\n        qb0,\r\n        qb1,\r\n        active_qubits,\r\n        segments,\r\n        neighbour_ids)\r\n      expect(segments).to.deep.equal([[0, 1, 2]])\r\n      expect(active_qubits).to.deep.equal(new Set([0, 1, 2]))\r\n      expect(neighbour_ids[1]).to.deep.equal(new Set([0, 2]))\r\n      expect(neighbour_ids[2]).to.deep.equal(new Set([1, 0]))\r\n    })\r\n  });\r\n\r\n  it('should test_process_two_qubit_gate_one_qb_free_one_qb_in_seg_cycle2', () => {\r\n    const qubits = [[1, 2], [2, 1]]\r\n    qubits.forEach(([qb0, qb1]) => {\r\n      // not yet long enough segment for cycle\r\n      const mapper = new LinearMapper(4, true)\r\n      const segments = [[0, 1]]\r\n      const active_qubits = new Set([0, 1, 2])\r\n      const neighbour_ids = {0: new Set([1]), 1: new Set([0]), 2: new Set()}\r\n      LinearMapper._processTwoQubitGate(mapper.num_qubits,\r\n        mapper.cyclic,\r\n        qb0,\r\n        qb1,\r\n        active_qubits,\r\n        segments,\r\n        neighbour_ids)\r\n      expect(segments).to.deep.equal([[0, 1, 2]])\r\n      expect(active_qubits).to.deep.equal(new Set([0, 1, 2]))\r\n      expect(neighbour_ids[1]).to.deep.equal(new Set([0, 2]))\r\n      expect(neighbour_ids[2]).to.deep.equal(new Set([1]))\r\n    })\r\n  });\r\n\r\n  it('should test_process_two_qubit_gate_one_qubit_in_middle_of_segment', () => {\r\n    const mapper = new LinearMapper(5, false)\r\n    const segments = []\r\n    const active_qubits = new Set([0, 1, 2, 3])\r\n    const neighbour_ids = {\r\n      0: new Set([1]), 1: new Set([0, 2]), 2: new Set([1]), 3: new Set()\r\n    }\r\n    LinearMapper._processTwoQubitGate(mapper.num_qubits,\r\n      mapper.cyclic,\r\n      1,\r\n      3,\r\n      active_qubits,\r\n      segments,\r\n      neighbour_ids)\r\n    expect(len(segments)).to.equal(0)\r\n    expect(active_qubits).to.deep.equal(new Set([0, 2]))\r\n  });\r\n\r\n  it('should test_process_two_qubit_gate_both_in_same_segment', () => {\r\n    const mapper = new LinearMapper(3, false)\r\n    const segments = [[0, 1, 2]]\r\n    const active_qubits = new Set([0, 1, 2])\r\n    const neighbour_ids = {0: new Set([1]), 1: new Set([0, 2]), 2: new Set([1])}\r\n    LinearMapper._processTwoQubitGate(mapper.num_qubits,\r\n      mapper.cyclic,\r\n      0,\r\n      2,\r\n      active_qubits,\r\n      segments,\r\n      neighbour_ids)\r\n    expect(segments).to.deep.equal([[0, 1, 2]])\r\n    expect(active_qubits).to.deep.equal(new Set([1]))\r\n  });\r\n\r\n  it('should test_process_two_qubit_gate_already_connected', () => {\r\n    const mapper = new LinearMapper(3, false)\r\n    const segments = [[0, 1, 2]]\r\n    const active_qubits = new Set([0, 1, 2])\r\n    const neighbour_ids = {0: new Set([1]), 1: new Set([0, 2]), 2: new Set([1])}\r\n    LinearMapper._processTwoQubitGate(mapper.num_qubits,\r\n      mapper.cyclic,\r\n      0,\r\n      1,\r\n      active_qubits,\r\n      segments,\r\n      neighbour_ids)\r\n    expect(segments).to.deep.equal([[0, 1, 2]])\r\n    expect(active_qubits).to.deep.equal(new Set([0, 1, 2]))\r\n  });\r\n\r\n  it('should test_process_two_qubit_gate_combine_segments', () => {\r\n    const data = [\r\n      [0, 2, [1, 0, 2, 3]],\r\n      [0, 3, [2, 3, 0, 1]],\r\n      [1, 2, [0, 1, 2, 3]],\r\n      [1, 3, [0, 1, 3, 2]]\r\n    ]\r\n    data.forEach(([qb0, qb1, result_seg]) => {\r\n      const mapper = new LinearMapper(4, false)\r\n      const segments = [[0, 1], [2, 3]]\r\n      const active_qubits = new Set([0, 1, 2, 3, 4])\r\n      const neighbour_ids = {\r\n        0: new Set([1]), 1: new Set([0]), 2: new Set([3]), 3: new Set([2])\r\n      }\r\n      LinearMapper._processTwoQubitGate(mapper.num_qubits,\r\n        mapper.cyclic,\r\n        qb0,\r\n        qb1,\r\n        active_qubits,\r\n        segments,\r\n        neighbour_ids)\r\n      const r = deepEqual(segments, [result_seg]) || deepEqual(segments, [result_seg.reverse()])\r\n      expect(r).to.equal(true)\r\n      expect(neighbour_ids[qb0].has(qb1)).to.equal(true)\r\n      expect(neighbour_ids[qb1].has(qb0)).to.equal(true)\r\n    })\r\n  });\r\n\r\n  it('should test_process_two_qubit_gate_combine_segments_cycle', () => {\r\n    const data = [\r\n      [0, 2, [1, 0, 2, 3]], [0, 3, [2, 3, 0, 1]],\r\n      [1, 2, [0, 1, 2, 3]], [1, 3, [0, 1, 3, 2]]\r\n    ]\r\n    data.forEach(([qb0, qb1, result_seg]) => {\r\n      const mapper = new LinearMapper(4, true)\r\n      const segments = [[0, 1], [2, 3]]\r\n      const active_qubits = new Set([0, 1, 2, 3, 4])\r\n      const neighbour_ids = {\r\n        0: new Set([1]), 1: new Set([0]), 2: new Set([3]), 3: new Set([2])\r\n      }\r\n      LinearMapper._processTwoQubitGate(mapper.num_qubits,\r\n        mapper.cyclic,\r\n        qb0,\r\n        qb1,\r\n        active_qubits,\r\n        segments,\r\n        neighbour_ids)\r\n      const r = deepEqual(segments, [result_seg]) || deepEqual(segments, [result_seg.reverse()])\r\n      expect(r).to.equal(true)\r\n      expect(neighbour_ids[qb0].has(qb1)).to.equal(true)\r\n      expect(neighbour_ids[qb1].has(qb0)).to.equal(true)\r\n      const last = result_seg[result_seg.length - 1]\r\n      expect(neighbour_ids[last].has(result_seg[0])).to.equal(true)\r\n      expect(neighbour_ids[result_seg[0]].has(last)).to.equal(true)\r\n    })\r\n  });\r\n\r\n  it('should test_process_two_qubit_gate_combine_segments_cycle2', () => {\r\n    const data = [\r\n      [0, 2, [1, 0, 2, 3]], [0, 3, [2, 3, 0, 1]],\r\n      [1, 2, [0, 1, 2, 3]],\r\n      [1, 3, [0, 1, 3, 2]]\r\n    ]\r\n    data.forEach(([qb0, qb1, result_seg]) => {\r\n      // // Not long enough segment for cyclic\r\n      const mapper = new LinearMapper(5, true)\r\n      const segments = [[0, 1], [2, 3]]\r\n      const active_qubits = new Set([0, 1, 2, 3, 4])\r\n      const neighbour_ids = {\r\n        0: new Set([1]), 1: new Set([0]), 2: new Set([3]), 3: new Set([2])\r\n      }\r\n      LinearMapper._processTwoQubitGate(mapper.num_qubits,\r\n        mapper.cyclic,\r\n        qb0,\r\n        qb1,\r\n        active_qubits,\r\n        segments,\r\n        neighbour_ids)\r\n      const r = deepEqual(segments, [result_seg]) || deepEqual(segments, [result_seg.reverse()])\r\n      expect(r).to.equal(true)\r\n      expect(neighbour_ids[qb0].has(qb1)).to.equal(true)\r\n      expect(neighbour_ids[qb1].has(qb0)).to.equal(true)\r\n      const last = result_seg[result_seg.length - 1]\r\n      expect(neighbour_ids[last].has(result_seg[0])).to.equal(false)\r\n      expect(neighbour_ids[result_seg[0]].has(last)).to.equal(false)\r\n    })\r\n  });\r\n\r\n  it('should test_return_new_mapping_from_segments', () => {\r\n    const data = [\r\n      [[[0, 2, 4]], [0, 1, 2, 3, 4], [0, 2, 4, 3, 1], [0, 1, 2, 3, 4]],\r\n      [[[0, 2, 4]], [0, 1, 2, 3, 4], [0, 2, 4, 3, null], [0, 2, 3, 4]],\r\n      [[[1, 2], [3, 0]], [0, 1, 2, 3, 4], [null, 1, 2, 3, 0], [0, 1, 2, 3]],\r\n      [[[1, 2], [3, 0]], [0, 1, 2, 3, 4], [1, 2, 3, 0, 4], [0, 1, 2, 3, 4]]\r\n    ]\r\n    data.forEach(([segments, current_chain, correct_chain, allocated_qubits]) => {\r\n      const mapper = new LinearMapper(5, false)\r\n      const currentMapping = {}\r\n      current_chain.forEach((logical_id, pos) => currentMapping[logical_id] = pos)\r\n      mapper.currentMapping = currentMapping\r\n      const new_mapping = LinearMapper._returnNewMappingFromSegments(\r\n        mapper.num_qubits,\r\n        segments,\r\n        allocated_qubits,\r\n        mapper.currentMapping\r\n      )\r\n      const correct_mapping = {}\r\n      correct_chain.forEach((logical_id, pos) => {\r\n        if (logical_id !== null) {\r\n          correct_mapping[logical_id] = pos\r\n        }\r\n      })\r\n      expect(correct_mapping).to.deep.equal(new_mapping)\r\n    })\r\n  });\r\n  it('should test_odd_even_transposition_sort_swaps', () => {\r\n    const data = [\r\n      [[0, 1, 2, 3, 4], [4, 3, 2, 1, 0]],\r\n      [[2, 0, 14, 44, 12], [14, 12, 44, 0, 2]],\r\n      [[2, null, 14, 44, 12], [14, 1, 44, 0, 2]],\r\n      [[2, null, 14, 44, 12], [14, null, 44, 0, 2]]\r\n    ]\r\n    data.forEach(([old_chain, new_chain]) => {\r\n      const mapper = new LinearMapper(5, false)\r\n      const old_map = {}\r\n      const new_map = {}\r\n      old_chain.forEach((logical_id, pos) => {\r\n        if (logical_id !== null) {\r\n          old_map[logical_id] = pos\r\n        }\r\n      })\r\n\r\n      new_chain.forEach((logical_id, pos) => {\r\n        if (logical_id !== null) {\r\n          new_map[logical_id] = pos\r\n        }\r\n      })\r\n      const swaps = mapper._oddEvenTranspositionSortSwaps(old_map, new_map)\r\n      const sorted_chain = old_chain.slice(0)\r\n      // Remove all ids which are not in new_chain by null\r\n      sorted_chain.forEach((item, i) => {\r\n        if (!new_chain.includes(item)) {\r\n          sorted_chain[i] = null\r\n        }\r\n      })\r\n      swaps.forEach(([i, j]) => {\r\n        const tmp = sorted_chain[i]\r\n        sorted_chain[i] = sorted_chain[j]\r\n        sorted_chain[j] = tmp\r\n      })\r\n\r\n      expect(len(sorted_chain)).to.equal(len(new_chain))\r\n      sorted_chain.forEach((item, i) => {\r\n        if (item !== null) {\r\n          expect(sorted_chain[i]).to.equal(new_chain[i])\r\n        }\r\n      })\r\n    })\r\n  });\r\n  it('should test_send_possible_commands_allocate', () => {\r\n    const mapper = new LinearMapper(4, false)\r\n    const backend = new DummyEngine(true)\r\n    backend.isLastEngine = true\r\n    mapper.next = backend\r\n    const qb0 = new BasicQubit(null, 0)\r\n    const cmd0 = new Command(null, Allocate, tuple([qb0]), [], [])\r\n    mapper._stored_commands = [cmd0]\r\n    mapper._currently_allocated_ids = new Set([10])\r\n    // not in mapping:\r\n    mapper.currentMapping = {}\r\n    expect(len(backend.receivedCommands)).to.equal(0)\r\n    mapper._sendPossibleCommands()\r\n    expect(len(backend.receivedCommands)).to.equal(0)\r\n    expect(mapper._stored_commands).to.deep.equal([cmd0])\r\n    // in mapping:\r\n    mapper.currentMapping = {0: 3}\r\n    mapper._sendPossibleCommands()\r\n    expect(len(mapper._stored_commands)).to.equal(0)\r\n    expect(len(backend.receivedCommands)).to.equal(1)\r\n    expect(backend.receivedCommands[0].gate.equal(Allocate)).to.equal(true)\r\n    expect(backend.receivedCommands[0].qubits[0][0].id).to.equal(3)\r\n    expect(backend.receivedCommands[0].tags).to.deep.equal([new LogicalQubitIDTag(0)])\r\n    expect(mapper._currently_allocated_ids).to.deep.equal(new Set([10, 0]))\r\n  });\r\n  it('should test_send_possible_commands_deallocate', () => {\r\n    const mapper = new LinearMapper(4, false)\r\n    const backend = new DummyEngine(true)\r\n    backend.isLastEngine = true\r\n    mapper.next = backend\r\n    const qb0 = new BasicQubit(null, 0)\r\n    const cmd0 = new Command(null, Deallocate, tuple([qb0]), [], [])\r\n    mapper._stored_commands = [cmd0]\r\n    mapper.currentMapping = {}\r\n    mapper._currently_allocated_ids = new Set([10])\r\n    // not yet allocated:\r\n    mapper._sendPossibleCommands()\r\n    expect(len(backend.receivedCommands)).to.equal(0)\r\n    expect(mapper._stored_commands).to.deep.equal([cmd0])\r\n    // allocated:\r\n    mapper.currentMapping = {0: 3}\r\n    mapper._currently_allocated_ids.add(0)\r\n    mapper._sendPossibleCommands()\r\n    expect(len(backend.receivedCommands)).to.equal(1)\r\n    expect(backend.receivedCommands[0].gate.equal(Deallocate)).to.equal(true)\r\n    expect(backend.receivedCommands[0].qubits[0][0].id).to.equal(3)\r\n    expect(backend.receivedCommands[0].tags).to.deep.equal([new LogicalQubitIDTag(0)])\r\n    expect(len(mapper._stored_commands)).to.equal(0)\r\n    expect(mapper.currentMapping).to.deep.equal({})\r\n    expect(mapper._currently_allocated_ids).to.deep.equal(new Set([10]))\r\n  });\r\n\r\n  it('should test_send_possible_commands_keep_remaining_gates', () => {\r\n    const mapper = new LinearMapper(4, false)\r\n    const backend = new DummyEngine(true)\r\n    backend.isLastEngine = true\r\n    mapper.next = backend\r\n    const qb0 = new BasicQubit(null, 0)\r\n    const qb1 = new BasicQubit(null, 1)\r\n    const cmd0 = new Command(null, Allocate, tuple([qb0]), [], [])\r\n    const cmd1 = new Command(null, Deallocate, tuple([qb0]), [], [])\r\n    const cmd2 = new Command(null, Allocate, tuple([qb1]), [], [])\r\n\r\n    mapper._stored_commands = [cmd0, cmd1, cmd2]\r\n    mapper.currentMapping = {0: 0}\r\n    mapper._sendPossibleCommands()\r\n    expect(mapper._stored_commands).to.deep.equal([cmd2])\r\n  });\r\n\r\n  it('should test_send_possible_commands_not_cyclic', () => {\r\n    const mapper = new LinearMapper(4, false)\r\n    const backend = new DummyEngine(true)\r\n    backend.isLastEngine = true\r\n    mapper.next = backend\r\n    const qb0 = new BasicQubit(null, 0)\r\n    const qb1 = new BasicQubit(null, 1)\r\n    const qb2 = new BasicQubit(null, 2)\r\n    const qb3 = new BasicQubit(null, 3)\r\n    mapper._currently_allocated_ids = new Set([0, 1, 2, 3])\r\n    const cmd0 = new Command(null, CNOT, tuple([qb0]), [qb2])\r\n    const cmd1 = new Command(null, CNOT, tuple([qb1]), [qb2])\r\n    const cmd2 = new Command(null, CNOT, tuple([qb1]), [qb3])\r\n    const cmd3 = new Command(null, X, tuple([qb0]), [])\r\n    mapper._stored_commands = [cmd0, cmd1, cmd2, cmd3]\r\n    // Following chain 0 <-> 2 <-> 3 <-> 1\r\n    mapper.currentMapping = {\r\n      0: 0, 2: 1, 3: 2, 1: 3\r\n    }\r\n    mapper._sendPossibleCommands()\r\n    expect(len(backend.receivedCommands)).to.equal(2)\r\n    expect(backend.receivedCommands[0]).to.deep.equal(new Command(null, CNOT, tuple([qb0]), [qb1]))\r\n    expect(backend.receivedCommands[1]).to.deep.equal(new Command(null, X, tuple([qb0])))\r\n    // Following chain 0 <-> 2 <-> 1 <-> 3\r\n    mapper.currentMapping = {\r\n      0: 0, 2: 1, 3: 3, 1: 2\r\n    }\r\n    mapper._sendPossibleCommands()\r\n    expect(len(backend.receivedCommands)).to.equal(4)\r\n    expect(len(mapper._stored_commands)).to.equal(0)\r\n  });\r\n\r\n  it('should test_send_possible_commands_cyclic', () => {\r\n    const mapper = new LinearMapper(4, true)\r\n    const backend = new DummyEngine(true)\r\n    backend.isLastEngine = true\r\n    mapper.next = backend\r\n    const qb0 = new BasicQubit(null, 0)\r\n    const qb1 = new BasicQubit(null, 1)\r\n    const qb2 = new BasicQubit(null, 2)\r\n    const qb3 = new BasicQubit(null, 3)\r\n    mapper._currently_allocated_ids = new Set([0, 1, 2, 3])\r\n    const cmd0 = new Command(null, CNOT, tuple([qb0]), [qb1])\r\n    const cmd1 = new Command(null, CNOT, tuple([qb1]), [qb2])\r\n    const cmd2 = new Command(null, CNOT, tuple([qb1]), [qb3])\r\n    const cmd3 = new Command(null, X, tuple([qb0]), [])\r\n    mapper._stored_commands = [cmd0, cmd1, cmd2, cmd3]\r\n    // Following chain 0 <-> 2 <-> 3 <-> 1\r\n    mapper.currentMapping = {\r\n      0: 0, 2: 1, 3: 2, 1: 3\r\n    }\r\n    mapper._sendPossibleCommands()\r\n    expect(len(backend.receivedCommands)).to.equal(2)\r\n    expect(backend.receivedCommands[0]).to.deep.equal(new Command(null, CNOT, tuple([qb0]), [qb3]))\r\n    expect(backend.receivedCommands[1]).to.deep.equal(new Command(null, X, tuple([qb0])))\r\n    // Following chain 0 <-> 2 <-> 1 <-> 3\r\n    mapper.currentMapping = {\r\n      0: 0, 2: 1, 3: 3, 1: 2\r\n    }\r\n    mapper._sendPossibleCommands()\r\n    expect(len(backend.receivedCommands)).to.equal(4)\r\n    expect(len(mapper._stored_commands)).to.equal(0)\r\n  });\r\n\r\n  it('should test_run_and_receive', () => {\r\n    const mapper = new LinearMapper(3, false)\r\n    const backend = new DummyEngine(true)\r\n    backend.isLastEngine = true\r\n    mapper.next = backend\r\n    const qb0 = new BasicQubit(null, 0)\r\n    const qb1 = new BasicQubit(null, 1)\r\n    const qb2 = new BasicQubit(null, 2)\r\n    const cmd0 = new Command(null, Allocate, tuple([qb0]))\r\n    const cmd1 = new Command(null, Allocate, tuple([qb1]))\r\n    const cmd2 = new Command(null, Allocate, tuple([qb2]))\r\n    const cmd3 = new Command(null, X, tuple([qb0]), [qb1])\r\n    const cmd4 = new Command(null, X, tuple([qb1]), [qb2])\r\n    const cmd5 = new Command(null, Deallocate, tuple([qb1]))\r\n    mapper.receive([cmd0, cmd1, cmd2, cmd3, cmd4, cmd5])\r\n    expect(mapper._stored_commands).to.deep.equal([cmd0, cmd1, cmd2, cmd3, cmd4, cmd5])\r\n    const qb3 = new BasicQubit(null, -1)\r\n    const cmd_flush = new Command(null, new FlushGate(), tuple([qb3]))\r\n    mapper.receive([cmd_flush])\r\n    expect(mapper._stored_commands).to.deep.equal([])\r\n    expect(len(backend.receivedCommands)).to.equal(7)\r\n    expect(mapper._currently_allocated_ids).to.deep.equal(new Set([0, 2]))\r\n\r\n    const f = deepEqual(mapper.currentMapping, {0: 2, 2: 0}) || deepEqual(mapper.currentMapping, {0: 0, 2: 2})\r\n    expect(f).to.equal(f)\r\n    const cmd6 = new Command(null, X, tuple([qb0]), [qb2])\r\n    mapper.storage = 1\r\n    mapper.receive([cmd6])\r\n    expect(mapper._currently_allocated_ids).to.deep.equal(new Set([0, 2]))\r\n    expect(mapper._stored_commands).to.deep.equal([])\r\n    expect(len(mapper.currentMapping)).to.equal(2)\r\n    expect(0 in mapper.currentMapping).to.equal(true)\r\n    expect(2 in mapper.currentMapping).to.equal(true)\r\n    expect(len(backend.receivedCommands)).to.equal(11)\r\n\r\n    backend.receivedCommands.forEach(cmd => console.log(cmd.toString()))\r\n\r\n    expect(backend.receivedCommands[backend.receivedCommands.length - 1]).to.deep.equal(new Command(null, X,\r\n      tuple([new BasicQubit(null, mapper.currentMapping[qb0.id])]),\r\n      [new BasicQubit(null, mapper.currentMapping[qb2.id])]))\r\n    expect(mapper.num_mappings).to.equal(1)\r\n  });\r\n\r\n  it('should test_run_infinite_loop_detection', () => {\r\n    const mapper = new LinearMapper(1, false)\r\n    const backend = new DummyEngine(true)\r\n    backend.isLastEngine = true\r\n    mapper.next = backend\r\n    const qb0 = new BasicQubit(null, 0)\r\n    const qb1 = new BasicQubit(null, 1)\r\n    const cmd0 = new Command(null, Allocate, tuple([qb0], ))\r\n    const cmd1 = new Command(null, Allocate, tuple([qb1], ))\r\n    const cmd2 = new Command(null, X, tuple([qb0]), [qb1])\r\n    const qb2 = new BasicQubit(null, -1)\r\n    const cmd_flush = new Command(null, new FlushGate(), tuple([qb2]))\r\n\r\n    expect(() => mapper.receive([cmd0, cmd1, cmd2, cmd_flush])).to.throw()\r\n  });\r\n\r\n  it('should test_logical_id_tags_allocate_and_deallocate', () => {\r\n    const mapper = new LinearMapper(4, false)\r\n    const backend = new DummyEngine(true)\r\n    backend.isLastEngine = true\r\n    mapper.next = backend\r\n    const qb0 = new BasicQubit(null, 0)\r\n    const qb1 = new BasicQubit(null, 1)\r\n    const cmd0 = new Command(null, Allocate, tuple([qb0], ))\r\n    const cmd1 = new Command(null, Allocate, tuple([qb1], ))\r\n    const cmd2 = new Command(null, X, tuple([qb0]), [qb1])\r\n    const cmd3 = new Command(null, Deallocate, tuple([qb0], ))\r\n    const cmd4 = new Command(null, Deallocate, tuple([qb1], ))\r\n    mapper.currentMapping = {0: 0, 1: 3}\r\n    const qb_flush = new BasicQubit(null, -1)\r\n    const cmd_flush = new Command(null, new FlushGate(), tuple([qb_flush], ))\r\n    mapper.receive([cmd0, cmd1, cmd2, cmd_flush])\r\n    expect(backend.receivedCommands[0].gate.equal(Allocate)).to.equal(true)\r\n    expect(backend.receivedCommands[0].qubits[0][0].id).to.equal(0)\r\n    expect(backend.receivedCommands[0].tags).to.deep.equal([new LogicalQubitIDTag(0)])\r\n    expect(backend.receivedCommands[1].gate.equal(Allocate)).to.equal(true)\r\n    expect(backend.receivedCommands[1].qubits[0][0].id).to.equal(3)\r\n    expect(backend.receivedCommands[1].tags).to.deep.equal([new LogicalQubitIDTag(1)])\r\n\r\n    backend.receivedCommands.slice(2).forEach((cmd) => {\r\n      if (cmd.gate.equal(Allocate)) {\r\n        expect(cmd.tags).to.deep.equal([])\r\n      } else if (cmd.gate.equal(Deallocate)) {\r\n        expect(cmd.tags).to.deep.equal([])\r\n      }\r\n    })\r\n\r\n    const mapped_id_for_0 = mapper.currentMapping[0]\r\n    const mapped_id_for_1 = mapper.currentMapping[1]\r\n    mapper.receive([cmd3, cmd4, cmd_flush])\r\n    const c = backend.receivedCommands.length\r\n    expect(backend.receivedCommands[c - 3].gate.equal(Deallocate)).to.equal(true)\r\n    expect(backend.receivedCommands[c - 3].qubits[0][0].id).to.equal(mapped_id_for_0)\r\n    expect(backend.receivedCommands[c - 3].tags).to.deep.equal([new LogicalQubitIDTag(0)])\r\n    expect(backend.receivedCommands[c - 2].gate.equal(Deallocate)).to.equal(true)\r\n    expect(backend.receivedCommands[c - 2].qubits[0][0].id).to.equal(mapped_id_for_1)\r\n    expect(backend.receivedCommands[c - 2].tags).to.deep.equal([new LogicalQubitIDTag(1)])\r\n  });\r\n\r\n  it('should test_send_possible_cmds_before_new_mapping', () => {\r\n    const mapper = new LinearMapper(3, false)\r\n    const backend = new DummyEngine(true)\r\n    backend.isLastEngine = true\r\n    mapper.next = backend\r\n\r\n    const dont_call_mapping = () => {\r\n      throw new Error('')\r\n    }\r\n\r\n    mapper._return_new_mapping = dont_call_mapping\r\n    mapper.currentMapping = {0: 1}\r\n    const qb0 = new BasicQubit(null, 0)\r\n    const cmd0 = new Command(null, Allocate, tuple([qb0]))\r\n    const qb2 = new BasicQubit(null, -1)\r\n    const cmd_flush = new Command(null, new FlushGate(), tuple([qb2]))\r\n    mapper.receive([cmd0, cmd_flush])\r\n  });\r\n  it('should test_correct_stats', () => {\r\n    // Should test stats for twice same mapping but depends on heuristic\r\n    const mapper = new LinearMapper(3, false)\r\n    const backend = new DummyEngine(true)\r\n    backend.isLastEngine = true\r\n    mapper.next = backend\r\n    const qb0 = new BasicQubit(null, 0)\r\n    const qb1 = new BasicQubit(null, 1)\r\n    const qb2 = new BasicQubit(null, 2)\r\n    const cmd0 = new Command(null, Allocate, tuple([qb0]))\r\n    const cmd1 = new Command(null, Allocate, tuple([qb1]))\r\n    const cmd2 = new Command(null, Allocate, tuple([qb2]))\r\n    const cmd3 = new Command(null, X, tuple([qb0]), [qb1])\r\n    const cmd4 = new Command(null, X, tuple([qb1]), [qb2])\r\n    const cmd5 = new Command(null, X, tuple([qb0]), [qb2])\r\n    const cmd6 = new Command(null, X, tuple([qb2]), [qb1])\r\n    const cmd7 = new Command(null, X, tuple([qb0]), [qb1])\r\n    const cmd8 = new Command(null, X, tuple([qb1]), [qb2])\r\n    const qb_flush = new BasicQubit(null, -1)\r\n    const cmd_flush = new Command(null, new FlushGate(), tuple([qb_flush]))\r\n    mapper.receive([cmd0, cmd1, cmd2, cmd3, cmd4, cmd5, cmd6, cmd7, cmd8, cmd_flush])\r\n    expect(mapper.num_mappings).to.equal(2)\r\n  });\r\n})\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/cengines/linearmapper.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 380,
    "kind": "file",
    "name": "src/cengines/main.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n// Contains the main engine of every compiler engine pipeline, called MainEngine.\r\nimport {BasicEngine} from './basics'\r\nimport {FlushGate} from '../ops/gates'\r\nimport BasicMapperEngine from './basicmapper'\r\nimport Command from '../ops/command'\r\nimport {BasicQubit} from '../types/qubit';\r\nimport {NotYetMeasuredError} from '../meta/error'\r\nimport {getEngineList} from '../setups'\r\nimport Simulator from '../backends/simulators/simulator'\r\n\r\n/**\r\n * @class MainEngine\r\n * @desc\r\nThe MainEngine class provides all functionality of the main compiler\r\nengine.\r\n\r\n    It initializes all further compiler engines (calls, e.g.,\r\n    .next_engine=...) and keeps track of measurement results and active\r\nqubits (and their IDs).\r\n\r\nAttributes:\r\n    next_engine (BasicEngine): Next compiler engine (or the back-end).\r\nmain_engine (MainEngine): Self.\r\nactive_qubits (WeakSet): WeakSet containing all active qubits\r\ndirty_qubits (Set): Containing all dirty qubit ids\r\nbackend (BasicEngine): Access the back-end.\r\nmapper (BasicMapperEngine): Access to the mapper if there is one.\r\n */\r\nexport default class MainEngine extends BasicEngine {\r\n  /**\r\n   * @constructor\r\n  Initialize the main compiler engine and all compiler engines.\r\n\r\n    Sets 'next_engine'- and 'main_engine'-attributes of all compiler\r\nengines and adds the back-end as the last engine.\r\n\r\n    @param {BasicEngine} backend Backend to send the compiled circuit to.\r\n    @param {Array.<BasicEngine>} engineList List of engines / backends to use\r\n            as compiler engines. Note: The engine list must not contain\r\n            multiple mappers (instances of BasicMapperEngine).\r\n            Default: getEngineList()\r\n   @param {boolean} verbose Either print full or compact error messages.\r\n    Default: false (i.e. compact error messages).\r\n\r\n    @example\r\n      const eng = new MainEngine() // uses default engine_list and the Simulator\r\n\r\nInstead of the default `engine_list` one can use, e.g., one of the IBM\r\nsetups which defines a custom `engine_list` useful for one of the IBM\r\nchips\r\n\r\n    @example\r\n      const eng = new MainEngine(new Simulator, getEngineList())\r\n      // eng uses the default Simulator backend\r\n\r\nAlternatively, one can specify all compiler engines explicitly, e.g.,\r\n\r\n    @example\r\n      const rule_set = new DecompositionRuleSet()\r\n      const engines = [new AutoReplacer(rule_set), new TagRemover(), new LocalOptimizer(3)]\r\n      const eng = new MainEngine(new Simulator(), engines)\r\n  */\r\n  constructor(backend, engineList, verbose = false) {\r\n    super()\r\n    if (!backend) {\r\n      backend = new Simulator()\r\n    } else if (!(backend instanceof BasicEngine)) {\r\n      throw new Error('\\nYou supplied a backend which is not supported,\\n'\r\n      + 'i.e. not an instance of BasicEngine.\\n'\r\n      + 'Did you forget the brackets to create an instance?\\n'\r\n      + 'E.g. MainEngine(backend=Simulator) instead of \\n'\r\n      + '     MainEngine(backend=Simulator())')\r\n    }\r\n\r\n    if (!engineList) {\r\n      engineList = getEngineList()\r\n    }\r\n\r\n    this.mapper = null\r\n    if (Array.isArray(engineList)) {\r\n      engineList.forEach((looper) => {\r\n        if (!(looper instanceof BasicEngine)) {\r\n          throw new Error('\\nYou supplied an unsupported engine in engine_list,'\r\n          + '\\ni.e. not an instance of BasicEngine.\\n'\r\n          + 'Did you forget the brackets to create an instance?\\n'\r\n          + 'E.g. MainEngine(engine_list=[AutoReplacer]) instead '\r\n          + 'of\\n     MainEngine(engine_list=[AutoReplacer()])')\r\n        }\r\n        if (looper instanceof BasicMapperEngine) {\r\n          if (!this.mapper) {\r\n            this.mapper = looper\r\n          } else {\r\n            throw new Error('More than one mapper engine is not supported.')\r\n          }\r\n        }\r\n      })\r\n    } else {\r\n      throw new Error('The provided list of engines is not a list!')\r\n    }\r\n\r\n    engineList = [...engineList, backend]\r\n\r\n    this.backend = backend\r\n\r\n    // Test that user did not supply twice the same engine instance\r\n    const num_different_engines = new Set(engineList).size\r\n    if (engineList.length !== num_different_engines) {\r\n      throw new Error('\\nError:\\n You supplied twice the same engine as backend'\r\n      + \" or item in engine_list. This doesn't work. Create two \\n\"\r\n      + ' separate instances of a compiler engine if it is needed\\n'\r\n      + ' twice.\\n')\r\n    }\r\n\r\n    this._qubitIdx = 0\r\n    for (let i = 0; i < engineList.length - 1; ++i) {\r\n      engineList[i].next = engineList[i + 1]\r\n      engineList[i].main = this\r\n    }\r\n\r\n    backend.main = this\r\n    backend.isLastEngine = true\r\n\r\n    this.next = engineList[0]\r\n    this.main = this\r\n    this.activeQubits = new Set()\r\n    this._measurements = {}\r\n    this.dirtyQubits = new Set()\r\n    this.verbose = verbose\r\n  }\r\n\r\n  /**\r\n  Register a measurement result\r\n\r\nThe engine being responsible for measurement results needs to register\r\nthese results with the master engine such that they are available when\r\nthe user calls an int() or bool() conversion operator on a measured\r\nqubit.\r\n\r\n    @param {BasicQubit} qubit Qubit for which to register the measurement result.\r\n    @param {boolean} value Boolean value of the measurement outcome (true / false = 1 / 0 respectively).\r\n   */\r\n  setMeasurementResult(qubit, value) {\r\n    this._measurements[qubit.id] = !!value\r\n  }\r\n\r\n  /**\r\n  Return the classical value of a measured qubit, given that an engine\r\nregistered this result previously (see setMeasurementResult).\r\n\r\n  @param {BasicQubit} qubit Qubit of which to get the measurement result.\r\n\r\n    @example\r\n\r\nconst eng = new MainEngine()\r\nconst qubit = eng.allocateQubit() // quantum register of size 1\r\nH.or(qubit)\r\nMeasure.or(qubit)\r\neng.getMeasurementResult(qubit[0]) == qubit.toNumber()\r\n   */\r\n  getMeasurementResult(qubit) {\r\n    const v = this._measurements[qubit.id]\r\n    if (typeof v === 'undefined') {\r\n      throw new NotYetMeasuredError(`${\"\\nError: Can't access measurement result for \"\r\n      + 'qubit #'}${qubit.id}. The problem may `\r\n      + 'be:\\n\\t1. Your '\r\n      + 'code lacks a measurement statement\\n\\t'\r\n      + '2. You have not yet called engine.flush() to '\r\n      + 'force execution of your code\\n\\t3. The '\r\n      + 'underlying backend failed to register '\r\n      + 'the measurement result\\n')\r\n    } else {\r\n      return v\r\n    }\r\n  }\r\n\r\n  /**\r\n    Returns a unique qubit id to be used for the next qubit allocation.\r\n\r\n    @return {number} New unique qubit id.\r\n  */\r\n  getNewQubitID() {\r\n    this._qubitIdx += 1\r\n    return this._qubitIdx - 1\r\n  }\r\n\r\n  /**\r\n  Forward the list of commands to the first engine.\r\n    @param {Command[]} commandList List of commands to receive (and then send on)\r\n   */\r\n  receive(commandList) {\r\n    this.send(commandList)\r\n  }\r\n\r\n  /**\r\n  Forward the list of commands to the next engine in the pipeline.\r\n    It also shortens exception stack traces if this.verbose is false.\r\n   */\r\n  send(commandList) {\r\n    try {\r\n      this.next.receive(commandList)\r\n    } catch (e) {\r\n      if (this.verbose) {\r\n        console.log(e)\r\n      }\r\n      throw e\r\n    }\r\n  }\r\n\r\n  /**\r\n    Destroy the main engine.\r\n   Flushes the entire circuit down the pipeline, clearing all temporary buffers (in, e.g., optimizers).\r\n */\r\n  deallocate() {\r\n    this.flush(true)\r\n  }\r\n\r\n  /**\r\n    Flush the entire circuit down the pipeline, clearing potential buffers (of, e.g., optimizers).\r\n\r\n    @param {boolean} deallocateQubits If true, deallocates all qubits that are\r\n    still alive (invalidating references to them by setting their id to -1).\r\n  */\r\n  flush(deallocateQubits = false) {\r\n    if (deallocateQubits) {\r\n      this.activeQubits.forEach(qb => qb.deallocate())\r\n      this.activeQubits = new Set()\r\n    }\r\n\r\n    this.receive([new Command(this, new FlushGate(), [[new BasicQubit(this, -1)]])])\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/cengines/main.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 381,
    "kind": "class",
    "name": "MainEngine",
    "memberof": "src/cengines/main.js",
    "static": true,
    "longname": "src/cengines/main.js~MainEngine",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/cengines/main.js",
    "importStyle": "MainEngine",
    "description": "The MainEngine class provides all functionality of the main compiler\nengine.\n\nIt initializes all further compiler engines (calls, e.g.,\n.next_engine=...) and keeps track of measurement results and active\nqubits (and their IDs).\n\nAttributes:\nnext_engine (BasicEngine): Next compiler engine (or the back-end).\nmain_engine (MainEngine): Self.\nactive_qubits (WeakSet): WeakSet containing all active qubits\ndirty_qubits (Set): Containing all dirty qubit ids\nbackend (BasicEngine): Access the back-end.\nmapper (BasicMapperEngine): Access to the mapper if there is one.",
    "lineNumber": 45,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "MainEngine"
      }
    ],
    "interface": false,
    "extends": [
      "src/cengines/basics.js~BasicEngine"
    ]
  },
  {
    "__docId__": 382,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/cengines/main.js~MainEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/main.js~MainEngine#constructor",
    "access": "public",
    "description": "",
    "examples": [
      "const eng = new MainEngine() // uses default engine_list and the Simulator\n\nInstead of the default `engine_list` one can use, e.g., one of the IBM\nsetups which defines a custom `engine_list` useful for one of the IBM\nchips",
      "const eng = new MainEngine(new Simulator, getEngineList())\n// eng uses the default Simulator backend\n\nAlternatively, one can specify all compiler engines explicitly, e.g.,",
      "const rule_set = new DecompositionRuleSet()\nconst engines = [new AutoReplacer(rule_set), new TagRemover(), new LocalOptimizer(3)]\nconst eng = new MainEngine(new Simulator(), engines)"
    ],
    "lineNumber": 79,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": "Initialize the main compiler engine and all compiler engines.\n\nSets 'next_engine'- and 'main_engine'-attributes of all compiler\nengines and adds the back-end as the last engine."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "BasicEngine"
        ],
        "spread": false,
        "optional": false,
        "name": "backend",
        "description": "Backend to send the compiled circuit to."
      },
      {
        "nullable": null,
        "types": [
          "Array.<BasicEngine>"
        ],
        "spread": false,
        "optional": false,
        "name": "engineList",
        "description": "List of engines / backends to use\nas compiler engines. Note: The engine list must not contain\nmultiple mappers (instances of BasicMapperEngine).\nDefault: getEngineList()"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "verbose",
        "description": "Either print full or compact error messages.\nDefault: false (i.e. compact error messages)."
      }
    ]
  },
  {
    "__docId__": 383,
    "kind": "member",
    "name": "mapper",
    "memberof": "src/cengines/main.js~MainEngine",
    "static": false,
    "longname": "src/cengines/main.js~MainEngine#mapper",
    "access": "public",
    "description": null,
    "lineNumber": 95,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 385,
    "kind": "member",
    "name": "backend",
    "memberof": "src/cengines/main.js~MainEngine",
    "static": false,
    "longname": "src/cengines/main.js~MainEngine#backend",
    "access": "public",
    "description": null,
    "lineNumber": 119,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 386,
    "kind": "member",
    "name": "_qubitIdx",
    "memberof": "src/cengines/main.js~MainEngine",
    "static": false,
    "longname": "src/cengines/main.js~MainEngine#_qubitIdx",
    "access": "private",
    "description": null,
    "lineNumber": 130,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 387,
    "kind": "member",
    "name": "next",
    "memberof": "src/cengines/main.js~MainEngine",
    "static": false,
    "longname": "src/cengines/main.js~MainEngine#next",
    "access": "public",
    "description": null,
    "lineNumber": 139,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 388,
    "kind": "member",
    "name": "main",
    "memberof": "src/cengines/main.js~MainEngine",
    "static": false,
    "longname": "src/cengines/main.js~MainEngine#main",
    "access": "public",
    "description": null,
    "lineNumber": 140,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 389,
    "kind": "member",
    "name": "activeQubits",
    "memberof": "src/cengines/main.js~MainEngine",
    "static": false,
    "longname": "src/cengines/main.js~MainEngine#activeQubits",
    "access": "public",
    "description": null,
    "lineNumber": 141,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 390,
    "kind": "member",
    "name": "_measurements",
    "memberof": "src/cengines/main.js~MainEngine",
    "static": false,
    "longname": "src/cengines/main.js~MainEngine#_measurements",
    "access": "private",
    "description": null,
    "lineNumber": 142,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 391,
    "kind": "member",
    "name": "dirtyQubits",
    "memberof": "src/cengines/main.js~MainEngine",
    "static": false,
    "longname": "src/cengines/main.js~MainEngine#dirtyQubits",
    "access": "public",
    "description": null,
    "lineNumber": 143,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 392,
    "kind": "member",
    "name": "verbose",
    "memberof": "src/cengines/main.js~MainEngine",
    "static": false,
    "longname": "src/cengines/main.js~MainEngine#verbose",
    "access": "public",
    "description": null,
    "lineNumber": 144,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 393,
    "kind": "method",
    "name": "setMeasurementResult",
    "memberof": "src/cengines/main.js~MainEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/main.js~MainEngine#setMeasurementResult",
    "access": "public",
    "description": "Register a measurement result\n\nThe engine being responsible for measurement results needs to register\nthese results with the master engine such that they are available when\nthe user calls an int() or bool() conversion operator on a measured\nqubit.",
    "lineNumber": 158,
    "params": [
      {
        "nullable": null,
        "types": [
          "BasicQubit"
        ],
        "spread": false,
        "optional": false,
        "name": "qubit",
        "description": "Qubit for which to register the measurement result."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "Boolean value of the measurement outcome (true / false = 1 / 0 respectively)."
      }
    ],
    "return": null
  },
  {
    "__docId__": 394,
    "kind": "method",
    "name": "getMeasurementResult",
    "memberof": "src/cengines/main.js~MainEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/main.js~MainEngine#getMeasurementResult",
    "access": "public",
    "description": "Return the classical value of a measured qubit, given that an engine\nregistered this result previously (see setMeasurementResult).",
    "examples": [
      "\nconst eng = new MainEngine()\nconst qubit = eng.allocateQubit() // quantum register of size 1\nH.or(qubit)\nMeasure.or(qubit)\neng.getMeasurementResult(qubit[0]) == qubit.toNumber()"
    ],
    "lineNumber": 176,
    "params": [
      {
        "nullable": null,
        "types": [
          "BasicQubit"
        ],
        "spread": false,
        "optional": false,
        "name": "qubit",
        "description": "Qubit of which to get the measurement result."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 395,
    "kind": "method",
    "name": "getNewQubitID",
    "memberof": "src/cengines/main.js~MainEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/main.js~MainEngine#getNewQubitID",
    "access": "public",
    "description": "Returns a unique qubit id to be used for the next qubit allocation.",
    "lineNumber": 197,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "New unique qubit id."
    },
    "params": []
  },
  {
    "__docId__": 397,
    "kind": "method",
    "name": "receive",
    "memberof": "src/cengines/main.js~MainEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/main.js~MainEngine#receive",
    "access": "public",
    "description": "Forward the list of commands to the first engine.",
    "lineNumber": 206,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command[]"
        ],
        "spread": false,
        "optional": false,
        "name": "commandList",
        "description": "List of commands to receive (and then send on)"
      }
    ],
    "return": null
  },
  {
    "__docId__": 398,
    "kind": "method",
    "name": "send",
    "memberof": "src/cengines/main.js~MainEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/main.js~MainEngine#send",
    "access": "public",
    "description": "Forward the list of commands to the next engine in the pipeline.\nIt also shortens exception stack traces if this.verbose is false.",
    "lineNumber": 214,
    "params": [
      {
        "name": "commandList",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 399,
    "kind": "method",
    "name": "deallocate",
    "memberof": "src/cengines/main.js~MainEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/main.js~MainEngine#deallocate",
    "access": "public",
    "description": "Destroy the main engine.\nFlushes the entire circuit down the pipeline, clearing all temporary buffers (in, e.g., optimizers).",
    "lineNumber": 229,
    "params": [],
    "return": null
  },
  {
    "__docId__": 400,
    "kind": "method",
    "name": "flush",
    "memberof": "src/cengines/main.js~MainEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/main.js~MainEngine#flush",
    "access": "public",
    "description": "Flush the entire circuit down the pipeline, clearing potential buffers (of, e.g., optimizers).",
    "lineNumber": 239,
    "params": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "deallocateQubits",
        "description": "If true, deallocates all qubits that are\nstill alive (invalidating references to them by setting their id to -1)."
      }
    ],
    "return": null
  },
  {
    "__docId__": 402,
    "kind": "file",
    "name": "src/cengines/main.spec.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport {expect} from 'chai'\r\nimport MainEngine from './main'\r\nimport {DummyEngine} from './testengine'\r\nimport {\r\n  H, AllocateQubitGate, FlushGate, DeallocateQubitGate\r\n} from '../ops/gates'\r\nimport BasicMapperEngine from './basicmapper'\r\nimport Simulator from \"../backends/simulators/simulator\";\r\nimport {getEngineList} from \"../setups\";\r\nimport LocalOptimizer from \"./optimize\";\r\n\r\ndescribe('main engine test', () => {\r\n  it('should test_main_engine_init', () => {\r\n    const ceng1 = new DummyEngine()\r\n    const ceng2 = new DummyEngine()\r\n    const test_backend = new DummyEngine()\r\n    const engine_list = [ceng1, ceng2]\r\n    const eng = new MainEngine(test_backend, engine_list)\r\n\r\n    expect(eng.next === ceng1).to.equal(true)\r\n    expect(eng.main === eng).to.equal(true)\r\n    expect(eng.isLastEngine).to.equal(false)\r\n\r\n    expect(ceng1.next === ceng2).to.equal(true)\r\n    expect(ceng1.main === eng).to.equal(true)\r\n    expect(ceng1.isLastEngine).to.equal(false)\r\n\r\n    expect(ceng2.next === test_backend).to.equal(true)\r\n    expect(ceng2.main === eng).to.equal(true)\r\n    expect(ceng2.isLastEngine).to.equal(false)\r\n\r\n    expect(test_backend.isLastEngine).to.equal(true)\r\n    expect(test_backend.main === eng).to.equal(true)\r\n    expect(!!test_backend.next).to.equal(false)\r\n\r\n    expect(engine_list.length).to.equal(2)\r\n\r\n  });\r\n\r\n  it('should test_main_engine_init_failure', () => {\r\n    expect(() => {\r\n      const eng = new MainEngine(DummyEngine)\r\n    }).to.throw()\r\n    expect(() => {\r\n      const eng = new MainEngine(null, DummyEngine)\r\n    }).to.throw()\r\n    expect(() => {\r\n      const eng = new MainEngine(null, [new DummyEngine(), DummyEngine])\r\n    }).to.throw()\r\n    expect(() => {\r\n      const engine = new DummyEngine()\r\n      const eng = new MainEngine(engine, [engine])\r\n    }).to.throw()\r\n  });\r\n\r\n  it('should test_main_engine_init_defaults', () => {\r\n    const eng = new MainEngine()\r\n    const eng_list = []\r\n    let current_engine = eng.next\r\n    while (!current_engine.isLastEngine) {\r\n      eng_list.push(current_engine)\r\n      current_engine = current_engine.next\r\n    }\r\n    expect(eng_list[eng_list.length - 1].next instanceof Simulator).to.equal(true)\r\n    const default_engines = getEngineList()\r\n    default_engines.forEach((looper, i) => {\r\n      expect(looper.constructor === eng_list[i].constructor).to.equal(true)\r\n    })\r\n  });\r\n\r\n  it('should test_main_engine_init_mapper', () => {\r\n    class LinearMapper extends BasicMapperEngine {\r\n\r\n    }\r\n\r\n    const mapper1 = new LinearMapper()\r\n    const mapper2 = new BasicMapperEngine()\r\n    const engine_list1 = [mapper1]\r\n    const eng1 = new MainEngine(null, engine_list1)\r\n\r\n    expect(eng1.mapper === mapper1).to.equal(true)\r\n    const engine_list2 = [mapper2]\r\n    const eng2 = new MainEngine(null, engine_list2)\r\n    expect(eng2.mapper === mapper2).to.equal(true)\r\n\r\n    const engine_list3 = [mapper1, mapper2]\r\n    expect(() => new MainEngine(null, engine_list3)).to.throw()\r\n  });\r\n\r\n  it('should test_main_engine_del', () => {\r\n    // Clear previous exceptions of other tests\r\n\r\n    // need engine which caches commands to test that del calls flush\r\n    const caching_engine = new LocalOptimizer(5)\r\n    const backend = new DummyEngine(true)\r\n    const eng = new MainEngine(backend, [caching_engine])\r\n    const qubit = eng.allocateQubit()\r\n    H.or(qubit)\r\n    expect(backend.receivedCommands.length).to.equal(0)\r\n\r\n    eng.deallocate()\r\n    // Allocate, H, Deallocate, and Flush Gate\r\n    expect(backend.receivedCommands.length).to.equal(4)\r\n  });\r\n\r\n  it('should test_main_engine_set_and_getMeasurementResult', () => {\r\n    const eng = new MainEngine(new DummyEngine(), [])\r\n    const qubit0 = eng.allocateQubit()\r\n    const qubit1 = eng.allocateQubit()\r\n\r\n    expect(() => qubit0.toNumber()).to.throw()\r\n\r\n    eng.setMeasurementResult(qubit0[0], true)\r\n    eng.setMeasurementResult(qubit1[0], false)\r\n\r\n    expect(qubit0.toNumber()).to.equal(1)\r\n    expect(qubit1.toNumber()).to.equal(0)\r\n  });\r\n\r\n  it('should test_main_engine_get_qubit_id', () => {\r\n    // Test that ids are not identical\r\n    const eng = new MainEngine(new DummyEngine(), [])\r\n    const ids = []\r\n    const total = 10\r\n    for (let i = 0; i < total; ++i) {\r\n      ids.push(eng.getNewQubitID())\r\n    }\r\n    expect(new Set(ids).size).to.equal(total)\r\n  });\r\n  it('should test_main_engine_flush', () => {\r\n    const backend = new DummyEngine(true)\r\n    const eng = new MainEngine(backend, [new DummyEngine()])\r\n    const qubit = eng.allocateQubit()\r\n    H.or(qubit)\r\n    eng.flush()\r\n\r\n    expect(backend.receivedCommands.length).to.equal(3)\r\n    expect(backend.receivedCommands[0].gate.equal(new AllocateQubitGate())).to.equal(true)\r\n    expect(backend.receivedCommands[1].gate.equal(H)).to.equal(true)\r\n    expect(backend.receivedCommands[2].gate.equal(new FlushGate())).to.equal(true)\r\n\r\n    eng.flush(true)\r\n\r\n    expect(backend.receivedCommands.length).to.equal(5)\r\n    expect(backend.receivedCommands[3].gate.equal(new DeallocateQubitGate())).to.equal(true)\r\n\r\n    // keep the qubit alive until at least here\r\n    expect(qubit.toString().length).not.to.equal(0)\r\n  });\r\n  // TODO\r\n  // it('should test_main_engine_atexit_with_error', () => {\r\n  //   // sys.last_type = \"Something\"\r\n  //   const backend = new DummyEngine(true)\r\n  //   const eng = new MainEngine(backend, [])\r\n  //   const qb = eng.allocateQubit()\r\n  //   // eng._delfun(weakref.ref(eng))\r\n  //   // assert len(backend.received_commands) == 1\r\n  //   // assert backend.received_commands[0].gate == AllocateQubitGate()\r\n  //   //\r\n  // });\r\n  it('should test_exceptions_are_forwarded', () => {\r\n    class ErrorEngine extends DummyEngine {\r\n      receive() {\r\n        throw new Error('TypeError')\r\n      }\r\n    }\r\n    const eng = new MainEngine(new ErrorEngine(), [])\r\n    expect(() => eng.allocateQubit()).to.throw()\r\n\r\n    const eng2 = new MainEngine(new ErrorEngine(), [], true)\r\n    expect(() => eng2.allocateQubit()).to.throw()\r\n  });\r\n})\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/cengines/main.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 403,
    "kind": "file",
    "name": "src/cengines/manualmapper.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport BasicMapperEngine from './basicmapper'\r\n\r\n/**\r\n * @class ManualMapper\r\n * @desc\r\nManual Mapper which adds QubitPlacementTags to Allocate gate commands\r\naccording to a user-specified mapping.\r\n    @property {function} map The function which maps a given qubit id to its\r\n    location. It gets set when initializing the mapper.\r\n */\r\nexport default class ManualMapper extends BasicMapperEngine {\r\n  /**\r\n   * @constructor\r\n    Initialize the mapper to a given mapping. If no mapping function is\r\nprovided, the qubit id is used as the location.\r\n\r\n    @param {function} mapFunc Function which, given the qubit id, returns\r\nan integer describing the physical location (must be constant).\r\n     */\r\n  constructor(mapFunc = x => x) {\r\n    super()\r\n    this.map = mapFunc\r\n    this.currentMapping = {}\r\n  }\r\n\r\n  /**\r\n    Receives a command list and passes it to the next engine, adding\r\n    qubit placement tags to allocate gates.\r\n\r\n    @param {Command[]} command_list list of commands to receive.\r\n  */\r\n  receive(command_list) {\r\n    command_list.forEach((cmd) => {\r\n      const ids = []\r\n      cmd.qubits.forEach((qr) => {\r\n        qr.forEach(qb => ids.push(qb.id))\r\n      })\r\n      ids.forEach((id) => {\r\n        const v = this._currentMapping[id]\r\n        if (typeof v === 'undefined') {\r\n          this._currentMapping[id] = this.map(id)\r\n        }\r\n      })\r\n      this.sendCMDWithMappedIDs(cmd)\r\n    })\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/cengines/manualmapper.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 404,
    "kind": "class",
    "name": "ManualMapper",
    "memberof": "src/cengines/manualmapper.js",
    "static": true,
    "longname": "src/cengines/manualmapper.js~ManualMapper",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/cengines/manualmapper.js",
    "importStyle": "ManualMapper",
    "description": "Manual Mapper which adds QubitPlacementTags to Allocate gate commands\naccording to a user-specified mapping.",
    "lineNumber": 27,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "ManualMapper"
      }
    ],
    "properties": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "map",
        "description": "The function which maps a given qubit id to its\nlocation. It gets set when initializing the mapper."
      }
    ],
    "interface": false,
    "extends": [
      "src/cengines/basicmapper.js~BasicMapperEngine"
    ]
  },
  {
    "__docId__": 405,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/cengines/manualmapper.js~ManualMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/manualmapper.js~ManualMapper#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 36,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": "Initialize the mapper to a given mapping. If no mapping function is\nprovided, the qubit id is used as the location."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "mapFunc",
        "description": "Function which, given the qubit id, returns\nan integer describing the physical location (must be constant)."
      }
    ]
  },
  {
    "__docId__": 406,
    "kind": "member",
    "name": "map",
    "memberof": "src/cengines/manualmapper.js~ManualMapper",
    "static": false,
    "longname": "src/cengines/manualmapper.js~ManualMapper#map",
    "access": "public",
    "description": null,
    "lineNumber": 38,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 407,
    "kind": "member",
    "name": "currentMapping",
    "memberof": "src/cengines/manualmapper.js~ManualMapper",
    "static": false,
    "longname": "src/cengines/manualmapper.js~ManualMapper#currentMapping",
    "access": "public",
    "description": null,
    "lineNumber": 39,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 408,
    "kind": "method",
    "name": "receive",
    "memberof": "src/cengines/manualmapper.js~ManualMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/manualmapper.js~ManualMapper#receive",
    "access": "public",
    "description": "Receives a command list and passes it to the next engine, adding\nqubit placement tags to allocate gates.",
    "lineNumber": 48,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command[]"
        ],
        "spread": false,
        "optional": false,
        "name": "command_list",
        "description": "list of commands to receive."
      }
    ],
    "return": null
  },
  {
    "__docId__": 409,
    "kind": "file",
    "name": "src/cengines/manualmapper.spec.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport {expect} from 'chai'\r\nimport {tuple} from '../libs/util';\r\nimport {Measure, H} from '../ops/gates'\r\nimport {All} from '../ops/metagates'\r\nimport {LogicalQubitIDTag} from '../meta/tag'\r\nimport {DummyEngine} from './testengine'\r\nimport MainEngine from './main'\r\nimport ManualMapper from './manualmapper'\r\n\r\ndescribe('manual mapper test', () => {\r\n  it('should test manual mapper', () => {\r\n    const backend = new DummyEngine(true)\r\n\r\n    const mapping = qubit_id => (qubit_id + 1) & 1\r\n    const eng = new MainEngine(backend, [new ManualMapper(mapping)])\r\n    const qb0 = eng.allocateQubit()\r\n    const qb1 = eng.allocateQubit()\r\n    H.or(qb0)\r\n    H.or(qb1)\r\n    new All(Measure).or(tuple(qb0.concat(qb1)))\r\n    eng.flush()\r\n\r\n    let num_measurements = 0\r\n    backend.receivedCommands.forEach((cmd) => {\r\n      if (cmd.gate.equal(Measure)) {\r\n        const tag = new LogicalQubitIDTag(mapping(cmd.qubits[0][0].id))\r\n        expect(tag.isInArray(cmd.tags)).to.equal(true)\r\n        const wrongTag = new LogicalQubitIDTag(cmd.qubits[0][0].id)\r\n        expect(wrongTag.isInArray(cmd.tags)).to.equal(false)\r\n        num_measurements += 1\r\n      }\r\n    })\r\n    expect(num_measurements).to.equal(2)\r\n  });\r\n})\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/cengines/manualmapper.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 410,
    "kind": "file",
    "name": "src/cengines/optimize.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport assert from 'assert'\r\nimport {BasicEngine} from './basics'\r\nimport {FastForwardingGate} from '../ops/basics';\r\nimport {FlushGate} from '../ops/gates'\r\nimport {instanceOf} from '../libs/util'\r\nimport {NotMergeable} from '../meta/error';\r\n\r\n\r\n/**\r\n * @class LocalOptimizer\r\n * @desc is a compiler engine which optimizes locally (merging\r\nrotations, cancelling gates with their inverse) in a local window of user-\r\ndefined size.\r\n\r\n    It stores all commands in a dict of lists, where each qubit has its own\r\ngate pipeline. After adding a gate, it tries to merge / cancel successive\r\ngates using the get_merged and getInverse functions of the gate (if\r\n    available). For examples, see BasicRotationGate. Once a list corresponding\r\nto a qubit contains >=m gates, the pipeline is sent on to the next engine.\r\n */\r\nexport default class LocalOptimizer extends BasicEngine {\r\n  /**\r\n   * @constructor\r\n   * @param {number} m Number of gates to cache per qubit, before sending on the first gate.\r\n   */\r\n  constructor(m = 5) {\r\n    super()\r\n    this._l = {} // dict of lists containing operations for each qubit\r\n    this._m = m // wait for m gates before sending on\r\n  }\r\n\r\n  /**\r\n   * Send n gate operations of the qubit with index idx to the next engine.\r\n   * @param {number} idx qubit index\r\n   * @param {number} n command position in qubit idx's command list\r\n   */\r\n  sendQubitPipeline(idx, n) {\r\n    if (typeof idx !== 'number') {\r\n      idx = parseInt(idx, 10)\r\n    }\r\n    // temporary label for readability\r\n    const il = this._l[idx]\r\n    const count = Math.min(n, il.length)\r\n\r\n    // loop over first n operations\r\n    // send all gates before n-qubit gate for other qubits involved\r\n    // --> recursively call send_helper\r\n    for (let i = 0; i < count; ++i) {\r\n      const other_involved_qubits = []\r\n      il[i].allQubits.forEach(qreg => qreg.forEach((qb) => {\r\n        if (qb.id !== idx) {\r\n          other_involved_qubits.push(qb)\r\n        }\r\n      }))\r\n\r\n      other_involved_qubits.forEach((qb) => {\r\n        const idLooper = qb.id\r\n        try {\r\n          let gateloc = 0\r\n          // find location of this gate within its list\r\n          while (!this._l[idLooper][gateloc].equal(il[i])) {\r\n            gateloc += 1\r\n          }\r\n\r\n          gateloc = this.optimize(idLooper, gateloc)\r\n          // flush the gates before the n-qubit gate\r\n          this.sendQubitPipeline(idLooper, gateloc)\r\n          // delete the n-qubit gate, we're taking care of it\r\n          // and don't want the other qubit to do so\r\n          this._l[idLooper] = this._l[idLooper].slice(1)\r\n        } catch (e) {\r\n          console.log(e)\r\n          console.log('Invalid qubit pipeline encountered (in the  process of shutting down?).')\r\n        }\r\n      })\r\n      // all qubits that need to be flushed have been flushed\r\n      // --> send on the n-qubit gate\r\n      this.send([il[i]])\r\n    }\r\n    // n operations have been sent on --> resize our gate list\r\n    this._l[idx] = this._l[idx].slice(n)\r\n  }\r\n\r\n  /**\r\n    Return all indices of a command, each index corresponding to the\r\n    command's index in one of the qubits' command lists.\r\n\r\n    @param {number} idx qubit index\r\n    @param {number} i command position in qubit idx's command list\r\n    @param {number[]} IDs IDs of all qubits involved in the command\r\n    @return {number[]}\r\n  */\r\n  getGateIndices(idx, i, IDs) {\r\n    if (typeof idx !== 'number') {\r\n      idx = parseInt(idx, 10)\r\n    }\r\n    const N = IDs.length\r\n    // 1-qubit gate: only gate at index i in list #idx is involved\r\n    if (N === 1) {\r\n      return [i]\r\n    }\r\n\r\n    // When the same gate appears multiple time, we need to make sure not to\r\n    // match earlier instances of the gate applied to the same qubits. So we\r\n    // count how many there are, and skip over them when looking in the\r\n    // other lists.\r\n    const cmd = this._l[idx][i]\r\n    let num_identical_to_skip = 0\r\n    this._l[idx].slice(0, i).forEach((prev_cmd) => {\r\n      if (prev_cmd.equal(cmd)) {\r\n        num_identical_to_skip += 1\r\n      }\r\n    })\r\n\r\n    const indices = []\r\n    IDs.forEach((Id) => {\r\n      const identical_indices = []\r\n      this._l[Id].forEach((c, j) => {\r\n        if (c.equal(cmd)) {\r\n          identical_indices.push(j)\r\n        }\r\n      })\r\n      indices.push(identical_indices[num_identical_to_skip])\r\n    })\r\n    return indices\r\n  }\r\n\r\n  /**\r\n  Try to merge or even cancel successive gates using the get_merged and\r\ngetInverse functions of the gate (see, e.g., BasicRotationGate).\r\n\r\n    It does so for all qubit command lists.\r\n   @param {number} idx\r\n   @param {number} lim\r\n   */\r\n  optimize(idx, lim) {\r\n    if (typeof idx !== 'number') {\r\n      idx = parseInt(idx, 10)\r\n    }\r\n    // loop over all qubit indices\r\n    let i = 0\r\n    let new_gateloc = 0\r\n    let limit = this._l[idx].length\r\n    if (typeof lim !== 'undefined') {\r\n      limit = lim\r\n      new_gateloc = limit\r\n    }\r\n\r\n    while (i < limit - 1) {\r\n    // can be dropped if two in a row are self-inverses\r\n      const cmd = this._l[idx][i]\r\n      const inv = cmd.getInverse()\r\n\r\n      if (inv.equal(this._l[idx][i + 1])) {\r\n      // determine index of this gate on all qubits\r\n        const qubitids = []\r\n        cmd.allQubits.forEach(sublist => sublist.forEach(qb => qubitids.push(qb.id)))\r\n        const gid = this.getGateIndices(idx, i, qubitids)\r\n        // check that there are no other gates between this and its\r\n        // inverse on any of the other qubits involved\r\n        let erase = true\r\n        qubitids.forEach((looper, j) => {\r\n          erase = inv.equal(this._l[looper][gid[j] + 1])\r\n        })\r\n\r\n        // drop these two gates if possible and goto next iteration\r\n        if (erase) {\r\n          let new_list = []\r\n          qubitids.forEach((looper, j) => {\r\n            new_list = this._l[looper].slice(0, gid[j]).concat(this._l[looper].slice(gid[j] + 2))\r\n            this._l[looper] = new_list\r\n          })\r\n          i = 0\r\n          limit -= 2\r\n          continue\r\n        }\r\n      }\r\n      // gates are not each other's inverses --> check if they're\r\n      // mergeable\r\n      try {\r\n        const merged_command = this._l[idx][i].getMerged(this._l[idx][i + 1])\r\n        // determine index of this gate on all qubits\r\n        const qubitids = []\r\n        const c = this._l[idx][i]\r\n        c.allQubits.forEach(sublist => sublist.forEach(qb => qubitids.push(qb.id)))\r\n\r\n        const gid = this.getGateIndices(idx, i, qubitids)\r\n\r\n        let merge = true\r\n        qubitids.forEach((looper, j) => {\r\n          const m = this._l[looper][gid[j]].getMerged(this._l[looper][gid[j] + 1])\r\n          merge = m.equal(merged_command)\r\n        })\r\n        if (merge) {\r\n          qubitids.forEach((looper, j) => {\r\n            this._l[looper][gid[j]] = merged_command\r\n            const new_list = this._l[looper].slice(0, gid[j] + 1).concat(this._l[looper].slice(gid[j] + 2))\r\n            this._l[looper] = new_list\r\n          })\r\n          i = 0\r\n          limit -= 1\r\n          continue\r\n        }\r\n      } catch (e) {\r\n        if (!(e instanceof NotMergeable)) {\r\n          throw e\r\n        }\r\n      }\r\n      i += 1 // next iteration: look at next gate\r\n    }\r\n    return limit\r\n  }\r\n\r\n\r\n  /**\r\n  Check whether a qubit pipeline must be sent on and, if so,\r\n    optimize the pipeline and then send it on.\r\n   */\r\n  checkAndSend() {\r\n    Object.keys(this._l).forEach((i) => {\r\n      let v = this._l[i]\r\n      let lastCMD = v.length > 0 ? v[v.length - 1] : {}\r\n      let gateFlag = instanceOf(lastCMD.gate, FastForwardingGate)\r\n      if (v.length >= this._m || (v.length > 0 && gateFlag)) {\r\n        this.optimize(i)\r\n        v = this._l[i]\r\n        lastCMD = v.length > 0 ? v[v.length - 1] : {}\r\n        gateFlag = instanceOf(lastCMD.gate, FastForwardingGate)\r\n\r\n        if (v.length >= this._m && !gateFlag) {\r\n          this.sendQubitPipeline(i, v.length - this._m + 1)\r\n        } else if (v.length > 0 && gateFlag) {\r\n          this.sendQubitPipeline(i, v.length)\r\n        }\r\n      }\r\n    })\r\n    const newDict = {}\r\n    Object.keys(this._l).forEach((key) => {\r\n      const v = this._l[key]\r\n      if (v.length > 0) {\r\n        newDict[key] = v\r\n      }\r\n    })\r\n\r\n    this._l = newDict\r\n  }\r\n\r\n  /**\r\n    Cache a command, i.e., inserts it into the command lists of all qubits involved.\r\n    @param {Command} cmd\r\n  */\r\n  cacheCMD(cmd) {\r\n    // are there qubit ids that haven't been added to the list?\r\n    const ids = []\r\n    cmd.allQubits.forEach(sublist => sublist.forEach(qubit => ids.push(qubit.id)))\r\n\r\n    // add gate command to each of the qubits involved\r\n    ids.forEach((ID) => {\r\n      const v = this._l[ID]\r\n      if (typeof v === 'undefined') {\r\n        this._l[ID] = []\r\n      }\r\n      this._l[ID].push(cmd)\r\n    })\r\n    this.checkAndSend()\r\n  }\r\n\r\n  /**\r\n    Receive commands from the previous engine and cache them.\r\n    If a flush gate arrives, the entire buffer is sent on.\r\n  */\r\n  receive(commandList) {\r\n    commandList.forEach((cmd) => {\r\n      if (instanceOf(cmd.gate, FlushGate)) {\r\n        Object.keys(this._l).forEach((idx) => {\r\n          const v = this._l[idx]\r\n          this.optimize(idx)\r\n          this.sendQubitPipeline(idx, v.length)\r\n        })\r\n\r\n        const newDict = {}\r\n        Object.keys(this._l).forEach((idx) => {\r\n          const v = this._l[idx]\r\n          if (v.length > 0) {\r\n            newDict[idx] = v\r\n          }\r\n        })\r\n        this._l = newDict\r\n        assert(Object.keys(this._l).length === 0)\r\n        this.send([cmd])\r\n      } else {\r\n        this.cacheCMD(cmd)\r\n      }\r\n    })\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/cengines/optimize.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 411,
    "kind": "class",
    "name": "LocalOptimizer",
    "memberof": "src/cengines/optimize.js",
    "static": true,
    "longname": "src/cengines/optimize.js~LocalOptimizer",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/cengines/optimize.js",
    "importStyle": "LocalOptimizer",
    "description": "is a compiler engine which optimizes locally (merging\nrotations, cancelling gates with their inverse) in a local window of user-\ndefined size.\n\nIt stores all commands in a dict of lists, where each qubit has its own\ngate pipeline. After adding a gate, it tries to merge / cancel successive\ngates using the get_merged and getInverse functions of the gate (if\navailable). For examples, see BasicRotationGate. Once a list corresponding\nto a qubit contains >=m gates, the pipeline is sent on to the next engine.",
    "lineNumber": 37,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "LocalOptimizer"
      }
    ],
    "interface": false,
    "extends": [
      "src/cengines/basics.js~BasicEngine"
    ]
  },
  {
    "__docId__": 412,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/cengines/optimize.js~LocalOptimizer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/optimize.js~LocalOptimizer#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 42,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "m",
        "description": "Number of gates to cache per qubit, before sending on the first gate."
      }
    ]
  },
  {
    "__docId__": 413,
    "kind": "member",
    "name": "_l",
    "memberof": "src/cengines/optimize.js~LocalOptimizer",
    "static": false,
    "longname": "src/cengines/optimize.js~LocalOptimizer#_l",
    "access": "private",
    "description": null,
    "lineNumber": 44,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 414,
    "kind": "member",
    "name": "_m",
    "memberof": "src/cengines/optimize.js~LocalOptimizer",
    "static": false,
    "longname": "src/cengines/optimize.js~LocalOptimizer#_m",
    "access": "private",
    "description": null,
    "lineNumber": 45,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 415,
    "kind": "method",
    "name": "sendQubitPipeline",
    "memberof": "src/cengines/optimize.js~LocalOptimizer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/optimize.js~LocalOptimizer#sendQubitPipeline",
    "access": "public",
    "description": "Send n gate operations of the qubit with index idx to the next engine.",
    "lineNumber": 53,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "idx",
        "description": "qubit index"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "n",
        "description": "command position in qubit idx's command list"
      }
    ],
    "return": null
  },
  {
    "__docId__": 416,
    "kind": "method",
    "name": "getGateIndices",
    "memberof": "src/cengines/optimize.js~LocalOptimizer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/optimize.js~LocalOptimizer#getGateIndices",
    "access": "public",
    "description": "Return all indices of a command, each index corresponding to the\ncommand's index in one of the qubits' command lists.",
    "lineNumber": 109,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "idx",
        "description": "qubit index"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "i",
        "description": "command position in qubit idx's command list"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "IDs",
        "description": "IDs of all qubits involved in the command"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number[]"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 417,
    "kind": "method",
    "name": "optimize",
    "memberof": "src/cengines/optimize.js~LocalOptimizer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/optimize.js~LocalOptimizer#optimize",
    "access": "public",
    "description": "Try to merge or even cancel successive gates using the get_merged and\ngetInverse functions of the gate (see, e.g., BasicRotationGate).\n\nIt does so for all qubit command lists.",
    "lineNumber": 152,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "idx",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "lim",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 418,
    "kind": "method",
    "name": "checkAndSend",
    "memberof": "src/cengines/optimize.js~LocalOptimizer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/optimize.js~LocalOptimizer#checkAndSend",
    "access": "public",
    "description": "Check whether a qubit pipeline must be sent on and, if so,\noptimize the pipeline and then send it on.",
    "lineNumber": 235,
    "params": [],
    "return": null
  },
  {
    "__docId__": 420,
    "kind": "method",
    "name": "cacheCMD",
    "memberof": "src/cengines/optimize.js~LocalOptimizer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/optimize.js~LocalOptimizer#cacheCMD",
    "access": "public",
    "description": "Cache a command, i.e., inserts it into the command lists of all qubits involved.",
    "lineNumber": 268,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 421,
    "kind": "method",
    "name": "receive",
    "memberof": "src/cengines/optimize.js~LocalOptimizer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/optimize.js~LocalOptimizer#receive",
    "access": "public",
    "description": "Receive commands from the previous engine and cache them.\nIf a flush gate arrives, the entire buffer is sent on.",
    "lineNumber": 288,
    "params": [
      {
        "name": "commandList",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 423,
    "kind": "file",
    "name": "src/cengines/optimize.spec.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport {expect} from 'chai'\r\nimport LocalOptimizer from './optimize'\r\nimport {DummyEngine} from './testengine'\r\nimport MainEngine from './main'\r\nimport {tuple, instanceOf} from '../libs/util';\r\nimport {\r\n  AllocateQubitGate, X, H, Rx\r\n} from '../ops/gates'\r\nimport {CNOT} from '../ops/shortcuts'\r\nimport {ClassicalInstructionGate, FastForwardingGate} from '../ops/basics'\r\n\r\ndescribe('optimize test', () => {\r\n  it('should test_local_optimizer_caching', () => {\r\n    const local_optimizer = new LocalOptimizer(4)\r\n    const backend = new DummyEngine(true)\r\n    const eng = new MainEngine(backend, [local_optimizer])\r\n    // Test that it caches for each qubit 3 gates\r\n    const qb0 = eng.allocateQubit()\r\n    const qb1 = eng.allocateQubit()\r\n    expect(backend.receivedCommands.length).to.equal(0)\r\n\r\n    H.or(qb0)\r\n    H.or(qb1)\r\n    CNOT.or(tuple(qb0, qb1))\r\n\r\n    expect(backend.receivedCommands.length).to.equal(0)\r\n\r\n    new Rx(0.5).or(qb0)\r\n\r\n    expect(backend.receivedCommands.length).to.equal(1)\r\n    expect(backend.receivedCommands[0].gate.equal(new AllocateQubitGate())).to.equal(true)\r\n\r\n    H.or(qb0)\r\n\r\n    expect(backend.receivedCommands.length).to.equal(2)\r\n    expect(backend.receivedCommands[1].gate.equal(H)).to.equal(true)\r\n    // Another gate on qb0 means it needs to send CNOT but clear pipeline of qb1\r\n    new Rx(0.6).or(qb0)\r\n\r\n    expect(backend.receivedCommands.length).to.equal(5)\r\n    expect(backend.receivedCommands[2].gate.equal(new AllocateQubitGate())).to.equal(true)\r\n    expect(backend.receivedCommands[3].gate.equal(H)).to.equal(true)\r\n    expect(backend.receivedCommands[3].qubits[0][0].id).to.equal(qb1[0].id)\r\n    expect(backend.receivedCommands[4].gate.equal(X)).to.equal(true)\r\n    expect(backend.receivedCommands[4].controlQubits[0].id).to.equal(qb0[0].id)\r\n    expect(backend.receivedCommands[4].qubits[0][0].id).to.equal(qb1[0].id)\r\n  });\r\n\r\n  it('should test_local_optimizer_flush_gate', () => {\r\n    const local_optimizer = new LocalOptimizer(4)\r\n    const backend = new DummyEngine(true)\r\n    const eng = new MainEngine(backend, [local_optimizer])\r\n    // Test that it caches for each qubit 3 gates\r\n    const qb0 = eng.allocateQubit()\r\n    const qb1 = eng.allocateQubit()\r\n    H.or(qb0)\r\n    H.or(qb1)\r\n\r\n    expect(backend.receivedCommands.length).to.equal(0)\r\n    eng.flush()\r\n    // Two allocate gates, two H gates and one flush gate\r\n    expect(backend.receivedCommands.length).to.equal(5)\r\n  });\r\n\r\n  it('should test_local_optimizer_fast_forwarding_gate', () => {\r\n    const local_optimizer = new LocalOptimizer(4)\r\n    const backend = new DummyEngine(true)\r\n    const eng = new MainEngine(backend, [local_optimizer])\r\n    // Test that FastForwardingGate (e.g. Deallocate) flushes that qb0 pipeline\r\n    const qb0 = eng.allocateQubit()\r\n    const qb1 = eng.allocateQubit()\r\n    H.or(qb0)\r\n    H.or(qb1)\r\n\r\n    expect(backend.receivedCommands.length).to.equal(0)\r\n\r\n    qb0[0].deallocate()\r\n    // As Deallocate gate is a FastForwardingGate, we should get gates of qb0\r\n    expect(backend.receivedCommands.length).to.equal(3)\r\n  });\r\n\r\n  it('should test_local_optimizer_cancel_inverse', () => {\r\n    const local_optimizer = new LocalOptimizer(4)\r\n    const backend = new DummyEngine(true)\r\n    const eng = new MainEngine(backend, [local_optimizer])\r\n    // Test that it cancels inverses (H, CNOT are self-inverse)\r\n    const qb0 = eng.allocateQubit()\r\n    const qb1 = eng.allocateQubit()\r\n\r\n    expect(backend.receivedCommands.length).to.equal(0)\r\n    for (let i = 0; i < 11; ++i) {\r\n      H.or(qb0)\r\n    }\r\n    expect(backend.receivedCommands.length).to.equal(0)\r\n\r\n    for (let i = 0; i < 11; ++i) {\r\n      CNOT.or(tuple(qb0, qb1))\r\n    }\r\n    expect(backend.receivedCommands.length).to.equal(0)\r\n\r\n    eng.flush()\r\n    const received_commands = []\r\n    // Remove Allocate and Deallocate gates\r\n    backend.receivedCommands.forEach((cmd) => {\r\n      if (!(instanceOf(cmd.gate, [FastForwardingGate, ClassicalInstructionGate]))) {\r\n        received_commands.push(cmd)\r\n      }\r\n    })\r\n\r\n    expect(received_commands.length).to.equal(2)\r\n    expect(received_commands[0].gate.equal(H)).to.equal(true)\r\n    expect(received_commands[0].qubits[0][0].id).to.equal(qb0[0].id)\r\n\r\n    expect(received_commands[1].gate.equal(X)).to.equal(true)\r\n    expect(received_commands[1].qubits[0][0].id).to.equal(qb1[0].id)\r\n    expect(received_commands[1].controlQubits[0].id).to.equal(qb0[0].id)\r\n  });\r\n\r\n  it('should test_local_optimizer_mergeable_gates', () => {\r\n    const local_optimizer = new LocalOptimizer(4)\r\n    const backend = new DummyEngine(true)\r\n    const eng = new MainEngine(backend, [local_optimizer])\r\n    // Test that it merges mergeable gates such as Rx\r\n    const qb0 = eng.allocateQubit()\r\n    for (let i = 0; i < 10; ++i) {\r\n      new Rx(0.5).or(qb0)\r\n    }\r\n\r\n    expect(backend.receivedCommands.length).to.equal(0)\r\n    eng.flush()\r\n    // Expect allocate, one Rx gate, and flush gate\r\n    expect(backend.receivedCommands.length).to.equal(3)\r\n    expect(backend.receivedCommands[1].gate.equal(new Rx(10 * 0.5))).to.equal(true)\r\n  });\r\n})\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/cengines/optimize.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 424,
    "kind": "file",
    "name": "src/cengines/replacer/decompositionrule.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport {BasicGate} from '../../ops/basics'\r\nimport { isKindclassOf } from '../../libs/util'\r\n\r\n/**\r\n * @class DecompositionRule\r\n * @desc A rule for breaking down specific gates into sequences of simpler gates.\r\n */\r\nexport default class DecompositionRule {\r\n  /**\r\n   * @constructor\r\n    @param {function} gateClass The type of gate that this rule decomposes.\r\n\r\n    The gate class is redundant information used to make lookups\r\nfaster when iterating over a circuit and deciding \"which rules\r\napply to this gate?\" again and again.\r\n\r\n    Note that this parameter is a gate type, not a gate instance.\r\n    You supply gate_class=MyGate or gate_class=MyGate().__class__,\r\n    not gate_class=MyGate().\r\n\r\n   @param {function} gateDecomposer Function which,\r\n    given the command to decompose, applies a sequence of gates\r\ncorresponding to the high-level function of a gate of type\r\ngate_class.\r\n\r\n   @param {function} gateRecognizer A\r\npredicate that determines if the decomposition applies to the\r\ngiven command (on top of the filtering by gate_class).\r\n\r\nFor example, a decomposition rule may only to apply rotation\r\ngates that rotate by a specific angle.\r\n\r\n    If no gate_recognizer is given, the decomposition applies to\r\nall gates matching the gate_class.\r\n     */\r\n  constructor(gateClass, gateDecomposer, gateRecognizer = () => true) {\r\n    // Check for common gate_class type mistakes.\r\n    if (gateClass instanceof BasicGate) {\r\n      throw new Error('gate_class is a gate instance instead of a type of BasicGate.'\r\n            + '\\nDid you pass in someGate instead of someGate.__class__?')\r\n    }\r\n\r\n    if (!isKindclassOf(gateClass, BasicGate)) {\r\n      throw new Error('Invalid class type, you should pass a subclass of BasicGate!')\r\n    }\r\n\r\n    this.gateClass = gateClass\r\n    this.gateDecomposer = gateDecomposer\r\n    this.gateRecognizer = gateRecognizer\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/cengines/replacer/decompositionrule.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 425,
    "kind": "class",
    "name": "DecompositionRule",
    "memberof": "src/cengines/replacer/decompositionrule.js",
    "static": true,
    "longname": "src/cengines/replacer/decompositionrule.js~DecompositionRule",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/cengines/replacer/decompositionrule.js",
    "importStyle": "DecompositionRule",
    "description": "A rule for breaking down specific gates into sequences of simpler gates.",
    "lineNumber": 24,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "DecompositionRule"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 426,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/cengines/replacer/decompositionrule.js~DecompositionRule",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/replacer/decompositionrule.js~DecompositionRule#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 52,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "gateClass",
        "description": "The type of gate that this rule decomposes.\n\nThe gate class is redundant information used to make lookups\nfaster when iterating over a circuit and deciding \"which rules\napply to this gate?\" again and again.\n\nNote that this parameter is a gate type, not a gate instance.\nYou supply gate_class=MyGate or gate_class=MyGate().__class__,\nnot gate_class=MyGate()."
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "gateDecomposer",
        "description": "Function which,\ngiven the command to decompose, applies a sequence of gates\ncorresponding to the high-level function of a gate of type\ngate_class."
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "gateRecognizer",
        "description": "A\npredicate that determines if the decomposition applies to the\ngiven command (on top of the filtering by gate_class).\n\nFor example, a decomposition rule may only to apply rotation\ngates that rotate by a specific angle.\n\nIf no gate_recognizer is given, the decomposition applies to\nall gates matching the gate_class."
      }
    ]
  },
  {
    "__docId__": 427,
    "kind": "member",
    "name": "gateClass",
    "memberof": "src/cengines/replacer/decompositionrule.js~DecompositionRule",
    "static": false,
    "longname": "src/cengines/replacer/decompositionrule.js~DecompositionRule#gateClass",
    "access": "public",
    "description": null,
    "lineNumber": 63,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 428,
    "kind": "member",
    "name": "gateDecomposer",
    "memberof": "src/cengines/replacer/decompositionrule.js~DecompositionRule",
    "static": false,
    "longname": "src/cengines/replacer/decompositionrule.js~DecompositionRule#gateDecomposer",
    "access": "public",
    "description": null,
    "lineNumber": 64,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 429,
    "kind": "member",
    "name": "gateRecognizer",
    "memberof": "src/cengines/replacer/decompositionrule.js~DecompositionRule",
    "static": false,
    "longname": "src/cengines/replacer/decompositionrule.js~DecompositionRule#gateRecognizer",
    "access": "public",
    "description": null,
    "lineNumber": 65,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 430,
    "kind": "file",
    "name": "src/cengines/replacer/decompositionruleset.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n// A collection of indexed decomposition rules.\r\nimport {Dagger} from '../../meta/dagger'\r\n\r\n/**\r\n * @class DecompositionRuleSet\r\n */\r\nexport default class DecompositionRuleSet {\r\n  /**\r\n    @param {Array.<DecompositionRule>} rules Initial decomposition rules.\r\n    @param {Array} modules A list of\r\nthings with an \"all_defined_decomposition_rules\" property\r\ncontaining decomposition rules to add to the rule set.\r\n     */\r\n  constructor(rules, modules) {\r\n    this.decompositions = {}\r\n    if (rules) {\r\n      this.addDecompositionRules(rules)\r\n    }\r\n    if (modules) {\r\n      modules.forEach((module) => {\r\n        this.addDecompositionRules(module.allDefinedDecompositionRules)\r\n      })\r\n    }\r\n  }\r\n\r\n  addDecompositionRules(rules) {\r\n    rules.forEach(rule => this.addDecompositionRule(rule))\r\n  }\r\n\r\n  /**\r\n    Add a decomposition rule to the rule set.\r\n\r\n    @param {DecompositionRule} rule The decomposition rule to add.\r\n     */\r\n  addDecompositionRule(rule) {\r\n    const decomp_obj = new _Decomposition(rule.gateDecomposer, rule.gateRecognizer)\r\n    const cls = rule.gateClass.name\r\n    if (!(cls in this.decompositions)) {\r\n      this.decompositions[cls] = []\r\n    }\r\n    this.decompositions[cls].push(decomp_obj)\r\n  }\r\n}\r\n\r\n/**\r\n * @class ModuleWithDecompositionRuleSet\r\n * @desc\r\nInterface type for explaining one of the parameters that can be given to\r\nDecompositionRuleSet.\r\n */\r\nclass ModuleWithDecompositionRuleSet {\r\n  constructor(allDefinedDecompositionRules) {\r\n    this.allDefinedDecompositionRules = allDefinedDecompositionRules\r\n  }\r\n}\r\n\r\n/**\r\n * @private\r\n * @class _Decomposition\r\n * @desc\r\nThe Decomposition class can be used to register a decomposition rule (by\r\ncalling register_decomposition)\r\n */\r\nclass _Decomposition {\r\n  /**\r\n   * @constructor\r\n    Construct the Decomposition object.\r\n\r\n    @param {function} replacementFunc Function that, when called with a `Command` object, decomposes this command.\r\n    @param {function} recognizerFunc Function that, when called with a `Command` object,\r\n    returns true if and only if the replacement rule can handle this command.\r\n\r\n    Every Decomposition is registered with the gate class. The\r\nDecomposition rule is then potentially valid for all objects which are\r\nan instance of that same class\r\n(i.e., instance of gate_object.constructor). All other parameters have\r\nto be checked by the recogn_fun, i.e., it has to decide whether the\r\ndecomposition rule can indeed be applied to replace the given Command.\r\n\r\n    As an example, consider recognizing the Toffoli gate, which is a\r\nPauli-X gate with 2 control qubits. The recognizer function would then\r\nbe:\r\n\r\n    @example\r\n\r\nfunction recogn_toffoli(cmd)\r\n// can be applied if the gate is an X-gate with 2 controls\r\n    return len(cmd.control_qubits) == 2\r\n\r\nand, given a replacement function `replace_toffoli`, the decomposition\r\nrule can be registered as\r\n\r\n   @example\r\n\r\nregister_decomposition(X.constructor, decompose_toffoli,\r\n    recogn_toffoli)\r\n\r\nNote:\r\n    See projectq.setups.decompositions for more example codes.\r\n     */\r\n  constructor(replacementFunc, recognizerFunc) {\r\n    this.decompose = replacementFunc\r\n    this.check = recognizerFunc\r\n  }\r\n\r\n  /**\r\n    Return the Decomposition object which handles the inverse of the\r\noriginal command.\r\n\r\n    This simulates the user having added a decomposition rule for the\r\n    inverse as well. Since decomposing the inverse of a command can be\r\nachieved by running the original decomposition inside a\r\n    `with Dagger(engine)` statement, this is not necessary\r\n(and will be done automatically by the framework).\r\n\r\n  @return {_Decomposition} Decomposition handling the inverse of the original command.\r\n  */\r\n  getInverseDecomposition() {\r\n    const decomp = (cmd) => {\r\n      Dagger(cmd.engine, () => this.decompose(cmd.getInverse()))\r\n    }\r\n    const recogn = (cmd) => {\r\n      return this.check(cmd.getInverse())\r\n    }\r\n    return new _Decomposition(decomp, recogn)\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/cengines/replacer/decompositionruleset.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 431,
    "kind": "class",
    "name": "DecompositionRuleSet",
    "memberof": "src/cengines/replacer/decompositionruleset.js",
    "static": true,
    "longname": "src/cengines/replacer/decompositionruleset.js~DecompositionRuleSet",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/cengines/replacer/decompositionruleset.js",
    "importStyle": "DecompositionRuleSet",
    "description": "",
    "lineNumber": 23,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "DecompositionRuleSet"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 432,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/cengines/replacer/decompositionruleset.js~DecompositionRuleSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/replacer/decompositionruleset.js~DecompositionRuleSet#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 30,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array.<DecompositionRule>"
        ],
        "spread": false,
        "optional": false,
        "name": "rules",
        "description": "Initial decomposition rules."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "modules",
        "description": "A list of\nthings with an \"all_defined_decomposition_rules\" property\ncontaining decomposition rules to add to the rule set."
      }
    ]
  },
  {
    "__docId__": 433,
    "kind": "member",
    "name": "decompositions",
    "memberof": "src/cengines/replacer/decompositionruleset.js~DecompositionRuleSet",
    "static": false,
    "longname": "src/cengines/replacer/decompositionruleset.js~DecompositionRuleSet#decompositions",
    "access": "public",
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 434,
    "kind": "method",
    "name": "addDecompositionRules",
    "memberof": "src/cengines/replacer/decompositionruleset.js~DecompositionRuleSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/replacer/decompositionruleset.js~DecompositionRuleSet#addDecompositionRules",
    "access": "public",
    "description": null,
    "lineNumber": 42,
    "undocument": true,
    "params": [
      {
        "name": "rules",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 435,
    "kind": "method",
    "name": "addDecompositionRule",
    "memberof": "src/cengines/replacer/decompositionruleset.js~DecompositionRuleSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/replacer/decompositionruleset.js~DecompositionRuleSet#addDecompositionRule",
    "access": "public",
    "description": "Add a decomposition rule to the rule set.",
    "lineNumber": 51,
    "params": [
      {
        "nullable": null,
        "types": [
          "DecompositionRule"
        ],
        "spread": false,
        "optional": false,
        "name": "rule",
        "description": "The decomposition rule to add."
      }
    ],
    "return": null
  },
  {
    "__docId__": 436,
    "kind": "class",
    "name": "ModuleWithDecompositionRuleSet",
    "memberof": "src/cengines/replacer/decompositionruleset.js",
    "static": true,
    "longname": "src/cengines/replacer/decompositionruleset.js~ModuleWithDecompositionRuleSet",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/cengines/replacer/decompositionruleset.js",
    "importStyle": null,
    "description": "Interface type for explaining one of the parameters that can be given to\nDecompositionRuleSet.",
    "lineNumber": 67,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "ModuleWithDecompositionRuleSet"
      }
    ],
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 437,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/cengines/replacer/decompositionruleset.js~ModuleWithDecompositionRuleSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/replacer/decompositionruleset.js~ModuleWithDecompositionRuleSet#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 68,
    "undocument": true
  },
  {
    "__docId__": 438,
    "kind": "member",
    "name": "allDefinedDecompositionRules",
    "memberof": "src/cengines/replacer/decompositionruleset.js~ModuleWithDecompositionRuleSet",
    "static": false,
    "longname": "src/cengines/replacer/decompositionruleset.js~ModuleWithDecompositionRuleSet#allDefinedDecompositionRules",
    "access": "public",
    "description": null,
    "lineNumber": 69,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 439,
    "kind": "class",
    "name": "_Decomposition",
    "memberof": "src/cengines/replacer/decompositionruleset.js",
    "static": true,
    "longname": "src/cengines/replacer/decompositionruleset.js~_Decomposition",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/cengines/replacer/decompositionruleset.js",
    "importStyle": null,
    "description": "The Decomposition class can be used to register a decomposition rule (by\ncalling register_decomposition)",
    "lineNumber": 80,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "_Decomposition"
      }
    ],
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 440,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/cengines/replacer/decompositionruleset.js~_Decomposition",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/replacer/decompositionruleset.js~_Decomposition#constructor",
    "access": "public",
    "description": "",
    "examples": [
      "\nfunction recogn_toffoli(cmd)\n// can be applied if the gate is an X-gate with 2 controls\nreturn len(cmd.control_qubits) == 2\n\nand, given a replacement function `replace_toffoli`, the decomposition\nrule can be registered as",
      "\nregister_decomposition(X.constructor, decompose_toffoli,\nrecogn_toffoli)\n\nNote:\nSee projectq.setups.decompositions for more example codes."
    ],
    "lineNumber": 117,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": "Construct the Decomposition object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "replacementFunc",
        "description": "Function that, when called with a `Command` object, decomposes this command."
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "recognizerFunc",
        "description": "Function that, when called with a `Command` object,\nreturns true if and only if the replacement rule can handle this command.\n\nEvery Decomposition is registered with the gate class. The\nDecomposition rule is then potentially valid for all objects which are\nan instance of that same class\n(i.e., instance of gate_object.constructor). All other parameters have\nto be checked by the recogn_fun, i.e., it has to decide whether the\ndecomposition rule can indeed be applied to replace the given Command.\n\nAs an example, consider recognizing the Toffoli gate, which is a\nPauli-X gate with 2 control qubits. The recognizer function would then\nbe:"
      }
    ]
  },
  {
    "__docId__": 441,
    "kind": "member",
    "name": "decompose",
    "memberof": "src/cengines/replacer/decompositionruleset.js~_Decomposition",
    "static": false,
    "longname": "src/cengines/replacer/decompositionruleset.js~_Decomposition#decompose",
    "access": "public",
    "description": null,
    "lineNumber": 118,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 442,
    "kind": "member",
    "name": "check",
    "memberof": "src/cengines/replacer/decompositionruleset.js~_Decomposition",
    "static": false,
    "longname": "src/cengines/replacer/decompositionruleset.js~_Decomposition#check",
    "access": "public",
    "description": null,
    "lineNumber": 119,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 443,
    "kind": "method",
    "name": "getInverseDecomposition",
    "memberof": "src/cengines/replacer/decompositionruleset.js~_Decomposition",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/replacer/decompositionruleset.js~_Decomposition#getInverseDecomposition",
    "access": "public",
    "description": "Return the Decomposition object which handles the inverse of the\noriginal command.\n\nThis simulates the user having added a decomposition rule for the\ninverse as well. Since decomposing the inverse of a command can be\nachieved by running the original decomposition inside a\n`with Dagger(engine)` statement, this is not necessary\n(and will be done automatically by the framework).",
    "lineNumber": 134,
    "return": {
      "nullable": null,
      "types": [
        "_Decomposition"
      ],
      "spread": false,
      "description": "Decomposition handling the inverse of the original command."
    },
    "params": []
  },
  {
    "__docId__": 444,
    "kind": "file",
    "name": "src/cengines/replacer/decompositionruleset.spec.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport {expect} from 'chai'\r\nimport {BasicRotationGate} from '../../ops/basics'\r\nimport DecompositionRule from './decompositionrule'\r\n\r\ndescribe('decomposition rule set test', () => {\r\n  it('should test_decomposition_rule_wrong_input', () => {\r\n    class WrongInput {\r\n\r\n    }\r\n\r\n    const noop = () => { }\r\n    expect(() => {\r\n      new DecompositionRule(WrongInput, noop, noop)\r\n    }).to.throw()\r\n\r\n    expect(() => {\r\n      new DecompositionRule(new WrongInput(0), noop, noop)\r\n    }).to.throw()\r\n  });\r\n})\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/cengines/replacer/decompositionruleset.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 445,
    "kind": "file",
    "name": "src/cengines/replacer/replacer.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport {BasicEngine, ForwarderEngine} from '../basics'\r\nimport {FlushGate} from '../../ops/gates'\r\nimport CommandModifier from '../cmdmodifier'\r\nimport {classHierachy} from '../../libs/util';\r\nimport {getInverse} from '../../ops/_cycle';\r\nimport {NoGateDecompositionError} from '../../meta/error';\r\n\r\n/**\r\n * @class InstructionFilter\r\n * @desc\r\nThe InstructionFilter is a compiler engine which changes the behavior of\r\nisAvailable according to a filter function. All commands are passed to\r\nthis function, which then returns whether this command can be executed\r\n(true) or needs replacement (false).\r\n */\r\nexport class InstructionFilter extends BasicEngine {\r\n  /**\r\n   * @constructor\r\n  Initializer: The provided filterfun returns true for all commands\r\nwhich do not need replacement and false for commands that do.\r\n\r\n    @param {function} filterFunc Filter function which returns true for\r\n    available commands, and false otherwise. filterfun will be\r\n    called as filterfun(self, cmd).\r\n  */\r\n  constructor(filterFunc) {\r\n    super()\r\n\r\n    this._filterFunc = filterFunc\r\n  }\r\n\r\n  /**\r\n  Specialized implementation of BasicBackend.isAvailable: Forwards this\r\ncall to the filter function given to the constructor.\r\n\r\n    @param {Command} cmd Command for which to check availability.\r\n   */\r\n  isAvailable(cmd) {\r\n    return this._filterFunc(this, cmd)\r\n  }\r\n\r\n  /**\r\n  Forward all commands to the next engine.\r\n\r\n    @param {Command[]} commandList List of commands to receive.\r\n   */\r\n  receive(commandList) {\r\n    this.next.receive(commandList)\r\n  }\r\n}\r\n\r\n/**\r\n * @class AutoReplacer\r\n * @desc\r\nThe AutoReplacer is a compiler engine which uses engine.isAvailable in\r\norder to determine which commands need to be replaced/decomposed/compiled\r\nfurther. The loaded setup is used to find decomposition rules appropriate\r\nfor each command (e.g., setups.default).\r\n */\r\nexport class AutoReplacer extends BasicEngine {\r\n  /**\r\n   * @constructor\r\n    @param {DecompositionRuleSet} decompositionRuleSet\r\n    @param {function} decomposition_chooser A function which, given the\r\nCommand to decompose and a list of potential Decomposition\r\nobjects, determines (and then returns) the 'best'\r\ndecomposition.\r\n\r\n    The default decomposition chooser simply returns the first list\r\nelement, i.e., calling\r\n\r\n   @example\r\n\r\nrepl = new AutoReplacer()\r\n\r\nAmounts to\r\n\r\n   @example\r\n\r\n  function decomposition_chooser(cmd, decomp_list) {\r\n    return decomp_list[0]\r\n  }\r\n  const repl = new AutoReplacer(decomposition_chooser)\r\n  */\r\n  constructor(decompositionRuleSet, decomposition_chooser) {\r\n    if (!decomposition_chooser) {\r\n      decomposition_chooser = (cmd, decomposition_list) => decomposition_list[0]\r\n    }\r\n\r\n    super()\r\n    this._decomp_chooser = decomposition_chooser\r\n    this.decompositionRuleSet = decompositionRuleSet\r\n  }\r\n\r\n  /**\r\n  Check whether a command cmd can be handled by further engines and,\r\nif not, replace it using the decomposition rules loaded with the setup\r\n(e.g., setups.default).\r\n\r\n    @param {Command} cmd Command to process.\r\n\r\n    @throws Exception if no replacement is available in the loaded setup.\r\n   */\r\n  _processCommand(cmd) {\r\n    if (this.isAvailable(cmd)) {\r\n      this.send([cmd])\r\n    } else {\r\n    // check for decomposition rules\r\n      const decomp_list = []\r\n      let potential_decomps = []\r\n\r\n      // First check for a decomposition rules of the gate class, then\r\n      // the gate class of the inverse gate. If nothing is found, do the\r\n      // same for the first parent class, etc.\r\n      const gate_mro = classHierachy(cmd.gate.constructor)\r\n      // If gate does not have an inverse it's parent classes are\r\n      // DaggeredGate, BasicGate, object. Hence don't check the last two\r\n      const inverse_mro = classHierachy(getInverse(cmd.gate).constructor)\r\n      const rules = this.decompositionRuleSet.decompositions\r\n      const total = Math.max(gate_mro.length, inverse_mro.length)\r\n      for (let level = 0; level < total; ++level) {\r\n        // Check for forward rules\r\n        if (level < gate_mro.length) {\r\n          const class_name = gate_mro[level].name\r\n          try {\r\n            potential_decomps = rules[class_name] || []\r\n          } catch (e) {\r\n            console.log(e)\r\n          }\r\n\r\n          potential_decomps.forEach(d => d.check(cmd) && decomp_list.push(d))\r\n          if (decomp_list.length > 0) {\r\n            break\r\n          }\r\n        }\r\n        // Check for rules implementing the inverse gate\r\n        // and run them in reverse\r\n\r\n        if (level < inverse_mro.length) {\r\n          const inv_class_name = inverse_mro[level].name\r\n          try {\r\n            let list = rules[inv_class_name] || []\r\n            list = list.map(d => d.getInverseDecomposition())\r\n            potential_decomps = potential_decomps.concat(list)\r\n          } catch (e) {\r\n            console.log(e)\r\n          }\r\n\r\n          // throw out the ones which don't recognize the command\r\n          potential_decomps.forEach(d => d.check(cmd) && decomp_list.push(d))\r\n          if (decomp_list.length > 0) {\r\n            break\r\n          }\r\n        }\r\n      }\r\n\r\n      if (decomp_list.length === 0) {\r\n        throw new NoGateDecompositionError(`\\nNo replacement found for ${cmd.toString()}!`)\r\n      }\r\n\r\n      // use decomposition chooser to determine the best decomposition\r\n      const chosen_decomp = this._decomp_chooser(cmd, decomp_list)\r\n\r\n      // the decomposed command must have the same tags\r\n      // (plus the ones it gets from meta-statements inside the\r\n      // decomposition rule).\r\n      // --> use a CommandModifier with a ForwarderEngine to achieve this.\r\n      const old_tags = cmd.tags.slice(0)\r\n\r\n      /*\r\n      Receive a list of commands from the previous compiler engine and, if\r\n            necessary, replace/decompose the gates according to the decomposition\r\n        rules in the loaded setup.\r\n\r\n            @param {Command} command List of commands to handle.\r\n       */\r\n      const cmd_mod_fun = (command) => { // Adds the tags\r\n        command.tags = [...old_tags, ...command.tags]\r\n        command.engine = this.main\r\n        return command\r\n      }\r\n      // the CommandModifier calls cmd_mod_fun for each command\r\n      // --> commands get the right tags.\r\n      const cmod_eng = new CommandModifier(cmd_mod_fun)\r\n      cmod_eng.next = this // send modified commands back here\r\n      cmod_eng.main = this.main\r\n      // forward everything to cmod_eng using the ForwarderEngine\r\n      // which behaves just like MainEngine\r\n      // (--> meta functions still work)\r\n      const forwarder_eng = new ForwarderEngine(cmod_eng)\r\n      cmd.engine = forwarder_eng // send gates directly to forwarder\r\n      // (and not to main engine, which would screw up the ordering).\r\n\r\n      chosen_decomp.decompose(cmd) // run the decomposition\r\n    }\r\n  }\r\n\r\n  receive(commandList) {\r\n    commandList.forEach((cmd) => {\r\n      if (!(cmd.gate instanceof FlushGate)) {\r\n        this._processCommand(cmd)\r\n      } else {\r\n        this.send([cmd])\r\n      }\r\n    })\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/cengines/replacer/replacer.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 446,
    "kind": "class",
    "name": "InstructionFilter",
    "memberof": "src/cengines/replacer/replacer.js",
    "static": true,
    "longname": "src/cengines/replacer/replacer.js~InstructionFilter",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/cengines/replacer/replacer.js",
    "importStyle": "{InstructionFilter}",
    "description": "The InstructionFilter is a compiler engine which changes the behavior of\nisAvailable according to a filter function. All commands are passed to\nthis function, which then returns whether this command can be executed\n(true) or needs replacement (false).",
    "lineNumber": 32,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "InstructionFilter"
      }
    ],
    "interface": false,
    "extends": [
      "src/cengines/basics.js~BasicEngine"
    ]
  },
  {
    "__docId__": 447,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/cengines/replacer/replacer.js~InstructionFilter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/replacer/replacer.js~InstructionFilter#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 42,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": "Initializer: The provided filterfun returns true for all commands\nwhich do not need replacement and false for commands that do."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "filterFunc",
        "description": "Filter function which returns true for\navailable commands, and false otherwise. filterfun will be\ncalled as filterfun(self, cmd)."
      }
    ]
  },
  {
    "__docId__": 448,
    "kind": "member",
    "name": "_filterFunc",
    "memberof": "src/cengines/replacer/replacer.js~InstructionFilter",
    "static": false,
    "longname": "src/cengines/replacer/replacer.js~InstructionFilter#_filterFunc",
    "access": "private",
    "description": null,
    "lineNumber": 45,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 449,
    "kind": "method",
    "name": "isAvailable",
    "memberof": "src/cengines/replacer/replacer.js~InstructionFilter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/replacer/replacer.js~InstructionFilter#isAvailable",
    "access": "public",
    "description": "Specialized implementation of BasicBackend.isAvailable: Forwards this\ncall to the filter function given to the constructor.",
    "lineNumber": 54,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": "Command for which to check availability."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 450,
    "kind": "method",
    "name": "receive",
    "memberof": "src/cengines/replacer/replacer.js~InstructionFilter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/replacer/replacer.js~InstructionFilter#receive",
    "access": "public",
    "description": "Forward all commands to the next engine.",
    "lineNumber": 63,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command[]"
        ],
        "spread": false,
        "optional": false,
        "name": "commandList",
        "description": "List of commands to receive."
      }
    ],
    "return": null
  },
  {
    "__docId__": 451,
    "kind": "class",
    "name": "AutoReplacer",
    "memberof": "src/cengines/replacer/replacer.js",
    "static": true,
    "longname": "src/cengines/replacer/replacer.js~AutoReplacer",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/cengines/replacer/replacer.js",
    "importStyle": "{AutoReplacer}",
    "description": "The AutoReplacer is a compiler engine which uses engine.isAvailable in\norder to determine which commands need to be replaced/decomposed/compiled\nfurther. The loaded setup is used to find decomposition rules appropriate\nfor each command (e.g., setups.default).",
    "lineNumber": 76,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "AutoReplacer"
      }
    ],
    "interface": false,
    "extends": [
      "src/cengines/basics.js~BasicEngine"
    ]
  },
  {
    "__docId__": 452,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/cengines/replacer/replacer.js~AutoReplacer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/replacer/replacer.js~AutoReplacer#constructor",
    "access": "public",
    "description": "",
    "examples": [
      "\nrepl = new AutoReplacer()\n\nAmounts to",
      "\nfunction decomposition_chooser(cmd, decomp_list) {\nreturn decomp_list[0]\n}\nconst repl = new AutoReplacer(decomposition_chooser)"
    ],
    "lineNumber": 101,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "DecompositionRuleSet"
        ],
        "spread": false,
        "optional": false,
        "name": "decompositionRuleSet",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "decomposition_chooser",
        "description": "A function which, given the\nCommand to decompose and a list of potential Decomposition\nobjects, determines (and then returns) the 'best'\ndecomposition.\n\nThe default decomposition chooser simply returns the first list\nelement, i.e., calling"
      }
    ]
  },
  {
    "__docId__": 453,
    "kind": "member",
    "name": "_decomp_chooser",
    "memberof": "src/cengines/replacer/replacer.js~AutoReplacer",
    "static": false,
    "longname": "src/cengines/replacer/replacer.js~AutoReplacer#_decomp_chooser",
    "access": "private",
    "description": null,
    "lineNumber": 107,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 454,
    "kind": "member",
    "name": "decompositionRuleSet",
    "memberof": "src/cengines/replacer/replacer.js~AutoReplacer",
    "static": false,
    "longname": "src/cengines/replacer/replacer.js~AutoReplacer#decompositionRuleSet",
    "access": "public",
    "description": null,
    "lineNumber": 108,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 455,
    "kind": "method",
    "name": "_processCommand",
    "memberof": "src/cengines/replacer/replacer.js~AutoReplacer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/replacer/replacer.js~AutoReplacer#_processCommand",
    "access": "private",
    "description": "Check whether a command cmd can be handled by further engines and,\nif not, replace it using the decomposition rules loaded with the setup\n(e.g., setups.default).",
    "lineNumber": 120,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": "Command to process."
      }
    ],
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "Exception if no replacement is available in the loaded setup."
      }
    ],
    "return": null
  },
  {
    "__docId__": 456,
    "kind": "method",
    "name": "receive",
    "memberof": "src/cengines/replacer/replacer.js~AutoReplacer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/replacer/replacer.js~AutoReplacer#receive",
    "access": "public",
    "description": null,
    "lineNumber": 214,
    "undocument": true,
    "params": [
      {
        "name": "commandList",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 457,
    "kind": "file",
    "name": "src/cengines/replacer/replacer.spec.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport {expect, assert} from 'chai'\r\nimport {H, X, Rx} from '../../ops/gates';\r\nimport {tuple} from '../../libs/util';\r\nimport Command from '../../ops/command';\r\nimport {DummyEngine} from '../testengine';\r\nimport MainEngine from '../main';\r\nimport {InstructionFilter, AutoReplacer} from './replacer';\r\nimport {BasicGate, ClassicalInstructionGate} from '../../ops/basics';\r\nimport DecompositionRuleSet from './decompositionruleset'\r\nimport DecompositionRule from './decompositionrule'\r\nimport '../../ops/metagates'\r\nimport {NoGateDecompositionError} from '../../meta/error';\r\n\r\ndescribe('replacer test', () => {\r\n  class SomeGateClass extends BasicGate {}\r\n\r\n  const SomeGate = new SomeGateClass()\r\n  const make_decomposition_rule_set = () => {\r\n    const result = new DecompositionRuleSet()\r\n    // BasicGate with no getInverse used for testing:\r\n    expect(() => SomeGate.getInverse()).to.throw()\r\n\r\n    // Loading of decomposition rules:\r\n    const decompose_test1 = cmd => X.or(cmd.qubits)\r\n\r\n    const recognize_test = () => true\r\n\r\n    result.addDecompositionRule(new DecompositionRule(SomeGateClass, decompose_test1, recognize_test))\r\n\r\n    const decompose_test2 = cmd => H.or(cmd.qubits)\r\n\r\n    result.addDecompositionRule(new DecompositionRule(SomeGateClass, decompose_test2, recognize_test))\r\n\r\n    assert(result.decompositions[SomeGateClass.name].length === 2)\r\n    return result\r\n  }\r\n\r\n  const rule_set = make_decomposition_rule_set()\r\n\r\n  const fixture_gate_filter = () => {\r\n    // Filter which doesn't allow SomeGate\r\n    const test_gate_filter_func = (eng, cmd) => cmd.gate !== SomeGate\r\n    return new InstructionFilter(test_gate_filter_func)\r\n  }\r\n\r\n  it('should test_filter_engine', () => {\r\n    const my_filter = (eng, cmd) => cmd.gate.equal(H)\r\n\r\n    const filter_eng = new InstructionFilter(my_filter)\r\n    const eng = new MainEngine(new DummyEngine(), [filter_eng])\r\n    const qubit = eng.allocateQubit()\r\n    const cmd = new Command(eng, H, tuple(qubit))\r\n    const cmd2 = new Command(eng, X, tuple(qubit))\r\n    expect(eng.isAvailable(cmd)).to.equal(true)\r\n    expect(eng.isAvailable(cmd2)).to.equal(false)\r\n    expect(filter_eng.isAvailable(cmd)).to.equal(true)\r\n    expect(filter_eng.isAvailable(cmd2)).to.equal(false)\r\n  });\r\n\r\n  it('should test_auto_replacer_default_chooser', () => {\r\n    const filter = fixture_gate_filter()\r\n    // Test that default decomposition_chooser takes always first rule.\r\n    const backend = new DummyEngine(true)\r\n    const eng = new MainEngine(backend, [new AutoReplacer(rule_set), filter])\r\n\r\n    expect(rule_set.decompositions[SomeGateClass.name].length).to.equal(2)\r\n    expect(backend.receivedCommands.length).to.equal(0)\r\n\r\n    const qb = eng.allocateQubit()\r\n    SomeGate.or(qb)\r\n    eng.flush()\r\n    expect(backend.receivedCommands.length).to.equal(3)\r\n    expect(backend.receivedCommands[1].gate.equal(X)).to.equal(true)\r\n  });\r\n\r\n  it('should test_auto_replacer_decomposition_chooser', () => {\r\n    // Supply a decomposition chooser which always chooses last rule.\r\n    const test_decomp_chooser = (cmd, decomposition_list) => decomposition_list[decomposition_list.length - 1]\r\n    const backend = new DummyEngine(true)\r\n    const eng = new MainEngine(backend, [new AutoReplacer(rule_set, test_decomp_chooser), fixture_gate_filter()])\r\n\r\n    expect(rule_set.decompositions[SomeGateClass.name].length).to.equal(2)\r\n    expect(backend.receivedCommands.length).to.equal(0)\r\n\r\n    const qb = eng.allocateQubit()\r\n    SomeGate.or(qb)\r\n    eng.flush()\r\n\r\n    expect(backend.receivedCommands.length).to.equal(3)\r\n    expect(backend.receivedCommands[1].gate.equal(H)).to.equal(true)\r\n  });\r\n\r\n  it('should test_auto_replacer_no_rule_found', () => {\r\n    // Check that exception is thrown if no rule is found\r\n    // For both the cmd and it's inverse (which exists)\r\n    const h_filter_func = (eng, cmd) => !cmd.gate.equal(H)\r\n\r\n    const h_filter = new InstructionFilter(h_filter_func)\r\n    const backend = new DummyEngine(true)\r\n    const eng = new MainEngine(backend, [new AutoReplacer(rule_set), h_filter])\r\n    const qubit = eng.allocateQubit()\r\n\r\n    expect(() => H.or(qubit)).to.throw(NoGateDecompositionError)\r\n    eng.flush()\r\n  });\r\n\r\n  it('should test_auto_replacer_use_inverse_decomposition', () => {\r\n    // Check that if there is no decomposition for the gate, that\r\n    // AutoReplacer runs the decomposition for the inverse gate in reverse\r\n\r\n    // Create test gate and inverse\r\n    class NoMagicGate extends BasicGate {\r\n\r\n    }\r\n\r\n    class MagicGate extends BasicGate {\r\n      getInverse() {\r\n        return new NoMagicGate()\r\n      }\r\n    }\r\n\r\n    const decompose_no_magic_gate = (cmd) => {\r\n      const qb = cmd.qubits\r\n      new Rx(0.6).or(qb)\r\n      H.or(qb)\r\n    }\r\n\r\n    const recognize_no_magic_gate = cmd => true\r\n\r\n    rule_set.addDecompositionRule(new DecompositionRule(NoMagicGate, decompose_no_magic_gate, recognize_no_magic_gate))\r\n\r\n    const magic_filter = (eng, cmd) => !(cmd.gate instanceof MagicGate)\r\n\r\n    const backend = new DummyEngine(true)\r\n    const eng = new MainEngine(backend, [new AutoReplacer(rule_set), new InstructionFilter(magic_filter)])\r\n\r\n    expect(backend.receivedCommands.length).to.equal(0)\r\n\r\n    const qb = eng.allocateQubit()\r\n    new MagicGate().or(qb)\r\n    eng.flush()\r\n\r\n    backend.receivedCommands.forEach(cmd => console.log(cmd.toString()))\r\n    expect(backend.receivedCommands.length).to.equal(4)\r\n    expect(backend.receivedCommands[1].gate.equal(H)).to.equal(true)\r\n    expect(backend.receivedCommands[2].gate.equal(new Rx(-0.6))).to.equal(true)\r\n  });\r\n\r\n  it('should test_auto_replacer_adds_tags', () => {\r\n    // Test that AutoReplacer puts back the tags\r\n    const backend = new DummyEngine(true)\r\n    const eng = new MainEngine(backend, [new AutoReplacer(rule_set), fixture_gate_filter()])\r\n\r\n    expect(rule_set.decompositions[SomeGateClass.name].length).to.equal(2)\r\n    expect(backend.receivedCommands.length).to.equal(0)\r\n    const qb = eng.allocateQubit()\r\n    const cmd = new Command(eng, SomeGate, tuple(qb))\r\n    cmd.tags = ['AddedTag']\r\n    eng.send([cmd])\r\n    eng.flush()\r\n\r\n    expect(backend.receivedCommands.length).to.equal(3)\r\n    expect(backend.receivedCommands[1].gate.equal(X)).to.equal(true)\r\n    expect(backend.receivedCommands[1].tags.length).to.equal(1)\r\n    expect(backend.receivedCommands[1].tags[0]).to.equal('AddedTag')\r\n  });\r\n\r\n  it('should test_auto_replacer_searches_parent_class_for_rule', () => {\r\n    class DerivedSomeGate extends SomeGateClass {\r\n\r\n    }\r\n\r\n    const test_gate_filter_func = (eng, cmd) => (cmd.gate.equal(X) || cmd.gate.equal(H) || (cmd.gate instanceof ClassicalInstructionGate))\r\n\r\n    const i_filter = new InstructionFilter(test_gate_filter_func)\r\n    const backend = new DummyEngine(true)\r\n    const eng = new MainEngine(backend, [new AutoReplacer(rule_set), i_filter])\r\n    const qb = eng.allocateQubit()\r\n    new DerivedSomeGate().or(qb)\r\n    eng.flush()\r\n    const received_gate = backend.receivedCommands[1].gate\r\n    expect(received_gate.equal(X) || received_gate.equal(H)).to.equal(true)\r\n  });\r\n})\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/cengines/replacer/replacer.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 458,
    "kind": "file",
    "name": "src/cengines/swapandcnotflipper.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport assert from 'assert'\r\nimport {BasicEngine, ForwarderEngine} from './basics'\r\nimport {NOT, H, Swap} from '../ops/gates'\r\nimport {All} from '../ops/metagates'\r\nimport {instanceOf, tuple} from '../libs/util';\r\nimport {CNOT} from '../ops/shortcuts'\r\nimport CommandModifier from './cmdmodifier'\r\n\r\n/**\r\n * @class SwapAndCNOTFlipper\r\n * @desc\r\nFlips CNOTs and translates Swaps to CNOTs where necessary.\r\n\r\n    Warning:\r\nThis engine assumes that CNOT and Hadamard gates are supported by\r\nthe following engines.\r\n\r\n    Warning:\r\nThis engine cannot be used as a backend.\r\n */\r\nexport default class SwapAndCNOTFlipper extends BasicEngine {\r\n  /**\r\n   * @constructor\r\n   * @param {Set<string> | Set<Array.<number>>} connectivity Set of tuples (c, t) where if (c, t) is an\r\n   *   element of the set means that a CNOT can be performed between the physical ids (c, t)\r\n   *   with c being the control and t being the target qubit.\r\n   */\r\n  constructor(connectivity) {\r\n    super()\r\n    if (connectivity instanceof Set) {\r\n      const newMap = {}\r\n      connectivity.forEach(v => newMap[v] = 1)\r\n      connectivity = newMap\r\n    }\r\n    this.connectivity = connectivity\r\n  }\r\n\r\n  /**\r\n   * Check if the IBM backend can perform the Command cmd and return true if so.\r\n   * @param {Command} cmd The command to check\r\n   */\r\n  isAvailable(cmd) {\r\n    return this.isSwap(cmd) || this.next.isAvailable(cmd)\r\n  }\r\n\r\n  isCNOT(cmd) {\r\n    return instanceOf(cmd.gate, NOT.constructor) && cmd.controlCount === 1\r\n  }\r\n\r\n  isSwap(cmd) {\r\n    const n = cmd.controlCount\r\n    const f = cmd.gate.equal(Swap)\r\n    return n === 0 && f\r\n  }\r\n\r\n  needsFlipping(cmd) {\r\n    if (!this.isCNOT(cmd)) {\r\n      return false\r\n    }\r\n\r\n    const target = cmd.qubits[0][0].id\r\n    const control = cmd.controlQubits[0].id\r\n    const key = [control, target]\r\n    const rkey = [target, control]\r\n    const v = this.connectivity[key]\r\n    const rv = this.connectivity[rkey]\r\n    const is_possible = typeof v !== 'undefined'\r\n    if (!is_possible && typeof rv === 'undefined') {\r\n      throw new Error(`The provided connectivity does not allow to execute the CNOT gate ${cmd.toString()}.`)\r\n    }\r\n    return !is_possible\r\n  }\r\n\r\n  sendCNOT(cmd, control, target, flip = false) {\r\n    const cmd_mod = (command) => {\r\n      command.tags = cmd.tags.slice(0).concat(command.tags)\r\n      command.engine = this.main\r\n      return command\r\n    }\r\n\r\n    // We'll have to add all meta tags before sending on\r\n    const cmd_mod_eng = new CommandModifier(cmd_mod)\r\n    cmd_mod_eng.next = this.next\r\n    cmd_mod_eng.main = this.main\r\n    // forward everything to the command modifier\r\n    const forwarder_eng = new ForwarderEngine(cmd_mod_eng)\r\n    target[0].engine = forwarder_eng\r\n    control[0].engine = forwarder_eng\r\n    if (flip) {\r\n      // flip the CNOT using Hadamard gates:\r\n      new All(H).or(control.concat(target))\r\n      CNOT.or(tuple(target, control))\r\n      new All(H).or(control.concat(target))\r\n    } else {\r\n      CNOT.or(tuple(control, target))\r\n    }\r\n  }\r\n\r\n  /**\r\n     Receives a command list and if the command is a CNOT gate, it flips\r\n    it using Hadamard gates if necessary; if it is a Swap gate, it\r\n    decomposes it using 3 CNOTs. All other gates are simply sent to the next engine.\r\n    @param {Command[]} commandList list of commands to receive.\r\n   */\r\n  receive(commandList) {\r\n    commandList.forEach((cmd) => {\r\n      if (this.needsFlipping(cmd)) {\r\n        this.sendCNOT(cmd, cmd.controlQubits, cmd.qubits[0], true)\r\n      } else if (this.isSwap(cmd)) {\r\n        const qubits = []\r\n        cmd.qubits.forEach(qr => qr.forEach(qb => qubits.push(qb)))\r\n        const ids = qubits.map(qb => qb.id)\r\n        assert(ids.length === 2)\r\n        let key = ids\r\n        let v = this.connectivity[key]\r\n        let control\r\n        let target\r\n        if (typeof v !== 'undefined') {\r\n          control = [qubits[0]]\r\n          target = [qubits[1]]\r\n        } else {\r\n          key = key.slice(0).reverse()\r\n          v = this.connectivity[key]\r\n          if (typeof v !== 'undefined') {\r\n            control = [qubits[1]]\r\n            target = [qubits[0]]\r\n          } else {\r\n            throw new Error(`The provided connectivity does not allow to execute the Swap gate ${cmd.toString()}.`)\r\n          }\r\n        }\r\n\r\n        this.sendCNOT(cmd, control, target)\r\n        this.sendCNOT(cmd, target, control, true)\r\n        this.sendCNOT(cmd, control, target)\r\n      } else {\r\n        this.next.receive([cmd])\r\n      }\r\n    })\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/cengines/swapandcnotflipper.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 459,
    "kind": "class",
    "name": "SwapAndCNOTFlipper",
    "memberof": "src/cengines/swapandcnotflipper.js",
    "static": true,
    "longname": "src/cengines/swapandcnotflipper.js~SwapAndCNOTFlipper",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/cengines/swapandcnotflipper.js",
    "importStyle": "SwapAndCNOTFlipper",
    "description": "Flips CNOTs and translates Swaps to CNOTs where necessary.\n\nWarning:\nThis engine assumes that CNOT and Hadamard gates are supported by\nthe following engines.\n\nWarning:\nThis engine cannot be used as a backend.",
    "lineNumber": 37,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "SwapAndCNOTFlipper"
      }
    ],
    "interface": false,
    "extends": [
      "src/cengines/basics.js~BasicEngine"
    ]
  },
  {
    "__docId__": 460,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/cengines/swapandcnotflipper.js~SwapAndCNOTFlipper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/swapandcnotflipper.js~SwapAndCNOTFlipper#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 44,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Set<string> | Set<Array.<number>>"
        ],
        "spread": false,
        "optional": false,
        "name": "connectivity",
        "description": "Set of tuples (c, t) where if (c, t) is an\n  element of the set means that a CNOT can be performed between the physical ids (c, t)\n  with c being the control and t being the target qubit."
      }
    ]
  },
  {
    "__docId__": 461,
    "kind": "member",
    "name": "connectivity",
    "memberof": "src/cengines/swapandcnotflipper.js~SwapAndCNOTFlipper",
    "static": false,
    "longname": "src/cengines/swapandcnotflipper.js~SwapAndCNOTFlipper#connectivity",
    "access": "public",
    "description": null,
    "lineNumber": 51,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 462,
    "kind": "method",
    "name": "isAvailable",
    "memberof": "src/cengines/swapandcnotflipper.js~SwapAndCNOTFlipper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/swapandcnotflipper.js~SwapAndCNOTFlipper#isAvailable",
    "access": "public",
    "description": "Check if the IBM backend can perform the Command cmd and return true if so.",
    "lineNumber": 58,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": "The command to check"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 463,
    "kind": "method",
    "name": "isCNOT",
    "memberof": "src/cengines/swapandcnotflipper.js~SwapAndCNOTFlipper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/swapandcnotflipper.js~SwapAndCNOTFlipper#isCNOT",
    "access": "public",
    "description": null,
    "lineNumber": 62,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 464,
    "kind": "method",
    "name": "isSwap",
    "memberof": "src/cengines/swapandcnotflipper.js~SwapAndCNOTFlipper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/swapandcnotflipper.js~SwapAndCNOTFlipper#isSwap",
    "access": "public",
    "description": null,
    "lineNumber": 66,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 465,
    "kind": "method",
    "name": "needsFlipping",
    "memberof": "src/cengines/swapandcnotflipper.js~SwapAndCNOTFlipper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/swapandcnotflipper.js~SwapAndCNOTFlipper#needsFlipping",
    "access": "public",
    "description": null,
    "lineNumber": 72,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 466,
    "kind": "method",
    "name": "sendCNOT",
    "memberof": "src/cengines/swapandcnotflipper.js~SwapAndCNOTFlipper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/swapandcnotflipper.js~SwapAndCNOTFlipper#sendCNOT",
    "access": "public",
    "description": null,
    "lineNumber": 90,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      },
      {
        "name": "control",
        "types": [
          "*"
        ]
      },
      {
        "name": "target",
        "types": [
          "*"
        ]
      },
      {
        "name": "flip",
        "optional": true,
        "types": [
          "boolean"
        ],
        "defaultRaw": false,
        "defaultValue": "false"
      }
    ],
    "return": null
  },
  {
    "__docId__": 467,
    "kind": "method",
    "name": "receive",
    "memberof": "src/cengines/swapandcnotflipper.js~SwapAndCNOTFlipper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/swapandcnotflipper.js~SwapAndCNOTFlipper#receive",
    "access": "public",
    "description": "Receives a command list and if the command is a CNOT gate, it flips\nit using Hadamard gates if necessary; if it is a Swap gate, it\ndecomposes it using 3 CNOTs. All other gates are simply sent to the next engine.",
    "lineNumber": 121,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command[]"
        ],
        "spread": false,
        "optional": false,
        "name": "commandList",
        "description": "list of commands to receive."
      }
    ],
    "return": null
  },
  {
    "__docId__": 468,
    "kind": "file",
    "name": "src/cengines/swapandcnotflipper.spec.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport {expect} from 'chai'\r\nimport SwapAndCNOTFlipper from './swapandcnotflipper'\r\nimport {Swap, H, X} from '../ops/gates'\r\nimport {CNOT} from '../ops/shortcuts'\r\nimport {tuple, instanceOf} from '../libs/util'\r\nimport {DummyEngine} from './testengine'\r\nimport MainEngine from './main'\r\nimport {Control} from '../meta/control'\r\nimport {Compute, Uncompute} from '../meta/compute';\r\nimport {ComputeTag, UncomputeTag} from '../meta/tag';\r\nimport {All} from '../ops/metagates'\r\n\r\ndescribe('swap and cnot flipper test', () => {\r\n  it('should test_swapandcnotflipper_missing_connection', () => {\r\n    const flipper = new SwapAndCNOTFlipper(new Set())\r\n    const eng = new MainEngine(new DummyEngine(true), [flipper])\r\n    const [qubit1, qubit2] = eng.allocateQureg(2)\r\n\r\n    expect(() => Swap.or(tuple(qubit1, qubit2))).to.throw()\r\n  });\r\n\r\n  it('should test_swapandcnotflipper_is_available', () => {\r\n    const flipper = new SwapAndCNOTFlipper(new Set())\r\n    const dummy = new DummyEngine()\r\n    dummy.isAvailable = () => false\r\n    flipper.next = dummy\r\n    let eng = new MainEngine(new DummyEngine(true), [])\r\n    const [qubit1, qubit2] = eng.allocateQureg(2)\r\n    Swap.or(tuple(qubit1, qubit2))\r\n    let swap_count = 0\r\n\r\n    eng.backend.receivedCommands.forEach((cmd) => {\r\n      if (cmd.gate.equal(Swap)) {\r\n        swap_count += 1\r\n        expect(flipper.isAvailable(cmd)).to.equal(true)\r\n      }\r\n    })\r\n\r\n    expect(swap_count).to.equal(1)\r\n\r\n    eng = new MainEngine(new DummyEngine(true), [])\r\n    const [qubit11, qubit21, qubit31] = eng.allocateQureg(3)\r\n\r\n    Control(eng, qubit31, () => {\r\n      Swap.or(tuple(qubit11, qubit21))\r\n    })\r\n\r\n    swap_count = 0\r\n    eng.backend.receivedCommands.forEach((cmd) => {\r\n      if (cmd.gate.equal(Swap)) {\r\n        swap_count += 1\r\n        expect(flipper.isAvailable(cmd)).to.equal(false)\r\n      }\r\n    })\r\n\r\n    expect(swap_count).to.equal(1)\r\n  });\r\n\r\n  it('should test_swapandcnotflipper_flips_cnot', () => {\r\n    const backend = new DummyEngine(true)\r\n    const connectivity = new Set()\r\n    connectivity.add([0, 1])\r\n    const flipper = new SwapAndCNOTFlipper(connectivity)\r\n    const eng = new MainEngine(backend, [flipper])\r\n    const qb0 = eng.allocateQubit()\r\n    const qb1 = eng.allocateQubit()\r\n    CNOT.or(tuple(qb0, qb1))\r\n    CNOT.or(tuple(qb1, qb0))\r\n    let hgates = 0\r\n    backend.receivedCommands.forEach((cmd) => {\r\n      if (cmd.gate.equal(H)) {\r\n        hgates += 1\r\n      }\r\n      if (cmd.gate.equal(X)) {\r\n        expect(cmd.qubits[0][0].id).to.equal(1)\r\n        expect(cmd.controlQubits[0].id).to.equal(0)\r\n      }\r\n    })\r\n    expect(hgates).to.equal(4)\r\n  });\r\n\r\n  it('should test_swapandcnotflipper_invalid_circuit', () => {\r\n    const backend = new DummyEngine(true)\r\n    const connectivity = new Set()\r\n    connectivity.add([0, 2])\r\n    const flipper = new SwapAndCNOTFlipper(connectivity)\r\n    const eng = new MainEngine(backend, [flipper])\r\n    const qb0 = eng.allocateQubit()\r\n    const qb1 = eng.allocateQubit()\r\n    const qb2 = eng.allocateQubit()\r\n    CNOT.or(tuple(qb0, qb2))\r\n    CNOT.or(tuple(qb2, qb0))\r\n\r\n    expect(() => CNOT.or(tuple(qb0, qb1))).to.throw()\r\n    expect(() => Swap.or(tuple(qb0, qb1))).to.throw()\r\n  });\r\n\r\n  it('should test_swapandcnotflipper_optimize_swaps', () => {\r\n    let backend = new DummyEngine(true)\r\n    let connectivity = new Set()\r\n    connectivity.add([1, 0])\r\n    let flipper = new SwapAndCNOTFlipper(connectivity)\r\n    let eng = new MainEngine(backend, [flipper])\r\n    let qb0 = eng.allocateQubit()\r\n    let qb1 = eng.allocateQubit()\r\n    Swap.or(tuple(qb0, qb1))\r\n    let hgates = 0\r\n\r\n    backend.receivedCommands.forEach((cmd) => {\r\n      if (cmd.gate.equal(H)) {\r\n        hgates += 1\r\n      }\r\n      if (cmd.gate.equal(X)) {\r\n        expect(cmd.qubits[0][0].id).to.equal(0)\r\n        expect(cmd.controlQubits[0].id).to.equal(1)\r\n      }\r\n    })\r\n\r\n    expect(hgates).to.equal(4)\r\n    backend = new DummyEngine(true)\r\n    connectivity = new Set()\r\n    connectivity.add([0, 1])\r\n    flipper = new SwapAndCNOTFlipper(connectivity)\r\n    eng = new MainEngine(backend, [flipper])\r\n    qb0 = eng.allocateQubit()\r\n    qb1 = eng.allocateQubit()\r\n    Swap.or(tuple(qb0, qb1))\r\n    hgates = 0\r\n    backend.receivedCommands.forEach((cmd) => {\r\n      if (cmd.gate.equal(H)) {\r\n        hgates += 1\r\n      }\r\n      if (cmd.gate.equal(X)) {\r\n        expect(cmd.qubits[0][0].id).to.equal(1)\r\n        expect(cmd.controlQubits[0].id).to.equal(0)\r\n      }\r\n    })\r\n  });\r\n\r\n  it('should test_swapandcnotflipper_keeps_tags', () => {\r\n    const backend = new DummyEngine(true)\r\n    const connectivity = new Set([[1, 0]])\r\n    const flipper = new SwapAndCNOTFlipper(connectivity)\r\n    const eng = new MainEngine(backend, [flipper])\r\n    const qb0 = eng.allocateQubit()\r\n    const qb1 = eng.allocateQubit()\r\n    Compute(eng, () => {\r\n      new All(H).or(tuple(qb0.concat(qb1)))\r\n      CNOT.or(tuple(qb0, qb1))\r\n      CNOT.or(tuple(qb1, qb0))\r\n      Swap.or(tuple(qb0, qb1))\r\n    })\r\n    Uncompute(eng)\r\n    let hgates = 0\r\n\r\n    backend.receivedCommands.forEach((cmd) => {\r\n      if (cmd.gate.equal(H)) {\r\n        cmd.tags.forEach((t) => {\r\n          if (instanceOf(t, [ComputeTag, UncomputeTag])) {\r\n            hgates += 1\r\n          }\r\n        })\r\n      }\r\n    })\r\n    expect(hgates).to.equal(20)\r\n  });\r\n})\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/cengines/swapandcnotflipper.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 469,
    "kind": "file",
    "name": "src/cengines/tagremover.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport assert from 'assert'\r\nimport {BasicEngine} from './basics'\r\nimport {ComputeTag, UncomputeTag} from '../meta/tag'\r\nimport {instanceOf} from '../libs/util'\r\n\r\n/**\r\n *  @class TagRemover\r\n *  @desc is a compiler engine which removes temporary command tags (see the tag classes such as LoopTag in `loop`).\r\n\r\nRemoving tags is important (after having handled them if necessary) in\r\norder to enable optimizations across meta-function boundaries (compute/\r\naction/uncompute or loops after unrolling)\r\n */\r\nexport default class TagRemover extends BasicEngine {\r\n  /**\r\n    @constructor\r\n    @param {Array.<function>} tags A list of meta tag classes (e.g., [ComputeTag, UncomputeTag])\r\n    denoting the tags to remove\r\n  */\r\n  constructor(tags = [ComputeTag, UncomputeTag]) {\r\n    super()\r\n    assert(Array.isArray(tags))\r\n    this._tags = tags\r\n  }\r\n\r\n  /**\r\n   * @param {function} tag\r\n   */\r\n  _isTagIn(tag) {\r\n    return instanceOf(tag, this._tags)\r\n  }\r\n\r\n  /**\r\n    Receive a list of commands from the previous engine, remove all tags\r\nwhich are an instance of at least one of the meta tags provided in the\r\nconstructor, and then send them on to the next compiler engine.\r\n\r\n    @param {Command[]} commandList List of commands to receive and then (after removing tags) send on.\r\n  */\r\n  receive(commandList) {\r\n    commandList.forEach((cmd) => {\r\n      cmd.tags = cmd.tags.filter(t => !this._isTagIn(t))\r\n      this.send([cmd])\r\n    })\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/cengines/tagremover.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 470,
    "kind": "class",
    "name": "TagRemover",
    "memberof": "src/cengines/tagremover.js",
    "static": true,
    "longname": "src/cengines/tagremover.js~TagRemover",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/cengines/tagremover.js",
    "importStyle": "TagRemover",
    "description": "is a compiler engine which removes temporary command tags (see the tag classes such as LoopTag in `loop`).\n\nRemoving tags is important (after having handled them if necessary) in\norder to enable optimizations across meta-function boundaries (compute/\naction/uncompute or loops after unrolling)",
    "lineNumber": 30,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "TagRemover"
      }
    ],
    "interface": false,
    "extends": [
      "src/cengines/basics.js~BasicEngine"
    ]
  },
  {
    "__docId__": 471,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/cengines/tagremover.js~TagRemover",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/tagremover.js~TagRemover#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 36,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Array.<function>"
        ],
        "spread": false,
        "optional": false,
        "name": "tags",
        "description": "A list of meta tag classes (e.g., [ComputeTag, UncomputeTag])\ndenoting the tags to remove"
      }
    ]
  },
  {
    "__docId__": 472,
    "kind": "member",
    "name": "_tags",
    "memberof": "src/cengines/tagremover.js~TagRemover",
    "static": false,
    "longname": "src/cengines/tagremover.js~TagRemover#_tags",
    "access": "private",
    "description": null,
    "lineNumber": 39,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 473,
    "kind": "method",
    "name": "_isTagIn",
    "memberof": "src/cengines/tagremover.js~TagRemover",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/tagremover.js~TagRemover#_isTagIn",
    "access": "private",
    "description": "",
    "lineNumber": 45,
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "tag",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 474,
    "kind": "method",
    "name": "receive",
    "memberof": "src/cengines/tagremover.js~TagRemover",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/tagremover.js~TagRemover#receive",
    "access": "public",
    "description": "Receive a list of commands from the previous engine, remove all tags\nwhich are an instance of at least one of the meta tags provided in the\nconstructor, and then send them on to the next compiler engine.",
    "lineNumber": 56,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command[]"
        ],
        "spread": false,
        "optional": false,
        "name": "commandList",
        "description": "List of commands to receive and then (after removing tags) send on."
      }
    ],
    "return": null
  },
  {
    "__docId__": 475,
    "kind": "file",
    "name": "src/cengines/tagremover.spec.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport {expect} from 'chai'\r\nimport TagRemover from './tagremover'\r\nimport {ComputeTag, UncomputeTag} from '../meta/tag'\r\nimport {tuple} from '../libs/util'\r\nimport {H} from '../ops/gates'\r\nimport Command from '../ops/command'\r\nimport {DummyEngine} from './testengine'\r\nimport MainEngine from './main'\r\n\r\ndescribe('tag remover test', () => {\r\n  it('should test_tagremover_default', () => {\r\n    const tag_remover = new TagRemover()\r\n    expect(tag_remover._tags).to.deep.equal([ComputeTag, UncomputeTag])\r\n  });\r\n\r\n  it('should test_tagremover', () => {\r\n    const backend = new DummyEngine(true)\r\n    const tag_remover = new TagRemover([String])\r\n    const eng = new MainEngine(backend, [tag_remover])\r\n    // Create a command_list and check if \"NewTag\" is removed\r\n    const qubit = eng.allocateQubit()\r\n    const cmd0 = new Command(eng, H, tuple(qubit))\r\n    cmd0.tags = ['NewTag']\r\n    const cmd1 = new Command(eng, H, tuple(qubit))\r\n    cmd1.tags = [1, 2, 'NewTag', 3]\r\n    const cmd_list = [cmd0, cmd1, cmd0]\r\n    expect(backend.receivedCommands.length).to.equal(1) // AllocateQubitGate\r\n    tag_remover.receive(cmd_list)\r\n\r\n    expect(backend.receivedCommands.length).to.equal(4)\r\n    expect(backend.receivedCommands[1].tags).to.deep.equal([])\r\n    expect(backend.receivedCommands[2].tags).to.deep.equal([1, 2, 3])\r\n  });\r\n})\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/cengines/tagremover.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 476,
    "kind": "file",
    "name": "src/cengines/testengine.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport {BasicEngine} from './basics'\r\nimport {FlushGate} from '../ops/gates'\r\n\r\n/**\r\n * @class CompareEngine\r\n * @desc CompareEngine is an engine which saves all commands. It is only intended\r\n * for testing purposes. Two CompareEngine backends can be compared and\r\n * return true if they contain the same commmands.\r\n */\r\nexport class CompareEngine extends BasicEngine {\r\n  /**\r\n   * @constructor\r\n   */\r\n  constructor() {\r\n    super()\r\n    this._l = [[]]\r\n  }\r\n\r\n  /**\r\n   * @return {boolean}\r\n   */\r\n  isAvailable() {\r\n    return true\r\n  }\r\n\r\n  /**\r\n   * @param {Command} cmd\r\n   */\r\n  cacheCMD(cmd) {\r\n    // are there qubit ids that haven't been added to the list?\r\n    const allQubitIDList = []\r\n    cmd.allQubits.forEach((qureg) => {\r\n      qureg.forEach(qubit => allQubitIDList.push(qubit.id))\r\n    })\r\n    let maxidx = 0\r\n    allQubitIDList.forEach(qid => maxidx = Math.max(maxidx, qid))\r\n\r\n    // if so, increase size of list to account for these qubits\r\n    const add = maxidx + 1 - this._l.length\r\n    if (add > 0) {\r\n      for (let i = 0; i < add; ++i) {\r\n        this._l.push([])\r\n      }\r\n    }\r\n    // add gate command to each of the qubits involved\r\n    allQubitIDList.forEach(qid => this._l[qid].push(cmd))\r\n  }\r\n\r\n  receive(commandList) {\r\n    const f = new FlushGate()\r\n    commandList.forEach((cmd) => {\r\n      if (!cmd.gate.equal(f)) {\r\n        this.cacheCMD(cmd)\r\n      }\r\n    })\r\n\r\n    if (!this.isLastEngine) {\r\n      this.send(commandList)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * test if c1 & c2 are equal\r\n   * @param c1 {Command}\r\n   * @param c2 {Command}\r\n   * @return {boolean}\r\n   */\r\n  compareCMDs(c1, c2) {\r\n    const item = c2.copy()\r\n    item.engine = c1.engine\r\n    return c1.equal(item)\r\n  }\r\n\r\n  equal(engine) {\r\n    const len = this._l.length\r\n    if (!(engine instanceof CompareEngine) || len !== engine._l.length) {\r\n      return false\r\n    }\r\n\r\n    for (let i = 0; i < len; ++i) {\r\n      const item1 = this._l[i]\r\n      const item2 = engine._l[i]\r\n      if (item1.length !== item2.length) {\r\n        return false\r\n      }\r\n      const total = item1.length\r\n      for (let j = 0; j < total; ++j) {\r\n        if (!this.compareCMDs(item1[j], item2[j])) {\r\n          return false\r\n        }\r\n      }\r\n    }\r\n    return true\r\n  }\r\n\r\n  /**\r\n   * string description\r\n   * @return {string}\r\n   */\r\n  toString() {\r\n    let string = ''\r\n    this._l.forEach((cmds, qubit_id) => {\r\n      string += `Qubit ${qubit_id} : `\r\n      cmds.forEach((command) => {\r\n        string += `${command.toString()}, `\r\n      })\r\n      string = `${string.substring(0, string.length - 2)}\\n`\r\n    })\r\n    return string\r\n  }\r\n}\r\n\r\n/**\r\n * @class DummyEngine\r\n   @desc DummyEngine used for testing.\r\n    The DummyEngine forwards all commands directly to next engine.\r\n    If this.is_last_engine == true it just discards all gates.\r\n    By setting save_commands == true all commands get saved as a\r\n    list in this.received_commands. Elements are appended to this\r\n    list so they are ordered according to when they are received.\r\n */\r\nexport class DummyEngine extends BasicEngine {\r\n  /**\r\n   * @constructor\r\n   * @param {boolean} saveCommands default is false\r\n   */\r\n  constructor(saveCommands = false) {\r\n    super()\r\n    this.saveCommands = saveCommands\r\n    this.receivedCommands = []\r\n  }\r\n\r\n  isAvailable() {\r\n    return true\r\n  }\r\n\r\n  receive(commandList) {\r\n    if (this.saveCommands) {\r\n      this.receivedCommands = this.receivedCommands.concat(commandList)\r\n    }\r\n\r\n    if (!this.isLastEngine) {\r\n      this.send(commandList)\r\n    }\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/cengines/testengine.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 477,
    "kind": "class",
    "name": "CompareEngine",
    "memberof": "src/cengines/testengine.js",
    "static": true,
    "longname": "src/cengines/testengine.js~CompareEngine",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/cengines/testengine.js",
    "importStyle": "{CompareEngine}",
    "description": "CompareEngine is an engine which saves all commands. It is only intended\nfor testing purposes. Two CompareEngine backends can be compared and\nreturn true if they contain the same commmands.",
    "lineNumber": 26,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "CompareEngine"
      }
    ],
    "interface": false,
    "extends": [
      "src/cengines/basics.js~BasicEngine"
    ]
  },
  {
    "__docId__": 478,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/cengines/testengine.js~CompareEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/testengine.js~CompareEngine#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 30,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ]
  },
  {
    "__docId__": 479,
    "kind": "member",
    "name": "_l",
    "memberof": "src/cengines/testengine.js~CompareEngine",
    "static": false,
    "longname": "src/cengines/testengine.js~CompareEngine#_l",
    "access": "private",
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "type": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 480,
    "kind": "method",
    "name": "isAvailable",
    "memberof": "src/cengines/testengine.js~CompareEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/testengine.js~CompareEngine#isAvailable",
    "access": "public",
    "description": "",
    "lineNumber": 38,
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 481,
    "kind": "method",
    "name": "cacheCMD",
    "memberof": "src/cengines/testengine.js~CompareEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/testengine.js~CompareEngine#cacheCMD",
    "access": "public",
    "description": "",
    "lineNumber": 45,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 482,
    "kind": "method",
    "name": "receive",
    "memberof": "src/cengines/testengine.js~CompareEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/testengine.js~CompareEngine#receive",
    "access": "public",
    "description": null,
    "lineNumber": 65,
    "undocument": true,
    "params": [
      {
        "name": "commandList",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 483,
    "kind": "method",
    "name": "compareCMDs",
    "memberof": "src/cengines/testengine.js~CompareEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/testengine.js~CompareEngine#compareCMDs",
    "access": "public",
    "description": "test if c1 & c2 are equal",
    "lineNumber": 84,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "c1",
        "description": "{Command}"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "c2",
        "description": "{Command}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 484,
    "kind": "method",
    "name": "equal",
    "memberof": "src/cengines/testengine.js~CompareEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/testengine.js~CompareEngine#equal",
    "access": "public",
    "description": null,
    "lineNumber": 90,
    "undocument": true,
    "params": [
      {
        "name": "engine",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 485,
    "kind": "method",
    "name": "toString",
    "memberof": "src/cengines/testengine.js~CompareEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/testengine.js~CompareEngine#toString",
    "access": "public",
    "description": "string description",
    "lineNumber": 116,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 486,
    "kind": "class",
    "name": "DummyEngine",
    "memberof": "src/cengines/testengine.js",
    "static": true,
    "longname": "src/cengines/testengine.js~DummyEngine",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/cengines/testengine.js",
    "importStyle": "{DummyEngine}",
    "description": "DummyEngine used for testing.\nThe DummyEngine forwards all commands directly to next engine.\nIf this.is_last_engine == true it just discards all gates.\nBy setting save_commands == true all commands get saved as a\nlist in this.received_commands. Elements are appended to this\nlist so they are ordered according to when they are received.",
    "lineNumber": 138,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "DummyEngine"
      }
    ],
    "interface": false,
    "extends": [
      "src/cengines/basics.js~BasicEngine"
    ]
  },
  {
    "__docId__": 487,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/cengines/testengine.js~DummyEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/testengine.js~DummyEngine#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 143,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "saveCommands",
        "description": "default is false"
      }
    ]
  },
  {
    "__docId__": 488,
    "kind": "member",
    "name": "saveCommands",
    "memberof": "src/cengines/testengine.js~DummyEngine",
    "static": false,
    "longname": "src/cengines/testengine.js~DummyEngine#saveCommands",
    "access": "public",
    "description": null,
    "lineNumber": 145,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 489,
    "kind": "member",
    "name": "receivedCommands",
    "memberof": "src/cengines/testengine.js~DummyEngine",
    "static": false,
    "longname": "src/cengines/testengine.js~DummyEngine#receivedCommands",
    "access": "public",
    "description": null,
    "lineNumber": 146,
    "undocument": true,
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 490,
    "kind": "method",
    "name": "isAvailable",
    "memberof": "src/cengines/testengine.js~DummyEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/testengine.js~DummyEngine#isAvailable",
    "access": "public",
    "description": null,
    "lineNumber": 149,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 491,
    "kind": "method",
    "name": "receive",
    "memberof": "src/cengines/testengine.js~DummyEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/testengine.js~DummyEngine#receive",
    "access": "public",
    "description": null,
    "lineNumber": 153,
    "undocument": true,
    "params": [
      {
        "name": "commandList",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 493,
    "kind": "file",
    "name": "src/cengines/testengine.spec.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport {expect} from 'chai'\r\nimport { tuple } from '../libs/util'\r\nimport MainEngine from './main'\r\nimport {DummyEngine, CompareEngine} from './testengine'\r\nimport {\r\n  H, Rx, FlushGate, Allocate\r\n} from '../ops/gates'\r\nimport {CNOT} from '../ops/shortcuts'\r\n\r\ndescribe('testengine test', () => {\r\n  it('should test_compare_engine_str', () => {\r\n    const compare_engine = new CompareEngine()\r\n    const eng = new MainEngine(compare_engine, [new DummyEngine()])\r\n    const qb0 = eng.allocateQubit()\r\n    const qb1 = eng.allocateQubit()\r\n    H.or(qb0)\r\n    CNOT.or(tuple(qb0, qb1))\r\n    eng.flush()\r\n    const expected = ('Qubit 0 : Allocate | Qureg[0], H | Qureg[0], '\r\n      + 'CX | ( Qureg[0], Qureg[1] )\\nQubit 1 : Allocate | Qureg[1],'\r\n      + ' CX | ( Qureg[0], Qureg[1] )\\n')\r\n\r\n    expect(compare_engine.toString()).to.equal(expected)\r\n  });\r\n\r\n  it('should test_compare_engine_is_available', () => {\r\n    const compare_engine = new CompareEngine()\r\n    expect(compare_engine.isAvailable('Anything')).to.equal(true)\r\n  });\r\n\r\n  it('should test_compare_engine_receive', () => {\r\n    // Test that CompareEngine would forward commands\r\n    const backend = new DummyEngine(true)\r\n    const compare_engine = new CompareEngine()\r\n    const eng = new MainEngine(backend, [compare_engine])\r\n    const qubit = eng.allocateQubit()\r\n    H.or(qubit)\r\n    eng.flush()\r\n    expect(backend.receivedCommands.length).to.equal(3)\r\n  });\r\n\r\n  it('should test_compare_engine', () => {\r\n    const compare_engine0 = new CompareEngine()\r\n    const compare_engine1 = new CompareEngine()\r\n    const compare_engine2 = new CompareEngine()\r\n    const compare_engine3 = new CompareEngine()\r\n    const eng0 = new MainEngine(compare_engine0, [new DummyEngine()])\r\n    const eng1 = new MainEngine(compare_engine1, [new DummyEngine()])\r\n    const eng2 = new MainEngine(compare_engine2, [new DummyEngine()])\r\n    const eng3 = new MainEngine(compare_engine3, [new DummyEngine()])\r\n    // reference circuit\r\n    const qb00 = eng0.allocateQubit()\r\n    const qb01 = eng0.allocateQubit()\r\n    const qb02 = eng0.allocateQubit()\r\n    H.or(qb00)\r\n    CNOT.or(tuple(qb00, qb01))\r\n    CNOT.or(tuple(qb01, qb00))\r\n    H.or(qb00)\r\n    new Rx(0.5).or(qb01)\r\n    CNOT.or(tuple(qb00, qb01))\r\n    new Rx(0.6).or(qb02)\r\n    eng0.flush()\r\n    // identical circuit:\r\n    const qb10 = eng1.allocateQubit()\r\n    const qb11 = eng1.allocateQubit()\r\n    const qb12 = eng1.allocateQubit()\r\n    H.or(qb10)\r\n    new Rx(0.6).or(qb12)\r\n    CNOT.or(tuple(qb10, qb11))\r\n    CNOT.or(tuple(qb11, qb10))\r\n    new Rx(0.5).or(qb11)\r\n    H.or(qb10)\r\n    CNOT.or(tuple(qb10, qb11))\r\n    eng1.flush()\r\n    // mistake in CNOT circuit:\r\n    const qb20 = eng2.allocateQubit()\r\n    const qb21 = eng2.allocateQubit()\r\n    const qb22 = eng2.allocateQubit()\r\n    H.or(qb20)\r\n    new Rx(0.6).or(qb22)\r\n    CNOT.or(tuple(qb21, qb20))\r\n    CNOT.or(tuple(qb20, qb21))\r\n    new Rx(0.5).or(qb21)\r\n    H.or(qb20)\r\n    CNOT.or(tuple(qb20, qb21))\r\n    eng2.flush()\r\n    // test other branch to fail\r\n    const qb30 = eng3.allocateQubit()\r\n    const qb31 = eng3.allocateQubit()\r\n    const qb32 = eng3.allocateQubit()\r\n    eng3.flush()\r\n\r\n    expect(compare_engine0.equal(compare_engine1)).to.equal(true)\r\n    expect(compare_engine1.equal(compare_engine2)).to.equal(false)\r\n    expect(compare_engine1.equal(compare_engine3)).to.equal(false)\r\n    expect(compare_engine0.equal(new DummyEngine())).to.equal(false)\r\n  });\r\n\r\n  it('should test dummy engine', () => {\r\n    const dummy_eng = new DummyEngine(true)\r\n    const eng = new MainEngine(dummy_eng, [])\r\n\r\n    expect(dummy_eng.isAvailable('Anything')).to.equal(true)\r\n    const qubit = eng.allocateQubit()\r\n    H.or(qubit)\r\n    eng.flush()\r\n    expect(dummy_eng.receivedCommands.length).to.equal(3)\r\n    expect(dummy_eng.receivedCommands[0].gate.equal(Allocate)).to.equal(true)\r\n    expect(dummy_eng.receivedCommands[1].gate.equal(H)).to.equal(true)\r\n    expect(dummy_eng.receivedCommands[2].gate.equal(new FlushGate())).to.equal(true)\r\n  });\r\n})\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/cengines/testengine.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 494,
    "kind": "file",
    "name": "src/cengines/twodmapper.js",
    "content": "/*\r\nMapper for a quantum circuit to a 2D square grid.\r\n\r\n    Input: Quantum circuit with 1 and 2 qubit gates on n qubits. Gates are assumed\r\nto be applied in parallel if they act on disjoint qubit(s) and any pair\r\nof qubits can perform a 2 qubit gate (all-to-all connectivity)\r\nOutput: Quantum circuit in which qubits are placed in 2-D square grid in which\r\nonly nearest neighbour qubits can perform a 2 qubit gate. The mapper\r\nuses Swap gates in order to move qubits next to each other.\r\n*/\r\nimport assert from 'assert'\r\nimport math from 'mathjs'\r\nimport {permutations} from 'itertools'\r\nimport BasicMapperEngine from './basicmapper';\r\nimport {return_swap_depth} from './linearmapper'\r\nimport NativeImpl from '../backends/simulators/cppsim'\r\nimport {\r\n  arrayFromRange, len, randomSample, setDifference, setEqual, setFromRange\r\n} from '../libs/polyfill';\r\nimport LinearMapper from './linearmapper';\r\nimport {\r\n  AllocateQubitGate, DeallocateQubitGate, FlushGate, Swap\r\n} from '../ops';\r\nimport {tuple} from '../libs/util';\r\nimport Command from '../ops/command';\r\nimport {BasicQubit} from '../types/qubit';\r\nimport {LogicalQubitIDTag} from '../meta';\r\n\r\n/**\r\n * @class GridMapper\r\n * @desc\r\nMapper to a 2-D grid graph.\r\n\r\n    Mapped qubits on the grid are numbered in row-major order. E.g. for\r\n3 rows and 2 columns:\r\n\r\n    0 - 1\r\n    |   |\r\n    2 - 3\r\n    |   |\r\n    4 - 5\r\n\r\nThe numbers are the mapped qubit ids. The backend might number\r\nthe qubits on the grid differently (e.g. not row-major), we call these\r\nbackend qubit ids. If the backend qubit ids are not row-major, one can\r\npass a dictionary translating from our row-major mapped ids to these\r\nbackend ids.\r\n\r\n    Note: The algorithm sorts twice inside each column and once inside each\r\nrow.\r\n\r\n    Attributes:\r\ncurrent_mapping:  Stores the mapping: key is logical qubit id, value\r\nis backend qubit id.\r\nstorage(int): Number of gate it caches before mapping.\r\nnum_rows(int): Number of rows in the grid\r\nnum_columns(int): Number of columns in the grid\r\nnum_qubits(int): num_rows x num_columns = number of qubits\r\nnum_mappings (int): Number of times the mapper changed the mapping\r\ndepth_of_swaps (dict): Key are circuit depth of swaps, value is the\r\nnumber of such mappings which have been\r\napplied\r\nnum_of_swaps_per_mapping (dict): Key are the number of swaps per\r\nmapping, value is the number of such\r\nmappings which have been applied\r\n */\r\nexport default class GridMapper extends BasicMapperEngine {\r\n  /**\r\n   * @constructor\r\n  Initialize a GridMapper compiler engine.\r\n\r\n    @param {{num_rows: number, num_columns: number, mapped_ids_to_backend_ids: Object, storage: number, optimization_function: function, num_optimization_steps: number}} args\r\n      num_rows(int): Number of rows in the grid\r\n      num_columns(int): Number of columns in the grid.\r\n      mapped_ids_to_backend_ids(dict): Stores a mapping from mapped ids which are 0,...,this.num_qubits-1\r\n      in row-major order on the grid to the corresponding qubit ids of the backend.\r\n      Key: mapped id. Value: corresponding backend id. Default is None\r\n      which means backend ids are identical to mapped ids.\r\n      storage: Number of gates to temporarily store\r\n      optimization_function: Function which takes a list of swaps and returns a cost value. Mapper chooses a\r\n        permutation which minimizes this cost. Default optimizes for circuit depth.\r\n      num_optimization_steps(int): Number of different permutations to of the matching to try and minimize the cost.\r\n    @throws {Error} if incorrect `mapped_ids_to_backend_ids` parameter\r\n   */\r\n  constructor(args) {\r\n    super()\r\n    const {\r\n      num_rows, num_columns, mapped_ids_to_backend_ids,\r\n      storage = 1000,\r\n      optimization_function = x => return_swap_depth(x),\r\n      num_optimization_steps = 50\r\n    } = args\r\n\r\n\r\n    this.num_rows = num_rows\r\n    this.num_columns = num_columns\r\n    this.num_qubits = num_rows * num_columns\r\n    // Internally we use the mapped ids until sending a command.\r\n    // Before sending we use this map to translate to backend ids:\r\n    this._mapped_ids_to_backend_ids = mapped_ids_to_backend_ids\r\n    if (typeof this._mapped_ids_to_backend_ids === 'undefined' || this._mapped_ids_to_backend_ids === null) {\r\n      this._mapped_ids_to_backend_ids = {}\r\n      for (let i = 0; i < this.num_qubits; ++i) {\r\n        this._mapped_ids_to_backend_ids[i] = i\r\n      }\r\n    }\r\n\r\n    const f1 = setEqual(new Set(Object.keys(this._mapped_ids_to_backend_ids).map(k => parseInt(k, 10))), setFromRange(this.num_qubits))\r\n    const f2 = new Set(Object.values(this._mapped_ids_to_backend_ids)).size === this.num_qubits\r\n    if (!f1 || !f2) {\r\n      throw new Error('Incorrect mapped_ids_to_backend_ids parameter')\r\n    }\r\n    this._backend_ids_to_mapped_ids = {}\r\n\r\n    Object.keys(this._mapped_ids_to_backend_ids).forEach((mapped_id) => {\r\n      const backend_id = this._mapped_ids_to_backend_ids[mapped_id]\r\n      this._backend_ids_to_mapped_ids[backend_id] = mapped_id\r\n    })\r\n    // As we use internally the mapped ids which are in row-major order,\r\n    // we have an internal current mapping which maps from logical ids to\r\n    // these mapped ids:\r\n    this._current_row_major_mapping = Object.assign({}, this._currentMapping)\r\n    this.storage = storage\r\n    this.optimization_function = optimization_function\r\n    this.num_optimization_steps = num_optimization_steps\r\n    // Randomness to pick permutations if there are too many.\r\n    // This creates an own instance of Random in order to not influence\r\n    // the bound methods of the random module which might be used in other\r\n    // places.\r\n    // TODO\r\n    // this._rng = random.Random(11)\r\n    // Storing commands\r\n    this._stored_commands = []\r\n    // Logical qubit ids for which the Allocate gate has already been\r\n    // processed and sent to the next engine but which are not yet\r\n    // deallocated:\r\n    this._currently_allocated_ids = new Set()\r\n    // Change between 2D and 1D mappings (2D is a snake like 1D chain)\r\n    // Note it translates to our mapped ids in row major order and not\r\n    // backend ids which might be different.\r\n    this._map_2d_to_1d = {}\r\n    this._map_1d_to_2d = {}\r\n    for (let row_index = 0; row_index < this.num_rows; ++row_index) {\r\n      for (let column_index = 0; column_index < this.num_columns; ++column_index) {\r\n        if (row_index % 2 === 0) {\r\n          const mapped_id = row_index * this.num_columns + column_index\r\n          this._map_2d_to_1d[mapped_id] = mapped_id\r\n          this._map_1d_to_2d[mapped_id] = mapped_id\r\n        } else {\r\n          const mapped_id_2d = row_index * this.num_columns + column_index\r\n          const mapped_id_1d = ((row_index + 1) * this.num_columns - column_index - 1)\r\n          this._map_2d_to_1d[mapped_id_2d] = mapped_id_1d\r\n          this._map_1d_to_2d[mapped_id_1d] = mapped_id_2d\r\n        }\r\n      }\r\n    }\r\n\r\n    // Statistics:\r\n    this.num_mappings = 0\r\n    this.depth_of_swaps = {}\r\n    this.num_of_swaps_per_mapping = {}\r\n  }\r\n\r\n  get currentMapping() {\r\n    return super.currentMapping\r\n  }\r\n\r\n  set currentMapping(newMapping) {\r\n    this._currentMapping = newMapping\r\n    if (typeof newMapping === 'undefined' || newMapping === null) {\r\n      this._current_row_major_mapping = newMapping\r\n    } else {\r\n      this._current_row_major_mapping = {}\r\n\r\n      Object.keys(newMapping).forEach((logical_id) => {\r\n        const backend_id = newMapping[logical_id]\r\n        const value = this._backend_ids_to_mapped_ids[backend_id]\r\n        this._current_row_major_mapping[logical_id] = parseInt(value, 10)\r\n      })\r\n    }\r\n  }\r\n\r\n  // Only allows 1 || two qubit gates.\r\n  isAvailable(cmd) {\r\n    let num_qubits = 0\r\n    cmd.allQubits.forEach(qureg => num_qubits += qureg.length)\r\n    return num_qubits <= 2\r\n  }\r\n\r\n  /**\r\n  Returns a new mapping of the qubits.\r\n\r\n    It goes through this._saved_commands and tries to find a\r\nmapping to apply these gates on a first come first served basis.\r\n    It reuses the function of a 1D mapper and creates a mapping for a\r\n  1D linear chain and then wraps it like a snake onto the square grid.\r\n\r\n    One might create better mappings by specializing this function for a\r\n  square grid.\r\n\r\n    @return {Object} A new mapping as a dict. key is logical qubit id, value is mapped id\r\n   */\r\n  returnNewMapping() {\r\n    // Change old mapping to 1D in order to use LinearChain heuristic\r\n    let old_mapping_1d\r\n    if (this._current_row_major_mapping) {\r\n      old_mapping_1d = {}\r\n      Object.keys(this._current_row_major_mapping).forEach((logical_id) => {\r\n        const mapped_id = this._current_row_major_mapping[logical_id]\r\n        old_mapping_1d[logical_id] = this._map_2d_to_1d[mapped_id]\r\n      })\r\n    } else {\r\n      old_mapping_1d = this._current_row_major_mapping\r\n    }\r\n\r\n    const new_mapping_1d = LinearMapper.returnNewMapping(\r\n      this.num_qubits,\r\n      false,\r\n      this._currently_allocated_ids,\r\n      this._stored_commands,\r\n      old_mapping_1d\r\n    )\r\n\r\n    const new_mapping_2d = {}\r\n    Object.keys(new_mapping_1d).forEach((logical_id) => {\r\n      const mapped_id = new_mapping_1d[logical_id]\r\n      new_mapping_2d[logical_id] = this._map_1d_to_2d[mapped_id]\r\n    })\r\n\r\n    return new_mapping_2d\r\n  }\r\n\r\n  // If swapped (inplace), then return swap operation\r\n  // so that key(element0) < key(element1)\r\n  _compareAndSwap(element0, element1, key) {\r\n    if (key(element0) > key(element1)) {\r\n      const mapped_id0 = (element0.current_column + element0.current_row * this.num_columns)\r\n      const mapped_id1 = (element1.current_column + element1.current_row * this.num_columns)\r\n      const swap_operation = [mapped_id0, mapped_id1]\r\n      // swap elements but update also current position:\r\n      const tmp_0 = element0.final_row\r\n      const tmp_1 = element0.final_column\r\n      const tmp_2 = element0.row_after_step_1\r\n      element0.final_row = element1.final_row\r\n      element0.final_column = element1.final_column\r\n      element0.row_after_step_1 = element1.row_after_step_1\r\n      element1.final_row = tmp_0\r\n      element1.final_column = tmp_1\r\n      element1.row_after_step_1 = tmp_2\r\n      return swap_operation\r\n    }\r\n    return undefined\r\n  }\r\n\r\n  _sortWithinRows(final_positions, key) {\r\n    const swap_operations = []\r\n    for (let row = 0; row < this.num_rows; ++row) {\r\n      let finished_sorting = false\r\n      while (!finished_sorting) {\r\n        finished_sorting = true\r\n        for (let column = 1; column < this.num_columns - 1; column += 2) {\r\n          const element0 = final_positions[row][column]\r\n          const element1 = final_positions[row][column + 1]\r\n          const swap = this._compareAndSwap(element0, element1, key)\r\n          if (typeof swap !== 'undefined') {\r\n            finished_sorting = false\r\n            swap_operations.push(swap)\r\n          }\r\n        }\r\n\r\n        for (let column = 0; column < this.num_columns - 1; column += 2) {\r\n          const element0 = final_positions[row][column]\r\n          const element1 = final_positions[row][column + 1]\r\n          const swap = this._compareAndSwap(element0, element1, key)\r\n          if (typeof swap !== 'undefined') {\r\n            finished_sorting = false\r\n            swap_operations.push(swap)\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return swap_operations\r\n  }\r\n\r\n  _sortWithinColumns(final_positions, key) {\r\n    const swap_operations = []\r\n    for (let column = 0; column < this.num_columns; ++column) {\r\n      let finished_sorting = false\r\n      while (!finished_sorting) {\r\n        finished_sorting = true\r\n        for (let row = 1; row < this.num_rows - 1; row += 2) {\r\n          const element0 = final_positions[row][column]\r\n          const element1 = final_positions[row + 1][column]\r\n          const swap = this._compareAndSwap(element0, element1, key)\r\n          if (typeof swap !== 'undefined') {\r\n            finished_sorting = false\r\n            swap_operations.push(swap)\r\n          }\r\n        }\r\n\r\n        for (let row = 0; row < this.num_rows - 1; row += 2) {\r\n          const element0 = final_positions[row][column]\r\n          const element1 = final_positions[row + 1][column]\r\n          const swap = this._compareAndSwap(element0, element1, key)\r\n          if (typeof swap !== 'undefined') {\r\n            finished_sorting = false\r\n            swap_operations.push(swap)\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return swap_operations\r\n  }\r\n\r\n  /**\r\n  Creates a new mapping and executes possible gates.\r\n\r\n    It first allocates all 0, ..., this.num_qubits-1 mapped qubit ids, if\r\n    they are not already used because we might need them all for the\r\n  swaps. Then it creates a new map, swaps all the qubits to the new map,\r\n    executes all possible gates, and finally deallocates mapped qubit ids\r\nwhich don't store any information.\r\n   */\r\n  _run() {\r\n    const num_of_stored_commands_before = len(this._stored_commands)\r\n    if (!this._currentMapping) {\r\n      this.currentMapping = {}\r\n    } else {\r\n      this._sendPossibleCommands()\r\n      if (len(this._stored_commands) === 0) {\r\n        return\r\n      }\r\n    }\r\n\r\n    const new_row_major_mapping = this.returnNewMapping()\r\n    // Find permutation of matchings with lowest cost\r\n    let swaps\r\n    let lowest_cost\r\n    const matchings_numbers = arrayFromRange(this.num_rows)\r\n    const ps = []\r\n    if (this.num_optimization_steps <= math.factorial(this.num_rows)) {\r\n      for (const looper of permutations(matchings_numbers, this.num_rows)) {\r\n        ps.push(looper)\r\n      }\r\n    } else {\r\n      for (let i = 0; i < this.num_optimization_steps; ++i) {\r\n        ps.push(randomSample(matchings_numbers, this.num_rows))\r\n      }\r\n    }\r\n\r\n    ps.forEach((permutation) => {\r\n      const trial_swaps = this.returnSwaps(\r\n        this._current_row_major_mapping,\r\n        new_row_major_mapping,\r\n        permutation\r\n      )\r\n      if (typeof swaps === 'undefined') {\r\n        swaps = trial_swaps\r\n        lowest_cost = this.optimization_function(trial_swaps)\r\n      } else if (lowest_cost > this.optimization_function(trial_swaps)) {\r\n        swaps = trial_swaps\r\n        lowest_cost = this.optimization_function(trial_swaps)\r\n      }\r\n    })\r\n    if (swaps.length > 0) { // first mapping requires no swaps\r\n      // Allocate all mapped qubit ids (which are not already allocated,\r\n      // i.e., contained in this._currently_allocated_ids)\r\n      let mapped_ids_used = new Set()\r\n      for (const logical_id of this._currently_allocated_ids) {\r\n        mapped_ids_used.add(this._current_row_major_mapping[logical_id])\r\n      }\r\n      const not_allocated_ids = setDifference(setFromRange(this.num_qubits), mapped_ids_used)\r\n      for (const mapped_id of not_allocated_ids) {\r\n        const qb = new BasicQubit(this, this._mapped_ids_to_backend_ids[mapped_id])\r\n        const cmd = new Command(this, new AllocateQubitGate(), tuple([qb]))\r\n        this.send([cmd])\r\n      }\r\n\r\n\r\n      // Send swap operations to arrive at new_mapping:\r\n      swaps.forEach(([qubit_id0, qubit_id1]) => {\r\n        const q0 = new BasicQubit(this, this._mapped_ids_to_backend_ids[qubit_id0])\r\n        const q1 = new BasicQubit(this, this._mapped_ids_to_backend_ids[qubit_id1])\r\n        const cmd = new Command(this, Swap, tuple([q0], [q1]))\r\n        this.send([cmd])\r\n      })\r\n      // Register statistics:\r\n      this.num_mappings += 1\r\n      const depth = return_swap_depth(swaps)\r\n      if (!(depth in this.depth_of_swaps)) {\r\n        this.depth_of_swaps[depth] = 1\r\n      } else {\r\n        this.depth_of_swaps[depth] += 1\r\n      }\r\n      if (!(len(swaps) in this.num_of_swaps_per_mapping)) {\r\n        this.num_of_swaps_per_mapping[len(swaps)] = 1\r\n      } else {\r\n        this.num_of_swaps_per_mapping[len(swaps)] += 1\r\n      }\r\n      // Deallocate all previously mapped ids which we only needed for the\r\n      // swaps:\r\n      mapped_ids_used = new Set()\r\n      for (const logical_id of this._currently_allocated_ids) {\r\n        mapped_ids_used.add(new_row_major_mapping[logical_id])\r\n      }\r\n      const not_needed_anymore = setDifference(setFromRange(this.num_qubits), mapped_ids_used)\r\n      for (const mapped_id of not_needed_anymore) {\r\n        const qb = new BasicQubit(this, this._mapped_ids_to_backend_ids[mapped_id])\r\n        const cmd = new Command(this, new DeallocateQubitGate(), tuple([qb]))\r\n        this.send([cmd])\r\n      }\r\n    }\r\n\r\n    // Change to new map:\r\n    this._current_row_major_mapping = new_row_major_mapping\r\n    const new_mapping = {}\r\n    Object.keys(new_row_major_mapping).forEach((logical_id) => {\r\n      const mapped_id = new_row_major_mapping[logical_id]\r\n      new_mapping[logical_id] = this._mapped_ids_to_backend_ids[mapped_id]\r\n    })\r\n\r\n    this.currentMapping = new_mapping\r\n    // Send possible gates\r\n    this._sendPossibleCommands()\r\n    // Check that mapper actually made progress\r\n    if (len(this._stored_commands) === num_of_stored_commands_before) {\r\n      throw new Error('Mapper is potentially in an infinite loop. '\r\n          + 'It is likely that the algorithm requires '\r\n          + 'too many qubits. Increase the number of '\r\n          + 'qubits for this mapper.')\r\n    }\r\n  }\r\n\r\n  /**\r\n  Sends the stored commands possible without changing the mapping.\r\n\r\n    Note: this._current_row_major_mapping (hence also this.currentMapping) must exist already\r\n   */\r\n  _sendPossibleCommands() {\r\n    const active_ids = new Set(Array.from(this._currently_allocated_ids).map(k => parseInt(k, 10)))\r\n    Object.keys(this._current_row_major_mapping).forEach(logical_id => active_ids.add(parseInt(logical_id, 10)))\r\n\r\n    let new_stored_commands = []\r\n    for (let i = 0; i < this._stored_commands.length; ++i) {\r\n      const cmd = this._stored_commands[i]\r\n      if (len(active_ids) === 0) {\r\n        new_stored_commands = new_stored_commands.concat(this._stored_commands.slice(i))\r\n        break\r\n      }\r\n      if (cmd.gate instanceof AllocateQubitGate) {\r\n        const qid = cmd.qubits[0][0].id\r\n        if (qid in this._current_row_major_mapping) {\r\n          this._currently_allocated_ids.add(qid)\r\n          const mapped_id = this._current_row_major_mapping[qid]\r\n          const qb = new BasicQubit(this, this._mapped_ids_to_backend_ids[mapped_id])\r\n          const new_cmd = new Command(this, new AllocateQubitGate(), tuple([qb]), [], [new LogicalQubitIDTag(qid)])\r\n          this.send([new_cmd])\r\n        } else {\r\n          new_stored_commands.push(cmd)\r\n        }\r\n      } else if (cmd.gate instanceof DeallocateQubitGate) {\r\n        const qid = cmd.qubits[0][0].id\r\n        if (active_ids.has(qid)) {\r\n          const mapped_id = this._current_row_major_mapping[qid]\r\n          const qb = new BasicQubit(this, this._mapped_ids_to_backend_ids[mapped_id])\r\n          const new_cmd = new Command(this, new DeallocateQubitGate(), tuple([qb]), [], [new LogicalQubitIDTag(qid)])\r\n          this._currently_allocated_ids.delete(qid)\r\n          active_ids.delete(qid)\r\n          delete this._current_row_major_mapping[qid]\r\n          delete this._currentMapping[qid]\r\n          this.send([new_cmd])\r\n        } else {\r\n          new_stored_commands.push(cmd)\r\n        }\r\n      } else {\r\n        let send_gate = true\r\n        const mapped_ids = new Set()\r\n\r\n        for (let k = 0; k < cmd.allQubits.length; ++k) {\r\n          const qureg = cmd.allQubits[k]\r\n          for (let j = 0; j < qureg.length; ++j) {\r\n            const qubit = qureg[j]\r\n            if (!active_ids.has(qubit.id)) {\r\n              send_gate = false\r\n              break\r\n            }\r\n            mapped_ids.add(this._current_row_major_mapping[qubit.id])\r\n          }\r\n        }\r\n\r\n\r\n        // Check that mapped ids are nearest neighbour on 2D grid\r\n        if (len(mapped_ids) === 2) {\r\n          const [qb0, qb1] = Array.from(mapped_ids).sort((a, b) => a - b)\r\n          send_gate = false\r\n          if (qb1 - qb0 === this.num_columns) {\r\n            send_gate = true\r\n          } else if (qb1 - qb0 === 1 && (qb1 % this.num_columns !== 0)) {\r\n            send_gate = true\r\n          }\r\n        }\r\n        if (send_gate) {\r\n          // Note: This sends the cmd correctly with the backend ids\r\n          //       as it looks up the mapping in this.currentMapping\r\n          //       and not our internal mapping\r\n          //       this._current_row_major_mapping\r\n          this.sendCMDWithMappedIDs(cmd)\r\n        } else {\r\n          cmd.allQubits.forEach(qureg => qureg.forEach(qubit => active_ids.delete(qubit.id)))\r\n          new_stored_commands.push(cmd)\r\n        }\r\n      }\r\n    }\r\n\r\n    this._stored_commands = new_stored_commands\r\n  }\r\n\r\n  /**\r\n  Receives a command list and, for each command, stores it until\r\n  we do a mapping (FlushGate || Cache of stored commands is full).\r\n   @param {Command[]} command_list  list of commands to receive.\r\n  */\r\n  receive(command_list) {\r\n    command_list.forEach((cmd) => {\r\n      if (cmd.gate instanceof FlushGate) {\r\n        while (this._stored_commands.length > 0) {\r\n          this._run()\r\n        }\r\n        this.send([cmd])\r\n      } else {\r\n        this._stored_commands.push(cmd)\r\n      }\r\n\r\n      if (this._stored_commands.length >= this.storage) {\r\n        this._run()\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n  Returns the swap operation to change mapping\r\n\r\n    @param {Object} old_mapping dict keys are logical ids and values are mapped qubit ids\r\n    @param {Object} new_mapping dict keys are logical ids and values are mapped qubit ids\r\n    @param {Array.<number[]>} permutation list of int from 0, 1, ..., this.num_rows-1. It is\r\n      used to permute the found perfect matchings. Default is None which keeps the original order.\r\n    @return {Array.<number[]>} List of tuples. Each tuple is a swap operation which needs to be\r\n      applied. Tuple contains the two mapped qubit ids for the Swap.\r\n   */\r\n  returnSwaps(old_mapping, new_mapping, permutation) {\r\n    if (typeof permutation === 'undefined') {\r\n      permutation = arrayFromRange(this.num_rows)\r\n    }\r\n    let swap_operations = []\r\n\r\n    class Position {\r\n      constructor(current_row, current_column, final_row, final_column, row_after_step_1) {\r\n        this.current_row = current_row\r\n        this.current_column = current_column\r\n        this.final_row = final_row\r\n        this.final_column = final_column\r\n        this.row_after_step_1 = row_after_step_1\r\n      }\r\n    }\r\n    // final_positions contains info containers\r\n    // final_position[i][j] contains info container with\r\n    // current_row == i and current_column == j\r\n    const final_positions = new Array(this.num_rows)\r\n    for (let i = 0; i < this.num_rows; ++i) {\r\n      final_positions[i] = new Array(this.num_columns)\r\n    }\r\n\r\n    // move qubits which are in both mappings\r\n    const used_mapped_ids = new Set()\r\n\r\n    Object.keys(old_mapping).forEach((logical_id) => {\r\n      if (logical_id in new_mapping) {\r\n        used_mapped_ids.add(new_mapping[logical_id])\r\n        const old_column = old_mapping[logical_id] % this.num_columns\r\n        const old_row = Math.floor(old_mapping[logical_id] / this.num_columns)\r\n        const new_column = new_mapping[logical_id] % this.num_columns\r\n        const new_row = Math.floor(new_mapping[logical_id] / this.num_columns)\r\n        const info_container = new Position(old_row,\r\n          old_column,\r\n          new_row,\r\n          new_column)\r\n        final_positions[old_row][old_column] = info_container\r\n      }\r\n    })\r\n    // exchange all remaining None with the not yet used mapped ids\r\n    const all_ids = setFromRange(this.num_qubits)\r\n    let not_used_mapped_ids = Array.from(setDifference(all_ids, used_mapped_ids))\r\n    not_used_mapped_ids = not_used_mapped_ids.sort((a, b) => b - a)\r\n\r\n    for (let row = 0; row < this.num_rows; ++row) {\r\n      for (let column = 0; column < this.num_columns; ++column) {\r\n        if (typeof final_positions[row][column] === 'undefined') {\r\n          const mapped_id = not_used_mapped_ids.pop()\r\n          const new_column = mapped_id % this.num_columns\r\n          const new_row = Math.floor(mapped_id / this.num_columns)\r\n          const info_container = new Position(row, column, new_row, new_column)\r\n          final_positions[row][column] = info_container\r\n        }\r\n      }\r\n    }\r\n\r\n    assert(len(not_used_mapped_ids) === 0)\r\n    const positions = []\r\n    final_positions.forEach(row => positions.push(row.map(item => item.final_column)))\r\n    const matchings = NativeImpl.returnNewSwap(this.num_rows, this.num_columns, positions)\r\n    const offset = this.num_columns\r\n    // permute the matchings\r\n    const tmp = matchings.map(looper => Object.assign({}, looper))\r\n    for (let i = 0; i < this.num_rows; ++i) {\r\n      matchings[i] = tmp[permutation[i]]\r\n    }\r\n    // Assign row_after_step_1\r\n    for (let column = 0; column < this.num_columns; ++column) {\r\n      for (let row_after_step_1 = 0; row_after_step_1 < this.num_rows; ++row_after_step_1) {\r\n        const dest_column = matchings[row_after_step_1][column] - offset\r\n        let best_element\r\n        for (let row = 0; row < this.num_rows; ++row) {\r\n          const element = final_positions[row][column]\r\n          if (typeof element.row_after_step_1 !== 'undefined') {\r\n            continue\r\n          } else if (element.final_column === dest_column) {\r\n            if (typeof best_element === 'undefined') {\r\n              best_element = element\r\n            } else if (best_element.final_row > element.final_row) {\r\n              best_element = element\r\n            }\r\n          }\r\n        }\r\n        best_element.row_after_step_1 = row_after_step_1\r\n      }\r\n    }\r\n\r\n    // 2. Sort inside all the rows\r\n    let swaps = this._sortWithinColumns(final_positions, x => x.row_after_step_1)\r\n    swap_operations = swap_operations.concat(swaps)\r\n    // 3. Sort inside all the columns\r\n    swaps = this._sortWithinRows(final_positions, x => x.final_column)\r\n    swap_operations = swap_operations.concat(swaps)\r\n    // 4. Sort inside all the rows\r\n    swaps = this._sortWithinColumns(final_positions, x => x.final_row)\r\n    swap_operations = swap_operations.concat(swaps)\r\n    return swap_operations\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/cengines/twodmapper.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 495,
    "kind": "class",
    "name": "GridMapper",
    "memberof": "src/cengines/twodmapper.js",
    "static": true,
    "longname": "src/cengines/twodmapper.js~GridMapper",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/cengines/twodmapper.js",
    "importStyle": "GridMapper",
    "description": "Mapper to a 2-D grid graph.\n\nMapped qubits on the grid are numbered in row-major order. E.g. for\n3 rows and 2 columns:\n\n0 - 1\n|   |\n2 - 3\n|   |\n4 - 5\n\nThe numbers are the mapped qubit ids. The backend might number\nthe qubits on the grid differently (e.g. not row-major), we call these\nbackend qubit ids. If the backend qubit ids are not row-major, one can\npass a dictionary translating from our row-major mapped ids to these\nbackend ids.\n\nNote: The algorithm sorts twice inside each column and once inside each\nrow.\n\nAttributes:\ncurrent_mapping:  Stores the mapping: key is logical qubit id, value\nis backend qubit id.\nstorage(int): Number of gate it caches before mapping.\nnum_rows(int): Number of rows in the grid\nnum_columns(int): Number of columns in the grid\nnum_qubits(int): num_rows x num_columns = number of qubits\nnum_mappings (int): Number of times the mapper changed the mapping\ndepth_of_swaps (dict): Key are circuit depth of swaps, value is the\nnumber of such mappings which have been\napplied\nnum_of_swaps_per_mapping (dict): Key are the number of swaps per\nmapping, value is the number of such\nmappings which have been applied",
    "lineNumber": 67,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "GridMapper"
      }
    ],
    "interface": false,
    "extends": [
      "src/cengines/basicmapper.js~BasicMapperEngine"
    ]
  },
  {
    "__docId__": 496,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 85,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": "Initialize a GridMapper compiler engine."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "{num_rows: number, num_columns: number, mapped_ids_to_backend_ids: Object, storage: number, optimization_function: function, num_optimization_steps: number}"
        ],
        "spread": false,
        "optional": false,
        "name": "args",
        "description": "num_rows(int): Number of rows in the grid\nnum_columns(int): Number of columns in the grid.\nmapped_ids_to_backend_ids(dict): Stores a mapping from mapped ids which are 0,...,this.num_qubits-1\nin row-major order on the grid to the corresponding qubit ids of the backend.\nKey: mapped id. Value: corresponding backend id. Default is None\nwhich means backend ids are identical to mapped ids.\nstorage: Number of gates to temporarily store\noptimization_function: Function which takes a list of swaps and returns a cost value. Mapper chooses a\npermutation which minimizes this cost. Default optimizes for circuit depth.\nnum_optimization_steps(int): Number of different permutations to of the matching to try and minimize the cost."
      }
    ],
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "if incorrect `mapped_ids_to_backend_ids` parameter"
      }
    ]
  },
  {
    "__docId__": 497,
    "kind": "member",
    "name": "num_rows",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#num_rows",
    "access": "public",
    "description": null,
    "lineNumber": 95,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 498,
    "kind": "member",
    "name": "num_columns",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#num_columns",
    "access": "public",
    "description": null,
    "lineNumber": 96,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 499,
    "kind": "member",
    "name": "num_qubits",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#num_qubits",
    "access": "public",
    "description": null,
    "lineNumber": 97,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 500,
    "kind": "member",
    "name": "_mapped_ids_to_backend_ids",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#_mapped_ids_to_backend_ids",
    "access": "private",
    "description": null,
    "lineNumber": 100,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 502,
    "kind": "member",
    "name": "_backend_ids_to_mapped_ids",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#_backend_ids_to_mapped_ids",
    "access": "private",
    "description": null,
    "lineNumber": 113,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 503,
    "kind": "member",
    "name": "_current_row_major_mapping",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#_current_row_major_mapping",
    "access": "private",
    "description": null,
    "lineNumber": 122,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 504,
    "kind": "member",
    "name": "storage",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#storage",
    "access": "public",
    "description": null,
    "lineNumber": 123,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 505,
    "kind": "member",
    "name": "optimization_function",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#optimization_function",
    "access": "public",
    "description": null,
    "lineNumber": 124,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 506,
    "kind": "member",
    "name": "num_optimization_steps",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#num_optimization_steps",
    "access": "public",
    "description": null,
    "lineNumber": 125,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 507,
    "kind": "member",
    "name": "_stored_commands",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#_stored_commands",
    "access": "private",
    "description": null,
    "lineNumber": 133,
    "undocument": true,
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 508,
    "kind": "member",
    "name": "_currently_allocated_ids",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#_currently_allocated_ids",
    "access": "private",
    "description": null,
    "lineNumber": 137,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 509,
    "kind": "member",
    "name": "_map_2d_to_1d",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#_map_2d_to_1d",
    "access": "private",
    "description": null,
    "lineNumber": 141,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 510,
    "kind": "member",
    "name": "_map_1d_to_2d",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#_map_1d_to_2d",
    "access": "private",
    "description": null,
    "lineNumber": 142,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 511,
    "kind": "member",
    "name": "num_mappings",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#num_mappings",
    "access": "public",
    "description": null,
    "lineNumber": 159,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 512,
    "kind": "member",
    "name": "depth_of_swaps",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#depth_of_swaps",
    "access": "public",
    "description": null,
    "lineNumber": 160,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 513,
    "kind": "member",
    "name": "num_of_swaps_per_mapping",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#num_of_swaps_per_mapping",
    "access": "public",
    "description": null,
    "lineNumber": 161,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 514,
    "kind": "get",
    "name": "currentMapping",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#currentMapping",
    "access": "public",
    "description": null,
    "lineNumber": 164,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 515,
    "kind": "set",
    "name": "currentMapping",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#currentMapping",
    "access": "public",
    "description": null,
    "lineNumber": 168,
    "undocument": true
  },
  {
    "__docId__": 516,
    "kind": "member",
    "name": "_currentMapping",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#_currentMapping",
    "access": "private",
    "description": null,
    "lineNumber": 169,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 519,
    "kind": "method",
    "name": "isAvailable",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#isAvailable",
    "access": "public",
    "description": null,
    "lineNumber": 184,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 520,
    "kind": "method",
    "name": "returnNewMapping",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#returnNewMapping",
    "access": "public",
    "description": "Returns a new mapping of the qubits.\n\nIt goes through this._saved_commands and tries to find a\nmapping to apply these gates on a first come first served basis.\nIt reuses the function of a 1D mapper and creates a mapping for a\n1D linear chain and then wraps it like a snake onto the square grid.\n\nOne might create better mappings by specializing this function for a\nsquare grid.",
    "lineNumber": 203,
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "A new mapping as a dict. key is logical qubit id, value is mapped id"
    },
    "params": []
  },
  {
    "__docId__": 521,
    "kind": "method",
    "name": "_compareAndSwap",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#_compareAndSwap",
    "access": "private",
    "description": null,
    "lineNumber": 235,
    "undocument": true,
    "params": [
      {
        "name": "element0",
        "types": [
          "*"
        ]
      },
      {
        "name": "element1",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 522,
    "kind": "method",
    "name": "_sortWithinRows",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#_sortWithinRows",
    "access": "private",
    "description": null,
    "lineNumber": 255,
    "undocument": true,
    "params": [
      {
        "name": "final_positions",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 523,
    "kind": "method",
    "name": "_sortWithinColumns",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#_sortWithinColumns",
    "access": "private",
    "description": null,
    "lineNumber": 285,
    "undocument": true,
    "params": [
      {
        "name": "final_positions",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 524,
    "kind": "method",
    "name": "_run",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#_run",
    "access": "private",
    "description": "Creates a new mapping and executes possible gates.\n\nIt first allocates all 0, ..., this.num_qubits-1 mapped qubit ids, if\nthey are not already used because we might need them all for the\nswaps. Then it creates a new map, swaps all the qubits to the new map,\nexecutes all possible gates, and finally deallocates mapped qubit ids\nwhich don't store any information.",
    "lineNumber": 324,
    "params": [],
    "return": null
  },
  {
    "__docId__": 529,
    "kind": "method",
    "name": "_sendPossibleCommands",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#_sendPossibleCommands",
    "access": "private",
    "description": "Sends the stored commands possible without changing the mapping.\n\nNote: this._current_row_major_mapping (hence also this.currentMapping) must exist already",
    "lineNumber": 439,
    "params": [],
    "return": null
  },
  {
    "__docId__": 531,
    "kind": "method",
    "name": "receive",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#receive",
    "access": "public",
    "description": "Receives a command list and, for each command, stores it until\nwe do a mapping (FlushGate || Cache of stored commands is full).",
    "lineNumber": 523,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command[]"
        ],
        "spread": false,
        "optional": false,
        "name": "command_list",
        "description": "list of commands to receive."
      }
    ],
    "return": null
  },
  {
    "__docId__": 532,
    "kind": "method",
    "name": "returnSwaps",
    "memberof": "src/cengines/twodmapper.js~GridMapper",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cengines/twodmapper.js~GridMapper#returnSwaps",
    "access": "public",
    "description": "Returns the swap operation to change mapping",
    "lineNumber": 550,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "old_mapping",
        "description": "dict keys are logical ids and values are mapped qubit ids"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "new_mapping",
        "description": "dict keys are logical ids and values are mapped qubit ids"
      },
      {
        "nullable": null,
        "types": [
          "Array.<number[]>"
        ],
        "spread": false,
        "optional": false,
        "name": "permutation",
        "description": "list of int from 0, 1, ..., this.num_rows-1. It is\nused to permute the found perfect matchings. Default is None which keeps the original order."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array.<number[]>"
      ],
      "spread": false,
      "description": "List of tuples. Each tuple is a swap operation which needs to be\napplied. Tuple contains the two mapped qubit ids for the Swap."
    }
  },
  {
    "__docId__": 533,
    "kind": "file",
    "name": "src/cengines/twodmapper.spec.js",
    "content": "import {expect} from 'chai'\r\nimport {permutations} from 'itertools'\r\nimport deepEqual from 'deep-eql'\r\nimport GridMapper from './twodmapper';\r\nimport {BasicQubit} from '../types/qubit';\r\nimport {\r\n  Allocate, BasicGate, Deallocate, FlushGate, X\r\n} from '../ops';\r\nimport Command from '../ops/command';\r\nimport {tuple} from '../libs/util';\r\nimport MainEngine from './main';\r\nimport {DummyEngine} from './testengine';\r\nimport {arrayFromRange, len, randomSample} from '../libs/polyfill';\r\nimport {LogicalQubitIDTag} from '../meta';\r\nimport LocalOptimizer from './optimize';\r\n\r\ndescribe('twodmapper test', () => {\r\n  it('should test_is_available', () => {\r\n    const mapper = new GridMapper({num_rows: 2, num_columns: 2})\r\n    const qb0 = new BasicQubit(null, 0)\r\n    const qb1 = new BasicQubit(null, 1)\r\n    const qb2 = new BasicQubit(null, 2)\r\n    const cmd0 = new Command(null, new BasicGate(), tuple([qb0]))\r\n    expect(mapper.isAvailable(cmd0)).to.equal(true)\r\n    const cmd1 = new Command(null, new BasicGate(), tuple([qb0]), [qb1])\r\n    expect(mapper.isAvailable(cmd1)).to.equal(true)\r\n    const cmd2 = new Command(null, new BasicGate(), tuple([qb0], [qb1, qb2]))\r\n    expect(!mapper.isAvailable(cmd2)).to.equal(true)\r\n    const cmd3 = new Command(null, new BasicGate(), tuple([qb0], [qb1]), [qb2])\r\n    expect(!mapper.isAvailable(cmd3)).to.equal(true)\r\n  });\r\n\r\n  it('should test_wrong_init_mapped_ids_to_backend_ids', () => {\r\n    expect(() => {\r\n      const test = {\r\n        0: 1, 1: 0, 2: 2, 3: 3, 4: 4\r\n      }\r\n      new GridMapper({\r\n        num_rows: 2,\r\n        num_columns: 3,\r\n        mapped_ids_to_backend_ids: test\r\n      })\r\n    }).to.throw()\r\n\r\n    expect(() => {\r\n      const test = {\r\n        0: 1, 1: 0, 2: 2, 3: 3, 4: 4, 5: 2\r\n      }\r\n      new GridMapper({\r\n        num_rows: 2,\r\n        num_columns: 3,\r\n        mapped_ids_to_backend_ids: test\r\n      })\r\n    }).to.throw()\r\n  });\r\n\r\n  it('should test_resetting_mapping_to_none', () => {\r\n    const mapper = new GridMapper({num_rows: 2, num_columns: 3})\r\n    mapper.currentMapping = {0: 1}\r\n    expect(mapper._current_row_major_mapping).to.deep.equal({0: 1})\r\n    mapper.currentMapping = null\r\n    expect(mapper._current_row_major_mapping).to.equal(null)\r\n  });\r\n\r\n  it('should test_return_new_mapping', () => {\r\n    const different_backend_ids = [false, true]\r\n    different_backend_ids.forEach((different_backend_id) => {\r\n      let map_to_backend_ids\r\n      if (different_backend_id) {\r\n        map_to_backend_ids = {\r\n          0: 21,\r\n          1: 32,\r\n          2: 1,\r\n          3: 4,\r\n          4: 5,\r\n          5: 6,\r\n          6: 10,\r\n          7: 7,\r\n          8: 0,\r\n          9: 56,\r\n          10: 55,\r\n          11: 9\r\n        }\r\n      } else {\r\n        map_to_backend_ids = null\r\n      }\r\n      const mapper = new GridMapper({\r\n        num_rows: 4,\r\n        num_columns: 3,\r\n        mapped_ids_to_backend_ids: map_to_backend_ids\r\n      })\r\n      const eng = new MainEngine(new DummyEngine(), [mapper])\r\n      const linear_chain_ids = [33, 22, 11, 2, 3, 0, 6, 7, 9, 12, 4, 88]\r\n      mapper._stored_commands = []\r\n      for (let i = 0; i < 12; ++i) {\r\n        const qb = new BasicQubit(null, linear_chain_ids[i])\r\n        const cmd = new Command(null, Allocate, tuple([qb]))\r\n        mapper._stored_commands.push(cmd)\r\n      }\r\n      for (let i = 0; i < 11; ++i) {\r\n        const qb0 = new BasicQubit(null, linear_chain_ids[i])\r\n        const qb1 = new BasicQubit(null, linear_chain_ids[i + 1])\r\n        const cmd = new Command(null, X, tuple([qb0]), [qb1])\r\n        mapper._stored_commands.push(cmd)\r\n      }\r\n      const new_mapping = mapper.returnNewMapping()\r\n      const possible_solution_1 = {\r\n        33: 0,\r\n        22: 1,\r\n        11: 2,\r\n        2: 5,\r\n        3: 4,\r\n        0: 3,\r\n        6: 6,\r\n        7: 7,\r\n        9: 8,\r\n        12: 11,\r\n        4: 10,\r\n        88: 9\r\n      }\r\n      const possible_solution_2 = {\r\n        88: 0,\r\n        4: 1,\r\n        12: 2,\r\n        9: 5,\r\n        7: 4,\r\n        6: 3,\r\n        0: 6,\r\n        3: 7,\r\n        2: 8,\r\n        11: 11,\r\n        22: 10,\r\n        33: 9\r\n      }\r\n      const f = deepEqual(new_mapping, possible_solution_1) || deepEqual(new_mapping, possible_solution_2)\r\n      expect(f).to.equal(true)\r\n      eng.flush()\r\n      if (different_backend_id) {\r\n        const transformed_sol1 = {}\r\n        Object.keys(possible_solution_1).forEach((logical_id) => {\r\n          const mapped_id = possible_solution_1[logical_id]\r\n          transformed_sol1[logical_id] = map_to_backend_ids[mapped_id]\r\n        })\r\n        const transformed_sol2 = {}\r\n        Object.keys(possible_solution_2).forEach((logical_id) => {\r\n          const mapped_id = possible_solution_2[logical_id]\r\n          transformed_sol2[logical_id] = map_to_backend_ids[mapped_id]\r\n        })\r\n\r\n        expect(deepEqual(mapper.currentMapping, transformed_sol1) || deepEqual(mapper.currentMapping, transformed_sol2)).to.equal(true)\r\n      } else {\r\n        expect(deepEqual(mapper.currentMapping, possible_solution_1) || deepEqual(mapper.currentMapping, possible_solution_2)).to.equal(true)\r\n      }\r\n    })\r\n  });\r\n\r\n  it('should test_return_swaps_random', () => {\r\n    const data = [\r\n      [2, 2, 0, 0, 0], [3, 4, 1, 0, 0], [4, 3, 2, 0, 0],\r\n      [5, 5, 3, 0, 0], [5, 3, 4, 3, 0], [4, 4, 5, 0, 3],\r\n      [6, 6, 7, 2, 3]]\r\n    data.forEach(([num_rows, num_columns, seed, none_old, none_new]) => {\r\n      const num_qubits = num_rows * num_columns\r\n      const range = arrayFromRange(num_qubits)\r\n      const old_chain = randomSample(range, num_qubits)\r\n      const new_chain = randomSample(range, num_qubits)\r\n      const old_mapping = {}\r\n      const new_mapping = {}\r\n      for (let i = 0; i < num_qubits; ++i) {\r\n        old_mapping[old_chain[i]] = i\r\n        new_mapping[new_chain[i]] = i\r\n      }\r\n\r\n      // Remove certain elements from mappings:\r\n      const old_none_ids = new Set(randomSample(range, none_old))\r\n      if (none_old !== 0) {\r\n        for (const logical_id of old_none_ids) {\r\n          delete old_mapping[logical_id]\r\n        }\r\n      }\r\n      const new_none_ids = new Set(randomSample(range, none_new))\r\n      if (none_new !== 0) {\r\n        for (const logical_id of new_none_ids) {\r\n          delete new_mapping[logical_id]\r\n        }\r\n      }\r\n      const mapper = new GridMapper({num_rows, num_columns})\r\n      const swaps = mapper.returnSwaps(old_mapping, new_mapping)\r\n      // Check that Swaps are allowed\r\n      const all_allowed_swaps = new Set()\r\n      for (let row = 0; row < num_rows; ++row) {\r\n        for (let column = 0; column < num_columns - 1; ++column) {\r\n          const qb_id = row * num_columns + column\r\n          all_allowed_swaps.add([qb_id, qb_id + 1])\r\n        }\r\n      }\r\n      for (let row = 0; row < num_rows - 1; ++row) {\r\n        for (let column = 0; column < num_columns; ++column) {\r\n          const qb_id = row * num_columns + column\r\n          all_allowed_swaps.add([qb_id, qb_id + num_columns])\r\n        }\r\n      }\r\n\r\n      function arrayInSet(set, array) {\r\n        for (const looper of set) {\r\n          if (deepEqual(looper, array)) {\r\n            return true\r\n          }\r\n        }\r\n        return false\r\n      }\r\n      swaps.forEach(swap => expect(arrayInSet(all_allowed_swaps, swap)).to.equal(true))\r\n\r\n      const test_chain = old_chain.slice(0)\r\n      swaps.forEach(([pos0, pos1]) => {\r\n        const tmp = test_chain[pos0]\r\n        test_chain[pos0] = test_chain[pos1]\r\n        test_chain[pos1] = tmp\r\n      })\r\n\r\n      expect(len(test_chain)).to.equal(len(new_chain))\r\n\r\n      new_chain.forEach((looper, i) => {\r\n        if (looper in old_mapping && looper in new_mapping) {\r\n          expect(test_chain[i]).to.equal(looper)\r\n        }\r\n      })\r\n    })\r\n  })\r\n\r\n  it('should test_send_possible_commands', () => {\r\n    const different_backend_ids = [false, true]\r\n    different_backend_ids.forEach((different_backend_id) => {\r\n      let map_to_backend_ids\r\n      if (different_backend_id) {\r\n        map_to_backend_ids = {\r\n          0: 21,\r\n          1: 32,\r\n          2: 1,\r\n          3: 4,\r\n          4: 5,\r\n          5: 6,\r\n          6: 10,\r\n          7: 7\r\n        }\r\n      }\r\n      const mapper = new GridMapper({\r\n        num_rows: 2,\r\n        num_columns: 4,\r\n        mapped_ids_to_backend_ids: map_to_backend_ids\r\n      })\r\n      const backend = new DummyEngine(true)\r\n      backend.isLastEngine = true\r\n      mapper.next = backend\r\n      // mapping is identical except 5 <-> 0\r\n      if (different_backend_id) {\r\n        mapper.currentMapping = {\r\n          0: 6,\r\n          1: 32,\r\n          2: 1,\r\n          3: 4,\r\n          4: 5,\r\n          5: 21,\r\n          6: 10,\r\n          7: 7\r\n        }\r\n      } else {\r\n        mapper.currentMapping = {\r\n          5: 0,\r\n          1: 1,\r\n          2: 2,\r\n          3: 3,\r\n          4: 4,\r\n          0: 5,\r\n          6: 6,\r\n          7: 7\r\n        }\r\n      }\r\n      const neighbours = [[5, 1], [1, 2], [2, 3], [4, 0], [0, 6], [6, 7],\r\n        [5, 4], [1, 0], [2, 6], [3, 7]]\r\n      neighbours.forEach(([qb0_id, qb1_id]) => {\r\n        const qb0 = new BasicQubit(null, qb0_id)\r\n        const qb1 = new BasicQubit(null, qb1_id)\r\n        const cmd1 = new Command(null, X, tuple([qb0]), [qb1])\r\n        const cmd2 = new Command(null, X, tuple([qb1]), [qb0])\r\n        mapper._stored_commands = [cmd1, cmd2]\r\n        mapper._sendPossibleCommands()\r\n        expect(len(mapper._stored_commands)).to.equal(0)\r\n      })\r\n\r\n      const r = arrayFromRange(8)\r\n      function arrayInSuperArray(sup, array) {\r\n        return sup.findIndex(looper => deepEqual(looper, array)) !== -1\r\n      }\r\n      for (const looper of permutations(r, 2)) {\r\n        const [qb0_id, qb1_id] = looper\r\n        if (!arrayInSuperArray(neighbours, [qb0_id, qb1_id]) && !arrayInSuperArray(neighbours, [qb1_id, qb0_id])) {\r\n          const qb0 = new BasicQubit(null, qb0_id)\r\n          const qb1 = new BasicQubit(null, qb1_id)\r\n          const cmd = new Command(null, X, tuple([qb0]), [qb1])\r\n          mapper._stored_commands = [cmd]\r\n          mapper._sendPossibleCommands()\r\n          expect(len(mapper._stored_commands)).to.equal(1)\r\n        }\r\n      }\r\n    })\r\n  });\r\n\r\n  it('should test_send_possible_commands_allocate', () => {\r\n    const different_backend_ids = [false, true]\r\n    different_backend_ids.forEach((different_backend_id) => {\r\n      let map_to_backend_ids\r\n      if (different_backend_id) {\r\n        map_to_backend_ids = {\r\n          0: 21, 1: 32, 2: 3, 3: 4, 4: 5, 5: 6\r\n        }\r\n      }\r\n      const mapper = new GridMapper({\r\n        num_rows: 3,\r\n        num_columns: 2,\r\n        mapped_ids_to_backend_ids: map_to_backend_ids\r\n      })\r\n      const backend = new DummyEngine(true)\r\n      backend.isLastEngine = true\r\n      mapper.next = backend\r\n      const qb0 = new BasicQubit(null, 0)\r\n      const cmd0 = new Command(null, Allocate, tuple([qb0]), [], [])\r\n      mapper._stored_commands = [cmd0]\r\n      mapper._currently_allocated_ids = new Set([10])\r\n      // not in mapping:\r\n      mapper.currentMapping = {}\r\n      expect(len(backend.receivedCommands)).to.equal(0)\r\n      mapper._sendPossibleCommands()\r\n      expect(len(backend.receivedCommands)).to.equal(0)\r\n      expect(mapper._stored_commands).to.deep.equal([cmd0])\r\n      // in mapping:\r\n      mapper.currentMapping = {0: 3}\r\n      mapper._sendPossibleCommands()\r\n      expect(len(mapper._stored_commands)).to.equal(0)\r\n      // Only self._run() sends Allocate gates\r\n      const mapped0 = new BasicQubit(null, 3)\r\n      const received_cmd = new Command(mapper, Allocate, tuple([mapped0]), [], [new LogicalQubitIDTag(0)])\r\n      expect(backend.receivedCommands[0].equal(received_cmd)).to.equal(true)\r\n      expect(mapper._currently_allocated_ids).to.deep.equal(new Set([10, 0]))\r\n    })\r\n  });\r\n\r\n  it('should test_send_possible_commands_deallocate', () => {\r\n    const different_backend_ids = [false, true]\r\n    different_backend_ids.forEach((different_backend_id) => {\r\n      let map_to_backend_ids\r\n      if (different_backend_id) {\r\n        map_to_backend_ids = {\r\n          0: 21, 1: 32, 2: 3, 3: 4, 4: 5, 5: 6\r\n        }\r\n      }\r\n      const mapper = new GridMapper({\r\n        num_rows: 3,\r\n        num_columns: 2,\r\n        mapped_ids_to_backend_ids: map_to_backend_ids\r\n      })\r\n      const backend = new DummyEngine(true)\r\n      backend.isLastEngine = true\r\n      mapper.next = backend\r\n      const qb0 = new BasicQubit(null, 0)\r\n      const cmd0 = new Command(null, Deallocate, tuple([qb0]), [], [])\r\n      mapper._stored_commands = [cmd0]\r\n      mapper.currentMapping = {}\r\n      mapper._currently_allocated_ids = new Set([10])\r\n      // not yet allocated:\r\n      mapper._sendPossibleCommands()\r\n      expect(len(backend.receivedCommands)).to.equal(0)\r\n      expect(mapper._stored_commands).to.deep.equal([cmd0])\r\n      // allocated:\r\n      mapper.currentMapping = {0: 3}\r\n      mapper._currently_allocated_ids.add(0)\r\n      mapper._sendPossibleCommands()\r\n      expect(len(backend.receivedCommands)).to.equal(1)\r\n      expect(len(mapper._stored_commands)).to.equal(0)\r\n      expect(mapper.currentMapping).to.deep.equal({})\r\n      expect(mapper._currently_allocated_ids).to.deep.equal(new Set([10]))\r\n    })\r\n  })\r\n\r\n  it('should test_send_possible_commands_keep_remaining_gates', () => {\r\n    const different_backend_ids = [false, true]\r\n    different_backend_ids.forEach((different_backend_id) => {\r\n      let map_to_backend_ids\r\n      if (different_backend_id) {\r\n        map_to_backend_ids = {\r\n          0: 21, 1: 32, 2: 3, 3: 0, 4: 5, 5: 6\r\n        }\r\n      }\r\n      const mapper = new GridMapper({\r\n        num_rows: 3,\r\n        num_columns: 2,\r\n        mapped_ids_to_backend_ids: map_to_backend_ids\r\n      });\r\n      const backend = new DummyEngine(true)\r\n      backend.isLastEngine = true\r\n      mapper.next = backend\r\n      const qb0 = new BasicQubit(null, 0)\r\n      const qb1 = new BasicQubit(null, 1)\r\n      const cmd0 = new Command(null, Allocate, tuple([qb0]), [], [])\r\n      const cmd1 = new Command(null, Deallocate, tuple([qb0]), [], [])\r\n      const cmd2 = new Command(null, Allocate, tuple([qb1]), [], [])\r\n\r\n      mapper._stored_commands = [cmd0, cmd1, cmd2]\r\n      mapper.currentMapping = {0: 0}\r\n      mapper._sendPossibleCommands()\r\n      expect(mapper._stored_commands).to.deep.equal([cmd2])\r\n    })\r\n  });\r\n\r\n  it('should test_send_possible_commands_one_inactive_qubit', () => {\r\n    const different_backend_ids = [false, true]\r\n    different_backend_ids.forEach((different_backend_id) => {\r\n      let map_to_backend_ids\r\n      if (different_backend_id) {\r\n        map_to_backend_ids = {\r\n          0: 21, 1: 32, 2: 3, 3: 0, 4: 5, 5: 6\r\n        }\r\n      }\r\n      const mapper = new GridMapper({\r\n        num_rows: 3,\r\n        num_columns: 2,\r\n        mapped_ids_to_backend_ids: map_to_backend_ids\r\n      })\r\n      const backend = new DummyEngine(true)\r\n      backend.isLastEngine = true\r\n      mapper.next = backend\r\n      const qb0 = new BasicQubit(null, 0)\r\n      const qb1 = new BasicQubit(null, 1)\r\n      const cmd0 = new Command(null, Allocate, tuple([qb0]), [], [])\r\n      const cmd1 = new Command(null, X, tuple([qb0]), [qb1])\r\n      mapper._stored_commands = [cmd0, cmd1]\r\n      mapper.currentMapping = {0: 0}\r\n      mapper._sendPossibleCommands()\r\n      expect(mapper._stored_commands).to.deep.equal([cmd1])\r\n    })\r\n  });\r\n\r\n  it('should test_run_and_receive', () => {\r\n    const different_backend_ids = [false, true]\r\n    const num_optimization_steps = [1, 10]\r\n    different_backend_ids.forEach((different_backend_id) => {\r\n      num_optimization_steps.forEach((num_optimization_step) => {\r\n        let map_to_backend_ids\r\n        if (different_backend_id) {\r\n          map_to_backend_ids = {\r\n            0: 21, 1: 32, 2: 3, 3: 0\r\n          }\r\n        }\r\n\r\n        function choose_last_permutation(swaps) {\r\n          choose_last_permutation.counter -= 1\r\n          return choose_last_permutation.counter\r\n        }\r\n\r\n        choose_last_permutation.counter = 100\r\n        const mapper = new GridMapper(\r\n          {\r\n            num_rows: 2,\r\n            num_columns: 2,\r\n            mapped_ids_to_backend_ids: map_to_backend_ids,\r\n            optimization_function: choose_last_permutation,\r\n            num_optimization_steps: num_optimization_step\r\n          }\r\n        )\r\n        const backend = new DummyEngine(true)\r\n        backend.isLastEngine = true\r\n        mapper.next = backend\r\n        const qb0 = new BasicQubit(null, 0)\r\n        const qb1 = new BasicQubit(null, 1)\r\n        const qb2 = new BasicQubit(null, 2)\r\n        const qb3 = new BasicQubit(null, 3)\r\n        const cmd0 = new Command(null, Allocate, tuple([qb0], ))\r\n        const cmd1 = new Command(null, Allocate, tuple([qb1], ))\r\n        const cmd2 = new Command(null, Allocate, tuple([qb2], ))\r\n        const cmd3 = new Command(null, Allocate, tuple([qb3], ))\r\n        const cmd4 = new Command(null, X, tuple([qb0]), [qb1])\r\n        const cmd5 = new Command(null, X, tuple([qb1]), [qb3])\r\n        const cmd6 = new Command(null, X, tuple([qb3]), [qb2])\r\n        const cmd7 = new Command(null, X, tuple([qb0]), [qb2])\r\n        const cmd8 = new Command(null, Deallocate, tuple([qb1], ))\r\n        const all_cmd = [cmd0, cmd1, cmd2, cmd3, cmd4, cmd5, cmd6, cmd7, cmd8]\r\n        mapper.receive(all_cmd)\r\n        expect(mapper._stored_commands).to.deep.equal(all_cmd)\r\n        const qb4 = new BasicQubit(null, -1)\r\n        const cmd_flush = new Command(null, new FlushGate(), tuple([qb4]))\r\n        mapper.receive([cmd_flush])\r\n        expect(mapper._stored_commands).to.deep.equal([])\r\n        expect(len(backend.receivedCommands)).to.equal(10)\r\n        expect(mapper._currently_allocated_ids).to.deep.equal(new Set([0, 2, 3]))\r\n        if (different_backend_id) {\r\n          const obj = mapper.currentMapping\r\n          const f1 = deepEqual(obj, {0: 21, 2: 3, 3: 0})\r\n          const f2 = deepEqual(obj, {0: 32, 2: 0, 3: 21})\r\n          const f3 = deepEqual(obj, {0: 3, 2: 21, 3: 32})\r\n          const f4 = deepEqual(obj, {0: 0, 2: 32, 3: 3})\r\n          expect(f1 || f2 || f3 || f4).to.equal(true)\r\n        } else {\r\n          const obj = mapper.currentMapping\r\n          const f1 = deepEqual(obj, {0: 0, 2: 2, 3: 3})\r\n          const f2 = deepEqual(obj, {0: 1, 2: 3, 3: 0})\r\n          const f3 = deepEqual(obj, {0: 2, 2: 0, 3: 1})\r\n          const f4 = deepEqual(obj, {0: 3, 2: 1, 3: 2})\r\n          expect(f1 || f2 || f3 || f4).to.equal(true)\r\n        }\r\n        const cmd9 = new Command(null, X, tuple([qb0]), [qb3])\r\n        mapper.storage = 1\r\n        mapper.receive([cmd9])\r\n        expect(mapper._currently_allocated_ids).to.deep.equal(new Set([0, 2, 3]))\r\n        expect(mapper._stored_commands).to.deep.equal([])\r\n        expect(len(mapper.currentMapping)).to.equal(3)\r\n        expect(0 in mapper.currentMapping).to.equal(true)\r\n        expect(2 in mapper.currentMapping).to.equal(true)\r\n        expect(3 in mapper.currentMapping).to.equal(true)\r\n        expect(mapper.num_mappings).to.equal(1)\r\n      })\r\n    })\r\n  })\r\n\r\n  it('should test_run_infinite_loop_detection', () => {\r\n    const mapper = new GridMapper({num_rows: 2, num_columns: 2})\r\n    const backend = new DummyEngine(true)\r\n    backend.isLastEngine = true\r\n    mapper.next = backend\r\n    const qb0 = new BasicQubit(null, 0)\r\n    const qb1 = new BasicQubit(null, 1)\r\n    let qb2 = new BasicQubit(null, 2)\r\n    const qb3 = new BasicQubit(null, 3)\r\n    const qb4 = new BasicQubit(null, 4)\r\n    const cmd0 = new Command(null, Allocate, tuple([qb0], ))\r\n    const cmd1 = new Command(null, Allocate, tuple([qb1], ))\r\n    const cmd2 = new Command(null, Allocate, tuple([qb2], ))\r\n    const cmd3 = new Command(null, Allocate, tuple([qb3], ))\r\n    const cmd4 = new Command(null, Allocate, tuple([qb4], ))\r\n    const cmd5 = new Command(null, X, tuple([qb0]), [qb1])\r\n    qb2 = new BasicQubit(null, -1)\r\n    const cmd_flush = new Command(null, new FlushGate(), tuple([qb2], ))\r\n\r\n    expect(() => mapper.receive([cmd0, cmd1, cmd2, cmd3, cmd4, cmd5, cmd_flush])).to.throw()\r\n  })\r\n\r\n  it('should test_correct_stats', () => {\r\n    // Should test stats for twice same mapping but depends on heuristic\r\n    const mapper = new GridMapper({num_rows: 3, num_columns: 1})\r\n    const backend = new DummyEngine(true)\r\n    backend.isLastEngine = true\r\n    mapper.next = backend\r\n    const qb0 = new BasicQubit(null, 0)\r\n    const qb1 = new BasicQubit(null, 1)\r\n    const qb2 = new BasicQubit(null, 2)\r\n    const cmd0 = new Command(null, Allocate, tuple([qb0]))\r\n    const cmd1 = new Command(null, Allocate, tuple([qb1]))\r\n    const cmd2 = new Command(null, Allocate, tuple([qb2]))\r\n    const cmd3 = new Command(null, X, tuple([qb0]), [qb1])\r\n    const cmd4 = new Command(null, X, tuple([qb1]), [qb2])\r\n    const cmd5 = new Command(null, X, tuple([qb0]), [qb2])\r\n    const cmd6 = new Command(null, X, tuple([qb2]), [qb1])\r\n    const cmd7 = new Command(null, X, tuple([qb0]), [qb1])\r\n    const cmd8 = new Command(null, X, tuple([qb1]), [qb2])\r\n    const qb_flush = new BasicQubit(null, -1)\r\n    const cmd_flush = new Command(null, new FlushGate(), tuple([qb_flush]))\r\n    mapper.receive([cmd0, cmd1, cmd2, cmd3, cmd4, cmd5, cmd6, cmd7, cmd8, cmd_flush])\r\n    expect(mapper.num_mappings).to.equal(2)\r\n  });\r\n\r\n  it('should test_send_possible_cmds_before_new_mapping', () => {\r\n    const mapper = new GridMapper({num_rows: 3, num_columns: 1})\r\n    const backend = new DummyEngine(true)\r\n    backend.isLastEngine = true\r\n    mapper.next = backend\r\n\r\n    function dont_call_mapping() {\r\n      throw new Error('')\r\n    }\r\n\r\n    mapper.returnNewMapping = dont_call_mapping\r\n    mapper.currentMapping = {0: 1}\r\n    const qb0 = new BasicQubit(null, 0)\r\n    const cmd0 = new Command(null, Allocate, tuple([qb0]))\r\n    const qb2 = new BasicQubit(null, -1)\r\n    const cmd_flush = new Command(null, new FlushGate(), tuple([qb2]))\r\n    mapper.receive([cmd0, cmd_flush])\r\n  })\r\n\r\n  it('should test_logical_id_tags_allocate_and_deallocate', () => {\r\n    const mapper = new GridMapper({num_rows: 2, num_columns: 2})\r\n    const backend = new DummyEngine(true)\r\n    backend.isLastEngine = true\r\n    mapper.next = backend\r\n    const qb0 = new BasicQubit(null, 0)\r\n    const qb1 = new BasicQubit(null, 1)\r\n    const cmd0 = new Command(null, Allocate, tuple([qb0]))\r\n    const cmd1 = new Command(null, Allocate, tuple([qb1]))\r\n    const cmd2 = new Command(null, X, tuple([qb0]), [qb1])\r\n    const cmd3 = new Command(null, Deallocate, tuple([qb0]))\r\n    const cmd4 = new Command(null, Deallocate, tuple([qb1]))\r\n    mapper.currentMapping = {0: 0, 1: 3}\r\n    const qb_flush = new BasicQubit(null, -1)\r\n    const cmd_flush = new Command(null, new FlushGate(), tuple([qb_flush], ))\r\n    mapper.receive([cmd0, cmd1, cmd2, cmd_flush])\r\n    expect(backend.receivedCommands[0].gate.equal(Allocate)).to.equal(true)\r\n    expect(backend.receivedCommands[0].qubits[0][0].id).to.equal(0)\r\n    expect(backend.receivedCommands[0].tags).to.deep.equal([new LogicalQubitIDTag(0)])\r\n    expect(backend.receivedCommands[1].gate.equal(Allocate)).to.equal(true)\r\n    expect(backend.receivedCommands[1].qubits[0][0].id).to.equal(3)\r\n    expect(backend.receivedCommands[1].tags).to.deep.equal([new LogicalQubitIDTag(1)])\r\n    backend.receivedCommands.slice(2).forEach((cmd) => {\r\n      if (cmd.gate.equal(Allocate) || cmd.gate.equal(Deallocate)) {\r\n        expect(cmd.tags).to.deep.equal([])\r\n      }\r\n    })\r\n\r\n    const mapped_id_for_0 = mapper.currentMapping[0]\r\n    const mapped_id_for_1 = mapper.currentMapping[1]\r\n    mapper.receive([cmd3, cmd4, cmd_flush])\r\n    const length = backend.receivedCommands.length\r\n    expect(backend.receivedCommands[length - 3].gate.equal(Deallocate)).to.equal(true)\r\n    expect(backend.receivedCommands[length - 3].qubits[0][0].id).to.equal(mapped_id_for_0)\r\n    expect(backend.receivedCommands[length - 3].tags).to.deep.equal([new LogicalQubitIDTag(0)])\r\n    expect(backend.receivedCommands[length - 2].gate.equal(Deallocate)).to.equal(true)\r\n    expect(backend.receivedCommands[length - 2].qubits[0][0].id).to.equal(mapped_id_for_1)\r\n    expect(backend.receivedCommands[length - 2].tags).to.deep.equal([new LogicalQubitIDTag(1)])\r\n  })\r\n\r\n  it('should test_check_that_local_optimizer_doesnt_merge', () => {\r\n    const mapper = new GridMapper({num_rows: 2, num_columns: 2})\r\n    const optimizer = new LocalOptimizer(10)\r\n    const backend = new DummyEngine(true)\r\n    backend.isLastEngine = true\r\n    mapper.next = optimizer\r\n    optimizer.next = backend\r\n    mapper.currentMapping = {0: 0}\r\n    mapper.storage = 1\r\n    const qb0 = new BasicQubit(null, 0)\r\n    const qb1 = new BasicQubit(null, 1)\r\n    const qb_flush = new BasicQubit(null, -1)\r\n    const cmd_flush = new Command(null, new FlushGate(), tuple([qb_flush]))\r\n    const cmd0 = new Command(null, Allocate, tuple([qb0]))\r\n    const cmd1 = new Command(null, X, tuple([qb0]))\r\n    const cmd2 = new Command(null, Deallocate, tuple([qb0]))\r\n    mapper.receive([cmd0, cmd1, cmd2])\r\n    expect(len(mapper._stored_commands)).to.equal(0)\r\n    mapper.currentMapping = {1: 0}\r\n    const cmd3 = new Command(null, Allocate, tuple([qb1]))\r\n    const cmd4 = new Command(null, X, tuple([qb1]))\r\n    const cmd5 = new Command(null, Deallocate, tuple([qb1]))\r\n    mapper.receive([cmd3, cmd4, cmd5, cmd_flush])\r\n    expect(len(backend.receivedCommands)).to.equal(7)\r\n  });\r\n})\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/cengines/twodmapper.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 534,
    "kind": "file",
    "name": "src/libs/math/constantmath.js",
    "content": "\r\n/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport assert from 'assert'\r\nimport math from 'mathjs'\r\nimport {Compute, CustomUncompute, Uncompute} from '../../meta/compute'\r\nimport {QFT} from '../../ops/qftgate'\r\nimport {R, Swap, X} from '../../ops/gates'\r\nimport {\r\n  AddConstant, AddConstantModN, SubConstant, SubConstantModN\r\n} from './gates';\r\nimport {tuple} from '../util';\r\nimport {CNOT} from '../../ops/shortcuts';\r\nimport {Control} from '../../meta/control';\r\nimport {len} from '../polyfill';\r\n\r\n/**\r\n * Adds a classical constant c to the quantum integer (qureg) quint using Draper addition.\r\n * Note: Uses the Fourier-transform adder\r\n * see https://arxiv.org/abs/quant-ph/0008033\r\n */\r\nexport function add_constant(eng, c, quint) {\r\n  Compute(eng, () => QFT.or(quint))\r\n\r\n  for (let i = 0; i < quint.length; ++i) {\r\n    for (let j = i; j > -1; j -= 1) {\r\n      if ((c >> j) & 1) {\r\n        new R(math.pi / (1 << (i - j))).or(quint[i])\r\n      }\r\n    }\r\n  }\r\n\r\n  Uncompute(eng)\r\n}\r\n\r\n/**\r\n * Modular adder by Beauregard\r\n * see https://arxiv.org/abs/quant-ph/0205095\r\nAdds a classical constant c to a quantum integer (qureg) quint modulo N\r\nusing Draper addition and the construction\r\n */\r\nexport function add_constant_modN(eng, c, N, quint) {\r\n  assert(c < N && c >= 0)\r\n\r\n  new AddConstant(c).or(quint)\r\n\r\n  let ancilla\r\n\r\n  Compute(eng, () => {\r\n    SubConstant(N).or(quint)\r\n    ancilla = eng.allocateQubit()\r\n    CNOT.or(tuple(quint[quint.length - 1], ancilla))\r\n    Control(eng, ancilla, () => new AddConstant(N).or(quint))\r\n  })\r\n\r\n  SubConstant(c).or(quint)\r\n\r\n  CustomUncompute(eng, () => {\r\n    X.or(quint[quint.length - 1])\r\n    CNOT.or(tuple(quint[quint.length - 1], ancilla))\r\n    X.or(quint[quint.length - 1])\r\n    ancilla.deallocate()\r\n  })\r\n\r\n  new AddConstant(c).or(quint)\r\n}\r\n\r\n\r\n// calculates the inverse of a modulo N\r\nfunction inv_mod_N(a, N) {\r\n  let s = 0\r\n  let old_s = 1\r\n  let r = N\r\n  let old_r = a\r\n  while (r !== 0) {\r\n    const q = Math.floor(old_r / r)\r\n    let tmp = r\r\n    r = old_r - q * r\r\n    old_r = tmp\r\n    tmp = s\r\n    s = old_s - q * s\r\n    old_s = tmp\r\n  }\r\n  return (old_s + N) % N\r\n}\r\n\r\n/**\r\n * Modular multiplication by modular addition & shift, followed by uncompute\r\n https://arxiv.org/abs/quant-ph/0205095\r\nMultiplies a quantum integer by a classical number a modulo N, i.e.,\r\n\r\n|x> -> |a*x mod N>\r\n\r\n(only works if a and N are relative primes, otherwise the modular inverse\r\ndoes not exist).\r\n */\r\nexport function mul_by_constant_modN(eng, c, N, quint_in) {\r\n  assert(c < N && c >= 0)\r\n  assert(math.gcd(c, N) === 1)\r\n\r\n  const n = len(quint_in)\r\n  const quint_out = eng.allocateQureg(n + 1)\r\n\r\n  for (let i = 0; i < n; ++i) {\r\n    Control(eng, quint_in[i], () => new AddConstantModN((c << i) % N, N).or(quint_out))\r\n  }\r\n\r\n  for (let i = 0; i < n; ++i) {\r\n    Swap.or(tuple(quint_out[i], quint_in[i]))\r\n  }\r\n\r\n  const cinv = inv_mod_N(c, N)\r\n\r\n  for (let i = 0; i < n; ++i) {\r\n    Control(eng, quint_in[i], () => SubConstantModN((cinv << i) % N, N).or(quint_out))\r\n  }\r\n\r\n  quint_out.deallocate()\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/libs/math/constantmath.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 535,
    "kind": "function",
    "name": "add_constant",
    "memberof": "src/libs/math/constantmath.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/math/constantmath.js~add_constant",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/math/constantmath.js",
    "importStyle": "{add_constant}",
    "description": "Adds a classical constant c to the quantum integer (qureg) quint using Draper addition.\nNote: Uses the Fourier-transform adder\nsee https://arxiv.org/abs/quant-ph/0008033",
    "lineNumber": 36,
    "params": [
      {
        "name": "eng",
        "types": [
          "*"
        ]
      },
      {
        "name": "c",
        "types": [
          "*"
        ]
      },
      {
        "name": "quint",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 536,
    "kind": "function",
    "name": "add_constant_modN",
    "memberof": "src/libs/math/constantmath.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/math/constantmath.js~add_constant_modN",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/math/constantmath.js",
    "importStyle": "{add_constant_modN}",
    "description": "Modular adder by Beauregard\nsee https://arxiv.org/abs/quant-ph/0205095\nAdds a classical constant c to a quantum integer (qureg) quint modulo N\nusing Draper addition and the construction",
    "lineNumber": 56,
    "params": [
      {
        "name": "eng",
        "types": [
          "*"
        ]
      },
      {
        "name": "c",
        "types": [
          "*"
        ]
      },
      {
        "name": "N",
        "types": [
          "*"
        ]
      },
      {
        "name": "quint",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 537,
    "kind": "function",
    "name": "inv_mod_N",
    "memberof": "src/libs/math/constantmath.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/math/constantmath.js~inv_mod_N",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/libs/math/constantmath.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 84,
    "undocument": true,
    "params": [
      {
        "name": "a",
        "types": [
          "*"
        ]
      },
      {
        "name": "N",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 538,
    "kind": "function",
    "name": "mul_by_constant_modN",
    "memberof": "src/libs/math/constantmath.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/math/constantmath.js~mul_by_constant_modN",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/math/constantmath.js",
    "importStyle": "{mul_by_constant_modN}",
    "description": "Modular multiplication by modular addition & shift, followed by uncompute\nhttps://arxiv.org/abs/quant-ph/0205095\nMultiplies a quantum integer by a classical number a modulo N, i.e.,\n\n|x> -> |a*x mod N>\n\n(only works if a and N are relative primes, otherwise the modular inverse\ndoes not exist).",
    "lineNumber": 111,
    "params": [
      {
        "name": "eng",
        "types": [
          "*"
        ]
      },
      {
        "name": "c",
        "types": [
          "*"
        ]
      },
      {
        "name": "N",
        "types": [
          "*"
        ]
      },
      {
        "name": "quint_in",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 539,
    "kind": "file",
    "name": "src/libs/math/constantmath.spec.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport {expect} from 'chai'\r\nimport math from 'mathjs'\r\nimport {BasicMathGate, ClassicalInstructionGate} from '../../ops/basics';\r\nimport {len} from '../polyfill';\r\nimport DecompositionRuleSet from '../../cengines/replacer/decompositionruleset';\r\nimport qft2crandhadamard from '../../setups/decompositions/qft2crandhadamard';\r\nimport swap2cnot from '../../setups/decompositions/swap2cnot';\r\nimport defaultrules from './defaultrules'\r\nimport {AutoReplacer, InstructionFilter} from '../../cengines/replacer/replacer';\r\nimport {AddConstant, AddConstantModN, MultiplyByConstantModN} from './gates';\r\nimport {All} from '../../ops/metagates';\r\nimport {Measure, X} from '../../ops/gates';\r\nimport Simulator from '../../backends/simulators/simulator';\r\nimport MainEngine from '../../cengines/main';\r\n\r\nfunction init(engine, quint, value) {\r\n  for (let i = 0; i < quint.length; ++i) {\r\n    if (((value >> i) & 1) == 1) {\r\n      X.or(quint[i])\r\n    }\r\n  }\r\n}\r\n\r\nfunction no_math_emulation(eng, cmd) {\r\n  if (cmd.gate instanceof BasicMathGate) {\r\n    return false\r\n  }\r\n  if (cmd.gate instanceof ClassicalInstructionGate) {\r\n    return true\r\n  }\r\n\r\n  try {\r\n    return len(cmd.gate.matrix) === 2\r\n  } catch (e) {\r\n    return false\r\n  }\r\n}\r\n\r\nconst rule_set = new DecompositionRuleSet([...defaultrules, ...qft2crandhadamard, ...swap2cnot])\r\n\r\ndescribe('constant math test', () => {\r\n  it('should test_adder', () => {\r\n    const sim = new Simulator()\r\n    const eng = new MainEngine(sim, [new AutoReplacer(rule_set),\r\n      new InstructionFilter(no_math_emulation)])\r\n    const qureg = eng.allocateQureg(4)\r\n    init(eng, qureg, 4)\r\n\r\n    new AddConstant(3).or(qureg)\r\n\r\n    let m = sim.cheat()[1]\r\n    let v = m[7]\r\n    expect(math.abs(math.complex(v.re, v.im))).to.be.closeTo(1, 1e-12)\r\n\r\n    init(eng, qureg, 7) // reset\r\n    init(eng, qureg, 2)\r\n\r\n    // check for overflow -> should be 15+2 = 1 (mod 16)\r\n    new AddConstant(15).or(qureg)\r\n    m = sim.cheat()[1]\r\n    v = m[1]\r\n    expect(math.abs(math.complex(v.re, v.im))).to.be.closeTo(1, 1e-12)\r\n\r\n    new All(Measure).or(qureg)\r\n  });\r\n\r\n  it('should test_modadder', () => {\r\n    const sim = new Simulator()\r\n    const eng = new MainEngine(sim, [new AutoReplacer(rule_set),\r\n      new InstructionFilter(no_math_emulation)])\r\n\r\n    const qureg = eng.allocateQureg(4)\r\n    init(eng, qureg, 4)\r\n\r\n    new AddConstantModN(3, 6).or(qureg)\r\n    let m = sim.cheat()[1]\r\n    let v = m[1]\r\n    expect(math.abs(math.complex(v.re, v.im))).to.closeTo(1, 1e-12)\r\n\r\n    init(eng, qureg, 1) // reset\r\n    init(eng, qureg, 7)\r\n\r\n    new AddConstantModN(10, 13).or(qureg)\r\n    m = sim.cheat()[1]\r\n    v = m[4]\r\n    expect(math.abs(math.complex(v.re, v.im))).to.closeTo(1, 1e-12)\r\n\r\n    new All(Measure).or(qureg)\r\n  });\r\n\r\n  it('should test_modmultiplier', () => {\r\n    const sim = new Simulator()\r\n    const eng = new MainEngine(sim, [new AutoReplacer(rule_set),\r\n      new InstructionFilter(no_math_emulation)])\r\n\r\n    const qureg = eng.allocateQureg(4)\r\n    init(eng, qureg, 4)\r\n\r\n    new MultiplyByConstantModN(3, 7).or(qureg)\r\n\r\n    let m = sim.cheat()[1]\r\n    let v = m[5]\r\n    expect(math.abs(math.complex(v.re, v.im))).to.closeTo(1, 1e-12)\r\n\r\n    init(eng, qureg, 5) // reset\r\n    init(eng, qureg, 7)\r\n\r\n    new MultiplyByConstantModN(4, 13).or(qureg)\r\n\r\n    m = sim.cheat()[1]\r\n    v = m[2]\r\n    expect(math.abs(math.complex(v.re, v.im))).to.closeTo(1, 1e-12)\r\n\r\n    new All(Measure).or(qureg)\r\n  });\r\n})\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/libs/math/constantmath.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 540,
    "kind": "function",
    "name": "init",
    "memberof": "src/libs/math/constantmath.spec.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/math/constantmath.spec.js~init",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/libs/math/constantmath.spec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "params": [
      {
        "name": "engine",
        "types": [
          "*"
        ]
      },
      {
        "name": "quint",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 541,
    "kind": "function",
    "name": "no_math_emulation",
    "memberof": "src/libs/math/constantmath.spec.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/math/constantmath.spec.js~no_math_emulation",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/libs/math/constantmath.spec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 40,
    "undocument": true,
    "params": [
      {
        "name": "eng",
        "types": [
          "*"
        ]
      },
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 542,
    "kind": "variable",
    "name": "rule_set",
    "memberof": "src/libs/math/constantmath.spec.js",
    "static": true,
    "longname": "src/libs/math/constantmath.spec.js~rule_set",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/libs/math/constantmath.spec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 55,
    "undocument": true,
    "type": {
      "types": [
        "src/cengines/replacer/decompositionruleset.js~DecompositionRuleSet"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 543,
    "kind": "file",
    "name": "src/libs/math/defaultrules.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport {add_constant, add_constant_modN, mul_by_constant_modN} from './constantmath';\r\nimport {Control} from '../../meta/control';\r\nimport DecompositionRule from '../../cengines/replacer/decompositionrule';\r\nimport {AddConstant, AddConstantModN, MultiplyByConstantModN} from './gates';\r\n\r\nfunction _replace_addconstant(cmd) {\r\n  const eng = cmd.engine\r\n  const c = cmd.gate.a\r\n  const quint = cmd.qubits[0]\r\n\r\n  Control(eng, cmd.controlQubits, () => add_constant(eng, c, quint))\r\n}\r\n\r\n\r\nfunction _replace_addconstmodN(cmd) {\r\n  const eng = cmd.engine\r\n  const c = cmd.gate.a\r\n  const N = cmd.gate.N\r\n  const quint = cmd.qubits[0]\r\n\r\n  Control(eng, cmd.controlQubits, () => add_constant_modN(eng, c, N, quint))\r\n}\r\n\r\n\r\nfunction _replace_multiplybyconstantmodN(cmd) {\r\n  const eng = cmd.engine\r\n  const c = cmd.gate.a\r\n  const N = cmd.gate.N\r\n  const quint = cmd.qubits[0]\r\n\r\n  Control(eng, cmd.controlQubits, () => mul_by_constant_modN(eng, c, N, quint))\r\n}\r\n\r\nexport default [\r\n  new DecompositionRule(AddConstant, _replace_addconstant),\r\n  new DecompositionRule(AddConstantModN, _replace_addconstmodN),\r\n  new DecompositionRule(MultiplyByConstantModN, _replace_multiplybyconstantmodN),\r\n]\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/libs/math/defaultrules.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 544,
    "kind": "function",
    "name": "_replace_addconstant",
    "memberof": "src/libs/math/defaultrules.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/math/defaultrules.js~_replace_addconstant",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/libs/math/defaultrules.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 545,
    "kind": "function",
    "name": "_replace_addconstmodN",
    "memberof": "src/libs/math/defaultrules.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/math/defaultrules.js~_replace_addconstmodN",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/libs/math/defaultrules.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 546,
    "kind": "function",
    "name": "_replace_multiplybyconstantmodN",
    "memberof": "src/libs/math/defaultrules.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/math/defaultrules.js~_replace_multiplybyconstantmodN",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/libs/math/defaultrules.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 41,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 547,
    "kind": "file",
    "name": "src/libs/math/gates.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nimport math from 'mathjs'\r\nimport {BasicMathGate} from '../../ops/basics'\r\n\r\n/**\r\n * @class AddConstant\r\n * @desc\r\nAdd a constant to a quantum number represented by a quantum register,\r\n    stored from low- to high-bit.\r\n\r\n    @example\r\n\r\nqunum = eng.allocateQureg(5) # 5-qubit number\r\nX | qunum[1] # qunum is now equal to 2\r\nAddConstant(3) | qunum # qunum is now equal to 5\r\n */\r\nexport class AddConstant extends BasicMathGate {\r\n  /**\r\n  Initializes the gate to the number to add.\r\n\r\n    @param {number} a Number to add to a quantum register.\r\n\r\n    It also initializes its base class, BasicMathGate, with the\r\n  corresponding function, so it can be emulated efficiently.\r\n   */\r\n  constructor(a) {\r\n    super(x => [x + a])\r\n    this.a = a\r\n  }\r\n\r\n  getInverse() {\r\n    return SubConstant(this.a)\r\n  }\r\n\r\n  toString() {\r\n    return `AddConstant(${this.a})`\r\n  }\r\n\r\n  equal(other) {\r\n    return other instanceof AddConstant && other.a === this.a\r\n  }\r\n}\r\n\r\n/**\r\nSubtract a constant from a quantum number represented by a quantum\r\nregister, stored from low- to high-bit.\r\n\r\n    @param {number} a Constant to subtract\r\n\r\n    @example\r\n\r\nqunum = eng.allocateQureg(5) # 5-qubit number\r\nX | qunum[2] # qunum is now equal to 4\r\nSubConstant(3) | qunum # qunum is now equal to 1\r\n */\r\nexport function SubConstant(a) {\r\n  return new AddConstant(-a)\r\n}\r\n\r\n/**\r\n * @class AddConstantModN\r\n * @desc\r\nAdd a constant to a quantum number represented by a quantum register\r\nmodulo N.\r\n\r\n    The number is stored from low- to high-bit, i.e., qunum[0] is the LSB.\r\n\r\n    @example\r\n\r\nqunum = eng.allocateQureg(5) # 5-qubit number\r\nX | qunum[1] # qunum is now equal to 2\r\nAddConstantModN(3, 4) | qunum # qunum is now equal to 1\r\n */\r\nexport class AddConstantModN extends BasicMathGate {\r\n  /**\r\n   * @constructor\r\n  Initializes the gate to the number to add modulo N.\r\n\r\n    @param {number} a Number to add to a quantum register (0 <= a < N).\r\n    @param {number} N Number modulo which the addition is carried out.\r\n\r\n    It also initializes its base class, BasicMathGate, with the\r\n  corresponding function, so it can be emulated efficiently.\r\n   */\r\n  constructor(a, N) {\r\n    super(x => [math.mod(x + a, N)])\r\n    this.a = a\r\n    this.N = N\r\n  }\r\n\r\n  toString() {\r\n    return `AddConstantModN(${this.a}, ${this.N})`\r\n  }\r\n\r\n  getInverse() {\r\n    return SubConstantModN(this.a, this.N)\r\n  }\r\n\r\n  equal(other) {\r\n    return other instanceof AddConstantModN && other.a === this.a && other.N === this.N\r\n  }\r\n}\r\n\r\n/**\r\nSubtract a constant from a quantum number represented by a quantum\r\nregister modulo N.\r\n\r\n    The number is stored from low- to high-bit, i.e., qunum[0] is the LSB.\r\n\r\n @param {number} a Constant to add\r\n @param {number} N Constant modulo which the addition of a should be carried out.\r\n\r\n    @example\r\n\r\nqunum = eng.allocateQureg(3) # 3-qubit number\r\nX | qunum[1] # qunum is now equal to 2\r\nSubConstantModN(4,5) | qunum # qunum is now -2 = 6 = 1 (mod 5)\r\n */\r\nexport function SubConstantModN(a, N) {\r\n  return new AddConstantModN(N - a, N)\r\n}\r\n\r\n/**\r\n * @class MultiplyByConstantModN\r\n * @desc\r\nMultiply a quantum number represented by a quantum register by a constant\r\nmodulo N.\r\n\r\n    The number is stored from low- to high-bit, i.e., qunum[0] is the LSB.\r\n\r\n    @example\r\nqunum = eng.allocateQureg(5) # 5-qubit number\r\nX | qunum[2] # qunum is now equal to 4\r\nMultiplyByConstantModN(3,5) | qunum # qunum is now 2.\r\n */\r\nexport class MultiplyByConstantModN extends BasicMathGate {\r\n  /**\r\n   * @constructor\r\n  Initializes the gate to the number to multiply with modulo N.\r\n\r\n   @param {number} a Number by which to multiply a quantum register (0 <= a < N).\r\n   @param {number} N Number modulo which the multiplication is carried out.\r\n\r\n    It also initializes its base class, BasicMathGate, with the\r\n  corresponding function, so it can be emulated efficiently.\r\n   */\r\n  constructor(a, N) {\r\n    super(x => [(a * x) % N])\r\n    this.a = a\r\n    this.N = N\r\n  }\r\n\r\n  toString() {\r\n    return `MultiplyByConstantModN(${this.a}, ${this.N})`\r\n  }\r\n\r\n  equal(other) {\r\n    return other instanceof MultiplyByConstantModN && other.a === this.a && other.N === this.N\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/libs/math/gates.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 548,
    "kind": "class",
    "name": "AddConstant",
    "memberof": "src/libs/math/gates.js",
    "static": true,
    "longname": "src/libs/math/gates.js~AddConstant",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/math/gates.js",
    "importStyle": "{AddConstant}",
    "description": "Add a constant to a quantum number represented by a quantum register,\nstored from low- to high-bit.",
    "examples": [
      "\nqunum = eng.allocateQureg(5) # 5-qubit number\nX | qunum[1] # qunum is now equal to 2\nAddConstant(3) | qunum # qunum is now equal to 5"
    ],
    "lineNumber": 31,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "AddConstant"
      }
    ],
    "interface": false,
    "extends": [
      "src/ops/basics.js~BasicMathGate"
    ]
  },
  {
    "__docId__": 549,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/libs/math/gates.js~AddConstant",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/libs/math/gates.js~AddConstant#constructor",
    "access": "public",
    "description": "Initializes the gate to the number to add.",
    "lineNumber": 40,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "a",
        "description": "Number to add to a quantum register.\n\nIt also initializes its base class, BasicMathGate, with the\ncorresponding function, so it can be emulated efficiently."
      }
    ]
  },
  {
    "__docId__": 550,
    "kind": "member",
    "name": "a",
    "memberof": "src/libs/math/gates.js~AddConstant",
    "static": false,
    "longname": "src/libs/math/gates.js~AddConstant#a",
    "access": "public",
    "description": null,
    "lineNumber": 42,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 551,
    "kind": "method",
    "name": "getInverse",
    "memberof": "src/libs/math/gates.js~AddConstant",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/libs/math/gates.js~AddConstant#getInverse",
    "access": "public",
    "description": null,
    "lineNumber": 45,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 552,
    "kind": "method",
    "name": "toString",
    "memberof": "src/libs/math/gates.js~AddConstant",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/libs/math/gates.js~AddConstant#toString",
    "access": "public",
    "description": null,
    "lineNumber": 49,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 553,
    "kind": "method",
    "name": "equal",
    "memberof": "src/libs/math/gates.js~AddConstant",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/libs/math/gates.js~AddConstant#equal",
    "access": "public",
    "description": null,
    "lineNumber": 53,
    "undocument": true,
    "params": [
      {
        "name": "other",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 554,
    "kind": "function",
    "name": "SubConstant",
    "memberof": "src/libs/math/gates.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/math/gates.js~SubConstant",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/math/gates.js",
    "importStyle": "{SubConstant}",
    "description": "Subtract a constant from a quantum number represented by a quantum\nregister, stored from low- to high-bit.",
    "examples": [
      "\nqunum = eng.allocateQureg(5) # 5-qubit number\nX | qunum[2] # qunum is now equal to 4\nSubConstant(3) | qunum # qunum is now equal to 1"
    ],
    "lineNumber": 70,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "a",
        "description": "Constant to subtract"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 555,
    "kind": "class",
    "name": "AddConstantModN",
    "memberof": "src/libs/math/gates.js",
    "static": true,
    "longname": "src/libs/math/gates.js~AddConstantModN",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/math/gates.js",
    "importStyle": "{AddConstantModN}",
    "description": "Add a constant to a quantum number represented by a quantum register\nmodulo N.\n\nThe number is stored from low- to high-bit, i.e., qunum[0] is the LSB.",
    "examples": [
      "\nqunum = eng.allocateQureg(5) # 5-qubit number\nX | qunum[1] # qunum is now equal to 2\nAddConstantModN(3, 4) | qunum # qunum is now equal to 1"
    ],
    "lineNumber": 88,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "AddConstantModN"
      }
    ],
    "interface": false,
    "extends": [
      "src/ops/basics.js~BasicMathGate"
    ]
  },
  {
    "__docId__": 556,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/libs/math/gates.js~AddConstantModN",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/libs/math/gates.js~AddConstantModN#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 99,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": "Initializes the gate to the number to add modulo N."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "a",
        "description": "Number to add to a quantum register (0 <= a < N)."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "N",
        "description": "Number modulo which the addition is carried out.\n\nIt also initializes its base class, BasicMathGate, with the\ncorresponding function, so it can be emulated efficiently."
      }
    ]
  },
  {
    "__docId__": 557,
    "kind": "member",
    "name": "a",
    "memberof": "src/libs/math/gates.js~AddConstantModN",
    "static": false,
    "longname": "src/libs/math/gates.js~AddConstantModN#a",
    "access": "public",
    "description": null,
    "lineNumber": 101,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 558,
    "kind": "member",
    "name": "N",
    "memberof": "src/libs/math/gates.js~AddConstantModN",
    "static": false,
    "longname": "src/libs/math/gates.js~AddConstantModN#N",
    "access": "public",
    "description": null,
    "lineNumber": 102,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 559,
    "kind": "method",
    "name": "toString",
    "memberof": "src/libs/math/gates.js~AddConstantModN",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/libs/math/gates.js~AddConstantModN#toString",
    "access": "public",
    "description": null,
    "lineNumber": 105,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 560,
    "kind": "method",
    "name": "getInverse",
    "memberof": "src/libs/math/gates.js~AddConstantModN",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/libs/math/gates.js~AddConstantModN#getInverse",
    "access": "public",
    "description": null,
    "lineNumber": 109,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 561,
    "kind": "method",
    "name": "equal",
    "memberof": "src/libs/math/gates.js~AddConstantModN",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/libs/math/gates.js~AddConstantModN#equal",
    "access": "public",
    "description": null,
    "lineNumber": 113,
    "undocument": true,
    "params": [
      {
        "name": "other",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 562,
    "kind": "function",
    "name": "SubConstantModN",
    "memberof": "src/libs/math/gates.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/math/gates.js~SubConstantModN",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/math/gates.js",
    "importStyle": "{SubConstantModN}",
    "description": "Subtract a constant from a quantum number represented by a quantum\nregister modulo N.\n\nThe number is stored from low- to high-bit, i.e., qunum[0] is the LSB.",
    "examples": [
      "\nqunum = eng.allocateQureg(3) # 3-qubit number\nX | qunum[1] # qunum is now equal to 2\nSubConstantModN(4,5) | qunum # qunum is now -2 = 6 = 1 (mod 5)"
    ],
    "lineNumber": 133,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "a",
        "description": "Constant to add"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "N",
        "description": "Constant modulo which the addition of a should be carried out."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 563,
    "kind": "class",
    "name": "MultiplyByConstantModN",
    "memberof": "src/libs/math/gates.js",
    "static": true,
    "longname": "src/libs/math/gates.js~MultiplyByConstantModN",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/math/gates.js",
    "importStyle": "{MultiplyByConstantModN}",
    "description": "Multiply a quantum number represented by a quantum register by a constant\nmodulo N.\n\nThe number is stored from low- to high-bit, i.e., qunum[0] is the LSB.",
    "examples": [
      "qunum = eng.allocateQureg(5) # 5-qubit number\nX | qunum[2] # qunum is now equal to 4\nMultiplyByConstantModN(3,5) | qunum # qunum is now 2."
    ],
    "lineNumber": 150,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "MultiplyByConstantModN"
      }
    ],
    "interface": false,
    "extends": [
      "src/ops/basics.js~BasicMathGate"
    ]
  },
  {
    "__docId__": 564,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/libs/math/gates.js~MultiplyByConstantModN",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/libs/math/gates.js~MultiplyByConstantModN#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 161,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": "Initializes the gate to the number to multiply with modulo N."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "a",
        "description": "Number by which to multiply a quantum register (0 <= a < N)."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "N",
        "description": "Number modulo which the multiplication is carried out.\n\nIt also initializes its base class, BasicMathGate, with the\ncorresponding function, so it can be emulated efficiently."
      }
    ]
  },
  {
    "__docId__": 565,
    "kind": "member",
    "name": "a",
    "memberof": "src/libs/math/gates.js~MultiplyByConstantModN",
    "static": false,
    "longname": "src/libs/math/gates.js~MultiplyByConstantModN#a",
    "access": "public",
    "description": null,
    "lineNumber": 163,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 566,
    "kind": "member",
    "name": "N",
    "memberof": "src/libs/math/gates.js~MultiplyByConstantModN",
    "static": false,
    "longname": "src/libs/math/gates.js~MultiplyByConstantModN#N",
    "access": "public",
    "description": null,
    "lineNumber": 164,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 567,
    "kind": "method",
    "name": "toString",
    "memberof": "src/libs/math/gates.js~MultiplyByConstantModN",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/libs/math/gates.js~MultiplyByConstantModN#toString",
    "access": "public",
    "description": null,
    "lineNumber": 167,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 568,
    "kind": "method",
    "name": "equal",
    "memberof": "src/libs/math/gates.js~MultiplyByConstantModN",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/libs/math/gates.js~MultiplyByConstantModN#equal",
    "access": "public",
    "description": null,
    "lineNumber": 171,
    "undocument": true,
    "params": [
      {
        "name": "other",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 569,
    "kind": "file",
    "name": "src/libs/math/gates.spec.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport {expect} from 'chai'\r\nimport {AddConstant, AddConstantModN, MultiplyByConstantModN} from \"./gates\";\r\n\r\ndescribe('gates test', () => {\r\n  it('should test_addconstant', function () {\r\n    expect(new AddConstant(3).equal(new AddConstant(3))).to.equal(true)\r\n    expect(new AddConstant(3).equal(new AddConstant(4))).to.equal(false)\r\n    expect(new AddConstant(3).toString()).to.equal('AddConstant(3)')\r\n  });\r\n\r\n  it('should test_addconstantmodn', function () {\r\n    expect(new AddConstantModN(3, 4).equal(new AddConstantModN(3, 4))).to.equal(true)\r\n    expect(new AddConstantModN(3, 4).equal(new AddConstantModN(4, 4))).to.equal(false)\r\n    expect(new AddConstantModN(3, 5).equal(new AddConstantModN(3, 4))).to.equal(false)\r\n\r\n    expect(new AddConstantModN(3, 4).toString()).to.equal(\"AddConstantModN(3, 4)\")\r\n  });\r\n\r\n  it('should test_multiplybyconstmodn', function () {\r\n    expect(new MultiplyByConstantModN(3, 4).equal(new MultiplyByConstantModN(3, 4))).to.equal(true)\r\n    expect(new MultiplyByConstantModN(3, 4).equal(new MultiplyByConstantModN(4, 4))).to.equal(false)\r\n\r\n    expect(new MultiplyByConstantModN(3, 4).toString()).to.equal(\"MultiplyByConstantModN(3, 4)\")\r\n  });\r\n})\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/libs/math/gates.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 570,
    "kind": "file",
    "name": "src/libs/polyfill.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport math from 'mathjs'\r\nimport {instanceOf} from './util';\r\n\r\nconst Complex = math.complex().constructor\r\nconst Matrix = math.matrix().constructor\r\n\r\n/**\r\n * check if value is complex number\r\n * @param {Object} value\r\n * @return {boolean}\r\n */\r\nexport function isComplex(value) {\r\n  return value instanceof Complex\r\n}\r\n\r\n/**\r\n * check if value is number or complex number\r\n * @param {Object} value\r\n * @return {boolean}\r\n */\r\nexport function isNumeric(value) {\r\n  return (typeof value === 'number' || value instanceof Complex)\r\n}\r\n\r\n/**\r\n * return intersection of s1 & s2\r\n * @param {Set} s1\r\n * @param {Set} s2\r\n * @return {Set}\r\n */\r\nexport function intersection(s1, s2) {\r\n  return new Set([...s1].filter(x => s2.has(x)))\r\n}\r\n\r\n/**\r\n * return union set of s1 & s2\r\n * @param {Set} s1\r\n * @param {Set} s2\r\n * @return {Set<any>}\r\n */\r\nexport function unionSet(s1, s2) {\r\n  const s = [...s2].filter(x => !s1.has(x))\r\n  const result = new Set(s1)\r\n  s.forEach(x => result.add(x))\r\n  return result\r\n}\r\n\r\n/**\r\n * return symmetric difference of s1 & s2\r\n * @param {Set} s1\r\n * @param {Set} s2\r\n * @return {Set<*>}\r\n */\r\nexport function symmetricDifference(s1, s2) {\r\n  const inset = intersection(s1, s2)\r\n  const a = [...s1].filter(x => !inset.has(x))\r\n  const b = [...s2].filter(x => !inset.has(x))\r\n  return new Set([...a, ...b])\r\n}\r\n\r\n/**\r\n * check if s1 is equal to s2\r\n * @param {Set} s1\r\n * @param {Set} s2\r\n * @return {boolean}\r\n */\r\nexport function setEqual(s1, s2) {\r\n  return symmetricDifference(s1, s2).size === 0\r\n}\r\n\r\n/**\r\n * check if `superset` is the super set of `s`\r\n * @param {Set} superset\r\n * @param {Set} s\r\n * @return {boolean}\r\n */\r\nexport function setIsSuperSet(superset, s) {\r\n  const result = [...s].filter(x => !superset.has(x))\r\n  return result.length === 0\r\n}\r\n\r\nexport function setDifference(s1, s2) {\r\n  return new Set([...s1].filter(x => !s2.has(x)))\r\n}\r\n\r\n/**\r\n * create a Set contains numbers in range from 0 to n\r\n * @param {number} n\r\n * @return {Set<number>}\r\n */\r\nexport function setFromRange(n) {\r\n  const result = new Set()\r\n  for (let i = 0; i < n; i++) {\r\n    result.add(i)\r\n  }\r\n  return result\r\n}\r\n\r\n/**\r\n * create an array filled by number in range, active like python does\r\n * @param {number} start\r\n * @param {number} end\r\n * @param {number} step\r\n * @return {number[]}\r\n */\r\nexport function arrayFromRange(start, end, step) {\r\n  if (typeof end === 'undefined') {\r\n    end = start\r\n    start = 0\r\n  }\r\n  if (typeof step === 'undefined') {\r\n    step = 1\r\n  }\r\n  const n = end - start\r\n  const result = new Array(n)\r\n  for (let i = 0; i < n; i += step) {\r\n    result[i] = i + start\r\n  }\r\n  return result\r\n}\r\n\r\n/**\r\n * return a random sample from `array` which length is `count`\r\n * @param {any[]} array\r\n * @param {number} count\r\n * @return {any[]}\r\n */\r\nexport function randomSample(array, count) {\r\n  const result = []\r\n  const {length} = array\r\n  if (length >= count) {\r\n    const copy = array.slice(0)\r\n    while (result.length < count) {\r\n      const idx = Math.floor(Math.random() * copy.length)\r\n      result.push(copy[idx])\r\n      copy.splice(idx, 1)\r\n    }\r\n  }\r\n  return result\r\n}\r\n\r\n/**\r\n * test if two array(a1, a2) are equal, support instance of classes in this library\r\n * @param {Array} a1\r\n * @param {Array} a2\r\n * @param {function} itemCompareFunc\r\n * @return {boolean}\r\n */\r\nexport function arrayEqual(a1, a2, itemCompareFunc) {\r\n  if (a1 === a2) {\r\n    return true\r\n  }\r\n\r\n  if (Array.isArray(a1) && Array.isArray(a2)) {\r\n    const l1 = a1.length\r\n    const l2 = a2.length\r\n    if (l1 === l2) {\r\n      for (let i = 0; i < l1; ++i) {\r\n        const c = a1[i]\r\n        const d = a2[i]\r\n        let func = itemCompareFunc\r\n        if (!func && c.__proto__.equal) {\r\n          func = (x, y) => Reflect.apply(c.__proto__.equal, x, [y])\r\n        }\r\n        if (Array.isArray(c) && Array.isArray(d)) {\r\n          func = arrayEqual\r\n        }\r\n        if (!func) {\r\n          func = (x, y) => x === y\r\n        }\r\n        const f = func(c, d)\r\n        if (!f) {\r\n          return false\r\n        }\r\n      }\r\n      return true\r\n    }\r\n  }\r\n  return false\r\n}\r\n\r\n/**\r\n * @function\r\n * reverse version of `forEach`\r\n * @param {function} callbackFunc\r\n */\r\nArray.prototype.rforEach = function (callbackFunc) {\r\n  if (typeof callbackFunc === 'function') {\r\n    const count = this.length\r\n    for (let i = count - 1; i >= 0; --i) {\r\n      callbackFunc(this[i])\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @function\r\n * reverse version of `map`\r\n * @param {function} callbackFunc\r\n * @return {any[]}\r\n */\r\nArray.prototype.rmap = function (callbackFunc) {\r\n  const result = []\r\n  if (typeof callbackFunc === 'function') {\r\n    const count = this.length\r\n    for (let i = count - 1; i >= 0; --i) {\r\n      result.push(callbackFunc(this[i]))\r\n    }\r\n  }\r\n  return result\r\n}\r\n\r\n/**\r\n * @function\r\n * return total exist count of `item` in array\r\n * @param {any} item\r\n */\r\nArray.prototype.count = function (item) {\r\n  let count = 0\r\n  for (let i = 0; i < this.length; ++i) {\r\n    if (this[i] === item) {\r\n      ++count\r\n    }\r\n  }\r\n  return count\r\n}\r\n\r\n/**\r\n * remove all existance of `target` from array\r\n * @param {any} target\r\n */\r\nArray.prototype.remove = function (target) {\r\n  let idx = -1\r\n  for (let i = 0; i < this.length; ++i) {\r\n    if (arrayEqual(this[i], target)) {\r\n      idx = i\r\n      break\r\n    }\r\n  }\r\n  if (idx !== -1) {\r\n    this.splice(idx, 1)\r\n  }\r\n}\r\n\r\n/**\r\n * return all regular expression match count of `substring` in string\r\n * @param {string} substring\r\n * @return {number}\r\n */\r\nString.prototype.count = function (substring) {\r\n  const exp = new RegExp(substring, 'g')\r\n  const result = this.match(exp)\r\n  if (result) return result.length\r\n  return 0\r\n}\r\n\r\n/**\r\n * return `length` of v, act like python\r\n * @param {any} v\r\n * @return {number}\r\n */\r\nexport function len(v) {\r\n  if (typeof v === 'undefined' || v === null) {\r\n    return 0\r\n  }\r\n  if (Array.isArray(v)) {\r\n    return v.length\r\n  }\r\n  if (v instanceof Set) {\r\n    return v.size\r\n  }\r\n  if (v instanceof Matrix) {\r\n    return v.size()[0]\r\n  }\r\n  if (instanceOf(v, String)) {\r\n    return v.length\r\n  }\r\n  if (typeof v.length !== 'undefined') {\r\n    if (typeof v.length === 'function') {\r\n      return v.length()\r\n    } else {\r\n      return v.length\r\n    }\r\n  }\r\n  if (typeof v === 'object') {\r\n    return Object.keys(v).length\r\n  }\r\n  return 0\r\n}\r\n\r\n/**\r\n * parse string contains 1/0 into bit array\r\n * @param {string} str\r\n * @return {boolean[]}\r\n */\r\nexport function stringToBitArray(str) {\r\n  if (Array.isArray(str)) {\r\n    return str\r\n  }\r\n  const result = []\r\n  if (instanceOf(str, String)) {\r\n    for (let i = 0; i < str.length; ++i) {\r\n      result.push(str.charAt(i) !== '0')\r\n    }\r\n  }\r\n  return result\r\n}\r\n\r\n/**\r\n * return dot product of two complex vector(a1, a2)\r\n * @param {Complex[]} a1\r\n * @param {Complex[]} a2\r\n * @return {Complex}\r\n */\r\nexport function complexVectorDot(a1, a2) {\r\n  let real = 0\r\n  let image = 0\r\n  a1.forEach((c1, [i]) => {\r\n    const c2 = a2.subset(math.index(i))\r\n    const r1 = math.re(c1)\r\n    const i1 = math.im(c1)\r\n    const r2 = math.re(c2)\r\n    const i2 = math.im(c2)\r\n    real += r1 * r2 - (-i1 * i2)\r\n    image += r1 * i2 - r2 * i1\r\n  })\r\n  return math.complex(real, image)\r\n}\r\n\r\n/**\r\n * return n-length Array filled by item\r\n * @param {Function|any} item\r\n * @param {number} count\r\n * @return {Array}\r\n */\r\nexport function narray(item, count) {\r\n  const result = []\r\n  if (typeof item === 'function') {\r\n    for (let i = 0; i < count; ++i) {\r\n      result.push(item())\r\n    }\r\n  } else {\r\n    for (let i = 0; i < count; ++i) {\r\n      result.push(item)\r\n    }\r\n  }\r\n  return result\r\n}\r\n\r\n/**\r\n * product loop on two Arrays p1 & p2\r\n * @param {Array} p1\r\n * @param {Array} p2\r\n * @param {function} func\r\n */\r\nexport function productLoop(p1, p2, func) {\r\n  for (let i = 0; i < p1.length; ++i) {\r\n    for (let j = 0; j < p2.length; ++j) {\r\n      const stop = func(p1[i], p2[j])\r\n      if (stop) {\r\n        return\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * product loop on three Arrays p1 & p2 & p3\r\n * @param {Array} p1\r\n * @param {Array} p2\r\n * @param {Array} p3\r\n * @param {function} func\r\n */\r\nexport function productLoop3(p1, p2, p3, func) {\r\n  for (let i = 0; i < p1.length; ++i) {\r\n    for (let j = 0; j < p2.length; ++j) {\r\n      for (let k = 0; k < p3.length; ++k) {\r\n        const stop = func(p1[i], p2[j], p3[k])\r\n        if (stop) {\r\n          return\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * return (base ^ exp) % mod, it's fast and support big number\r\n * @param {number} base\r\n * @param {number}  exp\r\n * @param  {number} mod\r\n * @return {number}\r\n */\r\nexport function expmod(base, exp, mod) {\r\n  if (exp === 0) return 1\r\n  if (exp % 2 === 0) {\r\n    return Math.pow(expmod(base, (exp / 2), mod), 2) % mod\r\n  } else {\r\n    return (base * expmod(base, (exp - 1), mod)) % mod\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/libs/polyfill.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 571,
    "kind": "variable",
    "name": "Complex",
    "memberof": "src/libs/polyfill.js",
    "static": true,
    "longname": "src/libs/polyfill.js~Complex",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/libs/polyfill.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 572,
    "kind": "variable",
    "name": "Matrix",
    "memberof": "src/libs/polyfill.js",
    "static": true,
    "longname": "src/libs/polyfill.js~Matrix",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/libs/polyfill.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 573,
    "kind": "function",
    "name": "isComplex",
    "memberof": "src/libs/polyfill.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/polyfill.js~isComplex",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/polyfill.js",
    "importStyle": "{isComplex}",
    "description": "check if value is complex number",
    "lineNumber": 28,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 574,
    "kind": "function",
    "name": "isNumeric",
    "memberof": "src/libs/polyfill.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/polyfill.js~isNumeric",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/polyfill.js",
    "importStyle": "{isNumeric}",
    "description": "check if value is number or complex number",
    "lineNumber": 37,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 575,
    "kind": "function",
    "name": "intersection",
    "memberof": "src/libs/polyfill.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/polyfill.js~intersection",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/polyfill.js",
    "importStyle": "{intersection}",
    "description": "return intersection of s1 & s2",
    "lineNumber": 47,
    "params": [
      {
        "nullable": null,
        "types": [
          "Set"
        ],
        "spread": false,
        "optional": false,
        "name": "s1",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Set"
        ],
        "spread": false,
        "optional": false,
        "name": "s2",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Set"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 576,
    "kind": "function",
    "name": "unionSet",
    "memberof": "src/libs/polyfill.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/polyfill.js~unionSet",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/polyfill.js",
    "importStyle": "{unionSet}",
    "description": "return union set of s1 & s2",
    "lineNumber": 57,
    "params": [
      {
        "nullable": null,
        "types": [
          "Set"
        ],
        "spread": false,
        "optional": false,
        "name": "s1",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Set"
        ],
        "spread": false,
        "optional": false,
        "name": "s2",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Set<any>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 577,
    "kind": "function",
    "name": "symmetricDifference",
    "memberof": "src/libs/polyfill.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/polyfill.js~symmetricDifference",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/polyfill.js",
    "importStyle": "{symmetricDifference}",
    "description": "return symmetric difference of s1 & s2",
    "lineNumber": 70,
    "params": [
      {
        "nullable": null,
        "types": [
          "Set"
        ],
        "spread": false,
        "optional": false,
        "name": "s1",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Set"
        ],
        "spread": false,
        "optional": false,
        "name": "s2",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Set<*>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 578,
    "kind": "function",
    "name": "setEqual",
    "memberof": "src/libs/polyfill.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/polyfill.js~setEqual",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/polyfill.js",
    "importStyle": "{setEqual}",
    "description": "check if s1 is equal to s2",
    "lineNumber": 83,
    "params": [
      {
        "nullable": null,
        "types": [
          "Set"
        ],
        "spread": false,
        "optional": false,
        "name": "s1",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Set"
        ],
        "spread": false,
        "optional": false,
        "name": "s2",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 579,
    "kind": "function",
    "name": "setIsSuperSet",
    "memberof": "src/libs/polyfill.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/polyfill.js~setIsSuperSet",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/polyfill.js",
    "importStyle": "{setIsSuperSet}",
    "description": "check if `superset` is the super set of `s`",
    "lineNumber": 93,
    "params": [
      {
        "nullable": null,
        "types": [
          "Set"
        ],
        "spread": false,
        "optional": false,
        "name": "superset",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Set"
        ],
        "spread": false,
        "optional": false,
        "name": "s",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 580,
    "kind": "function",
    "name": "setDifference",
    "memberof": "src/libs/polyfill.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/polyfill.js~setDifference",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/polyfill.js",
    "importStyle": "{setDifference}",
    "description": null,
    "lineNumber": 98,
    "undocument": true,
    "params": [
      {
        "name": "s1",
        "types": [
          "*"
        ]
      },
      {
        "name": "s2",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 581,
    "kind": "function",
    "name": "setFromRange",
    "memberof": "src/libs/polyfill.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/polyfill.js~setFromRange",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/polyfill.js",
    "importStyle": "{setFromRange}",
    "description": "create a Set contains numbers in range from 0 to n",
    "lineNumber": 107,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "n",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Set<number>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 582,
    "kind": "function",
    "name": "arrayFromRange",
    "memberof": "src/libs/polyfill.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/polyfill.js~arrayFromRange",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/polyfill.js",
    "importStyle": "{arrayFromRange}",
    "description": "create an array filled by number in range, active like python does",
    "lineNumber": 122,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "start",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "end",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "step",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number[]"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 583,
    "kind": "function",
    "name": "randomSample",
    "memberof": "src/libs/polyfill.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/polyfill.js~randomSample",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/polyfill.js",
    "importStyle": "{randomSample}",
    "description": "return a random sample from `array` which length is `count`",
    "lineNumber": 144,
    "params": [
      {
        "nullable": null,
        "types": [
          "any[]"
        ],
        "spread": false,
        "optional": false,
        "name": "array",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "count",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "any[]"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 584,
    "kind": "function",
    "name": "arrayEqual",
    "memberof": "src/libs/polyfill.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/polyfill.js~arrayEqual",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/polyfill.js",
    "importStyle": "{arrayEqual}",
    "description": "test if two array(a1, a2) are equal, support instance of classes in this library",
    "lineNumber": 165,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "a1",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "a2",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "itemCompareFunc",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 585,
    "kind": "function",
    "name": "rforEach",
    "memberof": "src/libs/polyfill.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/polyfill.js~rforEach",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/libs/polyfill.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 203,
    "unknown": [
      {
        "tagName": "@function",
        "tagValue": "reverse version of `forEach`"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "callbackFunc",
        "description": ""
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 586,
    "kind": "function",
    "name": "rmap",
    "memberof": "src/libs/polyfill.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/polyfill.js~rmap",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/libs/polyfill.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 218,
    "unknown": [
      {
        "tagName": "@function",
        "tagValue": "reverse version of `map`"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "callbackFunc",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "any[]"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 587,
    "kind": "function",
    "name": "count",
    "memberof": "src/libs/polyfill.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/polyfill.js~count",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/libs/polyfill.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 234,
    "unknown": [
      {
        "tagName": "@function",
        "tagValue": "return total exist count of `item` in array"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "any"
        ],
        "spread": false,
        "optional": false,
        "name": "item",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 588,
    "kind": "function",
    "name": "remove",
    "memberof": "src/libs/polyfill.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/polyfill.js~remove",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/libs/polyfill.js",
    "importStyle": null,
    "description": "remove all existance of `target` from array",
    "lineNumber": 248,
    "params": [
      {
        "nullable": null,
        "types": [
          "any"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": ""
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 589,
    "kind": "function",
    "name": "count",
    "memberof": "src/libs/polyfill.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/polyfill.js~count",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/libs/polyfill.js",
    "importStyle": null,
    "description": "return all regular expression match count of `substring` in string",
    "lineNumber": 266,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "substring",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 590,
    "kind": "function",
    "name": "len",
    "memberof": "src/libs/polyfill.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/polyfill.js~len",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/polyfill.js",
    "importStyle": "{len}",
    "description": "return `length` of v, act like python",
    "lineNumber": 278,
    "params": [
      {
        "nullable": null,
        "types": [
          "any"
        ],
        "spread": false,
        "optional": false,
        "name": "v",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 591,
    "kind": "function",
    "name": "stringToBitArray",
    "memberof": "src/libs/polyfill.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/polyfill.js~stringToBitArray",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/polyfill.js",
    "importStyle": "{stringToBitArray}",
    "description": "parse string contains 1/0 into bit array",
    "lineNumber": 312,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "str",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean[]"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 592,
    "kind": "function",
    "name": "complexVectorDot",
    "memberof": "src/libs/polyfill.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/polyfill.js~complexVectorDot",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/polyfill.js",
    "importStyle": "{complexVectorDot}",
    "description": "return dot product of two complex vector(a1, a2)",
    "lineNumber": 331,
    "params": [
      {
        "nullable": null,
        "types": [
          "Complex[]"
        ],
        "spread": false,
        "optional": false,
        "name": "a1",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Complex[]"
        ],
        "spread": false,
        "optional": false,
        "name": "a2",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Complex"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 593,
    "kind": "function",
    "name": "narray",
    "memberof": "src/libs/polyfill.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/polyfill.js~narray",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/polyfill.js",
    "importStyle": "{narray}",
    "description": "return n-length Array filled by item",
    "lineNumber": 352,
    "params": [
      {
        "nullable": null,
        "types": [
          "Function",
          "any"
        ],
        "spread": false,
        "optional": false,
        "name": "item",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "count",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 594,
    "kind": "function",
    "name": "productLoop",
    "memberof": "src/libs/polyfill.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/polyfill.js~productLoop",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/polyfill.js",
    "importStyle": "{productLoop}",
    "description": "product loop on two Arrays p1 & p2",
    "lineNumber": 372,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "p1",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "p2",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "func",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 595,
    "kind": "function",
    "name": "productLoop3",
    "memberof": "src/libs/polyfill.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/polyfill.js~productLoop3",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/polyfill.js",
    "importStyle": "{productLoop3}",
    "description": "product loop on three Arrays p1 & p2 & p3",
    "lineNumber": 390,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "p1",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "p2",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "p3",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "func",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 596,
    "kind": "function",
    "name": "expmod",
    "memberof": "src/libs/polyfill.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/polyfill.js~expmod",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/polyfill.js",
    "importStyle": "{expmod}",
    "description": "return (base ^ exp) % mod, it's fast and support big number",
    "lineNumber": 410,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "base",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "exp",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "mod",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 597,
    "kind": "file",
    "name": "src/libs/util.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nimport math from 'mathjs'\r\n\r\n/**\r\n * generate a n-Length Array filled by `0`\r\n * @param {number} n\r\n * @return {number[]}\r\n */\r\nexport function zeros(n) {\r\n  const array = new Array(n)\r\n  for (let i = 0; i < n; ++i) {\r\n    array[i] = 0\r\n  }\r\n  return array\r\n}\r\n\r\n/**\r\n * check if an array is `tuple`\r\n * @param {Array} value\r\n * @return {boolean}\r\n */\r\nexport function arrayIsTuple(value) {\r\n  let isTuple = false\r\n  if (typeof value.$$__tuple !== 'undefined') {\r\n    isTuple = value.$$__tuple\r\n    return isTuple\r\n  }\r\n  if (Array.isArray(value)) {\r\n    isTuple = value.some(item => item instanceof Array)\r\n  }\r\n  return isTuple\r\n}\r\n\r\n/**\r\n * force mark a value as `tuple`, internal usage only\r\n * @param value\r\n */\r\nexport function markTuple(value) {\r\n  value.$$__tuple = true\r\n}\r\n\r\n/**\r\n * create `tuple` from arguments\r\n * @param args\r\n * @return {Array}\r\n */\r\nexport function tuple(...args) {\r\n  const result = new Array(...args)\r\n  markTuple(result)\r\n  return result\r\n}\r\n\r\n/**\r\n * create copy of object, with same `class`\r\n * @param {Object} obj\r\n * @return {Object}\r\n */\r\nexport function ObjectCopy(obj) {\r\n  const copy = Object.create(obj.__proto__)\r\n  Object.assign(copy, obj)\r\n  return copy\r\n}\r\n\r\n/**\r\n * return class hierachy of `cls`\r\n * @param {function} cls\r\n * @return {function[]}\r\n */\r\nexport function classHierachy(cls) {\r\n  const result = []\r\n  if (typeof cls === 'function') {\r\n    let {name} = cls\r\n    while (name.length > 0) {\r\n      result.push({name, class: cls})\r\n      cls = cls.__proto__\r\n      name = cls.name\r\n    }\r\n  }\r\n  return result\r\n}\r\n\r\n/**\r\n * check if `cls` is subclass of `superClass`, will return false if cls is superClass\r\n * @param {function} cls\r\n * @param {function} superClass\r\n * @return {boolean}\r\n */\r\nexport function isSubclassOf(cls, superClass) {\r\n  if (typeof cls === 'function' && typeof superClass === 'function') {\r\n    const targetName = superClass.name\r\n    let {name} = cls\r\n    let level = 0\r\n    while (name.length > 0) {\r\n      if (name === targetName && level > 0) {\r\n        return true\r\n      }\r\n      cls = cls.__proto__\r\n      name = cls.name\r\n      ++level\r\n    }\r\n  }\r\n  return false\r\n}\r\n\r\n/**\r\n * check if `cls` is kind of `superClass`, will return true if cls is superClass\r\n * @param {function} cls\r\n * @param {function} superClass\r\n * @return {boolean}\r\n */\r\nexport function isKindclassOf(cls, superClass) {\r\n  if (typeof cls === 'function' && typeof superClass === 'function') {\r\n    const targetName = superClass.name\r\n    let {name} = cls\r\n    while (name.length > 0) {\r\n      if (name === targetName) {\r\n        return true\r\n      }\r\n      cls = cls.__proto__\r\n      name = cls.name\r\n    }\r\n  }\r\n  return false\r\n}\r\n\r\n/**\r\n * check if `inst` is instance of `cls`, specialized for some class\r\n * @param {any} inst\r\n * @param {function} cls\r\n * @return {boolean}\r\n */\r\nexport function instanceOf(inst, cls) {\r\n  if (Array.isArray(cls)) {\r\n    return cls.some(looper => instanceOf(inst, looper))\r\n  }\r\n  switch (cls.name) {\r\n    case 'String': {\r\n      return typeof inst === 'string' || inst instanceof cls\r\n    }\r\n    case 'Number': {\r\n      return typeof inst === 'number' || inst instanceof cls\r\n    }\r\n    default: {\r\n      return inst instanceof cls\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * return item * n string like python does.\r\n * @param {string} item\r\n * @param {number} n\r\n * @return {string}\r\n */\r\nexport function genString(item, n) {\r\n  let str = ''\r\n  for (let i = 0; i < n; ++i) {\r\n    str += item\r\n  }\r\n  return str\r\n}\r\n\r\n/**\r\n * assign value in `vector` into `matrix` by index in `indices`\r\n * @param {math.matrix} matrix\r\n * @param {number[]} indices\r\n * @param {number[]} vector\r\n */\r\nexport function matrixRangeAssign(matrix, indices, vector) {\r\n  if (Array.isArray(vector)) {\r\n    indices.forEach(idx => matrix.subset(math.index(idx), vector[idx]))\r\n  } else {\r\n    indices.forEach((idx, i) => matrix.subset(math.index(idx), vector.subset(math.index(i))))\r\n  }\r\n}\r\n\r\nexport function matrixRangeIndicesAssign(matrix, mstart, mend, vector, vstart) {\r\n  if (Array.isArray(vector)) {\r\n    for (let i = 0; i + mstart < mend; ++i) {\r\n      matrix.subset(math.index(i + mstart), vector[vstart + i])\r\n    }\r\n  } else {\r\n    for (let i = 0; i + mstart < mend; ++i) {\r\n      matrix.subset(math.index(i + mstart), vector.subset(math.index(vstart + i)))\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * return a row of matrix\r\n * @param {math.matrix} matrix\r\n * @param {number} index\r\n * @return {number[]}\r\n */\r\nexport function matrixGetRow(matrix, index) {\r\n  const rows = math.size(matrix).valueOf()[1];\r\n  return math.flatten(math.subset(matrix, math.index(index, math.range(0, rows))));\r\n}\r\n\r\n/**\r\n * dot product of matrix & vector\r\n * @param {math.matrix} matrix\r\n * @param {number[]} vector\r\n * @return {math.matrix}\r\n */\r\nexport function matrixDot(matrix, vector) {\r\n  const [rows] = matrix.size()\r\n  const result = []\r\n  for (let i = 0; i < rows; ++i) {\r\n    const row = matrixGetRow(matrix, i)\r\n    result.push(math.dot(row, vector))\r\n  }\r\n  return math.matrix(result)\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/libs/util.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 598,
    "kind": "function",
    "name": "zeros",
    "memberof": "src/libs/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/util.js~zeros",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/util.js",
    "importStyle": "{zeros}",
    "description": "generate a n-Length Array filled by `0`",
    "lineNumber": 23,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "n",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number[]"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 599,
    "kind": "function",
    "name": "arrayIsTuple",
    "memberof": "src/libs/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/util.js~arrayIsTuple",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/util.js",
    "importStyle": "{arrayIsTuple}",
    "description": "check if an array is `tuple`",
    "lineNumber": 36,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 600,
    "kind": "function",
    "name": "markTuple",
    "memberof": "src/libs/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/util.js~markTuple",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/util.js",
    "importStyle": "{markTuple}",
    "description": "force mark a value as `tuple`, internal usage only",
    "lineNumber": 52,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 601,
    "kind": "function",
    "name": "tuple",
    "memberof": "src/libs/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/util.js~tuple",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/util.js",
    "importStyle": "{tuple}",
    "description": "create `tuple` from arguments",
    "lineNumber": 61,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "args",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 602,
    "kind": "function",
    "name": "ObjectCopy",
    "memberof": "src/libs/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/util.js~ObjectCopy",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/util.js",
    "importStyle": "{ObjectCopy}",
    "description": "create copy of object, with same `class`",
    "lineNumber": 72,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "obj",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 603,
    "kind": "function",
    "name": "classHierachy",
    "memberof": "src/libs/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/util.js~classHierachy",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/util.js",
    "importStyle": "{classHierachy}",
    "description": "return class hierachy of `cls`",
    "lineNumber": 83,
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "cls",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "function[]"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 604,
    "kind": "function",
    "name": "isSubclassOf",
    "memberof": "src/libs/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/util.js~isSubclassOf",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/util.js",
    "importStyle": "{isSubclassOf}",
    "description": "check if `cls` is subclass of `superClass`, will return false if cls is superClass",
    "lineNumber": 102,
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "cls",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "superClass",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 605,
    "kind": "function",
    "name": "isKindclassOf",
    "memberof": "src/libs/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/util.js~isKindclassOf",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/util.js",
    "importStyle": "{isKindclassOf}",
    "description": "check if `cls` is kind of `superClass`, will return true if cls is superClass",
    "lineNumber": 125,
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "cls",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "superClass",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 606,
    "kind": "function",
    "name": "instanceOf",
    "memberof": "src/libs/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/util.js~instanceOf",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/util.js",
    "importStyle": "{instanceOf}",
    "description": "check if `inst` is instance of `cls`, specialized for some class",
    "lineNumber": 146,
    "params": [
      {
        "nullable": null,
        "types": [
          "any"
        ],
        "spread": false,
        "optional": false,
        "name": "inst",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "cls",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 607,
    "kind": "function",
    "name": "genString",
    "memberof": "src/libs/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/util.js~genString",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/util.js",
    "importStyle": "{genString}",
    "description": "return item * n string like python does.",
    "lineNumber": 169,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "item",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "n",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 608,
    "kind": "function",
    "name": "matrixRangeAssign",
    "memberof": "src/libs/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/util.js~matrixRangeAssign",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/util.js",
    "importStyle": "{matrixRangeAssign}",
    "description": "assign value in `vector` into `matrix` by index in `indices`",
    "lineNumber": 183,
    "params": [
      {
        "nullable": null,
        "types": [
          "math.matrix"
        ],
        "spread": false,
        "optional": false,
        "name": "matrix",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "indices",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "vector",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 609,
    "kind": "function",
    "name": "matrixRangeIndicesAssign",
    "memberof": "src/libs/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/util.js~matrixRangeIndicesAssign",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/util.js",
    "importStyle": "{matrixRangeIndicesAssign}",
    "description": null,
    "lineNumber": 191,
    "undocument": true,
    "params": [
      {
        "name": "matrix",
        "types": [
          "*"
        ]
      },
      {
        "name": "mstart",
        "types": [
          "*"
        ]
      },
      {
        "name": "mend",
        "types": [
          "*"
        ]
      },
      {
        "name": "vector",
        "types": [
          "*"
        ]
      },
      {
        "name": "vstart",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 610,
    "kind": "function",
    "name": "matrixGetRow",
    "memberof": "src/libs/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/util.js~matrixGetRow",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/util.js",
    "importStyle": "{matrixGetRow}",
    "description": "return a row of matrix",
    "lineNumber": 209,
    "params": [
      {
        "nullable": null,
        "types": [
          "math.matrix"
        ],
        "spread": false,
        "optional": false,
        "name": "matrix",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "index",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number[]"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 611,
    "kind": "function",
    "name": "matrixDot",
    "memberof": "src/libs/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/libs/util.js~matrixDot",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/libs/util.js",
    "importStyle": "{matrixDot}",
    "description": "dot product of matrix & vector",
    "lineNumber": 220,
    "params": [
      {
        "nullable": null,
        "types": [
          "math.matrix"
        ],
        "spread": false,
        "optional": false,
        "name": "matrix",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "vector",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "math.matrix"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 612,
    "kind": "file",
    "name": "src/libs/util.spec.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nimport math from 'mathjs'\r\nimport {expect} from 'chai'\r\nimport {\r\n  classHierachy, isSubclassOf, isKindclassOf, matrixDot\r\n} from './util'\r\nimport {HGate} from '../ops/gates'\r\nimport {BasicGate, SelfInverseGate} from '../ops/basics'\r\nimport {Qureg} from '../types/qubit'\r\nimport {expmod} from \"./polyfill\";\r\n\r\ndescribe('util test', () => {\r\n  it('should test class hierachy 1', () => {\r\n    const hierachy = classHierachy(HGate)\r\n    expect(hierachy).to.deep.equal([\r\n      {name: 'HGate', class: HGate},\r\n      {name: 'SelfInverseGate', class: SelfInverseGate},\r\n      {name: 'BasicGate', class: BasicGate}])\r\n\r\n    const h1 = classHierachy(Qureg)\r\n    expect(h1).to.deep.equal([\r\n      {name: 'Qureg', class: Qureg},\r\n      {name: 'Array', class: Array}])\r\n  });\r\n\r\n  it('should test isSubclassOf', () => {\r\n    expect(isSubclassOf(HGate, BasicGate)).to.equal(true)\r\n    expect(isSubclassOf(BasicGate, BasicGate)).to.equal(false)\r\n    expect(isSubclassOf(BasicGate, Array)).to.equal(false)\r\n    expect(isSubclassOf(Qureg, Array)).to.equal(true)\r\n  });\r\n\r\n  it('should test isKindclassOf', () => {\r\n    expect(isKindclassOf(HGate, BasicGate)).to.equal(true)\r\n    expect(isKindclassOf(BasicGate, BasicGate)).to.equal(true)\r\n    expect(isKindclassOf(HGate, Array)).to.equal(false)\r\n    expect(isKindclassOf(Qureg, Array)).to.equal(true)\r\n  });\r\n\r\n  it('should test matrixDot', () => {\r\n    const m = math.matrix([[1, 2], [3, 4]])\r\n    const v = math.matrix([1, 2])\r\n    const result = matrixDot(m, v)\r\n    expect(result).to.deep.equal(math.matrix([5, 11]))\r\n  });\r\n\r\n  it('should test expmod', function () {\r\n    expect(expmod(2, 10, 3)).to.equal(1)\r\n    expect(expmod(3, 200, 6)).to.equal(3)\r\n    expect(expmod(6, 278, 65)).to.equal(36)\r\n    expect(expmod(7, 399, 165)).to.equal(118)\r\n    expect(expmod(67, 32768, 212)).to.equal(81)\r\n  });\r\n})\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/libs/util.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 613,
    "kind": "file",
    "name": "src/meta/compute.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/* Compute, Uncompute, CustomUncompute.\r\n\r\n    Contains Compute, Uncompute, and CustomUncompute classes which can be used to\r\nannotate Compute / Action / Uncompute sections, facilitating the conditioning\r\nof the entire operation on the value of a qubit / register (only Action needs\r\ncontrols). This file also defines the corresponding meta tags.\r\n*/\r\nimport assert from 'assert'\r\nimport {BasicEngine} from '../cengines/basics'\r\nimport CommandModifier from '../cengines/cmdmodifier'\r\nimport {ComputeTag, UncomputeTag} from './tag'\r\nimport {dropEngineAfter, insertEngine} from './util'\r\nimport {Allocate, Deallocate} from '../ops/gates'\r\nimport {\r\n  unionSet, setEqual, setIsSuperSet, intersection\r\n} from '../libs/polyfill'\r\nimport {QubitManagementError} from './error'\r\n\r\n/**\r\n * @class ComputeEngine\r\n * @desc Adds Compute-tags to all commands and stores them (to later uncompute them automatically)\r\n */\r\nexport class ComputeEngine extends BasicEngine {\r\n  /**\r\n   * @constructor\r\n   */\r\n  constructor() {\r\n    super()\r\n    this._l = []\r\n    this._compute = true\r\n    // Save all qubit ids from qubits which are created or destroyed.\r\n    this.allocatedQubitIDs = new Set()\r\n    this.deallocatedQubitIDs = new Set()\r\n  }\r\n\r\n  /**\r\n    Modify the command tags, inserting an UncomputeTag.\r\n    @param {Command} cmd Command to modify.\r\n     */\r\n  addUnComputeTag(cmd) {\r\n    cmd.tags.push(new UncomputeTag())\r\n    return cmd\r\n  }\r\n\r\n  /**\r\n    Send uncomputing gates.\r\n\r\n    Sends the inverse of the stored commands in reverse order down to the\r\nnext engine. And also deals with allocated qubits in Compute section.\r\n    If a qubit has been allocated during compute, it will be deallocated\r\nduring uncompute. If a qubit has been allocated and deallocated during\r\ncompute, then a new qubit is allocated and deallocated during\r\nuncompute.\r\n     */\r\n  runUnCompute() {\r\n    // No qubits allocated during Compute section -> do standard uncompute\r\n    if (this.allocatedQubitIDs.size === 0) {\r\n      const cmds = this._l.rmap(cmd => this.addUnComputeTag(cmd.getInverse()))\r\n      this.send(cmds)\r\n      return\r\n    }\r\n\r\n\r\n    // qubits ids which were allocated and deallocated in Compute section\r\n    const ids_local_to_compute = intersection(this.allocatedQubitIDs, this.deallocatedQubitIDs)\r\n    // qubit ids which were allocated but not yet deallocated in\r\n    // Compute section\r\n    // TODO: why need to calculate this???\r\n    // const ids_still_alive = symmetricDifference(this.allocatedQubitIDs, this.deallocatedQubitIDs)\r\n\r\n    // No qubits allocated and already deallocated during compute.\r\n    // Don't inspect each command as below -> faster uncompute\r\n    // Just find qubits which have been allocated and deallocate them\r\n    if (ids_local_to_compute.size === 0) {\r\n      this._l.rforEach((cmd) => {\r\n        if (cmd.gate.equal(Allocate)) {\r\n          const qubit_id = cmd.qubits[0][0].id\r\n          // Remove this qubit from MainEngine.active_qubits and\r\n          // set qubit.id to = -1 in Qubit object such that it won't\r\n          // send another deallocate when it goes out of scope\r\n          let qubit_found = false\r\n          for (const active_qubit of this.main.activeQubits) {\r\n            if (active_qubit.id === qubit_id) {\r\n              active_qubit.id = -1\r\n              active_qubit.deallocate()\r\n              qubit_found = true\r\n              break\r\n            }\r\n          }\r\n\r\n          if (!qubit_found) {\r\n            throw new QubitManagementError('\\nQubit was not found in '\r\n                + 'MainEngine.active_qubits.\\n')\r\n          }\r\n          this.send([this.addUnComputeTag(cmd.getInverse())])\r\n        } else {\r\n          this.send([this.addUnComputeTag(cmd.getInverse())])\r\n        }\r\n      })\r\n      return\r\n    }\r\n\r\n    // There was at least one qubit allocated and deallocated within\r\n    // compute section. Handle uncompute in most general case\r\n    const new_local_id = {}\r\n    this._l.slice(0).rforEach((cmd) => {\r\n      if (cmd.gate.equal(Deallocate)) {\r\n        assert(ids_local_to_compute.has(cmd.qubits[0][0].id))\r\n        // Create new local qubit which lives within uncompute section\r\n\r\n        // Allocate needs to have old tags + uncompute tag\r\n        const add_uncompute = (command, old_tags = cmd.tags.slice(0)) => {\r\n          command.tags = old_tags.concat([new UncomputeTag()])\r\n          return command\r\n        }\r\n        const tagger_eng = new CommandModifier(add_uncompute)\r\n        insertEngine(this, tagger_eng)\r\n        const new_local_qb = this.allocateQubit()\r\n        dropEngineAfter(this)\r\n\r\n        new_local_id[cmd.qubits[0][0].id] = new_local_qb[0].id\r\n        // Set id of new_local_qb to -1 such that it doesn't send a\r\n        // deallocate gate\r\n        new_local_qb[0].id = -1\r\n      } else if (cmd.gate.equal(Allocate)) {\r\n        // Deallocate qubit\r\n        if (ids_local_to_compute.has(cmd.qubits[0][0].id)) {\r\n          // Deallocate local qubit and remove id from new_local_id\r\n          const old_id = cmd.qubits[0][0].id\r\n          cmd.qubits[0][0].id = new_local_id[cmd.qubits[0][0].id]\r\n          delete new_local_id[old_id]\r\n          this.send([this.addUnComputeTag(cmd.getInverse())])\r\n        } else {\r\n          // Deallocate qubit which was allocated in compute section:\r\n          const qubit_id = cmd.qubits[0][0].id\r\n          // Remove this qubit from MainEngine.active_qubits and\r\n          // set qubit.id to = -1 in Qubit object such that it won't\r\n          // send another deallocate when it goes out of scope\r\n          let qubit_found = false\r\n          for (const active_qubit of this.main.activeQubits) {\r\n            if (active_qubit.id === qubit_id) {\r\n              active_qubit.id = -1\r\n              active_qubit.deallocate()\r\n              qubit_found = true\r\n              break\r\n            }\r\n          }\r\n          if (!qubit_found) {\r\n            throw new QubitManagementError(\r\n              '\\nQubit was not found in '\r\n            + 'MainEngine.active_qubits.\\n'\r\n            )\r\n          }\r\n          this.send([this.addUnComputeTag(cmd.getInverse())])\r\n        }\r\n      } else {\r\n        // Process commands by replacing each local qubit from\r\n        // compute section with new local qubit from the uncompute\r\n        // section\r\n        if (Object.keys(new_local_id).length > 0) { // Only if we still have local qubits\r\n          cmd.allQubits.forEach((qureg) => {\r\n            qureg.forEach((qubit) => {\r\n              if (new_local_id[qubit.id]) {\r\n                qubit.id = new_local_id[qubit.id]\r\n              }\r\n            })\r\n          })\r\n        }\r\n        this.send([this.addUnComputeTag(cmd.getInverse())])\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\nEnd the compute step (exit the Compute() - statement).\r\n\r\nWill tell the Compute-engine to stop caching. It then waits for the\r\n    uncompute instruction, which is when it sends all cached commands\r\ninverted and in reverse order down to the next compiler engine.\r\n\r\n    @throws {QubitManagementError} If qubit has been deallocated in Compute\r\nsection which has not been allocated in Compute section\r\n*/\r\n  endCompute() {\r\n    this._compute = false\r\n    if (!setIsSuperSet(this.allocatedQubitIDs, this.deallocatedQubitIDs)) {\r\n      throw new QubitManagementError(\r\n        '\\nQubit has been deallocated in with Compute(eng) context \\n'\r\n    + 'which has not been allocated within this Compute section'\r\n      )\r\n    }\r\n  }\r\n\r\n  /**\r\n  If in compute-mode: Receive commands and store deepcopy of each cmd.\r\n    Add ComputeTag to received cmd and send it on.\r\n    Otherwise: send all received commands directly to next_engine.\r\n\r\n    @param {Command[]} commandList List of commands to receive.\r\n   */\r\n  receive(commandList) {\r\n    if (this._compute) {\r\n      commandList.forEach((cmd) => {\r\n        if (cmd.gate.equal(Allocate)) {\r\n          this.allocatedQubitIDs.add(cmd.qubits[0][0].id)\r\n        } else if (cmd.gate.equal(Deallocate)) {\r\n          this.deallocatedQubitIDs.add(cmd.qubits[0][0].id)\r\n        }\r\n        this._l.push(cmd.copy())\r\n        cmd.tags.push(new ComputeTag())\r\n      })\r\n    }\r\n    this.send(commandList)\r\n  }\r\n}\r\n\r\n/**\r\n * @class Uncompute\r\n */\r\nexport class UncomputeEngine extends BasicEngine {\r\n  /**\r\n   * @constructor\r\n   */\r\n  constructor() {\r\n    super()\r\n    // Save all qubit ids from qubits which are created or destroyed.\r\n    this.allocatedQubitIDs = new Set()\r\n    this.deallocatedQubitIDs = new Set()\r\n  }\r\n\r\n  /**\r\n  Receive commands and add an UncomputeTag to their tags.\r\n\r\n    @param {Command[]} commandList List of commands to handle.\r\n   */\r\n  receive(commandList) {\r\n    commandList.forEach((cmd) => {\r\n      if (cmd.gate.equal(Allocate)) {\r\n        this.allocatedQubitIDs.add(cmd.qubits[0][0].id)\r\n      } else if (cmd.gate.equal(Deallocate)) {\r\n        this.deallocatedQubitIDs.add(cmd.qubits[0][0].id)\r\n      }\r\n      cmd.tags.push(new UncomputeTag())\r\n      this.send([cmd])\r\n    })\r\n  }\r\n}\r\n\r\n/**\r\nStart a compute-section.\r\n\r\n    @example\r\n\r\nCompute(eng, () => {\r\n  do_something(qubits)\r\n  action(qubits)\r\n})\r\nUncompute(eng) // runs inverse of the compute section\r\n\r\nWarning:\r\n    If qubits are allocated within the compute section, they must either be\r\nuncomputed and deallocated within that section or, alternatively,\r\n    uncomputed and deallocated in the following uncompute section.\r\n\r\n    This means that the following examples are valid:\r\n\r\n @example\r\n\r\nCompute(eng, () => {\r\n  anc = eng.allocateQubit()\r\n  do_something_with_ancilla(anc)\r\n})\r\n ...\r\nuncompute_ancilla(anc)\r\nanc.deallocate()\r\n\r\ndo_something_else(qubits)\r\n\r\nUncompute(eng)  // will allocate a new ancilla (with a different id)\r\n// and then deallocate it again\r\n\r\n @example\r\n\r\nCompute(eng, () => {\r\nanc = eng.allocateQubit()\r\ndo_something_with_ancilla(anc)\r\n...\r\n})\r\ndo_something_else(qubits)\r\n\r\nUncompute(eng)  // will deallocate the ancilla!\r\n\r\n    After the uncompute section, ancilla qubits allocated within the\r\ncompute section will be invalid (and deallocated). The same holds when\r\nusing CustomUncompute.\r\n\r\n    Failure to comply with these rules results in an exception being thrown.\r\n */\r\nexport function Compute(engine, func) {\r\n  let computeEngine = null\r\n  const enter = () => {\r\n    computeEngine = new ComputeEngine()\r\n    insertEngine(engine, computeEngine)\r\n  }\r\n\r\n  const exit = () => {\r\n    computeEngine.endCompute()\r\n    computeEngine = null\r\n  }\r\n\r\n  if (typeof func === 'function') {\r\n    enter()\r\n    try {\r\n      func()\r\n    } catch (e) {\r\n      throw e\r\n    } finally {\r\n      exit()\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\nStart a custom uncompute-section.\r\n\r\n    @example\r\n\r\nCompute(eng, () => {\r\n  do_something(qubits)\r\n})\r\n\r\n action(qubits)\r\n\r\n CustomUncompute(eng, () => {\r\n  do_something_inverse(qubits)\r\n})\r\n\r\n@throws {QubitManagementError} If qubits are allocated within Compute or within\r\nCustomUncompute context but are not deallocated.\r\n */\r\nexport function CustomUncompute(engine, func) {\r\n  let allocatedQubitIDs = new Set()\r\n  let deallocatedQubitIDs = new Set()\r\n  let uncomputeEngine = null\r\n\r\n  const enter = () => {\r\n    // first, remove the compute engine\r\n    const compute_eng = engine.next\r\n    if (!(compute_eng instanceof ComputeEngine)) {\r\n      throw new QubitManagementError('Invalid call to CustomUncompute: No corresponding \"Compute\" statement found.')\r\n    }\r\n    // Make copy so there is not reference to compute_eng anymore\r\n    // after __enter__\r\n    allocatedQubitIDs = new Set(compute_eng.allocatedQubitIDs)\r\n    deallocatedQubitIDs = new Set(compute_eng.deallocatedQubitIDs)\r\n    dropEngineAfter(engine)\r\n    // Now add uncompute engine\r\n    uncomputeEngine = new UncomputeEngine()\r\n    insertEngine(engine, uncomputeEngine)\r\n  }\r\n\r\n  const exit = () => {\r\n    // If an error happens in this context, qubits might not have been\r\n    // deallocated because that code section was not yet executed,\r\n    // so don't check and raise an additional error.\r\n\r\n    // Check that all qubits allocated within Compute or within\r\n    // CustomUncompute have been deallocated.\r\n    const all_allocated_qubits = unionSet(allocatedQubitIDs, uncomputeEngine.allocatedQubitIDs)\r\n    const all_deallocated_qubits = unionSet(deallocatedQubitIDs, uncomputeEngine.deallocatedQubitIDs)\r\n    if (!setEqual(all_allocated_qubits, all_deallocated_qubits)) {\r\n      throw new QubitManagementError('\\nError. Not all qubits have been deallocated which have \\n'\r\n               + 'been allocated in the Compute(eng) or with '\r\n               + 'CustomUncompute(eng) context.')\r\n    }\r\n    // remove uncompute engine\r\n    dropEngineAfter(engine)\r\n  }\r\n\r\n  if (typeof func === 'function') {\r\n    enter()\r\n    try {\r\n      func()\r\n    } catch (e) {\r\n      throw e\r\n    } finally {\r\n      exit()\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\nUncompute automatically.\r\n\r\n    @example\r\n Compute(eng, () => {\r\n  do_something(qubits)\r\n})\r\n  action(qubits)\r\n  Uncompute(eng) // runs inverse of the compute section\r\n */\r\nexport function Uncompute(engine) {\r\n  const compute_eng = engine.next\r\n  if (!(compute_eng instanceof ComputeEngine)) {\r\n    throw new Error('Invalid call to Uncompute: No corresponding \"Compute\" statement found.')\r\n  }\r\n  compute_eng.runUnCompute()\r\n  dropEngineAfter(engine)\r\n\r\n  if (engine.autoDeallocateQubits) {\r\n    engine.autoDeallocateQubits()\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/meta/compute.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 614,
    "kind": "class",
    "name": "ComputeEngine",
    "memberof": "src/meta/compute.js",
    "static": true,
    "longname": "src/meta/compute.js~ComputeEngine",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/meta/compute.js",
    "importStyle": "{ComputeEngine}",
    "description": "Adds Compute-tags to all commands and stores them (to later uncompute them automatically)",
    "lineNumber": 39,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "ComputeEngine"
      }
    ],
    "interface": false,
    "extends": [
      "src/cengines/basics.js~BasicEngine"
    ]
  },
  {
    "__docId__": 615,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/meta/compute.js~ComputeEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/compute.js~ComputeEngine#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 43,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ]
  },
  {
    "__docId__": 616,
    "kind": "member",
    "name": "_l",
    "memberof": "src/meta/compute.js~ComputeEngine",
    "static": false,
    "longname": "src/meta/compute.js~ComputeEngine#_l",
    "access": "private",
    "description": null,
    "lineNumber": 45,
    "undocument": true,
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 617,
    "kind": "member",
    "name": "_compute",
    "memberof": "src/meta/compute.js~ComputeEngine",
    "static": false,
    "longname": "src/meta/compute.js~ComputeEngine#_compute",
    "access": "private",
    "description": null,
    "lineNumber": 46,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 618,
    "kind": "member",
    "name": "allocatedQubitIDs",
    "memberof": "src/meta/compute.js~ComputeEngine",
    "static": false,
    "longname": "src/meta/compute.js~ComputeEngine#allocatedQubitIDs",
    "access": "public",
    "description": null,
    "lineNumber": 48,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 619,
    "kind": "member",
    "name": "deallocatedQubitIDs",
    "memberof": "src/meta/compute.js~ComputeEngine",
    "static": false,
    "longname": "src/meta/compute.js~ComputeEngine#deallocatedQubitIDs",
    "access": "public",
    "description": null,
    "lineNumber": 49,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 620,
    "kind": "method",
    "name": "addUnComputeTag",
    "memberof": "src/meta/compute.js~ComputeEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/compute.js~ComputeEngine#addUnComputeTag",
    "access": "public",
    "description": "Modify the command tags, inserting an UncomputeTag.",
    "lineNumber": 56,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": "Command to modify."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 621,
    "kind": "method",
    "name": "runUnCompute",
    "memberof": "src/meta/compute.js~ComputeEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/compute.js~ComputeEngine#runUnCompute",
    "access": "public",
    "description": "Send uncomputing gates.\n\nSends the inverse of the stored commands in reverse order down to the\nnext engine. And also deals with allocated qubits in Compute section.\nIf a qubit has been allocated during compute, it will be deallocated\nduring uncompute. If a qubit has been allocated and deallocated during\ncompute, then a new qubit is allocated and deallocated during\nuncompute.",
    "lineNumber": 71,
    "params": [],
    "return": null
  },
  {
    "__docId__": 622,
    "kind": "method",
    "name": "endCompute",
    "memberof": "src/meta/compute.js~ComputeEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/compute.js~ComputeEngine#endCompute",
    "access": "public",
    "description": "End the compute step (exit the Compute() - statement).\n\nWill tell the Compute-engine to stop caching. It then waits for the\nuncompute instruction, which is when it sends all cached commands\ninverted and in reverse order down to the next compiler engine.",
    "lineNumber": 200,
    "throws": [
      {
        "types": [
          "QubitManagementError"
        ],
        "description": "If qubit has been deallocated in Compute\nsection which has not been allocated in Compute section"
      }
    ],
    "params": [],
    "return": null
  },
  {
    "__docId__": 624,
    "kind": "method",
    "name": "receive",
    "memberof": "src/meta/compute.js~ComputeEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/compute.js~ComputeEngine#receive",
    "access": "public",
    "description": "If in compute-mode: Receive commands and store deepcopy of each cmd.\nAdd ComputeTag to received cmd and send it on.\nOtherwise: send all received commands directly to next_engine.",
    "lineNumber": 217,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command[]"
        ],
        "spread": false,
        "optional": false,
        "name": "commandList",
        "description": "List of commands to receive."
      }
    ],
    "return": null
  },
  {
    "__docId__": 625,
    "kind": "class",
    "name": "UncomputeEngine",
    "memberof": "src/meta/compute.js",
    "static": true,
    "longname": "src/meta/compute.js~UncomputeEngine",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/meta/compute.js",
    "importStyle": "{UncomputeEngine}",
    "description": "",
    "lineNumber": 236,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "Uncompute"
      }
    ],
    "interface": false,
    "extends": [
      "src/cengines/basics.js~BasicEngine"
    ]
  },
  {
    "__docId__": 626,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/meta/compute.js~UncomputeEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/compute.js~UncomputeEngine#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 240,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ]
  },
  {
    "__docId__": 627,
    "kind": "member",
    "name": "allocatedQubitIDs",
    "memberof": "src/meta/compute.js~UncomputeEngine",
    "static": false,
    "longname": "src/meta/compute.js~UncomputeEngine#allocatedQubitIDs",
    "access": "public",
    "description": null,
    "lineNumber": 243,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 628,
    "kind": "member",
    "name": "deallocatedQubitIDs",
    "memberof": "src/meta/compute.js~UncomputeEngine",
    "static": false,
    "longname": "src/meta/compute.js~UncomputeEngine#deallocatedQubitIDs",
    "access": "public",
    "description": null,
    "lineNumber": 244,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 629,
    "kind": "method",
    "name": "receive",
    "memberof": "src/meta/compute.js~UncomputeEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/compute.js~UncomputeEngine#receive",
    "access": "public",
    "description": "Receive commands and add an UncomputeTag to their tags.",
    "lineNumber": 252,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command[]"
        ],
        "spread": false,
        "optional": false,
        "name": "commandList",
        "description": "List of commands to handle."
      }
    ],
    "return": null
  },
  {
    "__docId__": 630,
    "kind": "function",
    "name": "Compute",
    "memberof": "src/meta/compute.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/meta/compute.js~Compute",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/meta/compute.js",
    "importStyle": "{Compute}",
    "description": "Start a compute-section.",
    "examples": [
      "\nCompute(eng, () => {\ndo_something(qubits)\naction(qubits)\n})\nUncompute(eng) // runs inverse of the compute section\n\nWarning:\nIf qubits are allocated within the compute section, they must either be\nuncomputed and deallocated within that section or, alternatively,\nuncomputed and deallocated in the following uncompute section.\n\nThis means that the following examples are valid:",
      "\nCompute(eng, () => {\nanc = eng.allocateQubit()\ndo_something_with_ancilla(anc)\n})\n...\nuncompute_ancilla(anc)\nanc.deallocate()\n\ndo_something_else(qubits)\n\nUncompute(eng)  // will allocate a new ancilla (with a different id)\n// and then deallocate it again",
      "\nCompute(eng, () => {\nanc = eng.allocateQubit()\ndo_something_with_ancilla(anc)\n...\n})\ndo_something_else(qubits)\n\nUncompute(eng)  // will deallocate the ancilla!\n\nAfter the uncompute section, ancilla qubits allocated within the\ncompute section will be invalid (and deallocated). The same holds when\nusing CustomUncompute.\n\nFailure to comply with these rules results in an exception being thrown."
    ],
    "lineNumber": 315,
    "params": [
      {
        "name": "engine",
        "types": [
          "*"
        ]
      },
      {
        "name": "func",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 631,
    "kind": "function",
    "name": "CustomUncompute",
    "memberof": "src/meta/compute.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/meta/compute.js~CustomUncompute",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/meta/compute.js",
    "importStyle": "{CustomUncompute}",
    "description": "Start a custom uncompute-section.",
    "examples": [
      "\nCompute(eng, () => {\ndo_something(qubits)\n})\n\naction(qubits)\n\nCustomUncompute(eng, () => {\ndo_something_inverse(qubits)\n})"
    ],
    "lineNumber": 357,
    "throws": [
      {
        "types": [
          "QubitManagementError"
        ],
        "description": "If qubits are allocated within Compute or within\nCustomUncompute context but are not deallocated."
      }
    ],
    "params": [
      {
        "name": "engine",
        "types": [
          "*"
        ]
      },
      {
        "name": "func",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 632,
    "kind": "function",
    "name": "Uncompute",
    "memberof": "src/meta/compute.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/meta/compute.js~Uncompute",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/meta/compute.js",
    "importStyle": "{Uncompute}",
    "description": "Uncompute automatically.",
    "examples": [
      "Compute(eng, () => {\ndo_something(qubits)\n})\naction(qubits)\nUncompute(eng) // runs inverse of the compute section"
    ],
    "lineNumber": 418,
    "params": [
      {
        "name": "engine",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 633,
    "kind": "file",
    "name": "src/meta/compute.spec.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport {expect} from 'chai'\r\nimport {ComputeTag, UncomputeTag, DirtyQubitTag} from './tag'\r\nimport {\r\n  Allocate, Deallocate, H, NOT, Rx, Ry, FlushGate\r\n} from '../ops/gates'\r\nimport {CNOT} from '../ops/shortcuts'\r\nimport MainEngine from '../cengines/main'\r\nimport {DummyEngine, CompareEngine} from '../cengines/testengine'\r\nimport {\r\n  ComputeEngine, UncomputeEngine, Compute, Uncompute, CustomUncompute\r\n} from './compute'\r\nimport {tuple} from '../libs/util'\r\nimport {QubitManagementError} from './error'\r\n\r\ndescribe('compute test', () => {\r\n  it('should test compute tag', () => {\r\n    const tag0 = new ComputeTag()\r\n    const tag1 = new ComputeTag()\r\n    expect(tag0.equal(tag1)).to.equal(true)\r\n    expect(tag0 === {}).to.equal(false)\r\n  })\r\n\r\n  it('should test uncompute tag', () => {\r\n    const tag0 = new UncomputeTag()\r\n    const tag1 = new UncomputeTag()\r\n    expect(tag0.equal(tag1)).to.equal(true)\r\n    expect(tag0 === new Object()).to.equal(false)\r\n  })\r\n\r\n  it('should test compute engine', () => {\r\n    const backend = new DummyEngine(true)\r\n    const compute_engine = new ComputeEngine()\r\n    const eng = new MainEngine(backend, [compute_engine])\r\n    const ancilla = eng.allocateQubit() // Ancilla\r\n    H.or(ancilla)\r\n    new Rx(0.6).or(ancilla)\r\n    ancilla[0].deallocate()\r\n    // Test that adding later a new tag to one of the previous commands\r\n    // does not add this tags to cmds saved in compute_engine because\r\n    // this one does need to make a deepcopy and not store a reference.\r\n    expect(backend.receivedCommands[1].gate.equal(H)).to.equal(true)\r\n    backend.receivedCommands[1].tags.push('TagAddedLater')\r\n    const {tags} = backend.receivedCommands[1]\r\n    expect(tags[tags.length - 1]).equal('TagAddedLater')\r\n    compute_engine.endCompute()\r\n    const new_qubit = eng.allocateQubit()\r\n    new Ry(0.5).or(new_qubit)\r\n    compute_engine.runUnCompute()\r\n    eng.flush()\r\n\r\n    expect(backend.receivedCommands[0].gate.equal(Allocate)).to.equal(true)\r\n    expect(backend.receivedCommands[0].tags).to.deep.equal([new ComputeTag()])\r\n    expect(backend.receivedCommands[1].gate.equal(H)).to.equal(true)\r\n    expect(backend.receivedCommands[1].tags).to.deep.equal([new ComputeTag(), 'TagAddedLater'])\r\n\r\n    expect(backend.receivedCommands[2].gate.equal(new Rx(0.6))).to.equal(true)\r\n    expect(backend.receivedCommands[2].tags).to.deep.equal([new ComputeTag()])\r\n    expect(backend.receivedCommands[3].gate.equal(Deallocate)).to.equal(true)\r\n    expect(backend.receivedCommands[3].tags).to.deep.equal([new ComputeTag()])\r\n\r\n    expect(backend.receivedCommands[4].gate.equal(Allocate)).to.equal(true)\r\n    expect(backend.receivedCommands[4].tags).to.deep.equal([])\r\n    expect(backend.receivedCommands[5].gate.equal(new Ry(0.5))).to.equal(true)\r\n    expect(backend.receivedCommands[5].tags).to.deep.equal([])\r\n\r\n    expect(backend.receivedCommands[6].gate.equal(Allocate)).to.equal(true)\r\n    expect(backend.receivedCommands[6].tags).to.deep.equal([new UncomputeTag()])\r\n    expect(backend.receivedCommands[7].gate.equal(new Ry(-0.6))).to.equal(true)\r\n    expect(backend.receivedCommands[7].tags).to.deep.equal([new UncomputeTag()])\r\n\r\n    expect(backend.receivedCommands[8].gate.equal(H)).to.equal(true)\r\n    expect(backend.receivedCommands[8].tags).to.deep.equal([new UncomputeTag()])\r\n    expect(backend.receivedCommands[9].gate.equal(Deallocate)).to.equal(true)\r\n    expect(backend.receivedCommands[9].tags).to.deep.equal([new UncomputeTag()])\r\n  })\r\n\r\n  it('should test uncompute engine', () => {\r\n    const backend = new DummyEngine(true)\r\n    const uncompute_engine = new UncomputeEngine()\r\n    const eng = new MainEngine(backend, [uncompute_engine])\r\n    const qubit = eng.allocateQubit()\r\n    H.or(qubit)\r\n    expect(backend.receivedCommands[0].gate.equal(Allocate)).to.equal(true)\r\n    expect(backend.receivedCommands[0].tags).to.deep.equal([new UncomputeTag()])\r\n    expect(backend.receivedCommands[1].gate.equal(H)).to.equal(true)\r\n    expect(backend.receivedCommands[1].tags).to.deep.equal([new UncomputeTag()])\r\n  })\r\n\r\n  it('should test outside qubit deallocated in compute', () => {\r\n    // Test that there is an error if a qubit is deallocated which has\r\n    // not been allocated within the with Compute(eng) context\r\n    const eng = new MainEngine(new DummyEngine(), [new DummyEngine()])\r\n    const qubit = eng.allocateQubit()\r\n    expect(() => Compute(eng, () => qubit[0].deallocate())).to.throw(QubitManagementError)\r\n  })\r\n\r\n  it('should test deallocation using custom uncompute', () => {\r\n    // Test that qubits allocated within Compute and Uncompute\r\n    // section have all been deallocated\r\n    const eng = new MainEngine(new DummyEngine(), [new DummyEngine()])\r\n    // # Allowed versions:\r\n    Compute(eng, () => {\r\n      const ancilla = eng.allocateQubit()\r\n      ancilla[0].deallocate()\r\n    })\r\n    CustomUncompute(eng, () => {\r\n      const a2 = eng.allocateQubit()\r\n      a2[0].deallocate()\r\n    })\r\n    Compute(eng, () => {\r\n      const a3 = eng.allocateQubit()\r\n      CustomUncompute(eng, () => {\r\n        a3[0].deallocate()\r\n      })\r\n    })\r\n  })\r\n\r\n  it('should test deallocation using custom uncompute2', () => {\r\n    // Test not allowed version:\r\n    const eng = new MainEngine(new DummyEngine(), [new DummyEngine()])\r\n    let a\r\n    Compute(eng, () => {\r\n      a = eng.allocateQubit()\r\n    })\r\n    expect(() => {\r\n      CustomUncompute(eng, () => {\r\n\r\n      })\r\n    }).to.throw(QubitManagementError)\r\n    H.or(a)\r\n  })\r\n\r\n  it('should test deallocation using custom uncompute3', () => {\r\n    // Test not allowed version:\r\n    const eng = new MainEngine(new DummyEngine(), [new DummyEngine()])\r\n    Compute(eng, () => {\r\n\r\n    })\r\n    let a = null\r\n    expect(() => {\r\n      CustomUncompute(eng, () => {\r\n        a = eng.allocateQubit()\r\n      })\r\n    }).to.throw(QubitManagementError)\r\n    H.or(a)\r\n  })\r\n\r\n  it('should test automatic deallocation of qubit in uncompute', () => {\r\n    // Test that automatic uncomputation deallocates qubit\r\n    // which was created during compute context.\r\n    const backend = new DummyEngine(true)\r\n    const eng = new MainEngine(backend, [new DummyEngine()])\r\n    let ancilla\r\n    Compute(eng, () => {\r\n      ancilla = eng.allocateQubit()\r\n      expect(ancilla[0].id).not.to.equal(-1)\r\n      new Rx(0.6).or(ancilla)\r\n    })\r\n    // Test that ancilla qubit has been registered in MainEngine.active_qubits\r\n    expect(eng.activeQubits.has(ancilla[0])).to.equal(true)\r\n    Uncompute(eng)\r\n    // Test that ancilla id has been set to -1\r\n    expect(ancilla[0].id).to.equal(-1)\r\n    // Test that ancilla is not anymore in active qubits\r\n    // TODO: fixme\r\n    // expect(eng.activeQubits.has(ancilla[0])).to.equal(false)\r\n    expect(backend.receivedCommands[1].gate.equal(new Rx(0.6))).to.equal(true)\r\n    expect(backend.receivedCommands[2].gate.equal(new Rx(-0.6))).to.equal(true)\r\n    // Test that there are no additional deallocate gates\r\n    expect(backend.receivedCommands.length).to.equal(4)\r\n  })\r\n\r\n  it('should test compute uncompute no additional qubits', () => {\r\n    // No ancilla qubit created in compute section\r\n    const backend0 = new DummyEngine(true)\r\n    const compare_engine0 = new CompareEngine()\r\n    const eng0 = new MainEngine(backend0, [compare_engine0])\r\n    let qubit = eng0.allocateQubit()\r\n    Compute(eng0, () => {\r\n      new Rx(0.5).or(qubit)\r\n    })\r\n    H.or(qubit)\r\n    Uncompute(eng0)\r\n    eng0.flush(true)\r\n\r\n    expect(backend0.receivedCommands[0].gate.equal(Allocate)).to.equal(true)\r\n    expect(backend0.receivedCommands[1].gate.equal(new Rx(0.5))).to.equal(true)\r\n    expect(backend0.receivedCommands[2].gate.equal(H)).to.equal(true)\r\n    expect(backend0.receivedCommands[3].gate.equal(new Rx(-0.5))).to.equal(true)\r\n    expect(backend0.receivedCommands[4].gate.equal(Deallocate)).to.equal(true)\r\n\r\n    expect(backend0.receivedCommands[0].tags).to.deep.equal([])\r\n    expect(backend0.receivedCommands[1].tags).to.deep.equal([new ComputeTag()])\r\n    expect(backend0.receivedCommands[2].tags).to.deep.equal([])\r\n    expect(backend0.receivedCommands[3].tags).to.deep.equal([new UncomputeTag()])\r\n    expect(backend0.receivedCommands[4].tags).to.deep.equal([])\r\n\r\n    // Same using CustomUncompute and test using CompareEngine\r\n    const backend1 = new DummyEngine(true)\r\n    const compare_engine1 = new CompareEngine()\r\n    const eng1 = new MainEngine(backend1, [compare_engine1])\r\n    qubit = eng1.allocateQubit()\r\n    Compute(eng1, () => {\r\n      new Rx(0.5).or(qubit)\r\n    })\r\n    H.or(qubit)\r\n    CustomUncompute(eng1, () => {\r\n      new Rx(-0.5).or(qubit)\r\n    })\r\n    eng1.flush(true)\r\n    console.log(compare_engine0, compare_engine1)\r\n    expect(compare_engine0.equal(compare_engine1)).to.equal(true)\r\n  })\r\n\r\n  it('should test compute uncompute with statement', () => {\r\n    // Allocating and deallocating qubit within Compute\r\n    const backend = new DummyEngine(true)\r\n    const compare_engine0 = new CompareEngine()\r\n    // Allow dirty qubits\r\n    const dummy_cengine = new DummyEngine()\r\n    const allow_dirty_qubits = meta_tag => (meta_tag === DirtyQubitTag)\r\n\r\n    dummy_cengine.isMetaTagHandler = allow_dirty_qubits\r\n    const eng = new MainEngine(backend, [compare_engine0, dummy_cengine])\r\n    let qubit = eng.allocateQubit()\r\n\r\n    Compute(eng, () => {\r\n      new Rx(0.9).or(qubit)\r\n      const ancilla = eng.allocateQubit(true)\r\n      // ancilla2 will be deallocated in Uncompute section:\r\n      const ancilla2 = eng.allocateQubit()\r\n      // Test that ancilla is registered in MainEngine.active_qubits:\r\n      expect(eng.activeQubits.has(ancilla[0])).to.equal(true)\r\n\r\n      H.or(qubit)\r\n      new Rx(0.5).or(ancilla)\r\n      CNOT.or(tuple(ancilla, qubit))\r\n      new Rx(0.7).or(qubit)\r\n      new Rx(-0.5).or(ancilla)\r\n      ancilla[0].deallocate()\r\n    })\r\n\r\n    H.or(qubit)\r\n    Uncompute(eng)\r\n    eng.flush(true)\r\n\r\n    expect(backend.receivedCommands.length).to.equal(22)\r\n\r\n    // Test each Command has correct gate\r\n    expect(backend.receivedCommands[0].gate.equal(Allocate)).to.equal(true)\r\n    expect(backend.receivedCommands[1].gate.equal(new Rx(0.9))).to.equal(true)\r\n    expect(backend.receivedCommands[2].gate.equal(Allocate)).to.equal(true)\r\n    expect(backend.receivedCommands[3].gate.equal(Allocate)).to.equal(true)\r\n    expect(backend.receivedCommands[4].gate.equal(H)).to.equal(true)\r\n    expect(backend.receivedCommands[5].gate.equal(new Rx(0.5))).to.equal(true)\r\n    expect(backend.receivedCommands[6].gate.equal(NOT)).to.equal(true)\r\n\r\n    expect(backend.receivedCommands[7].gate.equal(new Rx(0.7))).to.equal(true)\r\n    expect(backend.receivedCommands[8].gate.equal(new Rx(-0.5))).to.equal(true)\r\n    expect(backend.receivedCommands[9].gate.equal(Deallocate)).to.equal(true)\r\n    expect(backend.receivedCommands[10].gate.equal(H)).to.equal(true)\r\n    expect(backend.receivedCommands[11].gate.equal(Allocate)).to.equal(true)\r\n    expect(backend.receivedCommands[12].gate.equal(new Rx(0.5))).to.equal(true)\r\n    expect(backend.receivedCommands[13].gate.equal(new Rx(-0.7))).to.equal(true)\r\n\r\n    expect(backend.receivedCommands[14].gate.equal(NOT)).to.equal(true)\r\n    expect(backend.receivedCommands[15].gate.equal(new Rx(-0.5))).to.equal(true)\r\n    expect(backend.receivedCommands[16].gate.equal(H)).to.equal(true)\r\n    expect(backend.receivedCommands[17].gate.equal(Deallocate)).to.equal(true)\r\n    expect(backend.receivedCommands[18].gate.equal(Deallocate)).to.equal(true)\r\n    expect(backend.receivedCommands[19].gate.equal(new Rx(-0.9))).to.equal(true)\r\n    expect(backend.receivedCommands[20].gate.equal(Deallocate)).to.equal(true)\r\n\r\n    expect(backend.receivedCommands[21].gate.equal(new FlushGate())).to.equal(true)\r\n    expect(backend.receivedCommands[20].gate.equal(Deallocate)).to.equal(true)\r\n    expect(backend.receivedCommands[20].gate.equal(Deallocate)).to.equal(true)\r\n\r\n    // Test that each command has correct tags\r\n    expect(backend.receivedCommands[0].tags).to.deep.equal([])\r\n    expect(backend.receivedCommands[1].tags).to.deep.equal([new ComputeTag()])\r\n    expect(backend.receivedCommands[2].tags).to.deep.equal([new DirtyQubitTag(), new ComputeTag()])\r\n\r\n    backend.receivedCommands.slice(3, 9).forEach((cmd) => {\r\n      expect(cmd.tags).to.deep.equal([new ComputeTag()])\r\n    })\r\n\r\n    // expect(backend.receivedCommands[9].tags == [DirtyQubitTag(),\r\n    //       ComputeTag]\r\n    expect(backend.receivedCommands[10].tags).to.deep.equal([])\r\n    expect(backend.receivedCommands[11].tags).to.deep.equal([new DirtyQubitTag(), new UncomputeTag()])\r\n\r\n    backend.receivedCommands.slice(12, 18).forEach((cmd) => {\r\n      expect(cmd.tags).to.deep.equal([new UncomputeTag()])\r\n    })\r\n    expect(backend.receivedCommands[18].tags).to.deep.equal([new DirtyQubitTag(), new UncomputeTag()])\r\n    expect(backend.receivedCommands[19].tags).to.deep.equal([new UncomputeTag()])\r\n    expect(backend.receivedCommands[20].tags).to.deep.equal([])\r\n    expect(backend.receivedCommands[21].tags).to.deep.equal([])\r\n\r\n    // Test that each command has correct qubits\r\n    // Note that ancilla qubit in compute should be\r\n    // different from ancilla qubit in uncompute section\r\n    const qubit_id = backend.receivedCommands[0].qubits[0][0].id\r\n    const ancilla_compt_id = backend.receivedCommands[2].qubits[0][0].id\r\n    const ancilla_uncompt_id = backend.receivedCommands[11].qubits[0][0].id\r\n    const ancilla2_id = backend.receivedCommands[3].qubits[0][0].id\r\n    expect(backend.receivedCommands[1].qubits[0][0].id).to.equal(qubit_id)\r\n    expect(backend.receivedCommands[4].qubits[0][0].id).to.equal(qubit_id)\r\n    expect(backend.receivedCommands[5].qubits[0][0].id).to.equal(ancilla_compt_id)\r\n    expect(backend.receivedCommands[6].qubits[0][0].id).to.equal(qubit_id)\r\n    expect(backend.receivedCommands[6].controlQubits[0].id).to.equal(ancilla_compt_id)\r\n    expect(backend.receivedCommands[7].qubits[0][0].id).to.equal(qubit_id)\r\n    expect(backend.receivedCommands[8].qubits[0][0].id).to.equal(ancilla_compt_id)\r\n    expect(backend.receivedCommands[9].qubits[0][0].id).to.equal(ancilla_compt_id)\r\n    expect(backend.receivedCommands[10].qubits[0][0].id).to.equal(qubit_id)\r\n    expect(backend.receivedCommands[12].qubits[0][0].id).to.equal(ancilla_uncompt_id)\r\n    expect(backend.receivedCommands[13].qubits[0][0].id).to.equal(qubit_id)\r\n    expect(backend.receivedCommands[14].qubits[0][0].id).to.equal(qubit_id)\r\n    expect(backend.receivedCommands[14].controlQubits[0].id).to.equal(ancilla_uncompt_id)\r\n    expect(backend.receivedCommands[15].qubits[0][0].id).to.equal(ancilla_uncompt_id)\r\n    expect(backend.receivedCommands[16].qubits[0][0].id).to.equal(qubit_id)\r\n    expect(backend.receivedCommands[17].qubits[0][0].id).to.equal(ancilla2_id)\r\n    expect(backend.receivedCommands[18].qubits[0][0].id).to.equal(ancilla_uncompt_id)\r\n    expect(backend.receivedCommands[19].qubits[0][0].id).to.equal(qubit_id)\r\n    expect(backend.receivedCommands[20].qubits[0][0].id).to.equal(qubit_id)\r\n    // Test that ancilla qubits should have seperate ids\r\n    expect(ancilla_uncompt_id !== ancilla_compt_id).to.equal(true)\r\n    //\r\n    //     # Do the same thing with CustomUncompute and compare using the\r\n    //     # CompareEngine:\r\n    const backend1 = new DummyEngine(true)\r\n    const compare_engine1 = new CompareEngine()\r\n    //     # Allow dirty qubits\r\n    const dummy_cengine1 = new DummyEngine()\r\n    dummy_cengine1.isMetaTagHandler = allow_dirty_qubits\r\n\r\n    const eng1 = new MainEngine(backend1, [compare_engine1, dummy_cengine1])\r\n    qubit = eng1.allocateQubit()\r\n    let ancilla2\r\n    Compute(eng1, () => {\r\n      new Rx(0.9).or(qubit)\r\n      const ancilla = eng1.allocateQubit(true)\r\n      // ancilla2 will be deallocated in Uncompute section:\r\n      ancilla2 = eng1.allocateQubit()\r\n      // Test that ancilla is registered in MainEngine.active_qubits:\r\n\r\n      expect(eng1.activeQubits.has(ancilla[0])).to.equal(true)\r\n      H.or(qubit)\r\n      new Rx(0.5).or(ancilla)\r\n      CNOT.or(tuple(ancilla, qubit))\r\n      new Rx(0.7).or(qubit)\r\n      new Rx(-0.5).or(ancilla)\r\n      ancilla[0].deallocate()\r\n    })\r\n\r\n    H.or(qubit)\r\n\r\n    CustomUncompute(eng1, () => {\r\n      const ancilla = eng1.allocateQubit(true)\r\n      new Rx(0.5).or(ancilla)\r\n      new Rx(-0.7).or(qubit)\r\n      CNOT.or(tuple(ancilla, qubit))\r\n      new Rx(-0.5).or(ancilla)\r\n      H.or(qubit)\r\n\r\n      expect(eng1.activeQubits.has(ancilla[0])).to.equal(true)\r\n\r\n      ancilla2[0].deallocate()\r\n      ancilla[0].deallocate()\r\n      new Rx(-0.9).or(qubit)\r\n    })\r\n\r\n    eng1.flush(true)\r\n\r\n    expect(compare_engine0.equal(compare_engine1)).to.equal(true)\r\n  })\r\n\r\n  it('should only single error in custom uncompute', () => {\r\n    const eng = new MainEngine(new DummyEngine(), [])\r\n    Compute(eng, () => {\r\n      const qb = eng.allocateQubit()\r\n      // Tests that QubitManagementError is not sent in addition\r\n      expect(() => {\r\n        CustomUncompute(eng, () => {})\r\n        throw new Error('RuntimeError')\r\n      }).to.throw()\r\n    })\r\n  })\r\n\r\n  it('should qubit management error', () => {\r\n    const eng = new MainEngine(new DummyEngine(), [new DummyEngine()])\r\n    Compute(eng, () => {\r\n      const ancilla = eng.allocateQubit()\r\n      eng.activeQubits = new Set()\r\n      expect(() => Uncompute(eng)).to.throw(QubitManagementError)\r\n    })\r\n  })\r\n  it('should qubit management error2', () => {\r\n    const eng = new MainEngine(new DummyEngine(), [new DummyEngine()])\r\n    Compute(eng, () => {\r\n      const ancilla = eng.allocateQubit()\r\n      const local_ancilla = eng.allocateQubit()\r\n      local_ancilla[0].deallocate()\r\n      eng.activeQubits = new Set()\r\n      expect(() => {\r\n        Uncompute(eng)\r\n      }).to.throw(QubitManagementError)\r\n    })\r\n  })\r\n\r\n  it('should test exception if no compute but uncompute', () => {\r\n    const eng = new MainEngine(new DummyEngine(), [new DummyEngine()])\r\n    expect(() => CustomUncompute(eng, () => {})).to.throw()\r\n  })\r\n  it('should test exception if no compute but uncompute 2', () => {\r\n    const eng = new MainEngine(new DummyEngine(), [new DummyEngine()])\r\n    expect(() => Uncompute(eng)).to.throw()\r\n  })\r\n})\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/meta/compute.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 634,
    "kind": "file",
    "name": "src/meta/control.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/**\r\nContains the tools to make an entire section of operations controlled.\r\n\r\n    @example\r\n\r\nwith Control(eng, qubit1):\r\nH | qubit2\r\nX | qubit3\r\n*/\r\n\r\n// Adds control qubits to all commands that have no compute / uncompute tags.\r\nimport {ClassicalInstructionGate} from '../ops/basics'\r\nimport {BasicQubit} from '../types/qubit'\r\nimport {BasicEngine} from '../cengines/basics'\r\nimport {dropEngineAfter, insertEngine} from './util'\r\nimport {UncomputeTag, ComputeTag} from './tag'\r\nimport {instanceOf} from '../libs/util'\r\n\r\n/**\r\n * @class ControlEngine\r\n */\r\nexport class ControlEngine extends BasicEngine {\r\n  /**\r\n   * @constructor\r\n    @param {Array.<BasicQubit>} qubits qubits conditional on which the following operations are executed.\r\n     */\r\n  constructor(qubits) {\r\n    super()\r\n    this.qubits = qubits\r\n  }\r\n\r\n  /**\r\n    Return true if command cmd has a compute/uncompute tag.\r\n    @param {Command} cmd\r\n  */\r\n  hasComputeUnComputeTag(cmd) {\r\n    const tagClass = [UncomputeTag, ComputeTag]\r\n    return cmd.tags.some(looper => instanceOf(looper, tagClass))\r\n  }\r\n\r\n  handleCommand(cmd) {\r\n    if (!this.hasComputeUnComputeTag(cmd) && !(cmd.gate instanceof ClassicalInstructionGate)) {\r\n      cmd.addControlQubits(this.qubits)\r\n    }\r\n    this.send([cmd])\r\n  }\r\n\r\n  receive(commandList) {\r\n    commandList.forEach(cmd => this.handleCommand(cmd))\r\n  }\r\n}\r\n\r\n/**\r\nCondition an entire code block on the value of qubits being 1.\r\n\r\n@example\r\n\r\nwith Control(eng, ctrlqubits)\r\ndo_something(otherqubits)\r\n Enter a controlled section.\r\n\r\n @param {BasicEngine} engine Engine which handles the commands (usually MainEngine)\r\n @param {Array.<BasicQubit>} qubits Qubits to condition on\r\n @param {function} func\r\n Enter the section using a with-statement\r\n @example\r\n Control(eng, ctrlqubits, () => ...)\r\n */\r\nexport function Control(engine, qubits, func) {\r\n  if (qubits instanceof BasicQubit) {\r\n    qubits = [qubits]\r\n  }\r\n  const qs = qubits\r\n\r\n  const enter = () => {\r\n    if (qs.length > 0) {\r\n      const ce = new ControlEngine(qs)\r\n      insertEngine(engine, ce)\r\n    }\r\n  }\r\n\r\n  const exit = () => {\r\n    if (qs.length > 0) {\r\n      dropEngineAfter(engine)\r\n    }\r\n  }\r\n\r\n  if (typeof func === 'function') {\r\n    enter()\r\n    try {\r\n      func()\r\n    } catch (e) {\r\n      throw e\r\n    } finally {\r\n      exit()\r\n    }\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/meta/control.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 635,
    "kind": "class",
    "name": "ControlEngine",
    "memberof": "src/meta/control.js",
    "static": true,
    "longname": "src/meta/control.js~ControlEngine",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/meta/control.js",
    "importStyle": "{ControlEngine}",
    "description": "",
    "lineNumber": 38,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "ControlEngine"
      }
    ],
    "interface": false,
    "extends": [
      "src/cengines/basics.js~BasicEngine"
    ]
  },
  {
    "__docId__": 636,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/meta/control.js~ControlEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/control.js~ControlEngine#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 43,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Array.<BasicQubit>"
        ],
        "spread": false,
        "optional": false,
        "name": "qubits",
        "description": "qubits conditional on which the following operations are executed."
      }
    ]
  },
  {
    "__docId__": 637,
    "kind": "member",
    "name": "qubits",
    "memberof": "src/meta/control.js~ControlEngine",
    "static": false,
    "longname": "src/meta/control.js~ControlEngine#qubits",
    "access": "public",
    "description": null,
    "lineNumber": 45,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 638,
    "kind": "method",
    "name": "hasComputeUnComputeTag",
    "memberof": "src/meta/control.js~ControlEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/control.js~ControlEngine#hasComputeUnComputeTag",
    "access": "public",
    "description": "Return true if command cmd has a compute/uncompute tag.",
    "lineNumber": 52,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 639,
    "kind": "method",
    "name": "handleCommand",
    "memberof": "src/meta/control.js~ControlEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/control.js~ControlEngine#handleCommand",
    "access": "public",
    "description": null,
    "lineNumber": 57,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 640,
    "kind": "method",
    "name": "receive",
    "memberof": "src/meta/control.js~ControlEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/control.js~ControlEngine#receive",
    "access": "public",
    "description": null,
    "lineNumber": 64,
    "undocument": true,
    "params": [
      {
        "name": "commandList",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 641,
    "kind": "function",
    "name": "Control",
    "memberof": "src/meta/control.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/meta/control.js~Control",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/meta/control.js",
    "importStyle": "{Control}",
    "description": "Condition an entire code block on the value of qubits being 1.",
    "examples": [
      "\nwith Control(eng, ctrlqubits)\ndo_something(otherqubits)\nEnter a controlled section.",
      "Control(eng, ctrlqubits, () => ...)"
    ],
    "lineNumber": 85,
    "params": [
      {
        "nullable": null,
        "types": [
          "BasicEngine"
        ],
        "spread": false,
        "optional": false,
        "name": "engine",
        "description": "Engine which handles the commands (usually MainEngine)"
      },
      {
        "nullable": null,
        "types": [
          "Array.<BasicQubit>"
        ],
        "spread": false,
        "optional": false,
        "name": "qubits",
        "description": "Qubits to condition on"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "func",
        "description": "Enter the section using a with-statement"
      }
    ],
    "return": null
  },
  {
    "__docId__": 642,
    "kind": "file",
    "name": "src/meta/control.spec.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport {expect} from 'chai'\r\n\r\nimport MainEngine from '../cengines/main'\r\nimport {DummyEngine} from '../cengines/testengine'\r\nimport { H, Rx } from '../ops/gates'\r\nimport Command from '../ops/command'\r\nimport {ComputeTag, UncomputeTag, DirtyQubitTag} from './tag'\r\nimport {Control, ControlEngine} from './control'\r\nimport {Compute, Uncompute} from './compute'\r\n\r\ndescribe('control test', () => {\r\n  it('should control engine has compute tag', () => {\r\n    const eng = new MainEngine(new DummyEngine(), [new DummyEngine()])\r\n    const qubit = eng.allocateQubit()\r\n    const test_cmd0 = new Command(eng, H, [qubit])\r\n    const test_cmd1 = new Command(eng, H, [qubit])\r\n    const test_cmd2 = new Command(eng, H, [qubit])\r\n    test_cmd0.tags = [DirtyQubitTag, new ComputeTag(), DirtyQubitTag]\r\n    test_cmd1.tags = [DirtyQubitTag, new UncomputeTag(), DirtyQubitTag]\r\n    test_cmd2.tags = [DirtyQubitTag]\r\n    const control_eng = new ControlEngine('MockEng')\r\n    expect(control_eng.hasComputeUnComputeTag(test_cmd0)).to.equal(true)\r\n    expect(control_eng.hasComputeUnComputeTag(test_cmd1)).to.equal(true)\r\n    expect(control_eng.hasComputeUnComputeTag(test_cmd2)).to.equal(false)\r\n  });\r\n\r\n  it('should test control', () => {\r\n    const backend = new DummyEngine(true)\r\n    const eng = new MainEngine(backend, [new DummyEngine()])\r\n    const qureg = eng.allocateQureg(2)\r\n    let qubit\r\n    Control(eng, qureg, () => {\r\n      qubit = eng.allocateQubit()\r\n      Compute(eng, () => {\r\n        new Rx(0.5).or(qubit)\r\n      })\r\n      H.or(qubit)\r\n      Uncompute(eng)\r\n    })\r\n\r\n    Control(eng, qureg[0], () => {\r\n      H.or(qubit)\r\n    })\r\n\r\n    eng.flush()\r\n\r\n    backend.receivedCommands.forEach(cmd => console.log(cmd.toString()))\r\n    expect(backend.receivedCommands.length).to.equal(8)\r\n    expect(backend.receivedCommands[0].controlQubits.length).to.equal(0)\r\n    expect(backend.receivedCommands[1].controlQubits.length).to.equal(0)\r\n    expect(backend.receivedCommands[2].controlQubits.length).to.equal(0)\r\n    expect(backend.receivedCommands[3].controlQubits.length).to.equal(0)\r\n    expect(backend.receivedCommands[4].controlQubits.length).to.equal(2)\r\n    expect(backend.receivedCommands[5].controlQubits.length).to.equal(0)\r\n    expect(backend.receivedCommands[6].controlQubits.length).to.equal(1)\r\n    expect(backend.receivedCommands[7].controlQubits.length).to.equal(0)\r\n\r\n    expect(backend.receivedCommands[4].controlQubits[0].id).to.equal(qureg[0].id)\r\n    expect(backend.receivedCommands[4].controlQubits[1].id).to.equal(qureg[1].id)\r\n    expect(backend.receivedCommands[6].controlQubits[0].id).to.equal(qureg[0].id)\r\n  });\r\n})\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/meta/control.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 643,
    "kind": "file",
    "name": "src/meta/dagger.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/**\r\nTools to easily invert a sequence of gates.\r\n\r\n @example\r\n\r\nwith Dagger(eng)\r\nH | qubit1\r\nRz(0.5) | qubit2\r\n*/\r\n\r\nimport {BasicEngine} from '../cengines/basics'\r\nimport {Allocate, Deallocate} from '../ops/gates'\r\nimport {insertEngine, dropEngineAfter} from './util'\r\nimport {setEqual} from '../libs/polyfill';\r\nimport {QubitManagementError} from './error';\r\n\r\n/**\r\n * @class DaggerEngine\r\n * @desc\r\n *  Stores all commands and, when done, inverts the circuit & runs it.\r\n*/\r\nexport class DaggerEngine extends BasicEngine {\r\n  /**\r\n   * @constructor\r\n   */\r\n  constructor() {\r\n    super()\r\n    this.commands = []\r\n    this.allocateQubitIDs = new Set()\r\n    this.deallocateQubitIDs = new Set()\r\n  }\r\n\r\n  /**\r\n    Run the stored circuit in reverse and check that local qubits have been deallocated.\r\n   */\r\n  run() {\r\n    if (!setEqual(this.deallocateQubitIDs, this.allocateQubitIDs)) {\r\n      throw new QubitManagementError(\r\n        \"\\n Error. Qubits have been allocated in 'with \"\r\n          + \"Dagger(eng)' context,\\n which have not explicitely \"\r\n          + 'been deallocated.\\n'\r\n          + 'Correct usage:\\n'\r\n          + 'with Dagger(eng):\\n'\r\n          + '    qubit = eng.allocateQubit()\\n'\r\n          + '    ...\\n'\r\n          + '    del qubit[0]\\n'\r\n      )\r\n    }\r\n    this.commands.rforEach((cmd) => {\r\n      this.send([cmd.getInverse()])\r\n    })\r\n  }\r\n\r\n  /**\r\n    Receive a list of commands and store them for later inversion.\r\n    @param {Command[]} cmdList List of commands to temporarily store.\r\n  */\r\n  receive(cmdList) {\r\n    cmdList.forEach((cmd) => {\r\n      if (cmd.gate.equal(Allocate)) {\r\n        this.allocateQubitIDs.add(cmd.qubits[0][0].id)\r\n      } else if (cmd.gate.equal(Deallocate)) {\r\n        this.deallocateQubitIDs.add(cmd.qubits[0][0].id)\r\n      }\r\n    })\r\n    this.commands = this.commands.concat(cmdList)\r\n  }\r\n}\r\n\r\n/**\r\nInvert an entire code block.\r\n\r\n    Use it with a with-statement, i.e.,\r\n\r\n @example\r\n    Dagger(eng, () => [code to invert])\r\n\r\nWarning:\r\n    If the code to invert contains allocation of qubits, those qubits have\r\nto be deleted prior to exiting the 'with Dagger()' context.\r\n\r\n    This code is **NOT VALID**:\r\n\r\n @example\r\n\r\nwith Dagger(eng):\r\nqb = eng.allocateQubit()\r\nH | qb // qb is still available!!!\r\n\r\nThe **correct way** of handling qubit (de-)allocation is as follows:\r\n\r\n @example\r\n\r\nwith Dagger(eng):\r\nqb = eng.allocateQubit()\r\n...\r\ndel qb // sends deallocate gate (which becomes an allocate)\r\n\r\n @param {BasicEngine} engine Engine which handles the commands (usually MainEngine)\r\n @param {function} func\r\n */\r\nexport function Dagger(engine, func) {\r\n  let daggerEngine = null\r\n\r\n  const enter = () => {\r\n    daggerEngine = new DaggerEngine()\r\n    insertEngine(engine, daggerEngine)\r\n  }\r\n\r\n  const exit = () => {\r\n    daggerEngine.run()\r\n    daggerEngine = null\r\n    dropEngineAfter(engine)\r\n  }\r\n\r\n  if (typeof func === 'function') {\r\n    enter()\r\n    try {\r\n      func()\r\n    } catch (e) {\r\n      throw e\r\n    } finally {\r\n      exit()\r\n    }\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/meta/dagger.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 644,
    "kind": "class",
    "name": "DaggerEngine",
    "memberof": "src/meta/dagger.js",
    "static": true,
    "longname": "src/meta/dagger.js~DaggerEngine",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/meta/dagger.js",
    "importStyle": "{DaggerEngine}",
    "description": " Stores all commands and, when done, inverts the circuit & runs it.",
    "lineNumber": 38,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "DaggerEngine"
      }
    ],
    "interface": false,
    "extends": [
      "src/cengines/basics.js~BasicEngine"
    ]
  },
  {
    "__docId__": 645,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/meta/dagger.js~DaggerEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/dagger.js~DaggerEngine#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 42,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ]
  },
  {
    "__docId__": 646,
    "kind": "member",
    "name": "commands",
    "memberof": "src/meta/dagger.js~DaggerEngine",
    "static": false,
    "longname": "src/meta/dagger.js~DaggerEngine#commands",
    "access": "public",
    "description": null,
    "lineNumber": 44,
    "undocument": true,
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 647,
    "kind": "member",
    "name": "allocateQubitIDs",
    "memberof": "src/meta/dagger.js~DaggerEngine",
    "static": false,
    "longname": "src/meta/dagger.js~DaggerEngine#allocateQubitIDs",
    "access": "public",
    "description": null,
    "lineNumber": 45,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 648,
    "kind": "member",
    "name": "deallocateQubitIDs",
    "memberof": "src/meta/dagger.js~DaggerEngine",
    "static": false,
    "longname": "src/meta/dagger.js~DaggerEngine#deallocateQubitIDs",
    "access": "public",
    "description": null,
    "lineNumber": 46,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 649,
    "kind": "method",
    "name": "run",
    "memberof": "src/meta/dagger.js~DaggerEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/dagger.js~DaggerEngine#run",
    "access": "public",
    "description": "Run the stored circuit in reverse and check that local qubits have been deallocated.",
    "lineNumber": 52,
    "params": [],
    "return": null
  },
  {
    "__docId__": 650,
    "kind": "method",
    "name": "receive",
    "memberof": "src/meta/dagger.js~DaggerEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/dagger.js~DaggerEngine#receive",
    "access": "public",
    "description": "Receive a list of commands and store them for later inversion.",
    "lineNumber": 74,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command[]"
        ],
        "spread": false,
        "optional": false,
        "name": "cmdList",
        "description": "List of commands to temporarily store."
      }
    ],
    "return": null
  },
  {
    "__docId__": 652,
    "kind": "function",
    "name": "Dagger",
    "memberof": "src/meta/dagger.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/meta/dagger.js~Dagger",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/meta/dagger.js",
    "importStyle": "{Dagger}",
    "description": "Invert an entire code block.\n\nUse it with a with-statement, i.e.,",
    "examples": [
      "Dagger(eng, () => [code to invert])\n\nWarning:\nIf the code to invert contains allocation of qubits, those qubits have\nto be deleted prior to exiting the 'with Dagger()' context.\n\nThis code is **NOT VALID**:",
      "\nwith Dagger(eng):\nqb = eng.allocateQubit()\nH | qb // qb is still available!!!\n\nThe **correct way** of handling qubit (de-)allocation is as follows:",
      "\nwith Dagger(eng):\nqb = eng.allocateQubit()\n...\ndel qb // sends deallocate gate (which becomes an allocate)"
    ],
    "lineNumber": 118,
    "params": [
      {
        "nullable": null,
        "types": [
          "BasicEngine"
        ],
        "spread": false,
        "optional": false,
        "name": "engine",
        "description": "Engine which handles the commands (usually MainEngine)"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "func",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 653,
    "kind": "file",
    "name": "src/meta/dagger.spec.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport {expect} from 'chai'\r\nimport {\r\n  Allocate, Deallocate, H, Rx, X\r\n} from '../ops/gates'\r\nimport {DirtyQubitTag} from './tag'\r\nimport MainEngine from '../cengines/main'\r\nimport {DummyEngine} from '../cengines/testengine'\r\nimport {Dagger} from './dagger'\r\nimport {CNOT} from '../ops/shortcuts'\r\nimport {tuple} from '../libs/util'\r\nimport {QubitManagementError} from './error'\r\n\r\ndescribe('dagger test', () => {\r\n  it('should test dagger with dirty qubits', () => {\r\n    const backend = new DummyEngine(true)\r\n\r\n    const allow_dirty_qubits = meta_tag => meta_tag === DirtyQubitTag\r\n\r\n    backend.isMetaTagHandler = allow_dirty_qubits.bind(backend)\r\n    const eng = new MainEngine(backend, [new DummyEngine()])\r\n    const qubit = eng.allocateQubit()\r\n\r\n    Dagger(eng, () => {\r\n      const ancilla = eng.allocateQubit(true)\r\n      new Rx(0.6).or(ancilla)\r\n      CNOT.or(tuple(ancilla, qubit))\r\n      H.or(qubit)\r\n      new Rx(-0.6).or(ancilla)\r\n      ancilla[0].deallocate()\r\n    })\r\n\r\n    eng.flush(true)\r\n    expect(backend.receivedCommands.length).to.equal(9)\r\n    expect(backend.receivedCommands[0].gate.equal(Allocate)).to.equal(true)\r\n    expect(backend.receivedCommands[1].gate.equal(Allocate)).to.equal(true)\r\n    expect(backend.receivedCommands[2].gate.equal(new Rx(0.6))).to.equal(true)\r\n    expect(backend.receivedCommands[3].gate.equal(H)).to.equal(true)\r\n    expect(backend.receivedCommands[4].gate.equal(X)).to.equal(true)\r\n    expect(backend.receivedCommands[5].gate.equal(new Rx(-0.6))).to.equal(true)\r\n    expect(backend.receivedCommands[6].gate.equal(Deallocate)).to.equal(true)\r\n    expect(backend.receivedCommands[7].gate.equal(Deallocate)).to.equal(true)\r\n\r\n    expect(backend.receivedCommands[1].tags).to.deep.equal([new DirtyQubitTag()])\r\n    expect(backend.receivedCommands[6].tags).to.deep.equal([new DirtyQubitTag()])\r\n  })\r\n\r\n  it('should test dagger qubit management error', () => {\r\n    const eng = new MainEngine(new DummyEngine(), [new DummyEngine()])\r\n    expect(() => {\r\n      Dagger(eng, () => {\r\n        const ancilla = eng.allocateQubit()\r\n      })\r\n    }).to.throw(QubitManagementError)\r\n  })\r\n\r\n  it('should test dagger raise only single error', () => {\r\n    const eng = new MainEngine(new DummyEngine(), [])\r\n    // Tests that QubitManagementError is not sent in addition\r\n    expect(() => {\r\n      Dagger(eng, () => {\r\n        const ancilla = eng.allocateQubit()\r\n        throw new Error('RuntimeError')\r\n      })\r\n    }).to.throw()\r\n  })\r\n})\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/meta/dagger.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 654,
    "kind": "file",
    "name": "src/meta/error.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nexport class NotMergeable extends Error {\r\n  constructor(...args) {\r\n    super(...args)\r\n    this.__proto__ = NotMergeable.prototype\r\n  }\r\n}\r\n\r\nexport class LastEngineError extends Error {\r\n  constructor(...args) {\r\n    super(...args)\r\n    this.__proto__ = LastEngineError.prototype\r\n  }\r\n}\r\n\r\nexport class QubitManagementError extends Error {\r\n  constructor(...args) {\r\n    super(...args)\r\n    this.__proto__ = QubitManagementError.prototype\r\n  }\r\n}\r\n\r\nexport class NotYetMeasuredError extends Error {\r\n  constructor(...args) {\r\n    super(...args)\r\n    this.__proto__ = NotYetMeasuredError.prototype\r\n  }\r\n}\r\n\r\nexport class NoGateDecompositionError extends Error {\r\n  constructor(...args) {\r\n    super(...args)\r\n    this.__proto__ = NoGateDecompositionError.prototype\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/meta/error.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 655,
    "kind": "class",
    "name": "NotMergeable",
    "memberof": "src/meta/error.js",
    "static": true,
    "longname": "src/meta/error.js~NotMergeable",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/meta/error.js",
    "importStyle": "{NotMergeable}",
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "interface": false,
    "extends": [
      "Error"
    ]
  },
  {
    "__docId__": 656,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/meta/error.js~NotMergeable",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/error.js~NotMergeable#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 18,
    "undocument": true
  },
  {
    "__docId__": 657,
    "kind": "member",
    "name": "__proto__",
    "memberof": "src/meta/error.js~NotMergeable",
    "static": false,
    "longname": "src/meta/error.js~NotMergeable#__proto__",
    "access": "private",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 658,
    "kind": "class",
    "name": "LastEngineError",
    "memberof": "src/meta/error.js",
    "static": true,
    "longname": "src/meta/error.js~LastEngineError",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/meta/error.js",
    "importStyle": "{LastEngineError}",
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "interface": false,
    "extends": [
      "Error"
    ]
  },
  {
    "__docId__": 659,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/meta/error.js~LastEngineError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/error.js~LastEngineError#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 25,
    "undocument": true
  },
  {
    "__docId__": 660,
    "kind": "member",
    "name": "__proto__",
    "memberof": "src/meta/error.js~LastEngineError",
    "static": false,
    "longname": "src/meta/error.js~LastEngineError#__proto__",
    "access": "private",
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 661,
    "kind": "class",
    "name": "QubitManagementError",
    "memberof": "src/meta/error.js",
    "static": true,
    "longname": "src/meta/error.js~QubitManagementError",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/meta/error.js",
    "importStyle": "{QubitManagementError}",
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "interface": false,
    "extends": [
      "Error"
    ]
  },
  {
    "__docId__": 662,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/meta/error.js~QubitManagementError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/error.js~QubitManagementError#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 32,
    "undocument": true
  },
  {
    "__docId__": 663,
    "kind": "member",
    "name": "__proto__",
    "memberof": "src/meta/error.js~QubitManagementError",
    "static": false,
    "longname": "src/meta/error.js~QubitManagementError#__proto__",
    "access": "private",
    "description": null,
    "lineNumber": 34,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 664,
    "kind": "class",
    "name": "NotYetMeasuredError",
    "memberof": "src/meta/error.js",
    "static": true,
    "longname": "src/meta/error.js~NotYetMeasuredError",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/meta/error.js",
    "importStyle": "{NotYetMeasuredError}",
    "description": null,
    "lineNumber": 38,
    "undocument": true,
    "interface": false,
    "extends": [
      "Error"
    ]
  },
  {
    "__docId__": 665,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/meta/error.js~NotYetMeasuredError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/error.js~NotYetMeasuredError#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 39,
    "undocument": true
  },
  {
    "__docId__": 666,
    "kind": "member",
    "name": "__proto__",
    "memberof": "src/meta/error.js~NotYetMeasuredError",
    "static": false,
    "longname": "src/meta/error.js~NotYetMeasuredError#__proto__",
    "access": "private",
    "description": null,
    "lineNumber": 41,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 667,
    "kind": "class",
    "name": "NoGateDecompositionError",
    "memberof": "src/meta/error.js",
    "static": true,
    "longname": "src/meta/error.js~NoGateDecompositionError",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/meta/error.js",
    "importStyle": "{NoGateDecompositionError}",
    "description": null,
    "lineNumber": 45,
    "undocument": true,
    "interface": false,
    "extends": [
      "Error"
    ]
  },
  {
    "__docId__": 668,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/meta/error.js~NoGateDecompositionError",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/error.js~NoGateDecompositionError#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 46,
    "undocument": true
  },
  {
    "__docId__": 669,
    "kind": "member",
    "name": "__proto__",
    "memberof": "src/meta/error.js~NoGateDecompositionError",
    "static": false,
    "longname": "src/meta/error.js~NoGateDecompositionError#__proto__",
    "access": "private",
    "description": null,
    "lineNumber": 48,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 670,
    "kind": "file",
    "name": "src/meta/index.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nexport {Compute, CustomUncompute, Uncompute, UncomputeEngine, ComputeEngine} from './compute'\r\n\r\nexport {Control, ControlEngine} from './control'\r\n\r\nexport {Dagger, DaggerEngine} from './dagger'\r\n\r\nexport {Loop, LoopTag, LoopEngine} from './loop'\r\n\r\nexport {LogicalQubitIDTag, DirtyQubitTag, ComputeTag, UncomputeTag} from './tag'\r\n\r\nexport {insertEngine, dropEngineAfter} from './util'\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/meta/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 671,
    "kind": "file",
    "name": "src/meta/loop.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport {BasicEngine} from '../cengines/basics'\r\nimport {setEqual} from '../libs/polyfill';\r\nimport {dropEngineAfter, insertEngine} from './util';\r\nimport {Allocate, Deallocate} from '../ops/gates'\r\nimport {QubitManagementError} from './error'\r\n\r\n/**\r\n * @class LoopTag\r\n */\r\nexport class LoopTag {\r\n  /**\r\n   * @constructor\r\n   * @param {number} num\r\n   */\r\n  constructor(num) {\r\n    this.num = num\r\n    this.id = LoopTag.loop_tag_id\r\n    LoopTag.loop_tag_id += 1\r\n  }\r\n\r\n  equal(other) {\r\n    return other instanceof LoopTag && other.id === this.id && this.num === other.num\r\n  }\r\n}\r\n\r\nLoopTag.loop_tag_id = 0\r\n\r\n/**\r\n * @class LoopEngine\r\n * @desc\r\nStores all commands and, when done, executes them num times if no loop tag\r\nhandler engine is available.\r\n    If there is one, it adds a loop_tag to the commands and sends them on.\r\n */\r\nexport class LoopEngine extends BasicEngine {\r\n  /**\r\n   * @constructor\r\n    @param {number} num Number of loop iterations.\r\n   */\r\n  constructor(num) {\r\n    super()\r\n    this._tag = new LoopTag(num)\r\n    this._cmdList = []\r\n    this._allocatedQubitIDs = new Set()\r\n    this._deallocatedQubitIDs = new Set()\r\n    // key: qubit id of a local qubit, i.e. a qubit which has been allocated\r\n    //     and deallocated within the loop body.\r\n    // value: list contain reference to each weakref qubit with this qubit\r\n    //        id either within control_qubits or qubits.\r\n    this._refsToLocalQB = {}\r\n    this._nextEnginesSupportLoopTag = false\r\n  }\r\n\r\n  /**\r\n  Apply the loop statements to all stored commands.\r\n   Unrolls the loop if LoopTag is not supported by any of the following engines, i.e., if\r\n\r\n   @example\r\n    is_meta_tag_supported(next_engine, LoopTag) == false\r\n   */\r\n  run() {\r\n    const error_message = ('\\n Error. Qubits have been allocated in with '\r\n    + 'Loop(eng, num) context,\\n which have not '\r\n    + 'explicitely been deallocated in the Loop context.\\n'\r\n    + 'Correct usage:\\nLoop(eng, 5):\\n'\r\n    + '    qubit = eng.allocateQubit()\\n'\r\n    + '    ...\\n'\r\n    + '    qubit[0].deallocate()\\n')\r\n\r\n    if (!this._nextEnginesSupportLoopTag) {\r\n      // Unroll the loop\r\n      // Check that local qubits have been deallocated\r\n      if (!setEqual(this._deallocatedQubitIDs, this._allocatedQubitIDs)) {\r\n        throw new QubitManagementError(error_message)\r\n      }\r\n      if (this._allocatedQubitIDs.size === 0) {\r\n        // No local qubits, just send the circuit num times\r\n        for (let i = 0; i < this._tag.num; ++i) {\r\n          this.send(this._cmdList.slice(0))\r\n        }\r\n      } else {\r\n        // Ancilla qubits have been allocated in loop body\r\n        // For each iteration, allocate and deallocate a new qubit and\r\n        // replace the qubit id in all commands using it.\r\n        for (let i = 0; i < this._tag.num; ++i) {\r\n          if (i === 0) {\r\n            this.send(this._cmdList.map(cmd => cmd.copy()))\r\n          } else {\r\n            // Change local qubit ids before sending them\r\n            Object.values(this._refsToLocalQB).forEach(refs_loc_qubit => {\r\n              const new_qb_id = this.main.getNewQubitID()\r\n              refs_loc_qubit.forEach(qubitRef => qubitRef.id = new_qb_id)\r\n            })\r\n            this.send(this._cmdList.map(cmd => cmd.copy()))\r\n          }\r\n        }\r\n      }\r\n    } else if (!setEqual(this._deallocatedQubitIDs, this._allocatedQubitIDs)) {\r\n      throw new QubitManagementError(error_message)\r\n    }\r\n  }\r\n\r\n  /**\r\n  Receive (and potentially temporarily store) all commands.\r\n\r\n    Add LoopTag to all receiving commands and send to the next engine if\r\n    a further engine is a LoopTag-handling engine. Otherwise store all\r\ncommands (to later unroll them). Check that within the loop body,\r\n    all allocated qubits have also been deallocated. If loop needs to be\r\nunrolled and ancilla qubits have been allocated within the loop body,\r\n    then store a reference all these qubit ids (to change them when\r\nunrolling the loop)\r\n\r\n@param {Command[]} commandList List of commands to store and later\r\nunroll or, if there is a LoopTag-handling engine, add the LoopTag.\r\n   */\r\n  receive(commandList) {\r\n    if (this._nextEnginesSupportLoopTag || this.next.isMetaTagSupported(LoopTag)) {\r\n      // Loop tag is supported, send everything with a LoopTag\r\n      // Don't check is_meta_tag_supported anymore\r\n      this._nextEnginesSupportLoopTag = true\r\n      if (this._tag.num === 0) {\r\n        return\r\n      }\r\n      commandList.forEach((cmd) => {\r\n        if (cmd.gate.equal(Allocate)) {\r\n          this._allocatedQubitIDs.add(cmd.qubits[0][0].id)\r\n        } else if (cmd.gate.equal(Deallocate)) {\r\n          this._deallocatedQubitIDs.add(cmd.qubits[0][0].id)\r\n        }\r\n        cmd.tags.push(this._tag)\r\n        this.send([cmd])\r\n      })\r\n    } else {\r\n      // LoopTag is not supported, save the full loop body\r\n      this._cmdList = this._cmdList.concat(commandList)\r\n      // Check for all local qubits allocated and deallocated in loop body\r\n      commandList.forEach((cmd) => {\r\n        const qb = cmd.qubits[0][0]\r\n        const qid = qb.id\r\n        if (cmd.gate.equal(Allocate)) {\r\n          this._allocatedQubitIDs.add(qid)\r\n          this._refsToLocalQB[qid] = [qb]\r\n        } else if (cmd.gate.equal(Deallocate)) {\r\n          this._deallocatedQubitIDs.add(qid)\r\n          this._refsToLocalQB[qid].push(qb)\r\n        } else {\r\n          cmd.controlQubits.forEach((ctrlQubit) => {\r\n            const v = this._allocatedQubitIDs.has(ctrlQubit.id)\r\n            if (v) {\r\n              this._refsToLocalQB[ctrlQubit.id].push(ctrlQubit)\r\n            }\r\n          })\r\n          cmd.qubits.forEach(qureg => qureg.forEach((qubit) => {\r\n            if (this._allocatedQubitIDs.has(qubit.id)) {\r\n              this._refsToLocalQB[qubit.id].push(qubit)\r\n            }\r\n          }))\r\n        }\r\n      })\r\n    }\r\n  }\r\n}\r\n\r\n\r\n/**\r\nLoop n times over an entire code block.\r\n\r\n    @example\r\n    Loop(eng, 4, () => { })\r\n    // [quantum gates to be executed 4 times]\r\n\r\nWarning:\r\n    If the code in the loop contains allocation of qubits, those qubits\r\nhave to be deleted prior to exiting the 'Loop()' context.\r\n\r\n    This code is **NOT VALID**:\r\n\r\n @example\r\n\r\n  Loop(eng, 4, () => {\r\n    qb = eng.allocateQubit()\r\n  })\r\n\r\n  H.or(qb) // qb is still available!!!\r\n\r\nThe **correct way** of handling qubit (de-)allocation is as follows:\r\n\r\n @example\r\n  Loop(eng, 4, () => {\r\n    qb = eng.allocateQubit()\r\n  })\r\n...\r\n  qb.deallocate() // sends deallocate gate\r\n */\r\nexport function Loop(engine, num, func) {\r\n  if (typeof num === 'number' && num >= 0 && num % 1 === 0) {\r\n    const _num = num\r\n    let _loopEngine\r\n    const enter = () => {\r\n      if (_num !== 1) {\r\n        _loopEngine = new LoopEngine(num)\r\n        insertEngine(engine, _loopEngine)\r\n      }\r\n    }\r\n\r\n    const exit = () => {\r\n      if (_num !== 1) {\r\n        _loopEngine.run()\r\n        _loopEngine = null\r\n        dropEngineAfter(engine)\r\n      }\r\n    }\r\n\r\n    if (typeof func === 'function') {\r\n      enter()\r\n      try {\r\n        func()\r\n      } catch (e) {\r\n        throw e\r\n      } finally {\r\n        exit()\r\n      }\r\n    }\r\n  } else {\r\n    throw new Error('invalid number of loop iterations')\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/meta/loop.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 672,
    "kind": "class",
    "name": "LoopTag",
    "memberof": "src/meta/loop.js",
    "static": true,
    "longname": "src/meta/loop.js~LoopTag",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/meta/loop.js",
    "importStyle": "{LoopTag}",
    "description": "",
    "lineNumber": 26,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "LoopTag"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 673,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/meta/loop.js~LoopTag",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/loop.js~LoopTag#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 31,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "num",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 674,
    "kind": "member",
    "name": "num",
    "memberof": "src/meta/loop.js~LoopTag",
    "static": false,
    "longname": "src/meta/loop.js~LoopTag#num",
    "access": "public",
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 675,
    "kind": "member",
    "name": "id",
    "memberof": "src/meta/loop.js~LoopTag",
    "static": false,
    "longname": "src/meta/loop.js~LoopTag#id",
    "access": "public",
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 676,
    "kind": "method",
    "name": "equal",
    "memberof": "src/meta/loop.js~LoopTag",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/loop.js~LoopTag#equal",
    "access": "public",
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "params": [
      {
        "name": "other",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 677,
    "kind": "class",
    "name": "LoopEngine",
    "memberof": "src/meta/loop.js",
    "static": true,
    "longname": "src/meta/loop.js~LoopEngine",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/meta/loop.js",
    "importStyle": "{LoopEngine}",
    "description": "Stores all commands and, when done, executes them num times if no loop tag\nhandler engine is available.\nIf there is one, it adds a loop_tag to the commands and sends them on.",
    "lineNumber": 51,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "LoopEngine"
      }
    ],
    "interface": false,
    "extends": [
      "src/cengines/basics.js~BasicEngine"
    ]
  },
  {
    "__docId__": 678,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/meta/loop.js~LoopEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/loop.js~LoopEngine#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 56,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "num",
        "description": "Number of loop iterations."
      }
    ]
  },
  {
    "__docId__": 679,
    "kind": "member",
    "name": "_tag",
    "memberof": "src/meta/loop.js~LoopEngine",
    "static": false,
    "longname": "src/meta/loop.js~LoopEngine#_tag",
    "access": "private",
    "description": null,
    "lineNumber": 58,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 680,
    "kind": "member",
    "name": "_cmdList",
    "memberof": "src/meta/loop.js~LoopEngine",
    "static": false,
    "longname": "src/meta/loop.js~LoopEngine#_cmdList",
    "access": "private",
    "description": null,
    "lineNumber": 59,
    "undocument": true,
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 681,
    "kind": "member",
    "name": "_allocatedQubitIDs",
    "memberof": "src/meta/loop.js~LoopEngine",
    "static": false,
    "longname": "src/meta/loop.js~LoopEngine#_allocatedQubitIDs",
    "access": "private",
    "description": null,
    "lineNumber": 60,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 682,
    "kind": "member",
    "name": "_deallocatedQubitIDs",
    "memberof": "src/meta/loop.js~LoopEngine",
    "static": false,
    "longname": "src/meta/loop.js~LoopEngine#_deallocatedQubitIDs",
    "access": "private",
    "description": null,
    "lineNumber": 61,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 683,
    "kind": "member",
    "name": "_refsToLocalQB",
    "memberof": "src/meta/loop.js~LoopEngine",
    "static": false,
    "longname": "src/meta/loop.js~LoopEngine#_refsToLocalQB",
    "access": "private",
    "description": null,
    "lineNumber": 66,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 684,
    "kind": "member",
    "name": "_nextEnginesSupportLoopTag",
    "memberof": "src/meta/loop.js~LoopEngine",
    "static": false,
    "longname": "src/meta/loop.js~LoopEngine#_nextEnginesSupportLoopTag",
    "access": "private",
    "description": null,
    "lineNumber": 67,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 685,
    "kind": "method",
    "name": "run",
    "memberof": "src/meta/loop.js~LoopEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/loop.js~LoopEngine#run",
    "access": "public",
    "description": "Apply the loop statements to all stored commands.\nUnrolls the loop if LoopTag is not supported by any of the following engines, i.e., if",
    "examples": [
      "is_meta_tag_supported(next_engine, LoopTag) == false"
    ],
    "lineNumber": 77,
    "params": [],
    "return": null
  },
  {
    "__docId__": 686,
    "kind": "method",
    "name": "receive",
    "memberof": "src/meta/loop.js~LoopEngine",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/loop.js~LoopEngine#receive",
    "access": "public",
    "description": "Receive (and potentially temporarily store) all commands.\n\nAdd LoopTag to all receiving commands and send to the next engine if\na further engine is a LoopTag-handling engine. Otherwise store all\ncommands (to later unroll them). Check that within the loop body,\nall allocated qubits have also been deallocated. If loop needs to be\nunrolled and ancilla qubits have been allocated within the loop body,\nthen store a reference all these qubit ids (to change them when\nunrolling the loop)",
    "lineNumber": 133,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command[]"
        ],
        "spread": false,
        "optional": false,
        "name": "commandList",
        "description": "List of commands to store and later\nunroll or, if there is a LoopTag-handling engine, add the LoopTag."
      }
    ],
    "return": null
  },
  {
    "__docId__": 689,
    "kind": "function",
    "name": "Loop",
    "memberof": "src/meta/loop.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/meta/loop.js~Loop",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/meta/loop.js",
    "importStyle": "{Loop}",
    "description": "Loop n times over an entire code block.",
    "examples": [
      "Loop(eng, 4, () => { })\n// [quantum gates to be executed 4 times]\n\nWarning:\nIf the code in the loop contains allocation of qubits, those qubits\nhave to be deleted prior to exiting the 'Loop()' context.\n\nThis code is **NOT VALID**:",
      "\nLoop(eng, 4, () => {\nqb = eng.allocateQubit()\n})\n\nH.or(qb) // qb is still available!!!\n\nThe **correct way** of handling qubit (de-)allocation is as follows:",
      "Loop(eng, 4, () => {\nqb = eng.allocateQubit()\n})\n...\nqb.deallocate() // sends deallocate gate"
    ],
    "lineNumber": 212,
    "params": [
      {
        "name": "engine",
        "types": [
          "*"
        ]
      },
      {
        "name": "num",
        "types": [
          "*"
        ]
      },
      {
        "name": "func",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 690,
    "kind": "file",
    "name": "src/meta/loop.spec.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport {expect} from 'chai'\r\nimport {LoopTag, LoopEngine, Loop} from './loop'\r\nimport {ComputeTag} from './tag'\r\nimport {DummyEngine} from '../cengines/testengine'\r\nimport MainEngine from '../cengines/main'\r\nimport {\r\n  Allocate, Deallocate, H, X, FlushGate\r\n} from '../ops/gates'\r\nimport {instanceOf, tuple} from '../libs/util'\r\nimport {CNOT} from '../ops/shortcuts'\r\nimport {QubitManagementError} from './error'\r\n\r\ndescribe('loop test', () => {\r\n  it('should test_loop_tag', () => {\r\n    const tag0 = new LoopTag(10)\r\n    const tag1 = new LoopTag(10)\r\n    const tag2 = tag0\r\n    const other_tag = new ComputeTag()\r\n    expect(tag0.equal(tag2)).to.equal(true)\r\n    expect(tag0.equal(tag1)).to.equal(false)\r\n    expect(tag0.equal(other_tag)).to.equal(false)\r\n  });\r\n\r\n  it('should test_loop_wrong_input_type', () => {\r\n    const eng = new MainEngine(new DummyEngine(), [])\r\n    const qubit = eng.allocateQubit()\r\n    expect(() => Loop(eng, 1.1)).to.throw()\r\n  });\r\n\r\n  it('should test_loop_negative_iteration_number', () => {\r\n    const eng = new MainEngine(new DummyEngine(), [])\r\n    const qubit = eng.allocateQubit()\r\n    expect(() => Loop(eng, -1)).to.throw()\r\n  });\r\n\r\n  it('should test_loop_with_supported_loop_tag_and_local_qubits', () => {\r\n    const backend = new DummyEngine(true)\r\n    const eng = new MainEngine(backend, [new DummyEngine()])\r\n\r\n    const allow_loop_tags = meta_tag => meta_tag === LoopTag\r\n\r\n    backend.isMetaTagHandler = allow_loop_tags\r\n    const qubit = eng.allocateQubit()\r\n    H.or(qubit)\r\n\r\n    Loop(eng, 6, () => {\r\n      const ancilla = eng.allocateQubit()\r\n      const ancilla2 = eng.allocateQubit()\r\n\r\n      H.or(ancilla2)\r\n      H.or(ancilla)\r\n      CNOT.or(tuple(ancilla, qubit))\r\n      H.or(ancilla)\r\n      H.or(ancilla2)\r\n\r\n      ancilla2.deallocate()\r\n      ancilla.deallocate()\r\n    })\r\n\r\n    H.or(qubit)\r\n    eng.flush(true)\r\n\r\n    expect(backend.receivedCommands.length).to.equal(14)\r\n    expect(backend.receivedCommands[0].gate.equal(Allocate)).to.equal(true)\r\n    expect(backend.receivedCommands[1].gate.equal(H)).to.equal(true)\r\n    expect(backend.receivedCommands[2].gate.equal(Allocate)).to.equal(true)\r\n    expect(backend.receivedCommands[3].gate.equal(Allocate)).to.equal(true)\r\n    expect(backend.receivedCommands[4].gate.equal(H)).to.equal(true)\r\n    expect(backend.receivedCommands[5].gate.equal(H)).to.equal(true)\r\n    expect(backend.receivedCommands[6].gate.equal(X)).to.equal(true)\r\n\r\n    expect(backend.receivedCommands[7].gate.equal(H)).to.equal(true)\r\n    expect(backend.receivedCommands[8].gate.equal(H)).to.equal(true)\r\n    expect(backend.receivedCommands[9].gate.equal(Deallocate)).to.equal(true)\r\n    expect(backend.receivedCommands[10].gate.equal(Deallocate)).to.equal(true)\r\n    expect(backend.receivedCommands[11].gate.equal(H)).to.equal(true)\r\n    expect(backend.receivedCommands[12].gate.equal(Deallocate)).to.equal(true)\r\n    expect(backend.receivedCommands[13].gate.equal(new FlushGate())).to.equal(true)\r\n\r\n    // Test qubit ids\r\n    const qubit_id = backend.receivedCommands[0].qubits[0][0].id\r\n    const ancilla_id = backend.receivedCommands[2].qubits[0][0].id\r\n    const ancilla2_id = backend.receivedCommands[3].qubits[0][0].id\r\n\r\n    expect(qubit_id !== ancilla_id).to.equal(true)\r\n    expect(qubit_id !== ancilla2_id).to.equal(true)\r\n    expect(ancilla_id !== ancilla2_id).to.equal(true)\r\n\r\n    expect(backend.receivedCommands[1].qubits[0][0].id).to.equal(qubit_id)\r\n    expect(backend.receivedCommands[4].qubits[0][0].id).to.equal(ancilla2_id)\r\n    expect(backend.receivedCommands[5].qubits[0][0].id).to.equal(ancilla_id)\r\n    expect(backend.receivedCommands[6].qubits[0][0].id).to.equal(qubit_id)\r\n    expect(backend.receivedCommands[6].controlQubits[0].id).to.equal(ancilla_id)\r\n    expect(backend.receivedCommands[7].qubits[0][0].id).to.equal(ancilla_id)\r\n    expect(backend.receivedCommands[8].qubits[0][0].id).to.equal(ancilla2_id)\r\n\r\n    expect(backend.receivedCommands[9].qubits[0][0].id).to.equal(ancilla2_id)\r\n    expect(backend.receivedCommands[10].qubits[0][0].id).to.equal(ancilla_id)\r\n    expect(backend.receivedCommands[11].qubits[0][0].id).to.equal(qubit_id)\r\n    expect(backend.receivedCommands[12].qubits[0][0].id).to.equal(qubit_id)\r\n\r\n    // Tags\r\n    expect(backend.receivedCommands[3].tags.length).to.equal(1)\r\n\r\n    const loop_tag = backend.receivedCommands[3].tags[0]\r\n    expect(loop_tag instanceof LoopTag).to.equal(true)\r\n    expect(loop_tag.num).to.equal(6)\r\n    let ids = [0, 1, 11, 12, 13]\r\n    ids.forEach((ii) => {\r\n      expect(backend.receivedCommands[ii].tags).to.deep.equal([])\r\n    })\r\n    ids = [2, 9]\r\n    ids.forEach(ii => expect(backend.receivedCommands[ii].tags).to.deep.equal([loop_tag]))\r\n  });\r\n\r\n  it('should test_empty_loop', () => {\r\n    const backend = new DummyEngine(true)\r\n    const eng = new MainEngine(backend, [new DummyEngine()])\r\n    const qubit = eng.allocateQubit()\r\n\r\n    expect(backend.receivedCommands.length).to.equal(1)\r\n    Loop(eng, 0, () => H.or(qubit))\r\n    expect(backend.receivedCommands.length).to.equal(1)\r\n  });\r\n\r\n  it('should test_empty_loop_when_loop_tag_supported_by_backend', () => {\r\n    const backend = new DummyEngine(true)\r\n    const eng = new MainEngine(backend, [new DummyEngine()])\r\n\r\n    const allow_loop_tags = meta_tag => (meta_tag === LoopTag)\r\n\r\n    backend.isMetaTagHandler = allow_loop_tags\r\n    const qubit = eng.allocateQubit()\r\n\r\n    expect(backend.receivedCommands.length).to.equal(1)\r\n    Loop(eng, 0, () => H.or(qubit))\r\n    expect(backend.receivedCommands.length).to.equal(1)\r\n  });\r\n\r\n  it('should test_loop_with_supported_loop_tag_depending_on_num', () => {\r\n    // Test that if loop has only one iteration, there is no loop tag\r\n    const backend = new DummyEngine(true)\r\n    const eng = new MainEngine(backend, [new DummyEngine()])\r\n\r\n    const allow_loop_tags = meta_tag => (meta_tag === LoopTag)\r\n\r\n    backend.isMetaTagHandler = allow_loop_tags\r\n    const qubit = eng.allocateQubit()\r\n    Loop(eng, 1, () => H.or(qubit))\r\n    Loop(eng, 2, () => H.or(qubit))\r\n    expect(backend.receivedCommands[1].tags.length).to.equal(0)\r\n    expect(backend.receivedCommands[2].tags.length).to.equal(1)\r\n  });\r\n\r\n  it('should test_loop_unrolling', () => {\r\n    const backend = new DummyEngine(true)\r\n    const eng = new MainEngine(backend, [new DummyEngine()])\r\n    const qubit = eng.allocateQubit()\r\n    Loop(eng, 3, () => H.or(qubit))\r\n\r\n    eng.flush(true)\r\n    expect(backend.receivedCommands.length).to.equal(6)\r\n  });\r\n\r\n  it('should test_loop_unrolling_with_ancillas', () => {\r\n    const backend = new DummyEngine(true)\r\n    const eng = new MainEngine(backend, [new DummyEngine()])\r\n    const qubit = eng.allocateQubit()\r\n    const qubit_id = qubit[0].id\r\n    Loop(eng, 3, () => {\r\n      const ancilla = eng.allocateQubit()\r\n      H.or(ancilla)\r\n      CNOT.or(tuple(ancilla, qubit))\r\n      ancilla.deallocate()\r\n    })\r\n\r\n    eng.flush(true)\r\n\r\n    expect(backend.receivedCommands.length).to.equal(15)\r\n    expect(backend.receivedCommands[0].gate.equal(Allocate)).to.equal(true)\r\n    for (let ii = 0; ii < 3; ++ii) {\r\n      expect(backend.receivedCommands[ii * 4 + 1].gate.equal(Allocate)).to.equal(true)\r\n      expect(backend.receivedCommands[ii * 4 + 2].gate.equal(H)).to.equal(true)\r\n      expect(backend.receivedCommands[ii * 4 + 3].gate.equal(X)).to.equal(true)\r\n      expect(backend.receivedCommands[ii * 4 + 4].gate.equal(Deallocate)).to.equal(true)\r\n\r\n      // Check qubit ids\r\n      expect(backend.receivedCommands[ii * 4 + 1].qubits[0][0].id).to.equal(backend.receivedCommands[ii * 4 + 2].qubits[0][0].id)\r\n      expect(backend.receivedCommands[ii * 4 + 1].qubits[0][0].id).to.equal(backend.receivedCommands[ii * 4 + 3].controlQubits[0].id)\r\n      expect(backend.receivedCommands[ii * 4 + 3].qubits[0][0].id).to.equal(qubit_id)\r\n      expect(backend.receivedCommands[ii * 4 + 1].qubits[0][0].id).to.equal(backend.receivedCommands[ii * 4 + 4].qubits[0][0].id)\r\n    }\r\n\r\n    expect(backend.receivedCommands[13].gate.equal(Deallocate)).to.equal(true)\r\n    expect(backend.receivedCommands[14].gate.equal(new FlushGate())).to.equal(true)\r\n\r\n\r\n    expect(backend.receivedCommands[1].qubits[0][0].id\r\n    !== backend.receivedCommands[5].qubits[0][0].id).to.equal(true)\r\n    expect(backend.receivedCommands[1].qubits[0][0].id\r\n    !== backend.receivedCommands[9].qubits[0][0].id).to.equal(true)\r\n    expect(backend.receivedCommands[5].qubits[0][0].id\r\n    !== backend.receivedCommands[9].qubits[0][0].id).to.equal(true)\r\n  });\r\n\r\n  it('should test_nested_loop', () => {\r\n    const backend = new DummyEngine(true)\r\n\r\n    const allow_loop_tags = meta_tag => (meta_tag === LoopTag)\r\n\r\n    backend.isMetaTagHandler = allow_loop_tags\r\n    const eng = new MainEngine(backend, [new DummyEngine()])\r\n    const qubit = eng.allocateQubit()\r\n    Loop(eng, 3, () => {\r\n      Loop(eng, 4, () => {\r\n        H.or(qubit)\r\n      })\r\n    })\r\n\r\n    eng.flush(true)\r\n    expect(backend.receivedCommands.length).to.equal(4)\r\n    expect(backend.receivedCommands[1].gate.equal(H)).to.equal(true)\r\n    expect(backend.receivedCommands[1].tags.length).to.equal(2)\r\n    expect(backend.receivedCommands[1].tags[0].num).to.equal(4)\r\n    expect(backend.receivedCommands[1].tags[1].num).to.equal(3)\r\n    expect(backend.receivedCommands[1].tags[0].id !== backend.receivedCommands[1].tags[1].id).to.equal(true)\r\n  });\r\n\r\n  it('should test_qubit_management_error', () => {\r\n    const backend = new DummyEngine(true)\r\n    const eng = new MainEngine(backend, [new DummyEngine()])\r\n\r\n    expect(() => Loop(eng, 3, () => eng.allocateQubit())).to.throw(QubitManagementError)\r\n  });\r\n\r\n  it('should test_qubit_management_error_when_loop_tag_supported', () => {\r\n    const backend = new DummyEngine(true)\r\n\r\n    const allow_loop_tags = meta_tag => (meta_tag === LoopTag)\r\n\r\n    backend.isMetaTagHandler = allow_loop_tags\r\n    const eng = new MainEngine(backend, [new DummyEngine()])\r\n    expect(() => Loop(eng, 3, () => eng.allocateQubit())).to.throw(QubitManagementError)\r\n  });\r\n})\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/meta/loop.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 691,
    "kind": "file",
    "name": "src/meta/tag.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/**\r\n * @class ComputeTag\r\n */\r\nexport class ComputeTag {\r\n  equal(other) {\r\n    return other instanceof ComputeTag\r\n  }\r\n}\r\n\r\n/**\r\n * @class UncomputeTag\r\n */\r\nexport class UncomputeTag {\r\n  equal(other) {\r\n    return other instanceof UncomputeTag\r\n  }\r\n}\r\n\r\n/**\r\n * @class DirtyQubitTag\r\n */\r\nexport class DirtyQubitTag {\r\n  equal(other) {\r\n    return other instanceof DirtyQubitTag\r\n  }\r\n}\r\n\r\n/**\r\n * @class LogicalQubitIDTag\r\n */\r\nexport class LogicalQubitIDTag {\r\n  /**\r\n   * @constructor\r\n   * @param {number} logical_qubit_id\r\n   */\r\n  constructor(logical_qubit_id) {\r\n    this.logical_qubit_id = logical_qubit_id\r\n  }\r\n\r\n  equal(other) {\r\n    return other instanceof LogicalQubitIDTag && other.logical_qubit_id === this.logical_qubit_id\r\n  }\r\n\r\n  /**\r\n   * check if self is in `array`\r\n   * @param array\r\n   * @return {boolean}\r\n   */\r\n  isInArray(array) {\r\n    if (Array.isArray(array)) {\r\n      for (let i = 0; i < array.length; ++i) {\r\n        if (this.equal(array[i])) {\r\n          return true\r\n        }\r\n      }\r\n    }\r\n    return false\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/meta/tag.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 692,
    "kind": "class",
    "name": "ComputeTag",
    "memberof": "src/meta/tag.js",
    "static": true,
    "longname": "src/meta/tag.js~ComputeTag",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/meta/tag.js",
    "importStyle": "{ComputeTag}",
    "description": "",
    "lineNumber": 20,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "ComputeTag"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 693,
    "kind": "method",
    "name": "equal",
    "memberof": "src/meta/tag.js~ComputeTag",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/tag.js~ComputeTag#equal",
    "access": "public",
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "params": [
      {
        "name": "other",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 694,
    "kind": "class",
    "name": "UncomputeTag",
    "memberof": "src/meta/tag.js",
    "static": true,
    "longname": "src/meta/tag.js~UncomputeTag",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/meta/tag.js",
    "importStyle": "{UncomputeTag}",
    "description": "",
    "lineNumber": 29,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "UncomputeTag"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 695,
    "kind": "method",
    "name": "equal",
    "memberof": "src/meta/tag.js~UncomputeTag",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/tag.js~UncomputeTag#equal",
    "access": "public",
    "description": null,
    "lineNumber": 30,
    "undocument": true,
    "params": [
      {
        "name": "other",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 696,
    "kind": "class",
    "name": "DirtyQubitTag",
    "memberof": "src/meta/tag.js",
    "static": true,
    "longname": "src/meta/tag.js~DirtyQubitTag",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/meta/tag.js",
    "importStyle": "{DirtyQubitTag}",
    "description": "",
    "lineNumber": 38,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "DirtyQubitTag"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 697,
    "kind": "method",
    "name": "equal",
    "memberof": "src/meta/tag.js~DirtyQubitTag",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/tag.js~DirtyQubitTag#equal",
    "access": "public",
    "description": null,
    "lineNumber": 39,
    "undocument": true,
    "params": [
      {
        "name": "other",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 698,
    "kind": "class",
    "name": "LogicalQubitIDTag",
    "memberof": "src/meta/tag.js",
    "static": true,
    "longname": "src/meta/tag.js~LogicalQubitIDTag",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/meta/tag.js",
    "importStyle": "{LogicalQubitIDTag}",
    "description": "",
    "lineNumber": 47,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "LogicalQubitIDTag"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 699,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/meta/tag.js~LogicalQubitIDTag",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/tag.js~LogicalQubitIDTag#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 52,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "logical_qubit_id",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 700,
    "kind": "member",
    "name": "logical_qubit_id",
    "memberof": "src/meta/tag.js~LogicalQubitIDTag",
    "static": false,
    "longname": "src/meta/tag.js~LogicalQubitIDTag#logical_qubit_id",
    "access": "public",
    "description": null,
    "lineNumber": 53,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 701,
    "kind": "method",
    "name": "equal",
    "memberof": "src/meta/tag.js~LogicalQubitIDTag",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/tag.js~LogicalQubitIDTag#equal",
    "access": "public",
    "description": null,
    "lineNumber": 56,
    "undocument": true,
    "params": [
      {
        "name": "other",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 702,
    "kind": "method",
    "name": "isInArray",
    "memberof": "src/meta/tag.js~LogicalQubitIDTag",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/meta/tag.js~LogicalQubitIDTag#isInArray",
    "access": "public",
    "description": "check if self is in `array`",
    "lineNumber": 65,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "array",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 703,
    "kind": "file",
    "name": "src/meta/util.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/**\r\nInserts an engine into the singly-linked list of engines.\r\n    It also sets the correct main_engine for engine_to_insert.\r\n\r\n@param {BasicEngine} prevEngine The engine just before the insertion point.\r\n@param {BasicEngine} engineToInsert The engine to insert at the insertion point.\r\n */\r\nexport function insertEngine(prevEngine, engineToInsert) {\r\n  engineToInsert.main = prevEngine.main\r\n  engineToInsert.next = prevEngine.next\r\n  prevEngine.next = engineToInsert\r\n}\r\n\r\n/**\r\nRemoves an engine from the singly-linked list of engines.\r\n\r\n    @param {BasicEngine} engine The engine just before the engine to drop.\r\n    @return {BasicEngine} The dropped engine.\r\n */\r\nexport function dropEngineAfter(engine) {\r\n  const e = engine.next\r\n  engine.next = e.next\r\n  delete e.next\r\n  delete e.main\r\n  return e\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/meta/util.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 704,
    "kind": "function",
    "name": "insertEngine",
    "memberof": "src/meta/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/meta/util.js~insertEngine",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/meta/util.js",
    "importStyle": "{insertEngine}",
    "description": "Inserts an engine into the singly-linked list of engines.\nIt also sets the correct main_engine for engine_to_insert.",
    "lineNumber": 24,
    "params": [
      {
        "nullable": null,
        "types": [
          "BasicEngine"
        ],
        "spread": false,
        "optional": false,
        "name": "prevEngine",
        "description": "The engine just before the insertion point."
      },
      {
        "nullable": null,
        "types": [
          "BasicEngine"
        ],
        "spread": false,
        "optional": false,
        "name": "engineToInsert",
        "description": "The engine to insert at the insertion point."
      }
    ],
    "return": null
  },
  {
    "__docId__": 705,
    "kind": "function",
    "name": "dropEngineAfter",
    "memberof": "src/meta/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/meta/util.js~dropEngineAfter",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/meta/util.js",
    "importStyle": "{dropEngineAfter}",
    "description": "Removes an engine from the singly-linked list of engines.",
    "lineNumber": 36,
    "params": [
      {
        "nullable": null,
        "types": [
          "BasicEngine"
        ],
        "spread": false,
        "optional": false,
        "name": "engine",
        "description": "The engine just before the engine to drop."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "BasicEngine"
      ],
      "spread": false,
      "description": "The dropped engine."
    }
  },
  {
    "__docId__": 706,
    "kind": "file",
    "name": "src/meta/util.spec.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport {expect} from 'chai'\r\nimport {DummyEngine} from '../cengines/testengine'\r\nimport MainEngine from '../cengines/main'\r\nimport {dropEngineAfter, insertEngine} from './util'\r\n\r\ndescribe('util test', () => {\r\n  it('should test_insert_then_drop', () => {\r\n    const d1 = new DummyEngine()\r\n    const d2 = new DummyEngine()\r\n    const d3 = new DummyEngine()\r\n    const eng = new MainEngine(d3, [d1])\r\n\r\n    expect(d1.next === d3).to.equal(true)\r\n    expect(typeof d2.next === 'undefined').to.equal(true)\r\n    expect(typeof d3.next === 'undefined').to.equal(true)\r\n    expect(d1.main).to.equal(eng)\r\n    expect(typeof d2.main === 'undefined').to.equal(true)\r\n    expect(d3.main).to.equal(eng)\r\n\r\n    insertEngine(d1, d2)\r\n    expect(d1.next === d2).to.equal(true)\r\n    expect(d2.next === d3).to.equal(true)\r\n    expect(d3.next === undefined).to.equal(true)\r\n    expect(d1.main === eng).to.equal(true)\r\n    expect(d2.main === eng).to.equal(true)\r\n    expect(d3.main === eng).to.equal(true)\r\n\r\n    dropEngineAfter(d1)\r\n    expect(d1.next === d3).to.equal(true)\r\n    expect(d2.next === undefined).to.equal(true)\r\n    expect(d3.next === undefined).to.equal(true)\r\n    expect(d1.main === eng).to.equal(true)\r\n    expect(d2.main === undefined).to.equal(true)\r\n    expect(d3.main === eng).to.equal(true)\r\n  });\r\n})\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/meta/util.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 707,
    "kind": "file",
    "name": "src/ops/basics.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/**\r\nDefines the BasicGate class, the base class of all gates, the\r\nBasicRotationGate class, the SelfInverseGate, the FastForwardingGate, the\r\nClassicalInstruction gate, and the BasicMathGate class.\r\n\r\nGates overload the | operator to allow the following syntax:\r\n\r\n @example\r\nGate | (qureg1, qureg2, qureg2)\r\nGate | (qureg, qubit)\r\nGate | qureg\r\nGate | qubit\r\nGate | (qubit,)\r\n\r\nThis means that for more than one quantum argument (right side of | ), a tuple\r\nneeds to be made explicitely, while for one argument it is optional.\r\n*/\r\nimport math from 'mathjs'\r\nimport { BasicQubit } from '../types/qubit'\r\nimport Command from './command'\r\nimport {arrayIsTuple, ObjectCopy} from '../libs/util'\r\nimport {NotMergeable} from '../meta/error'\r\n\r\nconst ANGLE_PRECISION = 12\r\nconst ANGLE_TOLERANCE = 10 ** -ANGLE_PRECISION\r\n\r\n/**\r\n * @abstract\r\n * @class BasicGate\r\n * @desc Base class of all gates.\r\n */\r\nexport class BasicGate {\r\n  /**\r\n   * @constructor\r\n    Note:\r\nSet interchangeable qubit indices!\r\n    (gate.interchangeable_qubit_indices)\r\n\r\nAs an example, consider\r\n\r\n   @example\r\n   ExampleGate | (a,b,c,d,e)\r\n\r\nwhere a and b are interchangeable. Then, call this function as\r\nfollows:\r\n\r\n   @example\r\n   this.set_interchangeable_qubit_indices([[0,1]])\r\n\r\nAs another example, consider\r\n\r\n   @example\r\n   ExampleGate2 | (a,b,c,d,e)\r\n\r\nwhere a and b are interchangeable and, in addition, c, d, and e\r\nare interchangeable among themselves. Then, call this function as\r\n\r\n   @example\r\n    this.set_interchangeable_qubit_indices([[0,1],[2,3,4]])\r\n  */\r\n  constructor() {\r\n    this.interchangeableQubitIndices = []\r\n  }\r\n\r\n  /**\r\n   * @throws {Error}\r\n   */\r\n  getInverse() {\r\n    throw new Error('BasicGate: No getInverse() implemented.')\r\n  }\r\n\r\n  /**\r\n   * @throws {NotMergeable}\r\n   */\r\n  getMerged() {\r\n    throw new NotMergeable('BasicGate: No getMerged() implemented.')\r\n  }\r\n\r\n  /**\r\n   * @throws {Error}\r\n   */\r\n  toString() {\r\n    throw new Error('BasicGate: No toString() implemented.')\r\n  }\r\n\r\n  /**\r\n   * @return {string}\r\n   */\r\n  inspect() {\r\n    return this.toString()\r\n  }\r\n\r\n  /**\r\n    Convert quantum input of \"gate | quantum input\" to internal formatting.\r\n\r\n    A Command object only accepts tuples of Quregs (list of Qubit objects)\r\nas qubits input parameter. However, with this function we allow the\r\nuser to use a more flexible syntax:\r\n\r\n    1) Gate | qubit\r\n    2) Gate | [qubit0, qubit1]\r\n    3) Gate | qureg\r\n    4) Gate | (qubit, )\r\n    5) Gate | (qureg, qubit)\r\n\r\nwhere qubit is a Qubit object and qureg is a Qureg object. This\r\nfunction takes the right hand side of | and transforms it to the\r\ncorrect input parameter of a Command object which is:\r\n\r\n    1) -> Gate | ([qubit], )\r\n    2) -> Gate | ([qubit0, qubit1], )\r\n    3) -> Gate | (qureg, )\r\n    4) -> Gate | ([qubit], )\r\n    5) -> Gate | (qureg, [qubit])\r\n\r\n@param {Qubit|Qubit[]|Qureg|Qureg[]} qubits a Qubit object, a list of Qubit objects, a Qureg object,\r\n    or a tuple of Qubit or Qureg objects (can be mixed).\r\n@returns {Qureg[]} Canonical representation A tuple containing Qureg (or list of Qubits) objects.\r\n     */\r\n  static makeTupleOfQureg(qubits) {\r\n    const isTuple = arrayIsTuple(qubits)\r\n    if (!isTuple) {\r\n      qubits = [qubits]\r\n    }\r\n    qubits.forEach((looper, idx) => {\r\n      if (looper instanceof BasicQubit) {\r\n        qubits[idx] = [looper]\r\n      }\r\n    })\r\n    return qubits.slice(0)\r\n  }\r\n\r\n  /**\r\n    Helper function to generate a command consisting of the gate and the qubits being acted upon.\r\n\r\n    @param qubits {Qubit | Array.<Qubit> | Qureg} see BasicGate.makeTupleOfQureg(qubits)\r\n    @return {Command} A Command object containing the gate and the qubits.\r\n  */\r\n  generateCommand(qubits) {\r\n    const qs = BasicGate.makeTupleOfQureg(qubits)\r\n    const engines = []\r\n    qs.forEach((reg) => {\r\n      reg.forEach(q => engines.push(q.engine))\r\n    })\r\n    const eng = engines[0]\r\n    return new Command(eng, this, qs)\r\n  }\r\n\r\n  /**\r\n    Operator| overload which enables the syntax Gate | qubits.\r\n\r\n    @example\r\n1) Gate | qubit\r\n2) Gate | [qubit0, qubit1]\r\n3) Gate | qureg\r\n4) Gate | (qubit, )\r\n5) Gate | (qureg, qubit)\r\n\r\n   @param qubits {Qubit | Array.<Qubit> | Qureg}\r\n   a Qubit object, a list of Qubit objects, a Qureg object,\r\n   or a tuple of Qubit or Qureg objects (can be mixed).\r\n  */\r\n  or(qubits) {\r\n    const cmd = this.generateCommand(qubits)\r\n    cmd.apply()\r\n  }\r\n\r\n  /**\r\n   * @param {BasicGate | Object} other\r\n   * @return {boolean}\r\n   */\r\n  equal(other) {\r\n    return this.__proto__ === other.__proto__\r\n  }\r\n\r\n  /**\r\n   * @return {BasicGate}\r\n   */\r\n  copy() {\r\n    return ObjectCopy(this)\r\n  }\r\n}\r\n\r\n/**\r\n * @class SelfInverseGate\r\n * @desc Self-inverse basic gate class.\r\n * Automatic implementation of the getInverse-member function for self-inverse gates.\r\n * @example\r\n   // getInverse(H) == H, it is a self-inverse gate:\r\n    getInverse(H) | qubit\r\n */\r\nexport class SelfInverseGate extends BasicGate {\r\n  getInverse() {\r\n    return ObjectCopy(this)\r\n  }\r\n}\r\n\r\n/**\r\n * @class BasicRotationGate\r\n * @desc\r\nDefines a base class of a rotation gate.\r\n\r\n    A rotation gate has a continuous parameter (the angle), labeled 'angle' /\r\nthis.angle. Its inverse is the same gate with the negated argument.\r\n    Rotation gates of the same class can be merged by adding the angles.\r\n    The continuous parameter is modulo 4 * pi, this.angle is in the interval\r\n    [0, 4 * pi).\r\n */\r\nexport class BasicRotationGate extends BasicGate {\r\n  /**\r\n   * @constructor\r\n      Initialize a basic rotation gate.\r\n    @param angle {number} Angle of rotation (saved modulo 4 * pi)\r\n   */\r\n  constructor(angle, ...args) {\r\n    super(...args)\r\n\r\n    let rounded_angle = math.round(math.mod(angle, 4.0 * Math.PI), ANGLE_PRECISION)\r\n    if (rounded_angle > 4 * Math.PI - ANGLE_TOLERANCE) {\r\n      rounded_angle = 0.0\r\n    }\r\n    this.angle = rounded_angle\r\n  }\r\n\r\n  /**\r\n   * @return {BasicRotationGate}\r\nReturn the inverse of this rotation gate (negate the angle, return new\r\nobject).\r\n     */\r\n  getInverse() {\r\n    if (this.angle == 0) {\r\n      return new this.__proto__.constructor(0)\r\n    } else {\r\n      return new this.__proto__.constructor(-this.angle + 4 * Math.PI)\r\n    }\r\n  }\r\n\r\n  /**\r\n    Return self merged with another gate.\r\n\r\n    Default implementation handles rotation gate of the same type, where\r\nangles are simply added.\r\n\r\n    @param {BasicRotationGate|Object} other\r\n    @throws {NotMergeable}  For non-rotation gates or rotation gates of different type.\r\n    @return {BasicRotationGate} New object representing the merged gates.\r\n   */\r\n  getMerged(other) {\r\n    if (other instanceof BasicRotationGate) {\r\n      return new this.__proto__.constructor(this.angle + other.angle)\r\n    }\r\n    throw new NotMergeable('Can\\'t merge different types of rotation gates.')\r\n  }\r\n\r\n  toString() {\r\n    return `${this.constructor.name}(${this.angle})`\r\n  }\r\n\r\n  /**\r\n    Return the Latex string representation of a BasicRotationGate.\r\n\r\n  Returns the class name and the angle as a subscript, i.e.\r\n\r\n   @example\r\n  [CLASSNAME]$_[ANGLE]$\r\n   @return {string}\r\n   */\r\n  texString() {\r\n    return `${this.constructor.name}$_{${this.angle}}$`\r\n  }\r\n\r\n  equal(other) {\r\n    if (other instanceof BasicRotationGate) {\r\n      return this.angle == other.angle\r\n    }\r\n    return false\r\n  }\r\n}\r\n\r\n/**\r\n * @class BasicPhaseGate\r\n * @desc\r\nDefines a base class of a phase gate.\r\n\r\n    A phase gate has a continuous parameter (the angle), labeled 'angle' /\r\nthis.angle. Its inverse is the same gate with the negated argument.\r\n    Phase gates of the same class can be merged by adding the angles.\r\n    The continuous parameter is modulo 2 * pi, this.angle is in the interval\r\n    [0, 2 * pi).\r\n */\r\nexport class BasicPhaseGate extends BasicGate {\r\n  /**\r\n    Initialize a basic rotation gate.\r\n\r\n    @param {number} angle Angle of rotation (saved modulo 2 * pi)\r\n     */\r\n  constructor(angle, ...args) {\r\n    super(...args)\r\n    let rounded_angle = math.round(math.mod(angle, 2.0 * Math.PI), ANGLE_PRECISION)\r\n    if (rounded_angle > 2 * Math.PI - ANGLE_TOLERANCE) {\r\n      rounded_angle = 0.0\r\n    }\r\n    this.angle = rounded_angle\r\n  }\r\n\r\n  /**\r\n    Return the inverse of this rotation gate (negate the angle, return new object).\r\n    @return {BasicPhaseGate}\r\n   */\r\n  getInverse() {\r\n    if (this.angle == 0) {\r\n      return new this.__proto__.constructor(0)\r\n    } else {\r\n      return new this.__proto__.constructor(-this.angle + 2 * Math.PI)\r\n    }\r\n  }\r\n\r\n  /**\r\n    Return self merged with another gate.\r\n\r\n    Default implementation handles rotation gate of the same type, where angles are simply added.\r\n\r\n    @param {BasicPhaseGate} other Phase gate of same type.\r\n    @throws NotMergeable For non-rotation gates or rotation gates of different type.\r\n    @return {BasicPhaseGate} New object representing the merged gates.\r\n  */\r\n  getMerged(other) {\r\n    if (other instanceof BasicPhaseGate) {\r\n      return new this.__proto__.constructor(this.angle + other.angle)\r\n    }\r\n    throw new NotMergeable('Can\\'t merge different types of rotation gates.')\r\n  }\r\n\r\n  toString() {\r\n    return `${this.constructor.name}(${this.angle})`\r\n  }\r\n\r\n  texString() {\r\n    return `${this.constructor.name}$_{${this.angle}}$`\r\n  }\r\n\r\n  equal(other) {\r\n    if (other instanceof BasicPhaseGate) {\r\n      return this.angle === other.angle\r\n    }\r\n    return false\r\n  }\r\n}\r\n\r\n/**\r\n * @class ClassicalInstructionGate\r\n * @desc\r\n  Classical instruction gates never have control qubits.\r\n    Base class for all gates which are not quantum gates in the typical sense,\r\n    e.g., measurement, allocation/deallocation, ...\r\n */\r\nexport class ClassicalInstructionGate extends BasicGate {\r\n\r\n}\r\n\r\n/**\r\n * @class FastForwardingGate\r\n * @desc\r\nBase class for classical instruction gates which require a fast-forward\r\nthrough compiler engines that cache / buffer gates. Examples include\r\nMeasure and Deallocate, which both should be executed asap, such\r\nthat Measurement results are available and resources are freed,\r\n    respectively.\r\n\r\n        Note:\r\nThe only requirement is that FlushGate commands run the entire\r\ncircuit. FastForwardingGate objects can be used but the user cannot\r\nexpect a measurement result to be available for all back-ends when\r\ncalling only Measure. E.g., for the IBM Quantum Experience back-end,\r\n    sending the circuit for each Measure-gate would be too inefficient,\r\n    which is why a final\r\n\r\n @example\r\n\r\neng.flush()\r\n\r\nis required before the circuit gets sent through the API.\r\n */\r\nexport class FastForwardingGate extends ClassicalInstructionGate {\r\n\r\n}\r\n\r\n/**\r\n * @class BasicMathGate\r\n * @desc\r\nBase class for all math gates.\r\n\r\n    It allows efficient emulation by providing a mathematical representation\r\nwhich is given by the concrete gate which derives from this base class.\r\nThe AddConstant gate, for example, registers a function of the form\r\n\r\n @example\r\n\r\nfunction add(x)\r\nreturn (x+a,)\r\n\r\nupon initialization. More generally, the function takes integers as\r\nparameters and returns a tuple / list of outputs, each entry corresponding\r\nto the function input. As an example, consider out-of-place\r\nmultiplication, which takes two input registers and adds the result into a\r\nthird, i.e., (a,b,c) -> (a,b,c+a*b). The corresponding function then is\r\n\r\n @example\r\n\r\nfunction multiply(a,b,c)\r\nreturn (a,b,c+a*b)\r\n */\r\nexport class BasicMathGate extends BasicGate {\r\n  /**\r\n   * @constructor\r\n    Initialize a BasicMathGate by providing the mathematical function that it implements.\r\n\r\n    @param {function} mathFunc Function which takes as many int values as\r\ninput, as the gate takes registers. For each of these values,\r\n    it then returns the output (i.e., it returns a list/tuple of\r\noutput values).\r\n\r\n@example\r\n\r\nfunction add(a,b)\r\nreturn (a,a+b)\r\nBasicMathGate.__init__(self, add)\r\n\r\nIf the gate acts on, e.g., fixed point numbers, the number of bits per\r\nregister is also required in order to describe the action of such a\r\nmathematical gate. For this reason, there is\r\n\r\n   @example\r\n\r\nBasicMathGate.get_math_function(qubits)\r\n\r\nwhich can be overwritten by the gate deriving from BasicMathGate.\r\n\r\n    @example\r\n\r\nfunction get_math_function(self, qubits)\r\nn = len(qubits[0])\r\nscal = 2.**n\r\nfunction math_fun(a)\r\nreturn (int(scal * (math.sin(math.pi * a / scal))),)\r\nreturn math_fun\r\n     */\r\n  constructor(mathFunc, ...args) {\r\n    super(...args)\r\n    this.mathFunc = x => Array.from(mathFunc(...x))\r\n  }\r\n\r\n  /**\r\n    Return the math function which corresponds to the action of this math\r\ngate, given the input to the gate (a tuple of quantum registers).\r\n\r\n  @param {Array.<Qureg>} qubits Qubits to which the math gate is being applied.\r\n\r\n    @return {function} javascript function describing the action of this\r\n    gate. (See BasicMathGate.constructor for an example).\r\n   */\r\n  getMathFunction(qubits) {\r\n    return this.mathFunc\r\n  }\r\n\r\n  toString() {\r\n    return 'MATH'\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/ops/basics.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 708,
    "kind": "variable",
    "name": "ANGLE_PRECISION",
    "memberof": "src/ops/basics.js",
    "static": true,
    "longname": "src/ops/basics.js~ANGLE_PRECISION",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/ops/basics.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 40,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 709,
    "kind": "variable",
    "name": "ANGLE_TOLERANCE",
    "memberof": "src/ops/basics.js",
    "static": true,
    "longname": "src/ops/basics.js~ANGLE_TOLERANCE",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/ops/basics.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 41,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 710,
    "kind": "class",
    "name": "BasicGate",
    "memberof": "src/ops/basics.js",
    "static": true,
    "longname": "src/ops/basics.js~BasicGate",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/basics.js",
    "importStyle": "{BasicGate}",
    "description": "Base class of all gates.",
    "lineNumber": 48,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "BasicGate"
      }
    ],
    "abstract": true,
    "interface": false
  },
  {
    "__docId__": 711,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/ops/basics.js~BasicGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/basics.js~BasicGate#constructor",
    "access": "public",
    "description": "",
    "examples": [
      "ExampleGate | (a,b,c,d,e)\n\nwhere a and b are interchangeable. Then, call this function as\nfollows:",
      "this.set_interchangeable_qubit_indices([[0,1]])\n\nAs another example, consider",
      "ExampleGate2 | (a,b,c,d,e)\n\nwhere a and b are interchangeable and, in addition, c, d, and e\nare interchangeable among themselves. Then, call this function as",
      "this.set_interchangeable_qubit_indices([[0,1],[2,3,4]])"
    ],
    "lineNumber": 77,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": "Note:\nSet interchangeable qubit indices!\n(gate.interchangeable_qubit_indices)\n\nAs an example, consider"
      }
    ]
  },
  {
    "__docId__": 712,
    "kind": "member",
    "name": "interchangeableQubitIndices",
    "memberof": "src/ops/basics.js~BasicGate",
    "static": false,
    "longname": "src/ops/basics.js~BasicGate#interchangeableQubitIndices",
    "access": "public",
    "description": null,
    "lineNumber": 78,
    "undocument": true,
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 713,
    "kind": "method",
    "name": "getInverse",
    "memberof": "src/ops/basics.js~BasicGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/basics.js~BasicGate#getInverse",
    "access": "public",
    "description": "",
    "lineNumber": 84,
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": ""
      }
    ],
    "params": [],
    "return": null
  },
  {
    "__docId__": 714,
    "kind": "method",
    "name": "getMerged",
    "memberof": "src/ops/basics.js~BasicGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/basics.js~BasicGate#getMerged",
    "access": "public",
    "description": "",
    "lineNumber": 91,
    "throws": [
      {
        "types": [
          "NotMergeable"
        ],
        "description": ""
      }
    ],
    "params": [],
    "return": null
  },
  {
    "__docId__": 715,
    "kind": "method",
    "name": "toString",
    "memberof": "src/ops/basics.js~BasicGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/basics.js~BasicGate#toString",
    "access": "public",
    "description": "",
    "lineNumber": 98,
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": ""
      }
    ],
    "params": [],
    "return": null
  },
  {
    "__docId__": 716,
    "kind": "method",
    "name": "inspect",
    "memberof": "src/ops/basics.js~BasicGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/basics.js~BasicGate#inspect",
    "access": "public",
    "description": "",
    "lineNumber": 105,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 717,
    "kind": "method",
    "name": "makeTupleOfQureg",
    "memberof": "src/ops/basics.js~BasicGate",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/ops/basics.js~BasicGate.makeTupleOfQureg",
    "access": "public",
    "description": "Convert quantum input of \"gate | quantum input\" to internal formatting.\n\nA Command object only accepts tuples of Quregs (list of Qubit objects)\nas qubits input parameter. However, with this function we allow the\nuser to use a more flexible syntax:\n\n1) Gate | qubit\n2) Gate | [qubit0, qubit1]\n3) Gate | qureg\n4) Gate | (qubit, )\n5) Gate | (qureg, qubit)\n\nwhere qubit is a Qubit object and qureg is a Qureg object. This\nfunction takes the right hand side of | and transforms it to the\ncorrect input parameter of a Command object which is:\n\n1) -> Gate | ([qubit], )\n2) -> Gate | ([qubit0, qubit1], )\n3) -> Gate | (qureg, )\n4) -> Gate | ([qubit], )\n5) -> Gate | (qureg, [qubit])",
    "lineNumber": 136,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Qureg[]} Canonical representation A tuple containing Qureg (or list of Qubits) objects."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Qubit",
          "Qubit[]",
          "Qureg",
          "Qureg[]"
        ],
        "spread": false,
        "optional": false,
        "name": "qubits",
        "description": "a Qubit object, a list of Qubit objects, a Qureg object,\nor a tuple of Qubit or Qureg objects (can be mixed)."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Qureg[]"
      ],
      "spread": false,
      "description": "Canonical representation A tuple containing Qureg (or list of Qubits) objects."
    }
  },
  {
    "__docId__": 718,
    "kind": "method",
    "name": "generateCommand",
    "memberof": "src/ops/basics.js~BasicGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/basics.js~BasicGate#generateCommand",
    "access": "public",
    "description": "Helper function to generate a command consisting of the gate and the qubits being acted upon.",
    "lineNumber": 155,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "qubits",
        "description": "{Qubit | Array.<Qubit> | Qureg} see BasicGate.makeTupleOfQureg(qubits)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Command"
      ],
      "spread": false,
      "description": "A Command object containing the gate and the qubits."
    }
  },
  {
    "__docId__": 719,
    "kind": "method",
    "name": "or",
    "memberof": "src/ops/basics.js~BasicGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/basics.js~BasicGate#or",
    "access": "public",
    "description": "Operator| overload which enables the syntax Gate | qubits.",
    "examples": [
      "1) Gate | qubit\n2) Gate | [qubit0, qubit1]\n3) Gate | qureg\n4) Gate | (qubit, )\n5) Gate | (qureg, qubit)"
    ],
    "lineNumber": 179,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "qubits",
        "description": "{Qubit | Array.<Qubit> | Qureg}\na Qubit object, a list of Qubit objects, a Qureg object,\nor a tuple of Qubit or Qureg objects (can be mixed)."
      }
    ],
    "return": null
  },
  {
    "__docId__": 720,
    "kind": "method",
    "name": "equal",
    "memberof": "src/ops/basics.js~BasicGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/basics.js~BasicGate#equal",
    "access": "public",
    "description": "",
    "lineNumber": 188,
    "params": [
      {
        "nullable": null,
        "types": [
          "BasicGate ",
          " Object"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 721,
    "kind": "method",
    "name": "copy",
    "memberof": "src/ops/basics.js~BasicGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/basics.js~BasicGate#copy",
    "access": "public",
    "description": "",
    "lineNumber": 195,
    "return": {
      "nullable": null,
      "types": [
        "BasicGate"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 722,
    "kind": "class",
    "name": "SelfInverseGate",
    "memberof": "src/ops/basics.js",
    "static": true,
    "longname": "src/ops/basics.js~SelfInverseGate",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/basics.js",
    "importStyle": "{SelfInverseGate}",
    "description": "Self-inverse basic gate class.\nAutomatic implementation of the getInverse-member function for self-inverse gates.",
    "examples": [
      "// getInverse(H) == H, it is a self-inverse gate:\ngetInverse(H) | qubit"
    ],
    "lineNumber": 208,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "SelfInverseGate"
      }
    ],
    "interface": false,
    "extends": [
      "BasicGate"
    ]
  },
  {
    "__docId__": 723,
    "kind": "method",
    "name": "getInverse",
    "memberof": "src/ops/basics.js~SelfInverseGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/basics.js~SelfInverseGate#getInverse",
    "access": "public",
    "description": null,
    "lineNumber": 209,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 724,
    "kind": "class",
    "name": "BasicRotationGate",
    "memberof": "src/ops/basics.js",
    "static": true,
    "longname": "src/ops/basics.js~BasicRotationGate",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/basics.js",
    "importStyle": "{BasicRotationGate}",
    "description": "Defines a base class of a rotation gate.\n\nA rotation gate has a continuous parameter (the angle), labeled 'angle' /\nthis.angle. Its inverse is the same gate with the negated argument.\nRotation gates of the same class can be merged by adding the angles.\nThe continuous parameter is modulo 4 * pi, this.angle is in the interval\n[0, 4 * pi).",
    "lineNumber": 225,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "BasicRotationGate"
      }
    ],
    "interface": false,
    "extends": [
      "BasicGate"
    ]
  },
  {
    "__docId__": 725,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/ops/basics.js~BasicRotationGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/basics.js~BasicRotationGate#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 231,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": "Initialize a basic rotation gate."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "angle",
        "description": "{number} Angle of rotation (saved modulo 4 * pi)"
      }
    ]
  },
  {
    "__docId__": 726,
    "kind": "member",
    "name": "angle",
    "memberof": "src/ops/basics.js~BasicRotationGate",
    "static": false,
    "longname": "src/ops/basics.js~BasicRotationGate#angle",
    "access": "public",
    "description": null,
    "lineNumber": 238,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 727,
    "kind": "method",
    "name": "getInverse",
    "memberof": "src/ops/basics.js~BasicRotationGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/basics.js~BasicRotationGate#getInverse",
    "access": "public",
    "description": "",
    "lineNumber": 246,
    "return": {
      "nullable": null,
      "types": [
        "BasicRotationGate"
      ],
      "spread": false,
      "description": "Return the inverse of this rotation gate (negate the angle, return new\nobject)."
    },
    "params": []
  },
  {
    "__docId__": 728,
    "kind": "method",
    "name": "getMerged",
    "memberof": "src/ops/basics.js~BasicRotationGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/basics.js~BasicRotationGate#getMerged",
    "access": "public",
    "description": "Return self merged with another gate.\n\nDefault implementation handles rotation gate of the same type, where\nangles are simply added.",
    "lineNumber": 264,
    "params": [
      {
        "nullable": null,
        "types": [
          "BasicRotationGate",
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "BasicRotationGate"
      ],
      "spread": false,
      "description": "New object representing the merged gates."
    },
    "throws": [
      {
        "types": [
          "NotMergeable"
        ],
        "description": "For non-rotation gates or rotation gates of different type."
      }
    ]
  },
  {
    "__docId__": 729,
    "kind": "method",
    "name": "toString",
    "memberof": "src/ops/basics.js~BasicRotationGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/basics.js~BasicRotationGate#toString",
    "access": "public",
    "description": null,
    "lineNumber": 271,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 730,
    "kind": "method",
    "name": "texString",
    "memberof": "src/ops/basics.js~BasicRotationGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/basics.js~BasicRotationGate#texString",
    "access": "public",
    "description": "Return the Latex string representation of a BasicRotationGate.\n\nReturns the class name and the angle as a subscript, i.e.",
    "examples": [
      "[CLASSNAME]$_[ANGLE]$"
    ],
    "lineNumber": 284,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 731,
    "kind": "method",
    "name": "equal",
    "memberof": "src/ops/basics.js~BasicRotationGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/basics.js~BasicRotationGate#equal",
    "access": "public",
    "description": null,
    "lineNumber": 288,
    "undocument": true,
    "params": [
      {
        "name": "other",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 732,
    "kind": "class",
    "name": "BasicPhaseGate",
    "memberof": "src/ops/basics.js",
    "static": true,
    "longname": "src/ops/basics.js~BasicPhaseGate",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/basics.js",
    "importStyle": "{BasicPhaseGate}",
    "description": "Defines a base class of a phase gate.\n\nA phase gate has a continuous parameter (the angle), labeled 'angle' /\nthis.angle. Its inverse is the same gate with the negated argument.\nPhase gates of the same class can be merged by adding the angles.\nThe continuous parameter is modulo 2 * pi, this.angle is in the interval\n[0, 2 * pi).",
    "lineNumber": 307,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "BasicPhaseGate"
      }
    ],
    "interface": false,
    "extends": [
      "BasicGate"
    ]
  },
  {
    "__docId__": 733,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/ops/basics.js~BasicPhaseGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/basics.js~BasicPhaseGate#constructor",
    "access": "public",
    "description": "Initialize a basic rotation gate.",
    "lineNumber": 313,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "angle",
        "description": "Angle of rotation (saved modulo 2 * pi)"
      }
    ]
  },
  {
    "__docId__": 734,
    "kind": "member",
    "name": "angle",
    "memberof": "src/ops/basics.js~BasicPhaseGate",
    "static": false,
    "longname": "src/ops/basics.js~BasicPhaseGate#angle",
    "access": "public",
    "description": null,
    "lineNumber": 319,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 735,
    "kind": "method",
    "name": "getInverse",
    "memberof": "src/ops/basics.js~BasicPhaseGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/basics.js~BasicPhaseGate#getInverse",
    "access": "public",
    "description": "Return the inverse of this rotation gate (negate the angle, return new object).",
    "lineNumber": 326,
    "return": {
      "nullable": null,
      "types": [
        "BasicPhaseGate"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 736,
    "kind": "method",
    "name": "getMerged",
    "memberof": "src/ops/basics.js~BasicPhaseGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/basics.js~BasicPhaseGate#getMerged",
    "access": "public",
    "description": "Return self merged with another gate.\n\nDefault implementation handles rotation gate of the same type, where angles are simply added.",
    "lineNumber": 343,
    "params": [
      {
        "nullable": null,
        "types": [
          "BasicPhaseGate"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "Phase gate of same type."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "BasicPhaseGate"
      ],
      "spread": false,
      "description": "New object representing the merged gates."
    },
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "NotMergeable For non-rotation gates or rotation gates of different type."
      }
    ]
  },
  {
    "__docId__": 737,
    "kind": "method",
    "name": "toString",
    "memberof": "src/ops/basics.js~BasicPhaseGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/basics.js~BasicPhaseGate#toString",
    "access": "public",
    "description": null,
    "lineNumber": 350,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 738,
    "kind": "method",
    "name": "texString",
    "memberof": "src/ops/basics.js~BasicPhaseGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/basics.js~BasicPhaseGate#texString",
    "access": "public",
    "description": null,
    "lineNumber": 354,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 739,
    "kind": "method",
    "name": "equal",
    "memberof": "src/ops/basics.js~BasicPhaseGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/basics.js~BasicPhaseGate#equal",
    "access": "public",
    "description": null,
    "lineNumber": 358,
    "undocument": true,
    "params": [
      {
        "name": "other",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 740,
    "kind": "class",
    "name": "ClassicalInstructionGate",
    "memberof": "src/ops/basics.js",
    "static": true,
    "longname": "src/ops/basics.js~ClassicalInstructionGate",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/basics.js",
    "importStyle": "{ClassicalInstructionGate}",
    "description": "Classical instruction gates never have control qubits.\nBase class for all gates which are not quantum gates in the typical sense,\ne.g., measurement, allocation/deallocation, ...",
    "lineNumber": 373,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "ClassicalInstructionGate"
      }
    ],
    "interface": false,
    "extends": [
      "BasicGate"
    ]
  },
  {
    "__docId__": 741,
    "kind": "class",
    "name": "FastForwardingGate",
    "memberof": "src/ops/basics.js",
    "static": true,
    "longname": "src/ops/basics.js~FastForwardingGate",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/basics.js",
    "importStyle": "{FastForwardingGate}",
    "description": "Base class for classical instruction gates which require a fast-forward\nthrough compiler engines that cache / buffer gates. Examples include\nMeasure and Deallocate, which both should be executed asap, such\nthat Measurement results are available and resources are freed,\nrespectively.\n\nNote:\nThe only requirement is that FlushGate commands run the entire\ncircuit. FastForwardingGate objects can be used but the user cannot\nexpect a measurement result to be available for all back-ends when\ncalling only Measure. E.g., for the IBM Quantum Experience back-end,\nsending the circuit for each Measure-gate would be too inefficient,\nwhich is why a final",
    "examples": [
      "\neng.flush()\n\nis required before the circuit gets sent through the API."
    ],
    "lineNumber": 400,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "FastForwardingGate"
      }
    ],
    "interface": false,
    "extends": [
      "ClassicalInstructionGate"
    ]
  },
  {
    "__docId__": 742,
    "kind": "class",
    "name": "BasicMathGate",
    "memberof": "src/ops/basics.js",
    "static": true,
    "longname": "src/ops/basics.js~BasicMathGate",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/basics.js",
    "importStyle": "{BasicMathGate}",
    "description": "Base class for all math gates.\n\nIt allows efficient emulation by providing a mathematical representation\nwhich is given by the concrete gate which derives from this base class.\nThe AddConstant gate, for example, registers a function of the form",
    "examples": [
      "\nfunction add(x)\nreturn (x+a,)\n\nupon initialization. More generally, the function takes integers as\nparameters and returns a tuple / list of outputs, each entry corresponding\nto the function input. As an example, consider out-of-place\nmultiplication, which takes two input registers and adds the result into a\nthird, i.e., (a,b,c) -> (a,b,c+a*b). The corresponding function then is",
      "\nfunction multiply(a,b,c)\nreturn (a,b,c+a*b)"
    ],
    "lineNumber": 429,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "BasicMathGate"
      }
    ],
    "interface": false,
    "extends": [
      "BasicGate"
    ]
  },
  {
    "__docId__": 743,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/ops/basics.js~BasicMathGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/basics.js~BasicMathGate#constructor",
    "access": "public",
    "description": "",
    "examples": [
      "\nfunction add(a,b)\nreturn (a,a+b)\nBasicMathGate.__init__(self, add)\n\nIf the gate acts on, e.g., fixed point numbers, the number of bits per\nregister is also required in order to describe the action of such a\nmathematical gate. For this reason, there is",
      "\nBasicMathGate.get_math_function(qubits)\n\nwhich can be overwritten by the gate deriving from BasicMathGate.",
      "\nfunction get_math_function(self, qubits)\nn = len(qubits[0])\nscal = 2.**n\nfunction math_fun(a)\nreturn (int(scal * (math.sin(math.pi * a / scal))),)\nreturn math_fun"
    ],
    "lineNumber": 464,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": "Initialize a BasicMathGate by providing the mathematical function that it implements."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "mathFunc",
        "description": "Function which takes as many int values as\ninput, as the gate takes registers. For each of these values,\nit then returns the output (i.e., it returns a list/tuple of\noutput values)."
      }
    ]
  },
  {
    "__docId__": 744,
    "kind": "member",
    "name": "mathFunc",
    "memberof": "src/ops/basics.js~BasicMathGate",
    "static": false,
    "longname": "src/ops/basics.js~BasicMathGate#mathFunc",
    "access": "public",
    "description": null,
    "lineNumber": 466,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 745,
    "kind": "method",
    "name": "getMathFunction",
    "memberof": "src/ops/basics.js~BasicMathGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/basics.js~BasicMathGate#getMathFunction",
    "access": "public",
    "description": "Return the math function which corresponds to the action of this math\ngate, given the input to the gate (a tuple of quantum registers).",
    "lineNumber": 478,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array.<Qureg>"
        ],
        "spread": false,
        "optional": false,
        "name": "qubits",
        "description": "Qubits to which the math gate is being applied."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "function"
      ],
      "spread": false,
      "description": "javascript function describing the action of this\ngate. (See BasicMathGate.constructor for an example)."
    }
  },
  {
    "__docId__": 746,
    "kind": "method",
    "name": "toString",
    "memberof": "src/ops/basics.js~BasicMathGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/basics.js~BasicMathGate#toString",
    "access": "public",
    "description": null,
    "lineNumber": 482,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 747,
    "kind": "file",
    "name": "src/ops/basics.spec.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport {assert, expect} from 'chai'\r\nimport math from 'mathjs'\r\nimport MainEngine from '../cengines/main'\r\nimport {DummyEngine} from '../cengines/testengine'\r\nimport {\r\n  BasicGate, FastForwardingGate, BasicRotationGate, SelfInverseGate, BasicPhaseGate, BasicMathGate\r\n} from './basics';\r\nimport {Qubit, Qureg} from '../types/qubit'\r\nimport Command from './command'\r\nimport {arrayEqual} from '../libs/polyfill'\r\n\r\nfunction mainEngine() {\r\n  return new MainEngine(new DummyEngine(), [new DummyEngine()])\r\n}\r\n\r\ndescribe('basics test', () => {\r\n  it('should basic gate init', () => {\r\n    const basicGate = new BasicGate()\r\n    expect(basicGate.interchangeableQubitIndices).to.deep.equal([])\r\n    expect(basicGate.getInverse).to.throw()\r\n    try {\r\n      basicGate.getMerged('other gate')\r\n    } catch (e) {\r\n      assert(true)\r\n    }\r\n  });\r\n\r\n  it('should basic gate make array of qureg', () => {\r\n    const engine = mainEngine()\r\n    const qubit0 = new Qubit(engine, 0)\r\n    const qubit1 = new Qubit(engine, 1)\r\n    const qubit2 = new Qubit(engine, 2)\r\n    const qubit3 = new Qubit(engine, 3)\r\n    const qureg = new Qureg([qubit2, qubit3])\r\n    const case1 = BasicGate.makeTupleOfQureg(qubit0)\r\n    expect(case1).to.deep.equal([[qubit0]])\r\n    const case2 = BasicGate.makeTupleOfQureg([qubit0, qubit1])\r\n    expect(case2).to.deep.equal([[qubit0, qubit1]])\r\n    const case3 = BasicGate.makeTupleOfQureg(qureg)\r\n    expect(case3).to.deep.equal([qureg])\r\n    const case4 = BasicGate.makeTupleOfQureg([qubit0])\r\n    expect(case4).to.deep.equal([[qubit0]])\r\n    const case5 = BasicGate.makeTupleOfQureg([qureg, qubit0])\r\n    expect(case5).to.deep.equal([qureg, [qubit0]])\r\n  });\r\n\r\n  it('should basic gate generate command', () => {\r\n    const engine = mainEngine()\r\n    const qubit0 = new Qubit(engine, 0)\r\n    const qubit1 = new Qubit(engine, 1)\r\n    const qubit2 = new Qubit(engine, 2)\r\n    const qubit3 = new Qubit(engine, 3)\r\n    const qureg = new Qureg([qubit2, qubit3])\r\n    const basic_gate = new BasicGate()\r\n    const command1 = basic_gate.generateCommand(qubit0)\r\n    expect(command1.equal(new Command(engine, basic_gate, [[qubit0]]))).to.equal(true)\r\n    const command2 = basic_gate.generateCommand([qubit0, qubit1])\r\n    expect(command2.equal(new Command(engine, basic_gate, [[qubit0, qubit1]]))).to.equal(true)\r\n    const command3 = basic_gate.generateCommand(qureg)\r\n    expect(command3.equal(new Command(engine, basic_gate, [qureg]))).to.equal(true)\r\n    const command4 = basic_gate.generateCommand([qubit0])\r\n    expect(command4.equal(new Command(engine, basic_gate, [[qubit0]]))).to.equal(true)\r\n    const command5 = basic_gate.generateCommand([qureg, qubit0])\r\n    expect(command5.equal(new Command(engine, basic_gate, [qureg, [qubit0]]))).to.equal(true)\r\n  });\r\n\r\n\r\n  it('should basic gate or', () => {\r\n    const saving_backend = new DummyEngine(true)\r\n    const engine = new MainEngine(saving_backend, [new DummyEngine()])\r\n    const qubit0 = new Qubit(engine, 0)\r\n    const qubit1 = new Qubit(engine, 1)\r\n    const qubit2 = new Qubit(engine, 2)\r\n    const qubit3 = new Qubit(engine, 3)\r\n    const qureg = new Qureg([qubit2, qubit3])\r\n    const basic_gate = new BasicGate()\r\n    const command1 = basic_gate.generateCommand(qubit0)\r\n    basic_gate.or(qubit0)\r\n    const command2 = basic_gate.generateCommand([qubit0, qubit1])\r\n    basic_gate.or([qubit0, qubit1])\r\n    const command3 = basic_gate.generateCommand(qureg)\r\n    basic_gate.or(qureg)\r\n    const command4 = basic_gate.generateCommand([qubit0])\r\n    basic_gate.or([qubit0])\r\n    const command5 = basic_gate.generateCommand([qureg, qubit0])\r\n    basic_gate.or([qureg, qubit0])\r\n    const received_commands = []\r\n    // Remove Deallocate gates\r\n    saving_backend.receivedCommands.forEach((cmd) => {\r\n      if (!(cmd.gate instanceof FastForwardingGate)) {\r\n        received_commands.push(cmd)\r\n      }\r\n    })\r\n\r\n    expect(arrayEqual(received_commands, [command1, command2, command3, command4, command5])).to.equal(true)\r\n  });\r\n\r\n  it('should basic gate compare', () => {\r\n    const gate1 = new BasicGate()\r\n    const gate2 = new BasicGate()\r\n    expect(gate1.equal(gate2)).to.equal(true)\r\n  });\r\n\r\n  it('should comaring different gates', () => {\r\n    const basic_gate = new BasicGate()\r\n    const basic_rotation_gate = new BasicRotationGate(1.0)\r\n    const self_inverse_gate = new SelfInverseGate()\r\n    expect(basic_gate.equal(basic_rotation_gate)).to.equal(false)\r\n    expect(basic_gate.equal(self_inverse_gate)).to.equal(false)\r\n    expect(self_inverse_gate.equal(basic_rotation_gate)).to.equal(false)\r\n  });\r\n\r\n  it('should basic gate str', () => {\r\n    const basic_gate = new BasicGate()\r\n    expect(basic_gate.toString).to.throw()\r\n  });\r\n\r\n  it('should self inverse gate', () => {\r\n    const self_inverse_gate = new SelfInverseGate()\r\n    expect(self_inverse_gate.getInverse().equal(self_inverse_gate)).to.equal(true)\r\n    expect(self_inverse_gate.getInverse() != self_inverse_gate).to.equal(true)\r\n  });\r\n\r\n  it('should basic rotation gate init', () => {\r\n    // Test internal representation\r\n    const data = [[2.0, 2.0], [17, 4.4336293856408275], [-0.5 * Math.PI, 3.5 * Math.PI], [4 * Math.PI, 0]]\r\n    data.forEach(([input_angle, modulo_angle]) => {\r\n      const gate = new BasicRotationGate(input_angle)\r\n      expect(gate.angle).to.be.closeTo(modulo_angle, 1e-12)\r\n    })\r\n  });\r\n\r\n  it('should basic rotation gate str', () => {\r\n    const basic_rotation_gate = new BasicRotationGate(0.5)\r\n    expect(basic_rotation_gate.toString()).to.equal('BasicRotationGate(0.5)')\r\n  });\r\n\r\n  it('should basic roration gate get inverse', () => {\r\n    const data = [[2.0, -2.0 + 4 * Math.PI], [-0.5, 0.5], [0.0, 0]]\r\n    data.forEach(([input_angle, inverse_angle]) => {\r\n      const basic_rotation_gate = new BasicRotationGate(input_angle)\r\n      const inverse = basic_rotation_gate.getInverse()\r\n      expect(inverse instanceof BasicRotationGate).to.equal(true)\r\n      expect(inverse.angle).to.be.closeTo(inverse_angle, 1e-12)\r\n    })\r\n  });\r\n\r\n  it('should basic rotation gate get merged', () => {\r\n    const basic_gate = new BasicGate()\r\n    const basic_rotation_gate1 = new BasicRotationGate(0.5)\r\n    const basic_rotation_gate2 = new BasicRotationGate(1.0)\r\n    const basic_rotation_gate3 = new BasicRotationGate(1.5)\r\n    expect(() => basic_rotation_gate1.getMerged(basic_gate)).to.throw()\r\n    const merged_gate = basic_rotation_gate1.getMerged(basic_rotation_gate2)\r\n    expect(merged_gate.equal(basic_rotation_gate3)).to.equal(true)\r\n  });\r\n\r\n  it('should basic rotation gate comparison', () => {\r\n    const basic_rotation_gate1 = new BasicRotationGate(0.5)\r\n    const basic_rotation_gate2 = new BasicRotationGate(0.5)\r\n    const basic_rotation_gate3 = new BasicRotationGate(0.5 + 4 * Math.PI)\r\n    expect(basic_rotation_gate1.equal(basic_rotation_gate2)).to.equal(true)\r\n    expect(basic_rotation_gate1.equal(basic_rotation_gate3)).to.equal(true)\r\n\r\n    const basic_rotation_gate4 = new BasicRotationGate(0.50000001)\r\n    // Test __ne__:\r\n    expect(basic_rotation_gate4.equal(basic_rotation_gate1)).to.equal(false)\r\n\r\n    // Test one gate close to 4*pi the other one close to 0\r\n    const basic_rotation_gate5 = new BasicRotationGate(1.e-13)\r\n    const basic_rotation_gate6 = new BasicRotationGate(4 * Math.PI - 1.e-13)\r\n    expect(basic_rotation_gate5.equal(basic_rotation_gate6)).to.equal(true)\r\n    expect(basic_rotation_gate6.equal(basic_rotation_gate5)).to.equal(true)\r\n    // Test different types of gates\r\n    const basic_gate = new BasicGate()\r\n    expect(basic_gate.equal(basic_rotation_gate6)).to.equal(false)\r\n    expect(basic_rotation_gate2.equal(new BasicRotationGate(0.5 + 2 * Math.PI))).to.equal(false)\r\n  });\r\n\r\n  it('should phase gate init', () => {\r\n    const data = [[2.0, 2.0], [17.0, 4.4336293856408275],\r\n      [-0.5 * math.pi, 1.5 * math.pi], [2 * math.pi, 0]]\r\n    data.forEach(([input_angle, modulo_angle]) => {\r\n      // Test internal representation\r\n      const gate = new BasicPhaseGate(input_angle)\r\n      expect(gate.angle).to.be.closeTo(modulo_angle, 1e-12)\r\n    })\r\n  });\r\n\r\n  it('should basic phase gate str', () => {\r\n    const basic_phase_gate = new BasicPhaseGate(0.5)\r\n    expect(basic_phase_gate.toString()).to.be.equal('BasicPhaseGate(0.5)')\r\n  });\r\n\r\n  it('should basic phase gate get inverse', () => {\r\n    const data = [[2.0, -2.0 + 2 * math.pi], [-0.5, 0.5], [0.0, 0]]\r\n    data.forEach(([input_angle, inverse_angle]) => {\r\n      const basic_phase_gate = new BasicPhaseGate(input_angle)\r\n      const inverse = basic_phase_gate.getInverse()\r\n      expect(inverse instanceof BasicPhaseGate).to.equal(true)\r\n      expect(inverse.angle).to.be.closeTo(inverse_angle, 1e-12)\r\n    })\r\n  });\r\n\r\n  it('should basic phase gate get merged', () => {\r\n    const basic_gate = new BasicGate()\r\n    const basic_phase_gate1 = new BasicPhaseGate(0.5)\r\n    const basic_phase_gate2 = new BasicPhaseGate(1.0)\r\n    const basic_phase_gate3 = new BasicPhaseGate(1.5)\r\n    expect(() => basic_phase_gate1.getMerged(basic_gate)).to.throw()\r\n    const merged_gate = basic_phase_gate1.getMerged(basic_phase_gate2)\r\n    expect(merged_gate.equal(basic_phase_gate3)).to.equal(true)\r\n  });\r\n\r\n  it('should basic phase gate comparison', () => {\r\n    const basic_phase_gate1 = new BasicPhaseGate(0.5)\r\n    const basic_phase_gate2 = new BasicPhaseGate(0.5)\r\n    const basic_phase_gate3 = new BasicPhaseGate(0.5 + 2 * math.pi)\r\n    expect(basic_phase_gate1.equal(basic_phase_gate2)).to.equal(true)\r\n    expect(basic_phase_gate1.equal(basic_phase_gate3)).to.equal(true)\r\n    const basic_phase_gate4 = new BasicPhaseGate(0.50000001)\r\n    // Test __ne__:\r\n    expect(basic_phase_gate4.equal(basic_phase_gate1)).to.equal(false)\r\n    // Test one gate close to 2*pi the other one close to 0\r\n    const basic_phase_gate5 = new BasicPhaseGate(1.e-13)\r\n    const basic_phase_gate6 = new BasicPhaseGate(2 * math.pi - 1.e-13)\r\n    expect(basic_phase_gate5.equal(basic_phase_gate6)).to.equal(true)\r\n    expect(basic_phase_gate6.equal(basic_phase_gate5)).to.equal(true)\r\n    // Test different types of gates\r\n    const basic_gate = new BasicGate()\r\n    expect(basic_gate.equal(basic_phase_gate6)).to.equal(false)\r\n    expect(basic_phase_gate2.equal(new BasicPhaseGate(0.5 + math.pi))).to.equal(false)\r\n  });\r\n\r\n  it('should basic math gate', () => {\r\n    const mymathFunc = (a, b, c) => [a, b, c + a * b]\r\n\r\n    class MyMultiplyGate extends BasicMathGate {\r\n      constructor() {\r\n        super(mymathFunc)\r\n      }\r\n    }\r\n\r\n    const gate = new MyMultiplyGate()\r\n    expect(gate.toString()).to.equal('MATH')\r\n    // Test a=2, b=3, and c=5 should give a=2, b=3, c=11\r\n    const math_fun = gate.getMathFunction(['qreg1', 'qreg2', 'qreg3'])\r\n    expect(math_fun([2, 3, 5])).to.deep.equal([2, 3, 11])\r\n  });\r\n})\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/ops/basics.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 748,
    "kind": "function",
    "name": "mainEngine",
    "memberof": "src/ops/basics.spec.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/ops/basics.spec.js~mainEngine",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/ops/basics.spec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 749,
    "kind": "file",
    "name": "src/ops/command.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/**\r\nThis file defines the apply_command function and the Command class.\r\n\r\nWhen a gate is applied to qubits, e.g.,\r\n\r\n @example\r\n\r\nCNOT | (qubit1, qubit2)\r\n\r\na Command object is generated which represents both the gate, qubits and\r\ncontrol qubits. This Command object then gets sent down the compilation\r\npipeline.\r\n\r\n    In detail, the Gate object overloads the operator| (magic method __or__)\r\nto generate a Command object which stores the qubits in a canonical order\r\nusing interchangeable qubit indices defined by the gate to allow the\r\noptimizer to cancel the following two gates\r\n\r\n @example\r\nSwap | (qubit1, qubit2)\r\nSwap | (qubit2, qubit1)\r\n\r\nThe command then gets sent to the MainEngine via the\r\napply wrapper (apply_command).\r\n*/\r\nimport assert from 'assert'\r\nimport {arrayEqual} from '../libs/polyfill'\r\nimport {getInverse} from './_cycle'\r\nimport {BasicQubit, Qureg} from '../types/qubit'\r\nimport {markTuple} from '../libs/util'\r\nimport {NotMergeable} from '../meta/error'\r\n\r\n/**\r\n * @class Command\r\n * @desc\r\nClass used as a container to store commands. If a gate is applied to\r\nqubits, then the gate and qubits are saved in a command object. Qubits\r\nare copied into WeakQubitRefs in order to allow early deallocation (would\r\nbe kept alive otherwise). WeakQubitRef qubits don't send deallocate gate\r\nwhen destructed.\r\n\r\n    Attributes:\r\ngate: The gate to execute\r\nqubits: Tuple of qubit lists (e.g. Quregs). Interchangeable qubits\r\nare stored in a unique order\r\ncontrol_qubits: The Qureg of control qubits in a unique order\r\nengine: The engine (usually: MainEngine)\r\ntags: The list of tag objects associated with this command\r\n(e.g., ComputeTag, UncomputeTag, LoopTag, ...). tag objects need to\r\nsupport ==, != (__eq__ and __ne__) for comparison as used in e.g.\r\n    TagRemover. New tags should always be added to the end of the list.\r\n    This means that if there are e.g. two LoopTags in a command, tag[0]\r\nis from the inner scope while tag[1] is from the other scope as the\r\nother scope receives the command after the inner scope LoopEngine\r\nand hence adds its LoopTag to the end.\r\n    all_qubits: A tuple of control_qubits + qubits\r\n */\r\nexport default class Command {\r\n  /**\r\n   * @constructor\r\n    Note:\r\ncontrol qubits (Command.control_qubits) are stored as a\r\nlist of qubits, and command tags (Command.tags) as a list of tag-\r\nobjects. All functions within this class also work if\r\n    BasicQubits are supplied instead of normal Qubit objects (see BasicQubits).\r\n\r\n@param {BasicEngine} engine engine which created the qubit (mostly the MainEngine)\r\n@param {BasicGate} gate Gate to be executed\r\n@param {Array.<Qureg>} qubits Array of quantum registers (to which the gate is applied)\r\n@param {Qureg|Array.<Qubit>} controls Qubits that condition the command.\r\n@param {any[]} tags Tags associated with the command.\r\n     */\r\n  constructor(engine, gate, qubits, controls = [], tags = []) {\r\n    const qs = qubits.map(qureg => new Qureg(...qureg.map(looper => new BasicQubit(looper.engine, looper.id))))\r\n    this.gate = gate\r\n    this.tags = tags\r\n    this.qubits = qs\r\n    this.controlQubits = controls\r\n    this.engine = engine\r\n  }\r\n\r\n  get qubits() {\r\n    return this._qubits\r\n  }\r\n\r\n  set qubits(nq) {\r\n    this._qubits = this.orderQubits(nq)\r\n  }\r\n\r\n  /**\r\n   * return the copy of current command\r\n   * @return {Command}\r\n   */\r\n  copy() {\r\n    const qubits = this.qubits.map(looper => BasicQubit.copyArray(looper))\r\n    const controlQubits = BasicQubit.copyArray(this.controlQubits)\r\n    return new Command(this.engine, this.gate.copy(), qubits, controlQubits, this.tags.slice(0))\r\n  }\r\n\r\n  /**\r\n    Get the command object corresponding to the inverse of this command.\r\n    Inverts the gate (if possible) and creates a new command object from the result.\r\n\r\n    @throws {NotInvertible} If the gate does not provide an inverse (see BasicGate.getInverse)\r\n     */\r\n  getInverse() {\r\n    return new Command(this.engine, getInverse(this.gate), this.qubits, this.controlQubits, this.tags.slice(0))\r\n  }\r\n\r\n  /**\r\n    Merge this command with another one and return the merged command object.\r\n    @param {Command} other Other command to merge with this one (self)\r\n    @throws NotMergeable if the gates don't supply a get_merged()-function or can't be merged for other reasons.\r\n     */\r\n  getMerged(other) {\r\n    if (arrayEqual(this.tags, other.tags) && arrayEqual(this.allQubits, other.allQubits) && this.engine === other.engine) {\r\n      return new Command(this.engine, this.gate.getMerged(other.gate), this.qubits, this.controlQubits, this.tags.slice(0))\r\n    }\r\n\r\n    throw new NotMergeable('Command not mergeable')\r\n  }\r\n\r\n  /**\r\n    Order the given qubits according to their IDs (for unique comparison of commands).\r\n\r\n    @param {Array.<Qubit>} qubits Array of quantum registers (i.e., tuple of lists of qubits)\r\n    @return {Array.<Qubit>} Ordered tuple of quantum registers\r\n  */\r\n  orderQubits(qubits) {\r\n    const orderedQubits = qubits.slice(0)\r\n    const iqi = this.interchangeableQubitIndices\r\n    iqi.forEach((old_positions) => {\r\n      const new_positions = old_positions.slice(0).sort((a, b) => orderedQubits[a][0].id - orderedQubits[b][0].id)\r\n      const qubits_new_order = []\r\n      new_positions.forEach(l => qubits_new_order.push(orderedQubits[l]))\r\n\r\n      old_positions.forEach((v, i) => {\r\n        orderedQubits[v] = qubits_new_order[i]\r\n      })\r\n    })\r\n\r\n    markTuple(orderedQubits)\r\n    return orderedQubits\r\n  }\r\n\r\n  /**\r\n    Return nested list of qubit indices which are interchangeable.\r\n\r\n    Certain qubits can be interchanged (e.g., the qubit order for a Swap\r\ngate). To ensure that only those are sorted when determining the\r\nordering (see _order_qubits), this.interchangeable_qubit_indices is\r\nused.\r\n    @example\r\nIf we can interchange qubits 0,1 and qubits 3,4,5,\r\n    then this function returns [[0,1],[3,4,5]]\r\n     */\r\n  get interchangeableQubitIndices() {\r\n    return this.gate.interchangeableQubitIndices\r\n  }\r\n\r\n  get controlQubits() {\r\n    return this._controlQubits\r\n  }\r\n\r\n  /**\r\n    Set control_qubits to qubits\r\n  @param {Qureg} nq quantum register\r\n  */\r\n  set controlQubits(nq) {\r\n    this._controlQubits = nq.sort((a, b) => a.id - b.id).map(q => new BasicQubit(q.engine, q.id))\r\n  }\r\n\r\n  /**\r\nAdd (additional) control qubits to this command object.\r\n\r\n    They are sorted to ensure a canonical order. Also Qubit objects\r\nare converted to WeakQubitRef objects to allow garbage collection and\r\nthus early deallocation of qubits.\r\n\r\n    @param {Array.<Qubit>} qubits List of qubits which control this\r\n    gate, i.e., the gate is only executed if all qubits are in state 1.\r\n  */\r\n  addControlQubits(qubits) {\r\n    assert(Array.isArray(qubits))\r\n    this._controlQubits = this._controlQubits.concat(BasicQubit.copyArray(qubits))\r\n    this._controlQubits.sort((a, b) => a.id - b.id)\r\n  }\r\n\r\n  /**\r\n  Apply a command.\r\n\r\n    Extracts the qubits-owning (target) engine from the Command object and sends the Command to it.\r\n   */\r\n  apply() {\r\n    this.engine.receive([this])\r\n  }\r\n\r\n  /**\r\nGet all qubits (gate and control qubits).\r\n\r\nReturns a tuple T where T[0] is a quantum register (a list of\r\nWeakQubitRef objects) containing the control qubits and T[1:] contains\r\nthe quantum registers to which the gate is applied.\r\n  */\r\n  get allQubits() {\r\n    return [this._controlQubits].concat(this.qubits)\r\n  }\r\n\r\n  get controlCount() {\r\n    return this.controlQubits.length\r\n  }\r\n\r\n  get engine() {\r\n    return this._engine\r\n  }\r\n\r\n  /**\r\n    Set / Change engine of all qubits to engine.\r\n    @param {BasicEngine} ng New owner of qubits and owner of this Command object\r\n  */\r\n  set engine(ng) {\r\n    this._engine = ng\r\n    this.qubits.forEach((qureg) => {\r\n      qureg.forEach((qubit) => {\r\n        qubit.engine = ng\r\n      })\r\n    })\r\n    this._controlQubits.forEach(qubit => qubit.engine = ng)\r\n  }\r\n\r\n  equal(other) {\r\n    if (other instanceof Command) {\r\n      try {\r\n        const f1 = this.gate.equal(other.gate)\r\n        const t1 = arrayEqual(this.tags, other.tags)\r\n        const e1 = this.engine === other.engine\r\n        const b = arrayEqual(this.allQubits, other.allQubits)\r\n        return f1 && t1 && e1 && b\r\n      } catch (e) {\r\n        return false\r\n      }\r\n    }\r\n    return false\r\n  }\r\n\r\n  /**\r\n   * @return {string}\r\n   */\r\n  toString() {\r\n    let {qubits} = this\r\n    const ctrlqubits = this.controlQubits\r\n\r\n    if (ctrlqubits.length > 0) {\r\n      qubits = [ctrlqubits].concat(qubits)\r\n    }\r\n    let qs = ''\r\n    if (qubits.length === 1) {\r\n      qs = new Qureg(qubits[0]).toString()\r\n    } else {\r\n      qs = '( '\r\n      qubits.forEach((qreg) => {\r\n        qs += new Qureg(qreg).toString()\r\n        qs += ', '\r\n      })\r\n      qs = `${qs.substring(0, qs.length - 2)} )`\r\n    }\r\n    let cs = ''\r\n    for (let i = 0; i < ctrlqubits.length; ++i) {\r\n      cs += 'C'\r\n    }\r\n    return `${cs}${this.gate.toString()} | ${qs}`\r\n  }\r\n\r\n  /**\r\n   * @return {string}\r\n   */\r\n  inspect() {\r\n    return this.toString()\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/ops/command.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 750,
    "kind": "class",
    "name": "Command",
    "memberof": "src/ops/command.js",
    "static": true,
    "longname": "src/ops/command.js~Command",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/command.js",
    "importStyle": "Command",
    "description": "Class used as a container to store commands. If a gate is applied to\nqubits, then the gate and qubits are saved in a command object. Qubits\nare copied into WeakQubitRefs in order to allow early deallocation (would\nbe kept alive otherwise). WeakQubitRef qubits don't send deallocate gate\nwhen destructed.\n\nAttributes:\ngate: The gate to execute\nqubits: Tuple of qubit lists (e.g. Quregs). Interchangeable qubits\nare stored in a unique order\ncontrol_qubits: The Qureg of control qubits in a unique order\nengine: The engine (usually: MainEngine)\ntags: The list of tag objects associated with this command\n(e.g., ComputeTag, UncomputeTag, LoopTag, ...). tag objects need to\nsupport ==, != (__eq__ and __ne__) for comparison as used in e.g.\nTagRemover. New tags should always be added to the end of the list.\nThis means that if there are e.g. two LoopTags in a command, tag[0]\nis from the inner scope while tag[1] is from the other scope as the\nother scope receives the command after the inner scope LoopEngine\nand hence adds its LoopTag to the end.\nall_qubits: A tuple of control_qubits + qubits",
    "lineNumber": 74,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "Command"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 751,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/ops/command.js~Command",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/command.js~Command#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 89,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": "Note:\ncontrol qubits (Command.control_qubits) are stored as a\nlist of qubits, and command tags (Command.tags) as a list of tag-\nobjects. All functions within this class also work if\nBasicQubits are supplied instead of normal Qubit objects (see BasicQubits)."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "BasicEngine"
        ],
        "spread": false,
        "optional": false,
        "name": "engine",
        "description": "engine which created the qubit (mostly the MainEngine)"
      },
      {
        "nullable": null,
        "types": [
          "BasicGate"
        ],
        "spread": false,
        "optional": false,
        "name": "gate",
        "description": "Gate to be executed"
      },
      {
        "nullable": null,
        "types": [
          "Array.<Qureg>"
        ],
        "spread": false,
        "optional": false,
        "name": "qubits",
        "description": "Array of quantum registers (to which the gate is applied)"
      },
      {
        "nullable": null,
        "types": [
          "Qureg",
          "Array.<Qubit>"
        ],
        "spread": false,
        "optional": false,
        "name": "controls",
        "description": "Qubits that condition the command."
      },
      {
        "nullable": null,
        "types": [
          "any[]"
        ],
        "spread": false,
        "optional": false,
        "name": "tags",
        "description": "Tags associated with the command."
      }
    ]
  },
  {
    "__docId__": 752,
    "kind": "member",
    "name": "gate",
    "memberof": "src/ops/command.js~Command",
    "static": false,
    "longname": "src/ops/command.js~Command#gate",
    "access": "public",
    "description": null,
    "lineNumber": 91,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 753,
    "kind": "member",
    "name": "tags",
    "memberof": "src/ops/command.js~Command",
    "static": false,
    "longname": "src/ops/command.js~Command#tags",
    "access": "public",
    "description": null,
    "lineNumber": 92,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 757,
    "kind": "get",
    "name": "qubits",
    "memberof": "src/ops/command.js~Command",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/command.js~Command#qubits",
    "access": "public",
    "description": null,
    "lineNumber": 98,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 758,
    "kind": "set",
    "name": "qubits",
    "memberof": "src/ops/command.js~Command",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/command.js~Command#qubits",
    "access": "public",
    "description": null,
    "lineNumber": 102,
    "undocument": true
  },
  {
    "__docId__": 759,
    "kind": "member",
    "name": "_qubits",
    "memberof": "src/ops/command.js~Command",
    "static": false,
    "longname": "src/ops/command.js~Command#_qubits",
    "access": "private",
    "description": null,
    "lineNumber": 103,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 760,
    "kind": "method",
    "name": "copy",
    "memberof": "src/ops/command.js~Command",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/command.js~Command#copy",
    "access": "public",
    "description": "return the copy of current command",
    "lineNumber": 110,
    "return": {
      "nullable": null,
      "types": [
        "Command"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 761,
    "kind": "method",
    "name": "getInverse",
    "memberof": "src/ops/command.js~Command",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/command.js~Command#getInverse",
    "access": "public",
    "description": "Get the command object corresponding to the inverse of this command.\nInverts the gate (if possible) and creates a new command object from the result.",
    "lineNumber": 122,
    "throws": [
      {
        "types": [
          "NotInvertible"
        ],
        "description": "If the gate does not provide an inverse (see BasicGate.getInverse)"
      }
    ],
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 762,
    "kind": "method",
    "name": "getMerged",
    "memberof": "src/ops/command.js~Command",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/command.js~Command#getMerged",
    "access": "public",
    "description": "Merge this command with another one and return the merged command object.",
    "lineNumber": 131,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "Other command to merge with this one (self)"
      }
    ],
    "throws": [
      {
        "types": [
          "*"
        ],
        "description": "NotMergeable if the gates don't supply a get_merged()-function or can't be merged for other reasons."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 763,
    "kind": "method",
    "name": "orderQubits",
    "memberof": "src/ops/command.js~Command",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/command.js~Command#orderQubits",
    "access": "public",
    "description": "Order the given qubits according to their IDs (for unique comparison of commands).",
    "lineNumber": 145,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array.<Qubit>"
        ],
        "spread": false,
        "optional": false,
        "name": "qubits",
        "description": "Array of quantum registers (i.e., tuple of lists of qubits)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array.<Qubit>"
      ],
      "spread": false,
      "description": "Ordered tuple of quantum registers"
    }
  },
  {
    "__docId__": 764,
    "kind": "get",
    "name": "interchangeableQubitIndices",
    "memberof": "src/ops/command.js~Command",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/command.js~Command#interchangeableQubitIndices",
    "access": "public",
    "description": "Return nested list of qubit indices which are interchangeable.\n\nCertain qubits can be interchanged (e.g., the qubit order for a Swap\ngate). To ensure that only those are sorted when determining the\nordering (see _order_qubits), this.interchangeable_qubit_indices is\nused.",
    "examples": [
      "If we can interchange qubits 0,1 and qubits 3,4,5,\nthen this function returns [[0,1],[3,4,5]]"
    ],
    "lineNumber": 173,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 765,
    "kind": "get",
    "name": "controlQubits",
    "memberof": "src/ops/command.js~Command",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/command.js~Command#controlQubits",
    "access": "public",
    "description": null,
    "lineNumber": 177,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 766,
    "kind": "set",
    "name": "controlQubits",
    "memberof": "src/ops/command.js~Command",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/command.js~Command#controlQubits",
    "access": "public",
    "description": "Set control_qubits to qubits",
    "lineNumber": 185,
    "params": [
      {
        "nullable": null,
        "types": [
          "Qureg"
        ],
        "spread": false,
        "optional": false,
        "name": "nq",
        "description": "quantum register"
      }
    ]
  },
  {
    "__docId__": 767,
    "kind": "member",
    "name": "_controlQubits",
    "memberof": "src/ops/command.js~Command",
    "static": false,
    "longname": "src/ops/command.js~Command#_controlQubits",
    "access": "private",
    "description": null,
    "lineNumber": 186,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 768,
    "kind": "method",
    "name": "addControlQubits",
    "memberof": "src/ops/command.js~Command",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/command.js~Command#addControlQubits",
    "access": "public",
    "description": "Add (additional) control qubits to this command object.\n\nThey are sorted to ensure a canonical order. Also Qubit objects\nare converted to WeakQubitRef objects to allow garbage collection and\nthus early deallocation of qubits.",
    "lineNumber": 199,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array.<Qubit>"
        ],
        "spread": false,
        "optional": false,
        "name": "qubits",
        "description": "List of qubits which control this\ngate, i.e., the gate is only executed if all qubits are in state 1."
      }
    ],
    "return": null
  },
  {
    "__docId__": 770,
    "kind": "method",
    "name": "apply",
    "memberof": "src/ops/command.js~Command",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/command.js~Command#apply",
    "access": "public",
    "description": "Apply a command.\n\nExtracts the qubits-owning (target) engine from the Command object and sends the Command to it.",
    "lineNumber": 210,
    "params": [],
    "return": null
  },
  {
    "__docId__": 771,
    "kind": "get",
    "name": "allQubits",
    "memberof": "src/ops/command.js~Command",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/command.js~Command#allQubits",
    "access": "public",
    "description": "Get all qubits (gate and control qubits).\n\nReturns a tuple T where T[0] is a quantum register (a list of\nWeakQubitRef objects) containing the control qubits and T[1:] contains\nthe quantum registers to which the gate is applied.",
    "lineNumber": 221,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 772,
    "kind": "get",
    "name": "controlCount",
    "memberof": "src/ops/command.js~Command",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/command.js~Command#controlCount",
    "access": "public",
    "description": null,
    "lineNumber": 225,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 773,
    "kind": "get",
    "name": "engine",
    "memberof": "src/ops/command.js~Command",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/command.js~Command#engine",
    "access": "public",
    "description": null,
    "lineNumber": 229,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 774,
    "kind": "set",
    "name": "engine",
    "memberof": "src/ops/command.js~Command",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/command.js~Command#engine",
    "access": "public",
    "description": "Set / Change engine of all qubits to engine.",
    "lineNumber": 237,
    "params": [
      {
        "nullable": null,
        "types": [
          "BasicEngine"
        ],
        "spread": false,
        "optional": false,
        "name": "ng",
        "description": "New owner of qubits and owner of this Command object"
      }
    ]
  },
  {
    "__docId__": 775,
    "kind": "member",
    "name": "_engine",
    "memberof": "src/ops/command.js~Command",
    "static": false,
    "longname": "src/ops/command.js~Command#_engine",
    "access": "private",
    "description": null,
    "lineNumber": 238,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 776,
    "kind": "method",
    "name": "equal",
    "memberof": "src/ops/command.js~Command",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/command.js~Command#equal",
    "access": "public",
    "description": null,
    "lineNumber": 247,
    "undocument": true,
    "params": [
      {
        "name": "other",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 777,
    "kind": "method",
    "name": "toString",
    "memberof": "src/ops/command.js~Command",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/command.js~Command#toString",
    "access": "public",
    "description": "",
    "lineNumber": 265,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 778,
    "kind": "method",
    "name": "inspect",
    "memberof": "src/ops/command.js~Command",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/command.js~Command#inspect",
    "access": "public",
    "description": "",
    "lineNumber": 293,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 779,
    "kind": "file",
    "name": "src/ops/command.spec.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport {assert, expect} from 'chai'\r\nimport math from 'mathjs'\r\nimport MainEngine from '../cengines/main'\r\nimport {DummyEngine} from '../cengines/testengine'\r\nimport {\r\n  BasicGate, FastForwardingGate, BasicRotationGate, SelfInverseGate, BasicPhaseGate, BasicMathGate\r\n} from './basics';\r\nimport {Qubit, Qureg} from '../types/qubit'\r\nimport Command from './command'\r\nimport {arrayEqual} from '../libs/polyfill'\r\nimport {tuple, ObjectCopy} from '../libs/util';\r\nimport {Rx} from './gates'\r\nimport {ComputeTag} from '../meta/tag'\r\n\r\n\r\nfunction mainEngine() {\r\n  return new MainEngine(new DummyEngine(), [new DummyEngine()])\r\n}\r\n\r\ndescribe('command test', () => {\r\n  it('should command init', () => {\r\n    const main_engine = mainEngine()\r\n    const qureg0 = new Qureg([new Qubit(main_engine, 0)])\r\n    const qureg1 = new Qureg([new Qubit(main_engine, 1)])\r\n    const qureg2 = new Qureg([new Qubit(main_engine, 2)])\r\n    const qureg3 = new Qureg([new Qubit(main_engine, 3)])\r\n    const qureg4 = new Qureg([new Qubit(main_engine, 4)])\r\n    const gate = new BasicGate()\r\n    const cmd = new Command(main_engine, gate, [qureg0, qureg1, qureg2])\r\n    expect(cmd.gate.equal(gate)).to.equal(true)\r\n    expect(cmd.tags).to.deep.equal([])\r\n    const expected_tuple = [qureg0, qureg1, qureg2]\r\n    cmd.qubits.forEach((looper, idx) => {\r\n      expect(looper[0].id).to.equal(expected_tuple[idx][0].id)\r\n    })\r\n\r\n    // Testing that Qubits are now WeakQubitRef objects\r\n    expect(cmd.engine === main_engine).to.equal(true)\r\n    // Test that quregs are ordered if gate has interchangeable qubits:\r\n    const symmetric_gate = new BasicGate()\r\n    symmetric_gate.interchangeableQubitIndices = [[0, 1]]\r\n    const symmetric_cmd = new Command(main_engine, symmetric_gate, [qureg2, qureg1, qureg0])\r\n    expect(symmetric_cmd.gate.equal(symmetric_gate)).to.equal(true)\r\n    expect(symmetric_cmd.tags).to.deep.equal([])\r\n    const expected_ordered_tuple = [qureg1, qureg2, qureg0]\r\n    symmetric_cmd.qubits.forEach((looper, idx) => {\r\n      expect(looper[0].id).to.equal(expected_ordered_tuple[idx][0].id)\r\n    })\r\n    expect(symmetric_cmd.engine === main_engine).to.equal(true)\r\n  });\r\n\r\n  it('should command deepcopy', () => {\r\n    const main_engine = mainEngine()\r\n    const qureg0 = new Qureg([new Qubit(main_engine, 0)])\r\n    const qureg1 = new Qureg([new Qubit(main_engine, 1)])\r\n    const gate = new BasicGate()\r\n    const cmd = new Command(main_engine, gate, tuple(qureg0))\r\n    cmd.addControlQubits(qureg1)\r\n    cmd.tags.push('MyTestTag')\r\n    const copied_cmd = ObjectCopy(cmd)\r\n    // # Test that deepcopy gives same cmd\r\n    expect(copied_cmd.gate.equal(gate)).to.equal(true)\r\n    expect(copied_cmd.tags).to.deep.equal(['MyTestTag'])\r\n    expect(copied_cmd.qubits.length).to.equal(1)\r\n    expect(copied_cmd.qubits[0][0].id).to.equal(qureg0[0].id)\r\n    expect(copied_cmd.controlQubits.length).to.equal(1)\r\n    expect(copied_cmd.controlQubits[0].id).to.equal(qureg1[0].id)\r\n    // # Engine should not be deepcopied but a reference:\r\n    expect(copied_cmd.engine === main_engine).to.equal(true)\r\n    // # Test that deepcopy is actually a deepcopy\r\n    cmd.tags = ['ChangedTag']\r\n    expect(copied_cmd.tags).to.deep.equal(['MyTestTag'])\r\n    cmd.controlQubits[0].id == 10\r\n    expect(copied_cmd.controlQubits[0].id).to.equal(qureg1[0].id)\r\n    cmd.gate = 'ChangedGate'\r\n    expect(copied_cmd.gate.equal(gate)).to.equal(true)\r\n  });\r\n\r\n  it('should test command get inverse', () => {\r\n    const main_engine = mainEngine()\r\n    const qubit = main_engine.allocateQubit()\r\n    const ctrl_qubit = main_engine.allocateQubit()\r\n    const cmd = new Command(main_engine, new Rx(0.5), tuple(qubit))\r\n    cmd.addControlQubits(ctrl_qubit)\r\n    cmd.tags = [new ComputeTag()]\r\n    const inverse_cmd = cmd.getInverse()\r\n    expect(inverse_cmd.gate.equal(new Rx(-0.5 + 4 * math.pi))).to.equal(true)\r\n    expect(cmd.qubits.length).to.equal(inverse_cmd.qubits.length)\r\n    expect(cmd.qubits[0][0].id).to.equal(inverse_cmd.qubits[0][0].id)\r\n    expect(cmd.controlQubits.length).to.equal(inverse_cmd.controlQubits.length)\r\n    expect(cmd.controlQubits[0].id).to.equal(inverse_cmd.controlQubits[0].id)\r\n    expect(cmd.tags).to.deep.equal(inverse_cmd.tags)\r\n    expect(cmd.engine === inverse_cmd.engine).to.equal(true)\r\n  });\r\n\r\n  it('should test command merge', () => {\r\n    const main_engine = mainEngine()\r\n    const qubit = main_engine.allocateQubit()\r\n    const ctrl_qubit = main_engine.allocateQubit()\r\n    const cmd = new Command(main_engine, new Rx(0.5), tuple(qubit))\r\n    cmd.tags = ['TestTag']\r\n    cmd.addControlQubits(ctrl_qubit)\r\n    // # Merge two commands\r\n    const cmd2 = new Command(main_engine, new Rx(0.5), tuple(qubit))\r\n    cmd2.addControlQubits(ctrl_qubit)\r\n    cmd2.tags = ['TestTag']\r\n    const merged_cmd = cmd.getMerged(cmd2)\r\n    const expected_cmd = new Command(main_engine, new Rx(1.0), tuple(qubit))\r\n    expected_cmd.addControlQubits(ctrl_qubit)\r\n    expected_cmd.tags = ['TestTag']\r\n    expect(merged_cmd.equal(expected_cmd)).to.equal(true)\r\n\r\n    // # Don't merge commands as different control qubits\r\n    const cmd3 = new Command(main_engine, new Rx(0.5), tuple(qubit))\r\n    cmd3.tags = ['TestTag']\r\n    expect(() => cmd.getMerged(cmd3)).to.throw()\r\n    // # Don't merge commands as different tags\r\n    const cmd4 = new Command(main_engine, new Rx(0.5), tuple(qubit))\r\n    cmd4.addControlQubits(ctrl_qubit)\r\n    expect(() => cmd.getMerged(cmd4)).to.throw()\r\n  });\r\n\r\n  it('should test command order qubits', () => {\r\n    const main_engine = mainEngine()\r\n    const qubit0 = new Qureg([new Qubit(main_engine, 0)])\r\n    const qubit1 = new Qureg([new Qubit(main_engine, 1)])\r\n    const qubit2 = new Qureg([new Qubit(main_engine, 2)])\r\n    const qubit3 = new Qureg([new Qubit(main_engine, 3)])\r\n    const qubit4 = new Qureg([new Qubit(main_engine, 4)])\r\n    const qubit5 = new Qureg([new Qubit(main_engine, 5)])\r\n    const gate = new BasicGate()\r\n    gate.interchangeableQubitIndices = [[0, 4, 5], [1, 2]]\r\n    const input_tuple = tuple(qubit4, qubit5, qubit3, qubit2, qubit1, qubit0)\r\n    const expected_tuple = tuple(qubit0, qubit3, qubit5, qubit2, qubit1, qubit4)\r\n    const cmd = new Command(main_engine, gate, input_tuple)\r\n    cmd.qubits.forEach((ordered_qubit, idx) => {\r\n      const expected_qubit = expected_tuple[idx]\r\n      expect(ordered_qubit[0].id).to.equal(expected_qubit[0].id)\r\n    })\r\n  });\r\n\r\n  it('should test command interchangeable_qubit_indices', () => {\r\n    const main_engine = mainEngine()\r\n    const gate = new BasicGate()\r\n    gate.interchangeableQubitIndices = [[0, 4, 5], [1, 2]]\r\n    const qubit0 = new Qureg([new Qubit(main_engine, 0)])\r\n    const qubit1 = new Qureg([new Qubit(main_engine, 1)])\r\n    const qubit2 = new Qureg([new Qubit(main_engine, 2)])\r\n    const qubit3 = new Qureg([new Qubit(main_engine, 3)])\r\n    const qubit4 = new Qureg([new Qubit(main_engine, 4)])\r\n    const qubit5 = new Qureg([new Qubit(main_engine, 5)])\r\n    const input_tuple = tuple(qubit4, qubit5, qubit3, qubit2, qubit1, qubit0)\r\n    const cmd = new Command(main_engine, gate, input_tuple)\r\n    expect(cmd.interchangeableQubitIndices).to.deep.equal([[0, 4, 5], [1, 2]])\r\n  });\r\n\r\n  it('should test command add control qubits', () => {\r\n    const main_engine = mainEngine()\r\n    const qubit0 = new Qureg([new Qubit(main_engine, 0)])\r\n    const qubit1 = new Qureg([new Qubit(main_engine, 1)])\r\n    const qubit2 = new Qureg([new Qubit(main_engine, 2)])\r\n    const cmd = new Command(main_engine, new Rx(0.5), tuple(qubit0))\r\n    cmd.addControlQubits(qubit2.concat(qubit1))\r\n    expect(cmd.controlQubits[0].id).to.equal(1)\r\n    expect(cmd.controlQubits[1].id).to.equal(2)\r\n  });\r\n\r\n  it('should test command all qubits', () => {\r\n    const main_engine = mainEngine()\r\n    const qubit0 = new Qureg([new Qubit(main_engine, 0)])\r\n    const qubit1 = new Qureg([new Qubit(main_engine, 1)])\r\n    const cmd = new Command(main_engine, new Rx(0.5), tuple(qubit0))\r\n    cmd.addControlQubits(qubit1)\r\n    const all_qubits = cmd.allQubits\r\n    expect(all_qubits[0][0].id).to.equal(1)\r\n    expect(all_qubits[1][0].id).to.equal(0)\r\n  });\r\n\r\n  it('should test command engine', () => {\r\n    const main_engine = mainEngine()\r\n    const qubit0 = new Qureg([new Qubit('fake_engine', 0)])\r\n    const qubit1 = new Qureg([new Qubit('fake_engine', 1)])\r\n    const cmd = new Command('fake_engine', new Rx(0.5), tuple(qubit0))\r\n    cmd.addControlQubits(qubit1)\r\n    expect(cmd.engine).to.equal('fake_engine')\r\n    cmd.engine = main_engine\r\n    expect(cmd.engine === main_engine).to.equal(true)\r\n    expect(cmd.controlQubits[0].engine === main_engine).to.equal(true)\r\n    expect(cmd.qubits[0][0].engine === main_engine).to.equal(true)\r\n  });\r\n\r\n  it('should test command comparison', () => {\r\n    const main_engine = mainEngine()\r\n    const qubit = new Qureg([new Qubit(main_engine, 0)])\r\n    const ctrl_qubit = new Qureg([new Qubit(main_engine, 1)])\r\n    const cmd1 = new Command(main_engine, new Rx(0.5), tuple(qubit))\r\n    cmd1.tags = ['TestTag']\r\n    cmd1.addControlQubits(ctrl_qubit)\r\n    // Test equality\r\n    const cmd2 = new Command(main_engine, new Rx(0.5), tuple(qubit))\r\n    cmd2.tags = ['TestTag']\r\n    cmd2.addControlQubits(ctrl_qubit)\r\n\r\n    expect(cmd2.equal(cmd1)).to.equal(true)\r\n    // Test not equal because of tags\r\n    const cmd3 = new Command(main_engine, new Rx(0.5), tuple(qubit))\r\n    cmd3.tags = ['TestTag', 'AdditionalTag']\r\n    cmd3.addControlQubits(ctrl_qubit)\r\n    expect(cmd3.equal(cmd1)).to.equal(false)\r\n\r\n    // Test not equal because of control qubit\r\n    const cmd4 = new Command(main_engine, new Rx(0.5), tuple(qubit))\r\n    cmd4.tags = ['TestTag']\r\n    expect(cmd4.equal(cmd1)).to.equal(false)\r\n    // Test not equal because of qubit\r\n    const qubit2 = new Qureg([new Qubit(main_engine, 2)])\r\n    const cmd5 = new Command(main_engine, new Rx(0.5), tuple(qubit2))\r\n    cmd5.tags = ['TestTag']\r\n    cmd5.addControlQubits(ctrl_qubit)\r\n    expect(cmd5.equal(cmd1)).to.equal(false)\r\n    // Test not equal because of engine\r\n    const cmd6 = new Command('FakeEngine', new Rx(0.5), tuple(qubit))\r\n    cmd6.tags = ['TestTag']\r\n    cmd6.addControlQubits(ctrl_qubit)\r\n    expect(cmd6.equal(cmd1)).to.equal(false)\r\n  });\r\n  it('should test command string', () => {\r\n    const main_engine = mainEngine()\r\n    const qubit = new Qureg([new Qubit(main_engine, 0)])\r\n    const ctrl_qubit = new Qureg([new Qubit(main_engine, 1)])\r\n    const cmd = new Command(main_engine, new Rx(0.5), tuple(qubit))\r\n    cmd.tags = ['TestTag']\r\n    cmd.addControlQubits(ctrl_qubit)\r\n    expect(cmd.toString()).to.equal('CRx(0.5) | ( Qureg[1], Qureg[0] )')\r\n    const cmd2 = new Command(main_engine, new Rx(0.5), tuple(qubit))\r\n    expect(cmd2.toString()).to.equal('Rx(0.5) | Qureg[0]')\r\n  });\r\n})\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/ops/command.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 780,
    "kind": "function",
    "name": "mainEngine",
    "memberof": "src/ops/command.spec.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/ops/command.spec.js~mainEngine",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/ops/command.spec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 781,
    "kind": "file",
    "name": "src/ops/gates.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/**\r\nContains definitions of standard gates such as\r\n* Hadamard (H)\r\n* Pauli-X (X / NOT)\r\n* Pauli-Z (Z)\r\n* T and its inverse (T / Tdagger)\r\n* Swap gate (Swap)\r\n* Phase gate (Ph)\r\n* Rotation-Z (Rz)\r\n* Phase-shift (R)\r\n* Measurement (Measure)\r\n\r\nand meta gates, i.e.,\r\n* Allocate / Deallocate qubits\r\n* Flush gate (end of circuit)\r\n*/\r\nimport math from 'mathjs'\r\nimport {\r\n  SelfInverseGate, BasicPhaseGate, BasicRotationGate, BasicMathGate, BasicGate, FastForwardingGate, ClassicalInstructionGate\r\n} from './basics'\r\n\r\nimport {getInverse} from './_cycle'\r\n\r\nconst mc = math.complex\r\nconst mm = math.matrix\r\n\r\n/**\r\n * @class HGate\r\n */\r\nexport class HGate extends SelfInverseGate {\r\n  toString() {\r\n    return 'H'\r\n  }\r\n\r\n  get matrix() {\r\n    return mm([\r\n      [mc(Math.SQRT1_2, 0), mc(Math.SQRT1_2, 0)],\r\n      [mc(Math.SQRT1_2, 0), mc(-Math.SQRT1_2, 0)]\r\n    ])\r\n  }\r\n}\r\n\r\nexport const H = new HGate()\r\n\r\n/**\r\n * @class XGate\r\n */\r\n// Pauli-X gate class\r\nexport class XGate extends SelfInverseGate {\r\n  toString() {\r\n    return 'X'\r\n  }\r\n\r\n  get matrix() {\r\n    return mm([\r\n      [0, 1],\r\n      [1, 0]\r\n    ])\r\n  }\r\n}\r\n\r\n\r\n// Shortcut (instance of) `XGate`\r\nexport const X = new XGate()\r\nexport const NOT = X\r\n\r\n/**\r\n * @class YGate\r\n */\r\n// Pauli-Y gate class\r\nexport class YGate extends SelfInverseGate {\r\n  toString() {\r\n    return 'Y'\r\n  }\r\n\r\n  get matrix() {\r\n    return mm([\r\n      [0, mc(0, -1)],\r\n      [mc(0, 1), 0],\r\n    ])\r\n  }\r\n}\r\n\r\n// Shortcut (instance of) `YGate`\r\nexport const Y = new YGate()\r\n\r\n/**\r\n * @class ZGate\r\n * Pauli-Z gate class\r\n */\r\nexport class ZGate extends SelfInverseGate {\r\n  toString() {\r\n    return 'Z'\r\n  }\r\n\r\n  get matrix() {\r\n    return mm([\r\n      [1, 0],\r\n      [0, -1]\r\n    ])\r\n  }\r\n}\r\n\r\n// Shortcut (instance of) `ZGate`\r\nexport const Z = new ZGate()\r\n\r\n/**\r\n * @class SGate\r\n */\r\n// S gate class\r\nexport class SGate extends SelfInverseGate {\r\n  toString() {\r\n    return 'S'\r\n  }\r\n\r\n  get matrix() {\r\n    return mm([\r\n      [1, 0],\r\n      [0, mc(0, 1)]\r\n    ])\r\n  }\r\n}\r\n\r\n// Shortcut (instance of) `SGate`\r\nexport const S = new SGate()\r\n\r\n/**\r\n * @class TGate\r\n */\r\n// T gate class\r\nexport class TGate extends BasicGate {\r\n  get matrix() {\r\n    return mm([\r\n      [1, 0],\r\n      [0, mc(Math.SQRT1_2, Math.SQRT1_2)]\r\n    ])\r\n  }\r\n\r\n  toString() {\r\n    return 'T'\r\n  }\r\n}\r\n\r\n// Shortcut (instance of) `TGate`\r\nexport const T = new TGate()\r\n\r\n/**\r\n * @class SqrtXGate\r\n */\r\n// Square-root X gate class\r\nexport class SqrtXGate extends BasicGate {\r\n  get matrix() {\r\n    return mm([\r\n      [mc(0.5, 0.5), mc(0.5, -0.5)],\r\n      [mc(0.5, -0.5), mc(0.5, 0.5)]\r\n    ])\r\n  }\r\n\r\n  toString() {\r\n    return 'SqrtX'\r\n  }\r\n\r\n  texString() {\r\n    return '$\\\\sqrt{X}$'\r\n  }\r\n}\r\n\r\n// Shortcut (instance of) `SqrtXGate`\r\nexport const SqrtX = new SqrtXGate()\r\n\r\n/**\r\n * @class SwapGate\r\n * @desc Swap gate class (swaps 2 qubits) also self inverse gate\r\n */\r\nexport class SwapGate extends BasicMathGate {\r\n  constructor() {\r\n    super((x, y) => [y, x])\r\n    this.interchangeableQubitIndices = [[0, 1]]\r\n  }\r\n\r\n  toString() {\r\n    return 'Swap'\r\n  }\r\n\r\n  get matrix() {\r\n    return mm([\r\n      [1, 0, 0, 0],\r\n      [0, 0, 1, 0],\r\n      [0, 1, 0, 0],\r\n      [0, 0, 0, 1]\r\n    ])\r\n  }\r\n\r\n  getInverse() {\r\n    const inv = new SwapGate()\r\n    inv.interchangeableQubitIndices = this.interchangeableQubitIndices.slice(0)\r\n    return inv\r\n  }\r\n}\r\n\r\n// Shortcut (instance of) `SwapGate`\r\nexport const Swap = new SwapGate()\r\n\r\n/**\r\n * @class SqrtSwapGate\r\n * @desc Square-root Swap gate class\r\n */\r\nexport class SqrtSwapGate extends BasicGate {\r\n  constructor() {\r\n    super()\r\n    this.interchangeableQubitIndices = [[0, 1]]\r\n  }\r\n\r\n  toString() {\r\n    return 'SqrtSwap'\r\n  }\r\n\r\n  get matrix() {\r\n    return mm([\r\n      [1, 0, 0, 0],\r\n      [0, mc(0.5, 0.5), mc(0.5, -0.5), 0],\r\n      [0, mc(0.5, -0.5), mc(0.5, 0.5), 0],\r\n      [0, 0, 0, 1]\r\n    ])\r\n  }\r\n}\r\n\r\n// Shortcut (instance of) `SqrtSwapGate`\r\nexport const SqrtSwap = new SqrtSwapGate()\r\n\r\n/**\r\n * @class EntangleGate\r\n * @desc gate (Hadamard on first qubit, followed by CNOTs applied to all other qubits).\r\n*/\r\nexport class EntangleGate extends BasicGate {\r\n  toString() {\r\n    return 'Entangle'\r\n  }\r\n\r\n  get matrix() {\r\n    throw new Error('No Attribute')\r\n  }\r\n}\r\n\r\n\r\n// Shortcut (instance of) `EntangleGate`\r\nexport const Entangle = new EntangleGate()\r\n\r\n/**\r\n * @class Ph\r\n * @desc Phase gate (global phase)\r\n */\r\nexport class Ph extends BasicPhaseGate {\r\n  get matrix() {\r\n    return mm([\r\n      [mc(Math.cos(this.angle), Math.sin(this.angle)), 0],\r\n      [0, mc(Math.cos(this.angle), Math.sin(this.angle))]\r\n    ])\r\n  }\r\n}\r\n\r\n/**\r\n * @class Rx\r\n */\r\nexport class Rx extends BasicRotationGate {\r\n  get matrix() {\r\n    return mm([\r\n      [Math.cos(0.5 * this.angle), mc(0, -1 * Math.sin(0.5 * this.angle))],\r\n      [mc(0, -1 * Math.sin(0.5 * this.angle)), Math.cos(0.5 * this.angle)]\r\n    ])\r\n  }\r\n}\r\n\r\n/**\r\n * @class Ry\r\n */\r\nexport class Ry extends BasicRotationGate {\r\n  get matrix() {\r\n    return mm([\r\n      [Math.cos(0.5 * this.angle), -Math.sin(0.5 * this.angle)],\r\n      [Math.sin(0.5 * this.angle), Math.cos(0.5 * this.angle)]\r\n    ])\r\n  }\r\n}\r\n\r\n/**\r\n * @class Rz\r\n * @desc RotationZ gate class\r\n */\r\nexport class Rz extends BasicRotationGate {\r\n  get matrix() {\r\n    return mm([\r\n      [mc(Math.cos(-0.5 * this.angle), Math.sin(-0.5 * this.angle)), 0],\r\n      [0, mc(Math.cos(0.5 * this.angle), Math.sin(0.5 * this.angle))]\r\n    ])\r\n  }\r\n}\r\n\r\n/**\r\n * @class R\r\n * @desc Phase-shift gate (equivalent to Rz up to a global phase)\r\n */\r\nexport class R extends BasicPhaseGate {\r\n  get matrix() {\r\n    return mm([[1, 0], [0, mc(Math.cos(this.angle), Math.sin(this.angle))]])\r\n  }\r\n}\r\n\r\n/**\r\n * @class FlushGate\r\n * @desc\r\nFlush gate (denotes the end of the circuit).\r\n\r\nNote:\r\n    All compiler engines (cengines) which cache/buffer gates are obligated\r\nto flush and send all gates to the next compiler engine (followed by\r\nthe flush command).\r\n\r\nNote:\r\n    This gate is sent when calling\r\n\r\n @example\r\n\r\neng.flush()\r\n\r\non the MainEngine `eng`.\r\n\r\n */\r\nexport class FlushGate extends FastForwardingGate {\r\n  toString() {\r\n    return ''\r\n  }\r\n}\r\n\r\n/**\r\n * @class MeasureGate\r\n * @desc Measurement gate class (for single qubits).\r\n */\r\nexport class MeasureGate extends FastForwardingGate {\r\n  toString() {\r\n    return 'Measure'\r\n  }\r\n\r\n  /**\r\n    Previously (ProjectQ <= v0.3.6) MeasureGate/Measure was allowed to be\r\n    applied to any number of quantum registers. Now the MeasureGate/Measure\r\n    is strictly a single qubit gate. In the coming releases the backward\r\n    compatibility will be removed!\r\n\r\n     */\r\n  or(qubits) {\r\n    let num_qubits = 0\r\n    const qs = BasicGate.makeTupleOfQureg(qubits)\r\n    qs.forEach((qureg) => {\r\n      qureg.forEach((qubit) => {\r\n        num_qubits += 1\r\n        const cmd = this.generateCommand([qubit])\r\n        cmd.apply()\r\n      })\r\n    })\r\n    if (num_qubits > 1) {\r\n      console.warn('Pending syntax change in future versions of '\r\n      + 'ProjectQ: \\n Measure will be a single qubit gate '\r\n      + 'only. Use `All(Measure) | qureg` instead to '\r\n        + 'measure multiple qubits.')\r\n    }\r\n  }\r\n}\r\n\r\n\r\n// Shortcut (instance of) `MeasureGate`\r\nexport const Measure = new MeasureGate()\r\n\r\nexport let Deallocate\r\n\r\n/**\r\n * @class AllocateQubitGate\r\n */\r\nexport class AllocateQubitGate extends ClassicalInstructionGate {\r\n  toString() {\r\n    return 'Allocate'\r\n  }\r\n\r\n  getInverse() {\r\n    return Deallocate\r\n  }\r\n}\r\n\r\n// Shortcut (instance of) `AllocateQubitGate`\r\nexport const Allocate = new AllocateQubitGate()\r\n\r\n/**\r\n * @class DeallocateQubitGate\r\n */\r\nexport class DeallocateQubitGate extends FastForwardingGate {\r\n  toString() {\r\n    return 'Deallocate'\r\n  }\r\n\r\n  getInverse() {\r\n    return Allocate\r\n  }\r\n}\r\n\r\n// Shortcut (instance of) `DeallocateQubitGate`\r\nDeallocate = new DeallocateQubitGate()\r\n\r\n/**\r\n * @class AllocateDirtyQubitGate\r\n */\r\nexport class AllocateDirtyQubitGate extends ClassicalInstructionGate {\r\n  toString() {\r\n    return 'AllocateDirty'\r\n  }\r\n\r\n  getInverse() {\r\n    return Deallocate\r\n  }\r\n}\r\n\r\n// Shortcut (instance of) AllocateDirtyQubitGate\r\nexport const AllocateDirty = new AllocateDirtyQubitGate()\r\n\r\nexport let Barrier\r\n\r\nexport class BarrierGate extends BasicGate {\r\n  toString() {\r\n    return 'Barrier'\r\n  }\r\n\r\n  getInverse() {\r\n    return Barrier\r\n  }\r\n}\r\n\r\n// Shortcut (instance of) BarrierGate\r\nBarrier = new BarrierGate()\r\n\r\nconst obj = {}\r\nlet _sdag = null\r\nlet _tdag = null\r\nObject.defineProperties(obj, {\r\n  Sdag: {\r\n    get() {\r\n      if (!_sdag) {\r\n        _sdag = getInverse(S)\r\n      }\r\n      return _sdag\r\n    }\r\n  },\r\n  Sdagger: {\r\n    get() {\r\n      return obj.Sdag\r\n    }\r\n  },\r\n  Tdag: {\r\n    get() {\r\n      if (!_tdag) {\r\n        _tdag = getInverse(T)\r\n      }\r\n      return _tdag\r\n    }\r\n  },\r\n  Tdagger: {\r\n    get() {\r\n      return obj.Tdag\r\n    }\r\n  }\r\n})\r\n\r\nexport default obj\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/ops/gates.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 782,
    "kind": "variable",
    "name": "mc",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~mc",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 40,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 783,
    "kind": "variable",
    "name": "mm",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~mm",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 41,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 784,
    "kind": "class",
    "name": "HGate",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~HGate",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{HGate}",
    "description": "",
    "lineNumber": 46,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "HGate"
      }
    ],
    "interface": false,
    "extends": [
      "src/ops/basics.js~SelfInverseGate"
    ]
  },
  {
    "__docId__": 785,
    "kind": "method",
    "name": "toString",
    "memberof": "src/ops/gates.js~HGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~HGate#toString",
    "access": "public",
    "description": null,
    "lineNumber": 47,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 786,
    "kind": "get",
    "name": "matrix",
    "memberof": "src/ops/gates.js~HGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~HGate#matrix",
    "access": "public",
    "description": null,
    "lineNumber": 51,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 787,
    "kind": "variable",
    "name": "H",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~H",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{H}",
    "description": null,
    "lineNumber": 59,
    "undocument": true,
    "type": {
      "types": [
        "src/ops/gates.js~HGate"
      ]
    }
  },
  {
    "__docId__": 788,
    "kind": "class",
    "name": "XGate",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~XGate",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{XGate}",
    "description": "",
    "lineNumber": 65,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "XGate"
      }
    ],
    "interface": false,
    "extends": [
      "src/ops/basics.js~SelfInverseGate"
    ]
  },
  {
    "__docId__": 789,
    "kind": "method",
    "name": "toString",
    "memberof": "src/ops/gates.js~XGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~XGate#toString",
    "access": "public",
    "description": null,
    "lineNumber": 66,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 790,
    "kind": "get",
    "name": "matrix",
    "memberof": "src/ops/gates.js~XGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~XGate#matrix",
    "access": "public",
    "description": null,
    "lineNumber": 70,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 791,
    "kind": "variable",
    "name": "X",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~X",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{X}",
    "description": null,
    "lineNumber": 80,
    "undocument": true,
    "type": {
      "types": [
        "src/ops/gates.js~XGate"
      ]
    }
  },
  {
    "__docId__": 792,
    "kind": "variable",
    "name": "NOT",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~NOT",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{NOT}",
    "description": null,
    "lineNumber": 81,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 793,
    "kind": "class",
    "name": "YGate",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~YGate",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{YGate}",
    "description": "",
    "lineNumber": 87,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "YGate"
      }
    ],
    "interface": false,
    "extends": [
      "src/ops/basics.js~SelfInverseGate"
    ]
  },
  {
    "__docId__": 794,
    "kind": "method",
    "name": "toString",
    "memberof": "src/ops/gates.js~YGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~YGate#toString",
    "access": "public",
    "description": null,
    "lineNumber": 88,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 795,
    "kind": "get",
    "name": "matrix",
    "memberof": "src/ops/gates.js~YGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~YGate#matrix",
    "access": "public",
    "description": null,
    "lineNumber": 92,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 796,
    "kind": "variable",
    "name": "Y",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~Y",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{Y}",
    "description": null,
    "lineNumber": 101,
    "undocument": true,
    "type": {
      "types": [
        "src/ops/gates.js~YGate"
      ]
    }
  },
  {
    "__docId__": 797,
    "kind": "class",
    "name": "ZGate",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~ZGate",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{ZGate}",
    "description": "",
    "lineNumber": 107,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "ZGate\nPauli-Z gate class"
      }
    ],
    "interface": false,
    "extends": [
      "src/ops/basics.js~SelfInverseGate"
    ]
  },
  {
    "__docId__": 798,
    "kind": "method",
    "name": "toString",
    "memberof": "src/ops/gates.js~ZGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~ZGate#toString",
    "access": "public",
    "description": null,
    "lineNumber": 108,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 799,
    "kind": "get",
    "name": "matrix",
    "memberof": "src/ops/gates.js~ZGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~ZGate#matrix",
    "access": "public",
    "description": null,
    "lineNumber": 112,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 800,
    "kind": "variable",
    "name": "Z",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~Z",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{Z}",
    "description": null,
    "lineNumber": 121,
    "undocument": true,
    "type": {
      "types": [
        "src/ops/gates.js~ZGate"
      ]
    }
  },
  {
    "__docId__": 801,
    "kind": "class",
    "name": "SGate",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~SGate",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{SGate}",
    "description": "",
    "lineNumber": 127,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "SGate"
      }
    ],
    "interface": false,
    "extends": [
      "src/ops/basics.js~SelfInverseGate"
    ]
  },
  {
    "__docId__": 802,
    "kind": "method",
    "name": "toString",
    "memberof": "src/ops/gates.js~SGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~SGate#toString",
    "access": "public",
    "description": null,
    "lineNumber": 128,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 803,
    "kind": "get",
    "name": "matrix",
    "memberof": "src/ops/gates.js~SGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~SGate#matrix",
    "access": "public",
    "description": null,
    "lineNumber": 132,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 804,
    "kind": "variable",
    "name": "S",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~S",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{S}",
    "description": null,
    "lineNumber": 141,
    "undocument": true,
    "type": {
      "types": [
        "src/ops/gates.js~SGate"
      ]
    }
  },
  {
    "__docId__": 805,
    "kind": "class",
    "name": "TGate",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~TGate",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{TGate}",
    "description": "",
    "lineNumber": 147,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "TGate"
      }
    ],
    "interface": false,
    "extends": [
      "src/ops/basics.js~BasicGate"
    ]
  },
  {
    "__docId__": 806,
    "kind": "get",
    "name": "matrix",
    "memberof": "src/ops/gates.js~TGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~TGate#matrix",
    "access": "public",
    "description": null,
    "lineNumber": 148,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 807,
    "kind": "method",
    "name": "toString",
    "memberof": "src/ops/gates.js~TGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~TGate#toString",
    "access": "public",
    "description": null,
    "lineNumber": 155,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 808,
    "kind": "variable",
    "name": "T",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~T",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{T}",
    "description": null,
    "lineNumber": 161,
    "undocument": true,
    "type": {
      "types": [
        "src/ops/gates.js~TGate"
      ]
    }
  },
  {
    "__docId__": 809,
    "kind": "class",
    "name": "SqrtXGate",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~SqrtXGate",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{SqrtXGate}",
    "description": "",
    "lineNumber": 167,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "SqrtXGate"
      }
    ],
    "interface": false,
    "extends": [
      "src/ops/basics.js~BasicGate"
    ]
  },
  {
    "__docId__": 810,
    "kind": "get",
    "name": "matrix",
    "memberof": "src/ops/gates.js~SqrtXGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~SqrtXGate#matrix",
    "access": "public",
    "description": null,
    "lineNumber": 168,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 811,
    "kind": "method",
    "name": "toString",
    "memberof": "src/ops/gates.js~SqrtXGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~SqrtXGate#toString",
    "access": "public",
    "description": null,
    "lineNumber": 175,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 812,
    "kind": "method",
    "name": "texString",
    "memberof": "src/ops/gates.js~SqrtXGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~SqrtXGate#texString",
    "access": "public",
    "description": null,
    "lineNumber": 179,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 813,
    "kind": "variable",
    "name": "SqrtX",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~SqrtX",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{SqrtX}",
    "description": null,
    "lineNumber": 185,
    "undocument": true,
    "type": {
      "types": [
        "src/ops/gates.js~SqrtXGate"
      ]
    }
  },
  {
    "__docId__": 814,
    "kind": "class",
    "name": "SwapGate",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~SwapGate",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{SwapGate}",
    "description": "Swap gate class (swaps 2 qubits) also self inverse gate",
    "lineNumber": 191,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "SwapGate"
      }
    ],
    "interface": false,
    "extends": [
      "src/ops/basics.js~BasicMathGate"
    ]
  },
  {
    "__docId__": 815,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/ops/gates.js~SwapGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~SwapGate#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 192,
    "undocument": true
  },
  {
    "__docId__": 816,
    "kind": "member",
    "name": "interchangeableQubitIndices",
    "memberof": "src/ops/gates.js~SwapGate",
    "static": false,
    "longname": "src/ops/gates.js~SwapGate#interchangeableQubitIndices",
    "access": "public",
    "description": null,
    "lineNumber": 194,
    "undocument": true,
    "type": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 817,
    "kind": "method",
    "name": "toString",
    "memberof": "src/ops/gates.js~SwapGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~SwapGate#toString",
    "access": "public",
    "description": null,
    "lineNumber": 197,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 818,
    "kind": "get",
    "name": "matrix",
    "memberof": "src/ops/gates.js~SwapGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~SwapGate#matrix",
    "access": "public",
    "description": null,
    "lineNumber": 201,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 819,
    "kind": "method",
    "name": "getInverse",
    "memberof": "src/ops/gates.js~SwapGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~SwapGate#getInverse",
    "access": "public",
    "description": null,
    "lineNumber": 210,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 820,
    "kind": "variable",
    "name": "Swap",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~Swap",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{Swap}",
    "description": null,
    "lineNumber": 218,
    "undocument": true,
    "type": {
      "types": [
        "src/ops/gates.js~SwapGate"
      ]
    }
  },
  {
    "__docId__": 821,
    "kind": "class",
    "name": "SqrtSwapGate",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~SqrtSwapGate",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{SqrtSwapGate}",
    "description": "Square-root Swap gate class",
    "lineNumber": 224,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "SqrtSwapGate"
      }
    ],
    "interface": false,
    "extends": [
      "src/ops/basics.js~BasicGate"
    ]
  },
  {
    "__docId__": 822,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/ops/gates.js~SqrtSwapGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~SqrtSwapGate#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 225,
    "undocument": true
  },
  {
    "__docId__": 823,
    "kind": "member",
    "name": "interchangeableQubitIndices",
    "memberof": "src/ops/gates.js~SqrtSwapGate",
    "static": false,
    "longname": "src/ops/gates.js~SqrtSwapGate#interchangeableQubitIndices",
    "access": "public",
    "description": null,
    "lineNumber": 227,
    "undocument": true,
    "type": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 824,
    "kind": "method",
    "name": "toString",
    "memberof": "src/ops/gates.js~SqrtSwapGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~SqrtSwapGate#toString",
    "access": "public",
    "description": null,
    "lineNumber": 230,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 825,
    "kind": "get",
    "name": "matrix",
    "memberof": "src/ops/gates.js~SqrtSwapGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~SqrtSwapGate#matrix",
    "access": "public",
    "description": null,
    "lineNumber": 234,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 826,
    "kind": "variable",
    "name": "SqrtSwap",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~SqrtSwap",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{SqrtSwap}",
    "description": null,
    "lineNumber": 245,
    "undocument": true,
    "type": {
      "types": [
        "src/ops/gates.js~SqrtSwapGate"
      ]
    }
  },
  {
    "__docId__": 827,
    "kind": "class",
    "name": "EntangleGate",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~EntangleGate",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{EntangleGate}",
    "description": "gate (Hadamard on first qubit, followed by CNOTs applied to all other qubits).",
    "lineNumber": 251,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "EntangleGate"
      }
    ],
    "interface": false,
    "extends": [
      "src/ops/basics.js~BasicGate"
    ]
  },
  {
    "__docId__": 828,
    "kind": "method",
    "name": "toString",
    "memberof": "src/ops/gates.js~EntangleGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~EntangleGate#toString",
    "access": "public",
    "description": null,
    "lineNumber": 252,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 829,
    "kind": "get",
    "name": "matrix",
    "memberof": "src/ops/gates.js~EntangleGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~EntangleGate#matrix",
    "access": "public",
    "description": null,
    "lineNumber": 256,
    "undocument": true,
    "type": null
  },
  {
    "__docId__": 830,
    "kind": "variable",
    "name": "Entangle",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~Entangle",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{Entangle}",
    "description": null,
    "lineNumber": 263,
    "undocument": true,
    "type": {
      "types": [
        "src/ops/gates.js~EntangleGate"
      ]
    }
  },
  {
    "__docId__": 831,
    "kind": "class",
    "name": "Ph",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~Ph",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{Ph}",
    "description": "Phase gate (global phase)",
    "lineNumber": 269,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "Ph"
      }
    ],
    "interface": false,
    "extends": [
      "src/ops/basics.js~BasicPhaseGate"
    ]
  },
  {
    "__docId__": 832,
    "kind": "get",
    "name": "matrix",
    "memberof": "src/ops/gates.js~Ph",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~Ph#matrix",
    "access": "public",
    "description": null,
    "lineNumber": 270,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 833,
    "kind": "class",
    "name": "Rx",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~Rx",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{Rx}",
    "description": "",
    "lineNumber": 281,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "Rx"
      }
    ],
    "interface": false,
    "extends": [
      "src/ops/basics.js~BasicRotationGate"
    ]
  },
  {
    "__docId__": 834,
    "kind": "get",
    "name": "matrix",
    "memberof": "src/ops/gates.js~Rx",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~Rx#matrix",
    "access": "public",
    "description": null,
    "lineNumber": 282,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 835,
    "kind": "class",
    "name": "Ry",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~Ry",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{Ry}",
    "description": "",
    "lineNumber": 293,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "Ry"
      }
    ],
    "interface": false,
    "extends": [
      "src/ops/basics.js~BasicRotationGate"
    ]
  },
  {
    "__docId__": 836,
    "kind": "get",
    "name": "matrix",
    "memberof": "src/ops/gates.js~Ry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~Ry#matrix",
    "access": "public",
    "description": null,
    "lineNumber": 294,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 837,
    "kind": "class",
    "name": "Rz",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~Rz",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{Rz}",
    "description": "RotationZ gate class",
    "lineNumber": 306,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "Rz"
      }
    ],
    "interface": false,
    "extends": [
      "src/ops/basics.js~BasicRotationGate"
    ]
  },
  {
    "__docId__": 838,
    "kind": "get",
    "name": "matrix",
    "memberof": "src/ops/gates.js~Rz",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~Rz#matrix",
    "access": "public",
    "description": null,
    "lineNumber": 307,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 839,
    "kind": "class",
    "name": "R",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~R",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{R}",
    "description": "Phase-shift gate (equivalent to Rz up to a global phase)",
    "lineNumber": 319,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "R"
      }
    ],
    "interface": false,
    "extends": [
      "src/ops/basics.js~BasicPhaseGate"
    ]
  },
  {
    "__docId__": 840,
    "kind": "get",
    "name": "matrix",
    "memberof": "src/ops/gates.js~R",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~R#matrix",
    "access": "public",
    "description": null,
    "lineNumber": 320,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 841,
    "kind": "class",
    "name": "FlushGate",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~FlushGate",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{FlushGate}",
    "description": "Flush gate (denotes the end of the circuit).\n\nNote:\nAll compiler engines (cengines) which cache/buffer gates are obligated\nto flush and send all gates to the next compiler engine (followed by\nthe flush command).\n\nNote:\nThis gate is sent when calling",
    "examples": [
      "\neng.flush()\n\non the MainEngine `eng`."
    ],
    "lineNumber": 345,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "FlushGate"
      }
    ],
    "interface": false,
    "extends": [
      "src/ops/basics.js~FastForwardingGate"
    ]
  },
  {
    "__docId__": 842,
    "kind": "method",
    "name": "toString",
    "memberof": "src/ops/gates.js~FlushGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~FlushGate#toString",
    "access": "public",
    "description": null,
    "lineNumber": 346,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 843,
    "kind": "class",
    "name": "MeasureGate",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~MeasureGate",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{MeasureGate}",
    "description": "Measurement gate class (for single qubits).",
    "lineNumber": 355,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "MeasureGate"
      }
    ],
    "interface": false,
    "extends": [
      "src/ops/basics.js~FastForwardingGate"
    ]
  },
  {
    "__docId__": 844,
    "kind": "method",
    "name": "toString",
    "memberof": "src/ops/gates.js~MeasureGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~MeasureGate#toString",
    "access": "public",
    "description": null,
    "lineNumber": 356,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 845,
    "kind": "method",
    "name": "or",
    "memberof": "src/ops/gates.js~MeasureGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~MeasureGate#or",
    "access": "public",
    "description": "Previously (ProjectQ <= v0.3.6) MeasureGate/Measure was allowed to be\napplied to any number of quantum registers. Now the MeasureGate/Measure\nis strictly a single qubit gate. In the coming releases the backward\ncompatibility will be removed!",
    "lineNumber": 367,
    "params": [
      {
        "name": "qubits",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 846,
    "kind": "variable",
    "name": "Measure",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~Measure",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{Measure}",
    "description": null,
    "lineNumber": 388,
    "undocument": true,
    "type": {
      "types": [
        "src/ops/gates.js~MeasureGate"
      ]
    }
  },
  {
    "__docId__": 847,
    "kind": "class",
    "name": "AllocateQubitGate",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~AllocateQubitGate",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{AllocateQubitGate}",
    "description": "",
    "lineNumber": 395,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "AllocateQubitGate"
      }
    ],
    "interface": false,
    "extends": [
      "src/ops/basics.js~ClassicalInstructionGate"
    ]
  },
  {
    "__docId__": 848,
    "kind": "method",
    "name": "toString",
    "memberof": "src/ops/gates.js~AllocateQubitGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~AllocateQubitGate#toString",
    "access": "public",
    "description": null,
    "lineNumber": 396,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 849,
    "kind": "method",
    "name": "getInverse",
    "memberof": "src/ops/gates.js~AllocateQubitGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~AllocateQubitGate#getInverse",
    "access": "public",
    "description": null,
    "lineNumber": 400,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 850,
    "kind": "variable",
    "name": "Allocate",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~Allocate",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{Allocate}",
    "description": null,
    "lineNumber": 406,
    "undocument": true,
    "type": {
      "types": [
        "src/ops/gates.js~AllocateQubitGate"
      ]
    }
  },
  {
    "__docId__": 851,
    "kind": "class",
    "name": "DeallocateQubitGate",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~DeallocateQubitGate",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{DeallocateQubitGate}",
    "description": "",
    "lineNumber": 411,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "DeallocateQubitGate"
      }
    ],
    "interface": false,
    "extends": [
      "src/ops/basics.js~FastForwardingGate"
    ]
  },
  {
    "__docId__": 852,
    "kind": "method",
    "name": "toString",
    "memberof": "src/ops/gates.js~DeallocateQubitGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~DeallocateQubitGate#toString",
    "access": "public",
    "description": null,
    "lineNumber": 412,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 853,
    "kind": "method",
    "name": "getInverse",
    "memberof": "src/ops/gates.js~DeallocateQubitGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~DeallocateQubitGate#getInverse",
    "access": "public",
    "description": null,
    "lineNumber": 416,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 854,
    "kind": "class",
    "name": "AllocateDirtyQubitGate",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~AllocateDirtyQubitGate",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{AllocateDirtyQubitGate}",
    "description": "",
    "lineNumber": 427,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "AllocateDirtyQubitGate"
      }
    ],
    "interface": false,
    "extends": [
      "src/ops/basics.js~ClassicalInstructionGate"
    ]
  },
  {
    "__docId__": 855,
    "kind": "method",
    "name": "toString",
    "memberof": "src/ops/gates.js~AllocateDirtyQubitGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~AllocateDirtyQubitGate#toString",
    "access": "public",
    "description": null,
    "lineNumber": 428,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 856,
    "kind": "method",
    "name": "getInverse",
    "memberof": "src/ops/gates.js~AllocateDirtyQubitGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~AllocateDirtyQubitGate#getInverse",
    "access": "public",
    "description": null,
    "lineNumber": 432,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 857,
    "kind": "variable",
    "name": "AllocateDirty",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~AllocateDirty",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{AllocateDirty}",
    "description": null,
    "lineNumber": 438,
    "undocument": true,
    "type": {
      "types": [
        "src/ops/gates.js~AllocateDirtyQubitGate"
      ]
    }
  },
  {
    "__docId__": 858,
    "kind": "class",
    "name": "BarrierGate",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~BarrierGate",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "{BarrierGate}",
    "description": null,
    "lineNumber": 442,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/ops/basics.js~BasicGate"
    ]
  },
  {
    "__docId__": 859,
    "kind": "method",
    "name": "toString",
    "memberof": "src/ops/gates.js~BarrierGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~BarrierGate#toString",
    "access": "public",
    "description": null,
    "lineNumber": 443,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 860,
    "kind": "method",
    "name": "getInverse",
    "memberof": "src/ops/gates.js~BarrierGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/gates.js~BarrierGate#getInverse",
    "access": "public",
    "description": null,
    "lineNumber": 447,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 861,
    "kind": "variable",
    "name": "_sdag",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~_sdag",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 456,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 862,
    "kind": "variable",
    "name": "_tdag",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~_tdag",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 457,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 863,
    "kind": "variable",
    "name": "obj",
    "memberof": "src/ops/gates.js",
    "static": true,
    "longname": "src/ops/gates.js~obj",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/gates.js",
    "importStyle": "obj",
    "description": null,
    "lineNumber": 455,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 864,
    "kind": "file",
    "name": "src/ops/gates.spec.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport {expect} from 'chai'\r\nimport math from 'mathjs'\r\nimport Gates, {\r\n  HGate,\r\n  H,\r\n  XGate,\r\n  X,\r\n  YGate,\r\n  Y,\r\n  ZGate,\r\n  Z,\r\n  SGate,\r\n  S,\r\n  TGate,\r\n  T,\r\n  SqrtXGate,\r\n  SqrtX,\r\n  Swap,\r\n  SwapGate,\r\n  SqrtSwap,\r\n  SqrtSwapGate,\r\n  Allocate,\r\n  Deallocate,\r\n  Barrier,\r\n  Entangle,\r\n  EntangleGate,\r\n  R,\r\n  Rx,\r\n  Ry,\r\n  Rz,\r\n  Ph,\r\n  FlushGate,\r\n  Measure,\r\n  DeallocateQubitGate,\r\n  AllocateQubitGate,\r\n  AllocateDirtyQubitGate, AllocateDirty, BarrierGate,\r\n  MeasureGate\r\n} from './gates'\r\nimport './metagates'\r\nimport {getInverse} from './_cycle'\r\nconst {Tdag, Tdagger} = Gates\r\nconst np = math\r\nconst mm = math.matrix\r\nconst mc = math.complex\r\n\r\nfunction matrixEqual(m1, m2) {\r\n  if (math.equal(math.size(m1), math.size(m2))) {\r\n    let isSame = true\r\n    m1.forEach((value, index) => {\r\n      const v = m2.subset(np.index(...index))\r\n      if (math.abs(value - v) > 1e-12) {\r\n        isSame = false\r\n      }\r\n    })\r\n    return isSame\r\n  }\r\n  return false\r\n}\r\n\r\ndescribe('gate test', () => {\r\n  it('should test h gate', () => {\r\n    const gate = new HGate()\r\n    expect(gate.equal(gate.getInverse())).to.equal(true)\r\n    expect(gate.toString()).to.equal('H')\r\n    expect(H instanceof HGate).to.equal(true)\r\n    const m = mm([\r\n      [mc(Math.SQRT1_2, 0), mc(Math.SQRT1_2, 0)],\r\n      [mc(Math.SQRT1_2, 0), mc(-Math.SQRT1_2, 0)]\r\n    ])\r\n    expect(np.deepEqual(gate.matrix, m)).to.equal(true)\r\n  });\r\n\r\n  it('should test x gate', () => {\r\n    const gate = new XGate()\r\n    expect(gate.equal(gate.getInverse())).to.equal(true)\r\n    expect(gate.toString()).to.equal('X')\r\n    expect(X instanceof XGate).to.equal(true)\r\n    const m = mm([[0, 1], [1, 0]])\r\n    expect(np.deepEqual(gate.matrix, m)).to.equal(true)\r\n  })\r\n\r\n  it('should test y gate', () => {\r\n    const gate = new YGate()\r\n    expect(gate.equal(gate.getInverse())).to.equal(true)\r\n    expect(gate.toString()).to.equal('Y')\r\n    expect(Y instanceof YGate).to.equal(true)\r\n    const m = mm([[0, mc(0, -1)], [mc(0, 1), 0]])\r\n    expect(np.deepEqual(gate.matrix, m)).to.equal(true)\r\n  })\r\n\r\n  it('should test z gate', () => {\r\n    const gate = new ZGate()\r\n    expect(gate.equal(gate.getInverse())).to.equal(true)\r\n    expect(gate.toString()).to.equal('Z')\r\n    expect(Z instanceof ZGate).to.equal(true)\r\n    const m = mm([[1, 0], [0, -1]])\r\n    expect(np.deepEqual(gate.matrix, m)).to.equal(true)\r\n  })\r\n\r\n  it('should test s gate', () => {\r\n    const gate = new SGate()\r\n    expect(gate.equal(gate.getInverse())).to.equal(true)\r\n    expect(gate.toString()).to.equal('S')\r\n    expect(S instanceof SGate).to.equal(true)\r\n    const m = mm([[1, 0], [0, mc(0, 1)]])\r\n    expect(np.deepEqual(gate.matrix, m)).to.equal(true)\r\n  })\r\n\r\n  it('should test t gate', () => {\r\n    const gate = new TGate()\r\n    expect(gate.toString()).to.equal('T')\r\n    expect(T instanceof TGate).to.equal(true)\r\n    const m = mm([[1, 0], [0, math.exp(mc(0, math.pi / 4))]])\r\n    expect(np.deepEqual(gate.matrix, m)).to.equal(true)\r\n    expect(Tdag instanceof getInverse(gate).constructor).to.equal(true)\r\n    expect(Tdagger instanceof getInverse(gate).constructor).to.equal(true)\r\n  })\r\n\r\n  it('should sqrtx gate', () => {\r\n    const gate = new SqrtXGate()\r\n    expect(gate.toString()).to.equal('SqrtX')\r\n    const m = mm([[mc(0.5, 0.5), mc(0.5, -0.5)], [mc(0.5, -0.5), mc(0.5, 0.5)]])\r\n    expect(np.deepEqual(gate.matrix, m)).to.equal(true)\r\n    const t = mm([[0, 1], [1, 0]])\r\n    expect(np.deepEqual(t, math.multiply(gate.matrix, gate.matrix))).to.equal(true)\r\n    expect(SqrtX instanceof SqrtXGate).to.equal(true)\r\n  });\r\n\r\n  it('should test swap gate', () => {\r\n    const gate = new SwapGate()\r\n    expect(gate.toString()).to.equal('Swap')\r\n    expect(gate.interchangeableQubitIndices).to.deep.equal([[0, 1]])\r\n    const m = mm([[1, 0, 0, 0], [0, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 1]])\r\n    expect(np.deepEqual(gate.matrix, m)).to.equal(true)\r\n    expect(Swap instanceof SwapGate).to.equal(true)\r\n  });\r\n\r\n  it('should test sqrt swap gate', () => {\r\n    const sqrt_gate = new SqrtSwapGate()\r\n    const swap_gate = new SwapGate()\r\n    expect(sqrt_gate.toString()).to.equal('SqrtSwap')\r\n\r\n    const m = mm([[1, 0, 0, 0],\r\n      [0, mc(0.5, 0.5), mc(0.5, -0.5), 0],\r\n      [0, mc(0.5, -0.5), mc(0.5, 0.5), 0],\r\n      [0, 0, 0, 1]])\r\n    expect(np.deepEqual(sqrt_gate.matrix, m)).to.equal(true)\r\n    expect(Swap instanceof SwapGate).to.equal(true)\r\n    expect(SqrtSwap instanceof SqrtSwapGate).to.equal(true)\r\n    expect(math.deepEqual(math.multiply(sqrt_gate.matrix, sqrt_gate.matrix), swap_gate.matrix)).to.equal(true)\r\n  });\r\n\r\n  it('should test engangle gate', () => {\r\n    const gate = new EntangleGate()\r\n    expect(gate.toString()).to.equal('Entangle')\r\n    expect(Entangle instanceof EntangleGate).to.equal(true)\r\n  })\r\n\r\n  it('should test rx', () => {\r\n    const angles = [0, 0.2, 2.1, 4.1, 2 * math.pi, 4 * math.pi]\r\n    angles.forEach((angle) => {\r\n      const gate = new Rx(angle)\r\n      const expected_matrix = np.matrix([[math.cos(0.5 * angle), mc(0, -math.sin(0.5 * angle))],\r\n        [mc(0, -math.sin(0.5 * angle)), math.cos(0.5 * angle)]])\r\n      expect(math.deepEqual(gate.matrix, expected_matrix)).to.equal(true)\r\n    })\r\n  });\r\n\r\n  it('should test ry', () => {\r\n    const angles = [0, 0.2, 2.1, 4.1, 2 * math.pi, 4 * math.pi]\r\n    angles.forEach((angle) => {\r\n      const gate = new Ry(angle)\r\n      const expected_matrix = np.matrix([[math.cos(0.5 * angle), -math.sin(0.5 * angle)],\r\n        [math.sin(0.5 * angle), math.cos(0.5 * angle)]])\r\n      expect(matrixEqual(gate.matrix, expected_matrix)).to.equal(true)\r\n    })\r\n  });\r\n\r\n  it('should test rz', () => {\r\n    const angles = [0, 0.2, 2.1, 4.1, 2 * math.pi, 4 * math.pi]\r\n    angles.forEach((angle) => {\r\n      const gate = new Rz(angle)\r\n      const expected_matrix = np.matrix([\r\n        [np.exp(mc(0, -0.5 * angle)), 0],\r\n        [0, np.exp(mc(0, 0.5 * angle))]\r\n      ])\r\n      expect(matrixEqual(gate.matrix, expected_matrix)).to.equal(true)\r\n    })\r\n  });\r\n\r\n  it('should test ph', () => {\r\n    const angles = [0, 0.2, 2.1, 4.1, 2 * math.pi]\r\n    angles.forEach((angle) => {\r\n      const gate = new Ph(angle)\r\n      const gate2 = new Ph(angle + 2 * math.pi)\r\n      const expected_matrix = np.matrix([\r\n        [np.exp(mc(0, angle)), 0],\r\n        [0, np.exp(mc(0, angle))]\r\n      ])\r\n      expect(matrixEqual(gate.matrix, expected_matrix)).to.equal(true)\r\n      expect(matrixEqual(gate2.matrix, expected_matrix)).to.equal(true)\r\n      expect(gate.equal(gate2)).to.equal(true)\r\n    })\r\n  });\r\n\r\n  it('should test r', () => {\r\n    const angles = [0, 0.2, 2.1, 4.1, 2 * math.pi]\r\n    angles.forEach((angle) => {\r\n      const gate = new R(angle)\r\n      const gate2 = new R(angle + 2 * math.pi)\r\n      const expected_matrix = np.matrix([[1, 0], [0, np.exp(mc(0, angle))]])\r\n      expect(matrixEqual(gate.matrix, expected_matrix)).to.equal(true)\r\n      expect(matrixEqual(gate2.matrix, expected_matrix)).to.equal(true)\r\n      expect(gate.equal(gate2)).to.equal(true)\r\n    })\r\n  });\r\n\r\n  it('should test flush gate', () => {\r\n    const gate = new FlushGate()\r\n    expect(gate.toString()).to.equal('')\r\n  });\r\n\r\n  it('should test measure gate', () => {\r\n    const gate = new MeasureGate()\r\n    expect(gate.toString()).to.equal('Measure')\r\n    expect(Measure instanceof MeasureGate).to.equal(true)\r\n  });\r\n\r\n  it('should test allocate qubit gate', () => {\r\n    const gate = new AllocateQubitGate()\r\n    expect(gate.toString()).to.equal('Allocate')\r\n    expect(gate.getInverse().equal(new DeallocateQubitGate())).to.equal(true)\r\n    expect(Allocate instanceof AllocateQubitGate).to.equal(true)\r\n  });\r\n\r\n  it('should test deallocate qubit gate', () => {\r\n    const gate = new DeallocateQubitGate()\r\n    expect(gate.toString()).to.equal('Deallocate')\r\n    expect(gate.getInverse().equal(new AllocateQubitGate())).to.equal(true)\r\n    expect(Deallocate instanceof DeallocateQubitGate).to.equal(true)\r\n  });\r\n\r\n  it('should test allocate dirty qubit gate', () => {\r\n    const gate = new AllocateDirtyQubitGate()\r\n    expect(gate.toString()).to.equal('AllocateDirty')\r\n    expect(gate.getInverse().equal(new DeallocateQubitGate())).to.equal(true)\r\n    expect(AllocateDirty instanceof AllocateDirtyQubitGate).to.equal(true)\r\n  });\r\n\r\n  it('should test barrier gate', () => {\r\n    const gate = new BarrierGate()\r\n    expect(gate.toString()).to.equal('Barrier')\r\n    expect(gate.getInverse().equal(new BarrierGate())).to.equal(true)\r\n    expect(Barrier instanceof BarrierGate).to.equal(true)\r\n  });\r\n})\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/ops/gates.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 865,
    "kind": "variable",
    "name": "Tdag",
    "memberof": "src/ops/gates.spec.js",
    "static": true,
    "longname": "src/ops/gates.spec.js~Tdag",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/ops/gates.spec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 57,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 866,
    "kind": "variable",
    "name": "np",
    "memberof": "src/ops/gates.spec.js",
    "static": true,
    "longname": "src/ops/gates.spec.js~np",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/ops/gates.spec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 58,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 867,
    "kind": "variable",
    "name": "mm",
    "memberof": "src/ops/gates.spec.js",
    "static": true,
    "longname": "src/ops/gates.spec.js~mm",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/ops/gates.spec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 59,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 868,
    "kind": "variable",
    "name": "mc",
    "memberof": "src/ops/gates.spec.js",
    "static": true,
    "longname": "src/ops/gates.spec.js~mc",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/ops/gates.spec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 60,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 869,
    "kind": "function",
    "name": "matrixEqual",
    "memberof": "src/ops/gates.spec.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/ops/gates.spec.js~matrixEqual",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/ops/gates.spec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 62,
    "undocument": true,
    "params": [
      {
        "name": "m1",
        "types": [
          "*"
        ]
      },
      {
        "name": "m2",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 870,
    "kind": "file",
    "name": "src/ops/metagates.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/**\r\n* Contains meta gates, i.e.,\r\n* DaggeredGate (Represents the inverse of an arbitrary gate)\r\n* ControlledGate (Represents a controlled version of an arbitrary gate)\r\n* Tensor/All (Applies a single qubit gate to all supplied qubits), e.g.,\r\n    @example\r\n\r\nTensor(H) | (qubit1, qubit2) # apply H to qubit #1 and #2\r\n\r\nAs well as the meta functions\r\n* getInverse (Tries to access the getInverse member function of a gate\r\nand upon failure returns a DaggeredGate)\r\n* C (Creates an n-ary controlled version of an arbitrary gate)\r\n*/\r\nimport math from 'mathjs'\r\nimport {BasicGate} from './basics'\r\nimport {Control} from '../meta/control'\r\nimport Cycle, {getInverse} from './_cycle'\r\nimport { arrayIsTuple } from '../libs/util'\r\n\r\n/**\r\n * @class DaggeredGate\r\n * @desc\r\nWrapper class allowing to execute the inverse of a gate, even when it does\r\nnot define one.\r\n\r\n    If there is a replacement available, then there is also one for the\r\n    inverse, namely the replacement function run in reverse, while inverting\r\n    all gates. This class enables using this emulation automatically.\r\n\r\n    A DaggeredGate is returned automatically when employing the getInverse-\r\nfunction on a gate which does not provide a getInverse() member function.\r\n\r\n@example\r\n\r\nwith Dagger(eng)\r\nMySpecialGate | qubits\r\n\r\nwill create a DaggeredGate if MySpecialGate does not implement\r\ngetInverse. If there is a decomposition function available, an auto-\r\nreplacer engine can automatically replace the inverted gate by a call to\r\nthe decomposition function inside a \"with Dagger\"-statement.\r\n */\r\nexport class DaggeredGate extends BasicGate {\r\n  /**\r\n   * @constructor\r\n    Initialize a DaggeredGate representing the inverse of the gate 'gate'.\r\n\r\n    @param {BasicGate} gate Any gate object of which to represent the inverse.\r\n     */\r\n  constructor(gate) {\r\n    super()\r\n    this.gate = gate\r\n    try {\r\n      this._matrix = math.ctranspose(gate.matrix)\r\n    } catch (e) {\r\n\r\n    }\r\n  }\r\n\r\n  getInverse() {\r\n    return this.gate\r\n  }\r\n\r\n  get matrix() {\r\n    if (!this._matrix) {\r\n      throw new Error('No this attribute')\r\n    }\r\n    return this._matrix\r\n  }\r\n\r\n\r\n  /**\r\n    Return true if self is equal to other, i.e., same type and representing the inverse of the same gate.\r\n  */\r\n  equal(other) {\r\n    return other instanceof DaggeredGate && other.gate.equal(this.gate)\r\n  }\r\n\r\n  toString() {\r\n    return `${this.gate.toString()}^\\\\dagger`\r\n  }\r\n\r\n  texString() {\r\n    if (this.gate.texString) {\r\n      return `$${this.gate.texString()}^\\\\dagger$`\r\n    } else {\r\n      return `$${this.gate.toString()}^\\\\dagger$`\r\n    }\r\n  }\r\n}\r\n\r\nCycle.add('DaggeredGate', DaggeredGate)\r\n\r\n/**\r\n * @class ControlledGate\r\n * @desc\r\nControlled version of a gate.\r\n\r\n    Note:\r\nUse the meta function :func:`C()` to create a controlled gate\r\n\r\nA wrapper class which enables (multi-) controlled gates. It overloads\r\nthe __or__-operator, using the first qubits provided as control qubits.\r\n    The n control-qubits need to be the first n qubits. They can be in\r\nseparate quregs.\r\n\r\n    @example\r\n\r\nControlledGate(gate, 2) | (qb0, qb2, qb3) # qb0 & qb2 are controls\r\nC(gate, 2) | (qb0, qb2, qb3) # This is much nicer.\r\nC(gate, 2) | ([qb0,qb2], qb3) # Is equivalent\r\n\r\nNote:\r\n    Use :func:`C` rather than ControlledGate, i.e.,\r\n\r\n @example\r\n\r\nC(X, 2) == Toffoli\r\n */\r\nexport class ControlledGate extends BasicGate {\r\n  /**\r\n   * @constructor\r\n    @param {BasicGate} gate Gate to wrap.\r\n    @param {number} n Number of control qubits.\r\n  */\r\n  constructor(gate, n = 1) {\r\n    super()\r\n    if (gate instanceof ControlledGate) {\r\n      this.gate = gate.gate\r\n      this.n = gate.n + n\r\n    } else {\r\n      this.gate = gate\r\n      this.n = n\r\n    }\r\n  }\r\n\r\n  getInverse() {\r\n    return new ControlledGate(getInverse(this.gate), this.n)\r\n  }\r\n\r\n  /**\r\n    Apply the controlled gate to qubits, using the first n qubits as\r\ncontrols.\r\n\r\n    Note: The control qubits can be split across the first quregs.\r\n    However, the n-th control qubit needs to be the last qubit in a\r\nqureg. The following quregs belong to the gate.\r\n\r\n    @param {Array.<Qureg>} qubits qubits to which to apply the gate.\r\n     */\r\n  or(qubits) {\r\n    qubits = BasicGate.makeTupleOfQureg(qubits)\r\n    let ctrl = []\r\n    const gateQuregs = []\r\n    let addingToControls = true\r\n    qubits.forEach((reg) => {\r\n      if (addingToControls) {\r\n        ctrl = ctrl.concat(reg)\r\n        addingToControls = ctrl.length < this.n\r\n      } else {\r\n        gateQuregs.push(reg)\r\n      }\r\n    })\r\n\r\n    // Test that there were enough control quregs and that that\r\n    // the last control qubit was the last qubit in a qureg.\r\n    if (ctrl.length !== this.n) {\r\n      throw new Error('Wrong number of control qubits. '\r\n            + 'First qureg(s) need to contain exactly '\r\n            + 'the required number of control quregs.')\r\n    }\r\n\r\n    Control(gateQuregs[0][0].engine, ctrl, () => this.gate.or(gateQuregs))\r\n  }\r\n\r\n  toString() {\r\n    let prefix = ''\r\n    for (let i = 0; i < this.n; ++i) {\r\n      prefix += 'C'\r\n    }\r\n    return `${prefix}${this.gate.toString()}`\r\n  }\r\n\r\n  equal(other) {\r\n    if (other instanceof this.__proto__.constructor) {\r\n      return this.gate.equal(other.gate) && this.n === other.n\r\n    }\r\n    return false\r\n  }\r\n}\r\n\r\n/**\r\nReturn n-controlled version of the provided gate.\r\n\r\n    @param {BasicGate} gate Gate to turn into its controlled version\r\n    @param {number} n Number of controls (default: 1)\r\n\r\n@example\r\n\r\nC(NOT) | (c, q) # equivalent to CNOT | (c, q)\r\n */\r\nexport function C(gate, n = 1) {\r\n  return new ControlledGate(gate, n)\r\n}\r\n\r\n/**\r\n * @class Tensor\r\n * @desc\r\nWrapper class allowing to apply a (single-qubit) gate to every qubit in a\r\nquantum register. Allowed syntax is to supply either a qureg or a tuple\r\nwhich contains only one qureg.\r\n\r\n    @example\r\n\r\nTensor(H) | x # applies H to every qubit in the list of qubits x\r\nTensor(H) | (x,) # alternative to be consistent with other syntax\r\n */\r\nexport class Tensor extends BasicGate {\r\n  /**\r\n   * @constructor\r\n   * @param {BasicGate} gate\r\n   */\r\n  constructor(gate) {\r\n    super()\r\n    this.gate = gate\r\n  }\r\n\r\n  getInverse() {\r\n    return new Tensor(getInverse(this.gate))\r\n  }\r\n\r\n  or(qubits) {\r\n    const isTuple = arrayIsTuple(qubits)\r\n    let array = null\r\n    if (isTuple) {\r\n      if (qubits.length !== 1) {\r\n        throw new Error('wrong length')\r\n      }\r\n      array = qubits[0]\r\n    } else {\r\n      array = qubits\r\n    }\r\n    if (!Array.isArray(array)) {\r\n      throw new Error('should be array type!')\r\n    }\r\n    array.forEach(q => this.gate.or(q))\r\n  }\r\n\r\n  toString() {\r\n    return `Tensor(${this.gate.toString()})`\r\n  }\r\n}\r\n\r\nexport const All = Tensor\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/ops/metagates.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 871,
    "kind": "class",
    "name": "DaggeredGate",
    "memberof": "src/ops/metagates.js",
    "static": true,
    "longname": "src/ops/metagates.js~DaggeredGate",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/metagates.js",
    "importStyle": "{DaggeredGate}",
    "description": "Wrapper class allowing to execute the inverse of a gate, even when it does\nnot define one.\n\nIf there is a replacement available, then there is also one for the\ninverse, namely the replacement function run in reverse, while inverting\nall gates. This class enables using this emulation automatically.\n\nA DaggeredGate is returned automatically when employing the getInverse-\nfunction on a gate which does not provide a getInverse() member function.",
    "examples": [
      "\nwith Dagger(eng)\nMySpecialGate | qubits\n\nwill create a DaggeredGate if MySpecialGate does not implement\ngetInverse. If there is a decomposition function available, an auto-\nreplacer engine can automatically replace the inverted gate by a call to\nthe decomposition function inside a \"with Dagger\"-statement."
    ],
    "lineNumber": 60,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "DaggeredGate"
      }
    ],
    "interface": false,
    "extends": [
      "src/ops/basics.js~BasicGate"
    ]
  },
  {
    "__docId__": 872,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/ops/metagates.js~DaggeredGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/metagates.js~DaggeredGate#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 67,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": "Initialize a DaggeredGate representing the inverse of the gate 'gate'."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "BasicGate"
        ],
        "spread": false,
        "optional": false,
        "name": "gate",
        "description": "Any gate object of which to represent the inverse."
      }
    ]
  },
  {
    "__docId__": 873,
    "kind": "member",
    "name": "gate",
    "memberof": "src/ops/metagates.js~DaggeredGate",
    "static": false,
    "longname": "src/ops/metagates.js~DaggeredGate#gate",
    "access": "public",
    "description": null,
    "lineNumber": 69,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 874,
    "kind": "member",
    "name": "_matrix",
    "memberof": "src/ops/metagates.js~DaggeredGate",
    "static": false,
    "longname": "src/ops/metagates.js~DaggeredGate#_matrix",
    "access": "private",
    "description": null,
    "lineNumber": 71,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 875,
    "kind": "method",
    "name": "getInverse",
    "memberof": "src/ops/metagates.js~DaggeredGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/metagates.js~DaggeredGate#getInverse",
    "access": "public",
    "description": null,
    "lineNumber": 77,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 876,
    "kind": "get",
    "name": "matrix",
    "memberof": "src/ops/metagates.js~DaggeredGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/metagates.js~DaggeredGate#matrix",
    "access": "public",
    "description": null,
    "lineNumber": 81,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 877,
    "kind": "method",
    "name": "equal",
    "memberof": "src/ops/metagates.js~DaggeredGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/metagates.js~DaggeredGate#equal",
    "access": "public",
    "description": "Return true if self is equal to other, i.e., same type and representing the inverse of the same gate.",
    "lineNumber": 92,
    "params": [
      {
        "name": "other",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 878,
    "kind": "method",
    "name": "toString",
    "memberof": "src/ops/metagates.js~DaggeredGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/metagates.js~DaggeredGate#toString",
    "access": "public",
    "description": null,
    "lineNumber": 96,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 879,
    "kind": "method",
    "name": "texString",
    "memberof": "src/ops/metagates.js~DaggeredGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/metagates.js~DaggeredGate#texString",
    "access": "public",
    "description": null,
    "lineNumber": 100,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 880,
    "kind": "class",
    "name": "ControlledGate",
    "memberof": "src/ops/metagates.js",
    "static": true,
    "longname": "src/ops/metagates.js~ControlledGate",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/metagates.js",
    "importStyle": "{ControlledGate}",
    "description": "Controlled version of a gate.\n\nNote:\nUse the meta function :func:`C()` to create a controlled gate\n\nA wrapper class which enables (multi-) controlled gates. It overloads\nthe __or__-operator, using the first qubits provided as control qubits.\nThe n control-qubits need to be the first n qubits. They can be in\nseparate quregs.",
    "examples": [
      "\nControlledGate(gate, 2) | (qb0, qb2, qb3) # qb0 & qb2 are controls\nC(gate, 2) | (qb0, qb2, qb3) # This is much nicer.\nC(gate, 2) | ([qb0,qb2], qb3) # Is equivalent\n\nNote:\nUse :func:`C` rather than ControlledGate, i.e.,",
      "\nC(X, 2) == Toffoli"
    ],
    "lineNumber": 137,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "ControlledGate"
      }
    ],
    "interface": false,
    "extends": [
      "src/ops/basics.js~BasicGate"
    ]
  },
  {
    "__docId__": 881,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/ops/metagates.js~ControlledGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/metagates.js~ControlledGate#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 143,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "BasicGate"
        ],
        "spread": false,
        "optional": false,
        "name": "gate",
        "description": "Gate to wrap."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "n",
        "description": "Number of control qubits."
      }
    ]
  },
  {
    "__docId__": 882,
    "kind": "member",
    "name": "gate",
    "memberof": "src/ops/metagates.js~ControlledGate",
    "static": false,
    "longname": "src/ops/metagates.js~ControlledGate#gate",
    "access": "public",
    "description": null,
    "lineNumber": 146,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 883,
    "kind": "member",
    "name": "n",
    "memberof": "src/ops/metagates.js~ControlledGate",
    "static": false,
    "longname": "src/ops/metagates.js~ControlledGate#n",
    "access": "public",
    "description": null,
    "lineNumber": 147,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 886,
    "kind": "method",
    "name": "getInverse",
    "memberof": "src/ops/metagates.js~ControlledGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/metagates.js~ControlledGate#getInverse",
    "access": "public",
    "description": null,
    "lineNumber": 154,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 887,
    "kind": "method",
    "name": "or",
    "memberof": "src/ops/metagates.js~ControlledGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/metagates.js~ControlledGate#or",
    "access": "public",
    "description": "Apply the controlled gate to qubits, using the first n qubits as\ncontrols.\n\nNote: The control qubits can be split across the first quregs.\nHowever, the n-th control qubit needs to be the last qubit in a\nqureg. The following quregs belong to the gate.",
    "lineNumber": 168,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array.<Qureg>"
        ],
        "spread": false,
        "optional": false,
        "name": "qubits",
        "description": "qubits to which to apply the gate."
      }
    ],
    "return": null
  },
  {
    "__docId__": 888,
    "kind": "method",
    "name": "toString",
    "memberof": "src/ops/metagates.js~ControlledGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/metagates.js~ControlledGate#toString",
    "access": "public",
    "description": null,
    "lineNumber": 193,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 889,
    "kind": "method",
    "name": "equal",
    "memberof": "src/ops/metagates.js~ControlledGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/metagates.js~ControlledGate#equal",
    "access": "public",
    "description": null,
    "lineNumber": 201,
    "undocument": true,
    "params": [
      {
        "name": "other",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 890,
    "kind": "function",
    "name": "C",
    "memberof": "src/ops/metagates.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/ops/metagates.js~C",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/metagates.js",
    "importStyle": "{C}",
    "description": "Return n-controlled version of the provided gate.",
    "examples": [
      "\nC(NOT) | (c, q) # equivalent to CNOT | (c, q)"
    ],
    "lineNumber": 219,
    "params": [
      {
        "nullable": null,
        "types": [
          "BasicGate"
        ],
        "spread": false,
        "optional": false,
        "name": "gate",
        "description": "Gate to turn into its controlled version"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "n",
        "description": "Number of controls (default: 1)"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 891,
    "kind": "class",
    "name": "Tensor",
    "memberof": "src/ops/metagates.js",
    "static": true,
    "longname": "src/ops/metagates.js~Tensor",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/metagates.js",
    "importStyle": "{Tensor}",
    "description": "Wrapper class allowing to apply a (single-qubit) gate to every qubit in a\nquantum register. Allowed syntax is to supply either a qureg or a tuple\nwhich contains only one qureg.",
    "examples": [
      "\nTensor(H) | x # applies H to every qubit in the list of qubits x\nTensor(H) | (x,) # alternative to be consistent with other syntax"
    ],
    "lineNumber": 235,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "Tensor"
      }
    ],
    "interface": false,
    "extends": [
      "src/ops/basics.js~BasicGate"
    ]
  },
  {
    "__docId__": 892,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/ops/metagates.js~Tensor",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/metagates.js~Tensor#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 240,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "BasicGate"
        ],
        "spread": false,
        "optional": false,
        "name": "gate",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 893,
    "kind": "member",
    "name": "gate",
    "memberof": "src/ops/metagates.js~Tensor",
    "static": false,
    "longname": "src/ops/metagates.js~Tensor#gate",
    "access": "public",
    "description": null,
    "lineNumber": 242,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 894,
    "kind": "method",
    "name": "getInverse",
    "memberof": "src/ops/metagates.js~Tensor",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/metagates.js~Tensor#getInverse",
    "access": "public",
    "description": null,
    "lineNumber": 245,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 895,
    "kind": "method",
    "name": "or",
    "memberof": "src/ops/metagates.js~Tensor",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/metagates.js~Tensor#or",
    "access": "public",
    "description": null,
    "lineNumber": 249,
    "undocument": true,
    "params": [
      {
        "name": "qubits",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 896,
    "kind": "method",
    "name": "toString",
    "memberof": "src/ops/metagates.js~Tensor",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/metagates.js~Tensor#toString",
    "access": "public",
    "description": null,
    "lineNumber": 266,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 897,
    "kind": "variable",
    "name": "All",
    "memberof": "src/ops/metagates.js",
    "static": true,
    "longname": "src/ops/metagates.js~All",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/metagates.js",
    "importStyle": "{All}",
    "description": null,
    "lineNumber": 271,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 898,
    "kind": "file",
    "name": "src/ops/metagates.spec.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport {expect} from 'chai'\r\nimport math from 'mathjs'\r\nimport MainEngine from '../cengines/main'\r\nimport {DummyEngine} from '../cengines/testengine'\r\nimport Command from './command'\r\nimport {Tensor} from './metagates'\r\n\r\nimport {\r\n  Rx, T, Y, Entangle\r\n} from './gates'\r\nimport {\r\n  C, All, DaggeredGate, ControlledGate\r\n} from './metagates'\r\nimport {Qubit} from '../types/qubit'\r\nimport {getInverse} from './_cycle';\r\nimport { ClassicalInstructionGate, FastForwardingGate } from './basics'\r\nimport {tuple} from '../libs/util'\r\n\r\nconst np = math\r\nconst mm = math.matrix\r\nconst mc = math.complex\r\n\r\ndescribe('metagates test', () => {\r\n  it('should ', () => {\r\n    const saving_backend = new DummyEngine(true)\r\n    const main_engine = new MainEngine(saving_backend, [new DummyEngine()])\r\n    const gate = new Rx(0.6)\r\n    const qubit0 = new Qubit(main_engine, 0)\r\n    const qubit1 = new Qubit(main_engine, 1)\r\n    const qubit2 = new Qubit(main_engine, 2)\r\n    const target_qubits = [qubit1, qubit2]\r\n    C(new All(gate)).or([qubit0, target_qubits])\r\n\r\n    const array = saving_backend.receivedCommands\r\n    const last = array[array.length - 1]\r\n    expect(last.gate.equal(gate)).to.equal(true)\r\n    expect(last.controlQubits.length).to.equal(1)\r\n  })\r\n\r\n  it('should test daggered gate init', () => {\r\n    // Choose gate which does not have an inverse gate:\r\n    const not_invertible_gate = T\r\n    expect(() => not_invertible_gate.getInverse()).to.throw()\r\n\r\n    // Choose gate which does have an inverse defined:\r\n    const invertible_gate = Y\r\n    expect(invertible_gate.getInverse().equal(Y)).to.equal(true)\r\n    // Test init and matrix\r\n    const dagger_inv = new DaggeredGate(not_invertible_gate)\r\n    expect(dagger_inv.gate.equal(not_invertible_gate)).to.equal(true)\r\n    const m = mm([[1, 0],\r\n      [0, np.exp(mc(0, -math.pi / 4))]\r\n    ])\r\n    expect(math.deepEqual(dagger_inv.matrix, m)).to.equal(true)\r\n    const inv = new DaggeredGate(invertible_gate)\r\n    expect(inv.gate.equal(invertible_gate)).to.equal(true)\r\n    const m2 = mm([[0, mc(0, -1)], [mc(0, 1), 0]])\r\n    expect(math.deepEqual(inv.matrix, m2)).to.equal(true)\r\n    // Test matrix\r\n    const no_matrix_gate = Entangle\r\n    expect(() => no_matrix_gate.matrix).to.throw()\r\n    const inv_no_matrix_gate = new DaggeredGate(no_matrix_gate)\r\n    expect(() => inv_no_matrix_gate.matrix).to.throw()\r\n  });\r\n\r\n  it('should test daggered gate string', () => {\r\n    const daggered_gate = new DaggeredGate(Y)\r\n    expect(daggered_gate.toString()).to.equal(`${Y.toString()}^\\\\dagger`)\r\n  });\r\n\r\n  it('should test daggered gate get inverse', () => {\r\n    const daggered_gate = new DaggeredGate(Y)\r\n    expect(daggered_gate.getInverse().equal(Y)).to.equal(true)\r\n  });\r\n\r\n  it('should test daggered gate comparison', () => {\r\n    const daggered_gate = new DaggeredGate(Y)\r\n    const daggered_gate2 = new DaggeredGate(Y)\r\n    expect(daggered_gate.equal(daggered_gate2)).to.equal(true)\r\n  });\r\n\r\n  it('should test get inverse', () => {\r\n    // Choose gate which does not have an inverse gate:\r\n    const not_invertible_gate = T\r\n    expect(() => not_invertible_gate.getInverse()).to.throw()\r\n    // Choose gate which does have an inverse defined:\r\n    const invertible_gate = Y\r\n    expect(invertible_gate.getInverse().equal(Y)).to.equal(true)\r\n    // Check getInverse(gate)\r\n    const inv = getInverse(not_invertible_gate)\r\n    expect(inv instanceof DaggeredGate && inv.gate.equal(not_invertible_gate)).to.equal(true)\r\n    const inv2 = getInverse(invertible_gate)\r\n    expect(inv2.equal(Y)).to.equal(true)\r\n  });\r\n\r\n  it('should test controlled gate init', () => {\r\n    const one_control = new ControlledGate(Y, 1)\r\n    const two_control = new ControlledGate(Y, 2)\r\n    const three_control = new ControlledGate(one_control, 2)\r\n    expect(one_control.gate.equal(Y)).to.equal(true)\r\n    expect(one_control.n).to.equal(1)\r\n    expect(two_control.gate.equal(Y)).to.equal(true)\r\n    expect(two_control.n).to.equal(2)\r\n    expect(three_control.gate.equal(Y)).to.equal(true)\r\n    expect(three_control.n).to.equal(3)\r\n  });\r\n\r\n  it('should test controlled gate string', () => {\r\n    const c = new ControlledGate(Y, 2)\r\n    expect(c.toString()).to.equal(`CC${Y.toString()}`)\r\n  });\r\n\r\n  it('should test controlled gate get inverse', () => {\r\n    const one_control = new ControlledGate(new Rx(0.5), 1)\r\n    const expected = new ControlledGate(new Rx(-0.5 + 4 * math.pi), 1)\r\n    expect(one_control.getInverse().equal(expected)).to.equal(true)\r\n  });\r\n\r\n  it('should test controlled gate empty controls', () => {\r\n    const rec = new DummyEngine(true)\r\n    const eng = new MainEngine(rec, [])\r\n\r\n    const a = eng.allocateQureg(1)\r\n    new ControlledGate(Y, 0).or([[], a])\r\n    const cmds = rec.receivedCommands\r\n    const last = cmds[cmds.length - 1]\r\n    expect(last.equal(new Command(eng, Y, [a]))).to.equal(true)\r\n  });\r\n\r\n  it('should test controlled gate or', () => {\r\n    const saving_backend = new DummyEngine(true)\r\n    const main_engine = new MainEngine(saving_backend, [new DummyEngine()])\r\n    const gate = new Rx(0.6)\r\n    const qubit0 = new Qubit(main_engine, 0)\r\n    const qubit1 = new Qubit(main_engine, 1)\r\n    const qubit2 = new Qubit(main_engine, 2)\r\n    const qubit3 = new Qubit(main_engine, 3)\r\n    const expected_cmd = new Command(main_engine, gate, [[qubit3]], [qubit0, qubit1, qubit2])\r\n    const received_commands = []\r\n    // Option 1:\r\n    new ControlledGate(gate, 3).or([[qubit1], [qubit0], [qubit2], [qubit3]])\r\n    // Option 2:\r\n    new ControlledGate(gate, 3).or(tuple(qubit1, qubit0, qubit2, qubit3))\r\n    // Option 3:\r\n    new ControlledGate(gate, 3).or([[qubit1, qubit0], qubit2, qubit3])\r\n    // Option 4:\r\n    new ControlledGate(gate, 3).or([qubit1, [qubit0, qubit2], qubit3])\r\n    // Wrong option 5:\r\n    expect(() => new ControlledGate(gate, 3).or([qubit1, [qubit0, qubit2, qubit3]])).to.throw()\r\n    // Remove Allocate and Deallocate gates\r\n    saving_backend.receivedCommands.forEach((cmd) => {\r\n      if (!(cmd.gate instanceof FastForwardingGate || cmd.gate instanceof ClassicalInstructionGate)) {\r\n        received_commands.push(cmd)\r\n      }\r\n    })\r\n    expect(received_commands.length).to.equal(4)\r\n    received_commands.forEach((cmd) => {\r\n      expect(cmd.equal(expected_cmd)).to.equal(true)\r\n    })\r\n  });\r\n\r\n  it('should test controlled gate comparison', () => {\r\n    const gate1 = new ControlledGate(Y, 1)\r\n    const gate2 = new ControlledGate(Y, 1)\r\n    const gate3 = new ControlledGate(T, 1)\r\n    const gate4 = new ControlledGate(Y, 2)\r\n    expect(gate1.equal(gate2)).to.equal(true)\r\n    expect(gate1.equal(gate3)).to.equal(false)\r\n    expect(gate1.equal(gate4)).to.equal(false)\r\n  });\r\n\r\n  it('should test c', () => {\r\n    const expected = new ControlledGate(Y, 2)\r\n    expect(C(Y, 2).equal(expected)).to.equal(true)\r\n  });\r\n\r\n  it('should test tensor init', () => {\r\n    const gate = new Tensor(Y)\r\n    expect(gate.gate.equal(Y)).to.equal(true)\r\n  });\r\n\r\n  it('should test tensor string', () => {\r\n    const gate = new Tensor(Y)\r\n    expect(gate.toString()).to.equal(`Tensor(${Y.toString()})`)\r\n  });\r\n\r\n  it('should test tensor get inverse', () => {\r\n    const gate = new Tensor(new Rx(0.6))\r\n    const inverse = gate.getInverse()\r\n    expect(inverse instanceof Tensor).to.equal(true)\r\n    expect(inverse.gate.equal(new Rx(-0.6 + 4 * math.pi))).to.equal(true)\r\n  });\r\n\r\n  it('should test tensor comparison', () => {\r\n    const gate1 = new Tensor(new Rx(0.6))\r\n    const gate2 = new Tensor(new Rx(0.6 + 4 * math.pi))\r\n    expect(gate1.equal(gate2)).to.equal(true)\r\n    expect(gate1.equal(new Rx(0.6))).to.equal(false)\r\n  });\r\n\r\n  it('should test tensor or', () => {\r\n    const saving_backend = new DummyEngine(true)\r\n    const main_engine = new MainEngine(saving_backend, [new DummyEngine()])\r\n    const gate = new Rx(0.6)\r\n    const qubit0 = new Qubit(main_engine, 0)\r\n    const qubit1 = new Qubit(main_engine, 1)\r\n    const qubit2 = new Qubit(main_engine, 2)\r\n    // Option 1:\r\n    new Tensor(gate).or([[qubit0, qubit1, qubit2]])\r\n    // Option 2:\r\n    new Tensor(gate).or([qubit0, qubit1, qubit2])\r\n    const received_commands = []\r\n    // Remove Allocate and Deallocate gates\r\n    saving_backend.receivedCommands.forEach((cmd) => {\r\n      if (!(cmd.gate instanceof FastForwardingGate || cmd.gate instanceof ClassicalInstructionGate)) {\r\n        received_commands.push(cmd)\r\n      }\r\n    })\r\n    // Check results\r\n    expect(received_commands.length).to.equal(6)\r\n    const qubit_ids = []\r\n    received_commands.forEach((cmd) => {\r\n      expect(cmd.qubits.length).to.equal(1)\r\n      expect(cmd.gate.equal(gate))\r\n      qubit_ids.push(cmd.qubits[0][0].id)\r\n    })\r\n\r\n    expect(qubit_ids.sort()).to.deep.equal([0, 0, 1, 1, 2, 2])\r\n  });\r\n})\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/ops/metagates.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 899,
    "kind": "variable",
    "name": "np",
    "memberof": "src/ops/metagates.spec.js",
    "static": true,
    "longname": "src/ops/metagates.spec.js~np",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/ops/metagates.spec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 35,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 900,
    "kind": "variable",
    "name": "mm",
    "memberof": "src/ops/metagates.spec.js",
    "static": true,
    "longname": "src/ops/metagates.spec.js~mm",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/ops/metagates.spec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 36,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 901,
    "kind": "variable",
    "name": "mc",
    "memberof": "src/ops/metagates.spec.js",
    "static": true,
    "longname": "src/ops/metagates.spec.js~mc",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/ops/metagates.spec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 902,
    "kind": "file",
    "name": "src/ops/qftgate.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport {BasicGate} from './basics'\r\n\r\n/**\r\n * Quantum Fourier Transform gate\r\n */\r\nexport default class QFTGate extends BasicGate {\r\n  toString() {\r\n    return 'QFT'\r\n  }\r\n}\r\n\r\nexport const QFT = new QFTGate()\r\n\r\n// Shortcut (instance of) :class:`projectq.ops.QFTGate`\r\nQFTGate.QFT = QFT\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/ops/qftgate.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 903,
    "kind": "class",
    "name": "QFTGate",
    "memberof": "src/ops/qftgate.js",
    "static": true,
    "longname": "src/ops/qftgate.js~QFTGate",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/qftgate.js",
    "importStyle": "QFTGate",
    "description": "Quantum Fourier Transform gate",
    "lineNumber": 22,
    "interface": false,
    "extends": [
      "src/ops/basics.js~BasicGate"
    ]
  },
  {
    "__docId__": 904,
    "kind": "method",
    "name": "toString",
    "memberof": "src/ops/qftgate.js~QFTGate",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/qftgate.js~QFTGate#toString",
    "access": "public",
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 905,
    "kind": "variable",
    "name": "QFT",
    "memberof": "src/ops/qftgate.js",
    "static": true,
    "longname": "src/ops/qftgate.js~QFT",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/qftgate.js",
    "importStyle": "{QFT}",
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "type": {
      "types": [
        "src/ops/qftgate.js~QFTGate"
      ]
    }
  },
  {
    "__docId__": 906,
    "kind": "file",
    "name": "src/ops/qftgate.spec.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport {expect} from 'chai'\r\nimport {QFT} from './qftgate'\r\n\r\ndescribe('QFT gate test', () => {\r\n  it('should test_qft_gate_str', () => {\r\n    const gate = QFT\r\n    expect(gate.toString()).to.equal('QFT')\r\n  })\r\n})\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/ops/qftgate.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 907,
    "kind": "file",
    "name": "src/ops/qubitoperator.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport math from 'mathjs'\r\n\r\n// QubitOperator stores a sum of Pauli operators acting on qubits.\"\"\"\r\nimport {isNumeric, symmetricDifference} from '../libs/polyfill'\r\n\r\nconst mc = math.complex\r\n\r\nconst EQ_TOLERANCE = 1e-12\r\n\r\n\r\n// Define products of all Pauli operators for symbolic multiplication.\r\nexport const PAULI_OPERATOR_PRODUCTS = {\r\n  [['I', 'I']]: [1.0, 'I'],\r\n  [['I', 'X']]: [1.0, 'X'],\r\n  [['X', 'I']]: [1.0, 'X'],\r\n  [['I', 'Y']]: [1.0, 'Y'],\r\n  [['Y', 'I']]: [1.0, 'Y'],\r\n  [['I', 'Z']]: [1.0, 'Z'],\r\n  [['Z', 'I']]: [1.0, 'Z'],\r\n  [['X', 'X']]: [1.0, 'I'],\r\n  [['Y', 'Y']]: [1.0, 'I'],\r\n  [['Z', 'Z']]: [1.0, 'I'],\r\n  [['X', 'Y']]: [mc(0, 1), 'Z'],\r\n  [['X', 'Z']]: [mc(0, -1), 'Y'],\r\n  [['Y', 'X']]: [mc(0, -1), 'Z'],\r\n  [['Y', 'Z']]: [mc(0, 1), 'X'],\r\n  [['Z', 'X']]: [mc(0, 1), 'Y'],\r\n  [['Z', 'Y']]: [mc(0, -1), 'X']\r\n}\r\n\r\nexport function stringToArray(key) {\r\n  const parts = key.split(',').filter(item => item.length > 0)\r\n  if (parts.length % 2 === 0) {\r\n    const result = []\r\n    for (let i = 0; i < parts.length; i += 2) {\r\n      result.push([parseInt(parts[i], 10), parts[i + 1]])\r\n    }\r\n    return result\r\n  } else {\r\n    throw new Error(`invalid key ${key}`)\r\n  }\r\n}\r\n\r\nfunction checkTerm(term) {\r\n  term.forEach((localOperator) => {\r\n    if (!Array.isArray(localOperator) || localOperator.length !== 2) {\r\n      throw new Error('term specified incorrectly')\r\n    }\r\n    const [qubitNum, action] = localOperator\r\n    if (typeof action !== 'string' || 'XYZ'.indexOf(action) === -1) {\r\n      throw new Error('Invalid action provided: must be string \\'X\\', \\'Y\\', or \\'Z\\'.')\r\n    }\r\n    if (typeof qubitNum !== 'number' || qubitNum < 0) {\r\n      throw new Error('Invalid qubit number '\r\n          + 'provided to QubitTerm: '\r\n          + 'must be a non-negative '\r\n          + 'int.')\r\n    }\r\n  })\r\n}\r\n\r\n/**\r\n * @class QubitOperator\r\n * @desc\r\nA sum of terms acting on qubits, e.g., 0.5 * 'X0 X5' + 0.3 * 'Z1 Z2'.\r\n\r\n    A term is an operator acting on n qubits and can be represented as:\r\n\r\ncoefficent * local_operator[0] x ... x local_operator[n-1]\r\n\r\nwhere x is the tensor product. A local operator is a Pauli operator\r\n('I', 'X', 'Y', or 'Z') which acts on one qubit. In math notation a term\r\nis, for example, 0.5 * 'X0 X5', which means that a Pauli X operator acts\r\non qubit 0 and 5, while the identity operator acts on all other qubits.\r\n\r\n    A QubitOperator represents a sum of terms acting on qubits and overloads\r\noperations for easy manipulation of these objects by the user.\r\n\r\n    Note for a QubitOperator to be a Hamiltonian which is a hermitian\r\noperator, the coefficients of all terms must be real.\r\n\r\n @example\r\n\r\nhamiltonian = 0.5 * QubitOperator('X0 X5') + 0.3 * QubitOperator('Z0')\r\n\r\nAttributes:\r\n    terms (dict): **key**: A term represented by a tuple containing all\r\nnon-trivial local Pauli operators ('X', 'Y', or 'Z').\r\nA non-trivial local Pauli operator is specified by a\r\ntuple with the first element being an integer\r\nindicating the qubit on which a non-trivial local\r\noperator acts and the second element being a string,\r\n    either 'X', 'Y', or 'Z', indicating which non-trivial\r\nPauli operator acts on that qubit. Examples:\r\n((1, 'X'),) or ((1, 'X'), (4,'Z')) or the identity ().\r\n    The tuples representing the non-trivial local terms\r\nare sorted according to the qubit number they act on,\r\n    starting from 0.\r\n**value**: Coefficient of this term as a (complex) float\r\n */\r\nexport default class QubitOperator {\r\n  /**\r\n   * @constructor\r\n    The init function only allows to initialize one term. Additional terms\r\nhave to be added using += (which is fast) or using + of two\r\nQubitOperator objects:\r\n\r\n    @example\r\n\r\nham = ((QubitOperator('X0 Y3', 0.5)\r\n    + 0.6 * QubitOperator('X0 Y3')))\r\n# Equivalently\r\nham2 = QubitOperator('X0 Y3', 0.5)\r\nham2 += 0.6 * QubitOperator('X0 Y3')\r\n\r\nNote:\r\n    Adding terms to QubitOperator is faster using += (as this is done\r\nby in-place addition). Specifying the coefficient in the __init__\r\nis faster than by multiplying a QubitOperator with a scalar as\r\ncalls an out-of-place multiplication.\r\n\r\n    @param {number|Complex} coefficient The coefficient of the\r\nfirst term of this QubitOperator. Default is 1.0.\r\n    @param {Array.<Array>|string} term (optional, empy array, a array of arrays, or a string):\r\n1) Default is None which means there are no terms in the\r\nQubitOperator hence it is the \"zero\" Operator\r\n2) An empty tuple means there are no non-trivial Pauli\r\noperators acting on the qubits hence only identities\r\nwith a coefficient (which by default is 1.0).\r\n3) A sorted tuple of tuples. The first element of each tuple\r\nis an integer indicating the qubit on which a non-trivial\r\nlocal operator acts, starting from zero. The second element\r\nof each tuple is a string, either 'X', 'Y' or 'Z',\r\n    indicating which local operator acts on that qubit.\r\n4) A string of the form 'X0 Z2 Y5', indicating an X on\r\nqubit 0, Z on qubit 2, and Y on qubit 5. The string should\r\nbe sorted by the qubit number. '' is the identity.\r\n\r\n    @throws {QubitOperatorError} Invalid operators provided to QubitOperator.\r\n     */\r\n  constructor(term, coefficient = 1.0) {\r\n    // assert coefficient as numeric\r\n    this.terms = {}\r\n    if (!isNumeric(coefficient)) {\r\n      throw new Error('Coefficient must be a numeric type.')\r\n    }\r\n\r\n    if (typeof term === 'undefined') {\r\n      // leave it empty\r\n    } else if (Array.isArray(term)) {\r\n      if (term.length === 0) {\r\n        this.terms[[]] = coefficient\r\n      } else {\r\n        checkTerm(term)\r\n        term = term.sort((a, b) => a[0] - b[0])\r\n        this.terms[term] = coefficient\r\n      }\r\n    } else if (typeof term === 'string') {\r\n      const listOPs = []\r\n      const parts = term.split(/\\s+/).filter(item => item.length > 0)\r\n      parts.forEach((el) => {\r\n        if (el.length < 2) {\r\n          throw new Error('term specified incorrectly.')\r\n        }\r\n        listOPs.push([parseInt(el.substring(1), 10), el[0]])\r\n      })\r\n\r\n      checkTerm(listOPs)\r\n\r\n      term = listOPs.sort((a, b) => a[0] - b[0])\r\n      this.terms[term] = coefficient\r\n    } else {\r\n      throw new Error('term specified incorrectly.')\r\n    }\r\n  }\r\n\r\n  /**\r\n    Eliminates all terms with coefficients close to zero and removes\r\nimaginary parts of coefficients that are close to zero.\r\n\r\n    @param {number} absTolerance Absolute tolerance, must be at least 0.0\r\n     */\r\n  compress(absTolerance = 1e-12) {\r\n    const new_terms = {}\r\n    Object.keys(this.terms).forEach((key) => {\r\n      let coeff = this.terms[key]\r\n      if (math.abs(math.im(coeff)) <= absTolerance) {\r\n        coeff = math.re(coeff)\r\n      }\r\n      if (math.abs(coeff) > absTolerance) {\r\n        new_terms[key] = coeff\r\n      }\r\n    })\r\n    this.terms = new_terms\r\n  }\r\n\r\n  /**\r\n    Returns true if other (QubitOperator) is close to this.\r\n\r\n    Comparison is done for each term individually. Return true\r\nif the difference between each term in self and other is\r\nless than the relative tolerance w.r.t. either other or self\r\n(symmetric test) or if the difference is less than the absolute\r\ntolerance.\r\n\r\n    @param {QubitOperator} other QubitOperator to compare against.\r\n    @param {number} realTolerance Relative tolerance, must be greater than 0.0\r\n    @param {number} absTolerance Absolute tolerance, must be at least 0.0\r\n  */\r\n  isClose(other, realTolerance = EQ_TOLERANCE, absTolerance = EQ_TOLERANCE) {\r\n    // terms which are in both\r\n    const otherKeys = new Set(Object.keys(other.terms))\r\n    const myKeys = Object.keys(this.terms)\r\n    const intersection = new Set(myKeys.filter(x => otherKeys.has(x)))\r\n    for (const term of intersection) {\r\n      const a = this.terms[term]\r\n      const b = other.terms[term]\r\n      //\r\n      const tmp = math.multiply(realTolerance, math.max(math.abs(a), math.abs(b)))\r\n      if (math.abs(math.subtract(a, b)) > math.max(tmp, absTolerance)) {\r\n        return false\r\n      }\r\n    }\r\n    const diff = symmetricDifference(new Set(myKeys), otherKeys)\r\n    // terms only in one (compare to 0.0 so only abs_tol)\r\n    for (const term of diff) {\r\n      const value = this.terms[term]\r\n      if (typeof value !== 'undefined') {\r\n        if (math.abs(value) > absTolerance) {\r\n          return false\r\n        }\r\n      } else if (math.abs(other.terms[term]) > absTolerance) {\r\n        return false\r\n      }\r\n    }\r\n    return true\r\n  }\r\n\r\n  /**\r\n    In-place multiply (*=) terms with scalar or QubitOperator.\r\n    @param {Complex|number|QubitOperator} multiplier\r\n  */\r\n  imul(multiplier) {\r\n    // Handle QubitOperator.\r\n    if (multiplier instanceof QubitOperator) {\r\n      const result_terms = {}\r\n      Object.keys(this.terms).forEach((left_term) => {\r\n        const leftKey = stringToArray(left_term)\r\n        Object.keys(multiplier.terms).forEach((right_term) => {\r\n          let new_coefficient = math.multiply(this.terms[left_term], multiplier.terms[right_term])\r\n          // Loop through local operators and create new sorted list\r\n          // of representing the product local operator\r\n          let product_operators = []\r\n          let left_operator_index = 0\r\n          let right_operator_index = 0\r\n          const rightKey = stringToArray(right_term)\r\n          const n_operators_left = leftKey.length\r\n          const n_operators_right = rightKey.length\r\n\r\n          while (left_operator_index < n_operators_left && right_operator_index < n_operators_right) {\r\n            const [left_qubit, left_loc_op] = leftKey[left_operator_index]\r\n            const [right_qubit, right_loc_op] = rightKey[right_operator_index]\r\n\r\n            // Multiply local operators acting on the same qubit\r\n            if (left_qubit === right_qubit) {\r\n              left_operator_index += 1\r\n              right_operator_index += 1\r\n              const [scalar, loc_op] = PAULI_OPERATOR_PRODUCTS[[left_loc_op, right_loc_op]]\r\n\r\n              // Add new term.\r\n              if (loc_op !== 'I') {\r\n                product_operators.push([left_qubit, loc_op])\r\n                new_coefficient = math.multiply(new_coefficient, scalar)\r\n              }\r\n              // Note if loc_op == 'I', then scalar == 1.0\r\n\r\n              // If left_qubit > right_qubit, add right_loc_op; else,\r\n              // add left_loc_op.\r\n            } else if (left_qubit > right_qubit) {\r\n              product_operators.push([right_qubit, right_loc_op])\r\n              right_operator_index += 1\r\n            } else {\r\n              product_operators.push([left_qubit, left_loc_op])\r\n              left_operator_index += 1\r\n            }\r\n          }\r\n\r\n          // Finish the remainding operators\r\n          if (left_operator_index === n_operators_left) {\r\n            product_operators = product_operators.concat(rightKey.slice(right_operator_index))\r\n          } else if (right_operator_index === n_operators_right) {\r\n            product_operators = product_operators.concat(leftKey.slice(left_operator_index))\r\n          }\r\n\r\n          // Add to result dict\r\n          const tmp_key = product_operators\r\n          if (tmp_key in result_terms) {\r\n            result_terms[tmp_key] = math.add(result_terms[tmp_key], new_coefficient)\r\n          } else {\r\n            result_terms[tmp_key] = new_coefficient\r\n          }\r\n        })\r\n      })\r\n      this.terms = result_terms\r\n      return this\r\n    } else // Handle scalars.\r\n    if (isNumeric(multiplier)) {\r\n      Object.keys(this.terms).forEach((key) => {\r\n        this.terms[key] = math.multiply(this.terms[key], multiplier)\r\n      })\r\n      return this\r\n    } else {\r\n      throw new Error('Cannot in-place multiply term of invalid type '\r\n        + 'to QubitTerm.')\r\n    }\r\n  }\r\n\r\n  /**\r\n  Return self * multiplier for a scalar, or a QubitOperator.\r\n\r\n    @param {Complex|number|QubitOperator} multiplier A scalar, or a QubitOperator.\r\n\r\n    @return {QubitOperator}\r\n\r\n    @throws {Error} Invalid type cannot be multiply with QubitOperator.\r\n   */\r\n  mul(multiplier) {\r\n    if (isNumeric(multiplier) || multiplier instanceof QubitOperator) {\r\n      const product = this.copy()\r\n      return product.imul(multiplier)\r\n    }\r\n    throw new Error('Object of invalid type cannot multiply with QubitOperator.')\r\n  }\r\n\r\n  /**\r\n   * in-Place add\r\n   * @param {Complex|number|QubitOperator} addend\r\n   * @return {QubitOperator}\r\n   */\r\n  iadd(addend) {\r\n    if (addend instanceof QubitOperator) {\r\n      Object.keys(addend.terms).forEach((key) => {\r\n        const value = this.terms[key]\r\n        const ov = addend.terms[key]\r\n        if (typeof value !== 'undefined') {\r\n          const tmp = math.add(ov, value)\r\n          if (math.abs(tmp) > 0) {\r\n            this.terms[key] = tmp\r\n          } else {\r\n            delete this.terms[key]\r\n          }\r\n        } else {\r\n          this.terms[key] = ov\r\n        }\r\n      })\r\n    } else {\r\n      throw new Error('Cannot add invalid type to QubitOperator.')\r\n    }\r\n    return this\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {Complex|number|QubitOperator} addend\r\n   * @return {QubitOperator}\r\n   */\r\n  add(addend) {\r\n    const inst = this.copy()\r\n    inst.iadd(addend)\r\n    return inst\r\n  }\r\n\r\n  div(divisor) {\r\n    if (isNumeric(divisor)) {\r\n      return this.mul(math.divide(1.0, divisor))\r\n    } else {\r\n      throw new Error('Cannot divide QubitOperator by non-scalar type.')\r\n    }\r\n  }\r\n\r\n  /**\r\n   * in-Place dived by divisor\r\n   * @param {(Complex|number|QubitOperator)} divisor\r\n * @return {QubitOperator}\r\n   */\r\n  idiv(divisor) {\r\n    if (isNumeric(divisor)) {\r\n      return this.imul(math.divide(1.0, divisor))\r\n    } else {\r\n      throw new Error('Cannot divide QubitOperator by non-scalar type.')\r\n    }\r\n  }\r\n\r\n  /**\r\n   * in-Place subtract\r\n   * @param {Complex|number|QubitOperator} subtrahend\r\n   * @return {QubitOperator}\r\n   */\r\n  isub(subtrahend) {\r\n    if (subtrahend instanceof QubitOperator) {\r\n      Object.keys(subtrahend.terms).forEach((key) => {\r\n        const ov = subtrahend.terms[key]\r\n        const v = this.terms[key]\r\n        if (typeof v !== 'undefined') {\r\n          if (math.abs(math.subtract(v, ov)) > 0) {\r\n            this.terms[key] = math.subtract(v, ov)\r\n          } else {\r\n            delete this.terms[key]\r\n          }\r\n        } else {\r\n          this.terms[key] = math.subtract(0, ov)\r\n        }\r\n      })\r\n    } else {\r\n      throw new Error('Cannot subtract invalid type from QubitOperator.')\r\n    }\r\n    return this\r\n  }\r\n\r\n  sub(subtrahend) {\r\n    const ret = this.copy()\r\n    return ret.isub(subtrahend)\r\n  }\r\n\r\n  /**\r\n   * return negative of current qubit operator\r\n   * @return {QubitOperator}\r\n   */\r\n  negative() {\r\n    return this.mul(-1.0)\r\n  }\r\n\r\n  /**\r\n   * return copy of current qubit operator\r\n   * @return {QubitOperator}\r\n   */\r\n  copy() {\r\n    const terms = {}\r\n    Object.assign(terms, this.terms)\r\n    const inst = new QubitOperator([])\r\n    inst.terms = terms\r\n    return inst\r\n  }\r\n\r\n  /**\r\n   * string description of current qubit operator\r\n   * @return {string}\r\n   */\r\n  toString() {\r\n    const keys = Object.keys(this.terms)\r\n    if (keys.length === 0) {\r\n      return '0'\r\n    }\r\n    let string_rep = ''\r\n    keys.forEach((term) => {\r\n      const parts = stringToArray(term)\r\n      const v = this.terms[term]\r\n      let tmp_string = `${v}`\r\n      if (parts.length === 0) {\r\n        tmp_string += ' I'\r\n      }\r\n      parts.forEach((operator) => {\r\n        switch (operator[1]) {\r\n          case 'X':\r\n          case 'Y':\r\n          case 'Z': {\r\n            tmp_string += ` ${operator[1]}${operator[0]}`\r\n            break\r\n          }\r\n          default: {\r\n            throw new Error('invalid operator')\r\n            break\r\n          }\r\n        }\r\n      })\r\n      string_rep += `${tmp_string} +\\n`\r\n    })\r\n\r\n    return string_rep.substring(0, string_rep.length - 3)\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/ops/qubitoperator.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 908,
    "kind": "variable",
    "name": "mc",
    "memberof": "src/ops/qubitoperator.js",
    "static": true,
    "longname": "src/ops/qubitoperator.js~mc",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/ops/qubitoperator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 909,
    "kind": "variable",
    "name": "EQ_TOLERANCE",
    "memberof": "src/ops/qubitoperator.js",
    "static": true,
    "longname": "src/ops/qubitoperator.js~EQ_TOLERANCE",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/ops/qubitoperator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 910,
    "kind": "variable",
    "name": "PAULI_OPERATOR_PRODUCTS",
    "memberof": "src/ops/qubitoperator.js",
    "static": true,
    "longname": "src/ops/qubitoperator.js~PAULI_OPERATOR_PRODUCTS",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/qubitoperator.js",
    "importStyle": "{PAULI_OPERATOR_PRODUCTS}",
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "type": {
      "types": [
        "{\"undefined\": *}"
      ]
    }
  },
  {
    "__docId__": 911,
    "kind": "function",
    "name": "stringToArray",
    "memberof": "src/ops/qubitoperator.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/ops/qubitoperator.js~stringToArray",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/qubitoperator.js",
    "importStyle": "{stringToArray}",
    "description": null,
    "lineNumber": 47,
    "undocument": true,
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 912,
    "kind": "function",
    "name": "checkTerm",
    "memberof": "src/ops/qubitoperator.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/ops/qubitoperator.js~checkTerm",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/ops/qubitoperator.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 60,
    "undocument": true,
    "params": [
      {
        "name": "term",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 913,
    "kind": "class",
    "name": "QubitOperator",
    "memberof": "src/ops/qubitoperator.js",
    "static": true,
    "longname": "src/ops/qubitoperator.js~QubitOperator",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/qubitoperator.js",
    "importStyle": "QubitOperator",
    "description": "A sum of terms acting on qubits, e.g., 0.5 * 'X0 X5' + 0.3 * 'Z1 Z2'.\n\nA term is an operator acting on n qubits and can be represented as:\n\ncoefficent * local_operator[0] x ... x local_operator[n-1]\n\nwhere x is the tensor product. A local operator is a Pauli operator\n('I', 'X', 'Y', or 'Z') which acts on one qubit. In math notation a term\nis, for example, 0.5 * 'X0 X5', which means that a Pauli X operator acts\non qubit 0 and 5, while the identity operator acts on all other qubits.\n\nA QubitOperator represents a sum of terms acting on qubits and overloads\noperations for easy manipulation of these objects by the user.\n\nNote for a QubitOperator to be a Hamiltonian which is a hermitian\noperator, the coefficients of all terms must be real.",
    "examples": [
      "\nhamiltonian = 0.5 * QubitOperator('X0 X5') + 0.3 * QubitOperator('Z0')\n\nAttributes:\nterms (dict): **key**: A term represented by a tuple containing all\nnon-trivial local Pauli operators ('X', 'Y', or 'Z').\nA non-trivial local Pauli operator is specified by a\ntuple with the first element being an integer\nindicating the qubit on which a non-trivial local\noperator acts and the second element being a string,\neither 'X', 'Y', or 'Z', indicating which non-trivial\nPauli operator acts on that qubit. Examples:\n((1, 'X'),) or ((1, 'X'), (4,'Z')) or the identity ().\nThe tuples representing the non-trivial local terms\nare sorted according to the qubit number they act on,\nstarting from 0.\n*value**: Coefficient of this term as a (complex) float"
    ],
    "lineNumber": 117,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "QubitOperator"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 914,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/ops/qubitoperator.js~QubitOperator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/qubitoperator.js~QubitOperator#constructor",
    "access": "public",
    "description": "",
    "examples": [
      "\nham = ((QubitOperator('X0 Y3', 0.5)\n+ 0.6 * QubitOperator('X0 Y3')))\n# Equivalently\nham2 = QubitOperator('X0 Y3', 0.5)\nham2 += 0.6 * QubitOperator('X0 Y3')\n\nNote:\nAdding terms to QubitOperator is faster using += (as this is done\nby in-place addition). Specifying the coefficient in the __init__\nis faster than by multiplying a QubitOperator with a scalar as\ncalls an out-of-place multiplication."
    ],
    "lineNumber": 157,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": "The init function only allows to initialize one term. Additional terms\nhave to be added using += (which is fast) or using + of two\nQubitOperator objects:"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number",
          "Complex"
        ],
        "spread": false,
        "optional": false,
        "name": "coefficient",
        "description": "The coefficient of the\nfirst term of this QubitOperator. Default is 1.0."
      },
      {
        "nullable": null,
        "types": [
          "Array.<Array>",
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "term",
        "description": "(optional, empy array, a array of arrays, or a string):\n1) Default is None which means there are no terms in the\nQubitOperator hence it is the \"zero\" Operator\n2) An empty tuple means there are no non-trivial Pauli\noperators acting on the qubits hence only identities\nwith a coefficient (which by default is 1.0).\n3) A sorted tuple of tuples. The first element of each tuple\nis an integer indicating the qubit on which a non-trivial\nlocal operator acts, starting from zero. The second element\nof each tuple is a string, either 'X', 'Y' or 'Z',\nindicating which local operator acts on that qubit.\n4) A string of the form 'X0 Z2 Y5', indicating an X on\nqubit 0, Z on qubit 2, and Y on qubit 5. The string should\nbe sorted by the qubit number. '' is the identity."
      }
    ],
    "throws": [
      {
        "types": [
          "QubitOperatorError"
        ],
        "description": "Invalid operators provided to QubitOperator."
      }
    ]
  },
  {
    "__docId__": 915,
    "kind": "member",
    "name": "terms",
    "memberof": "src/ops/qubitoperator.js~QubitOperator",
    "static": false,
    "longname": "src/ops/qubitoperator.js~QubitOperator#terms",
    "access": "public",
    "description": null,
    "lineNumber": 159,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 916,
    "kind": "method",
    "name": "compress",
    "memberof": "src/ops/qubitoperator.js~QubitOperator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/qubitoperator.js~QubitOperator#compress",
    "access": "public",
    "description": "Eliminates all terms with coefficients close to zero and removes\nimaginary parts of coefficients that are close to zero.",
    "lineNumber": 199,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "absTolerance",
        "description": "Absolute tolerance, must be at least 0.0"
      }
    ],
    "return": null
  },
  {
    "__docId__": 918,
    "kind": "method",
    "name": "isClose",
    "memberof": "src/ops/qubitoperator.js~QubitOperator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/qubitoperator.js~QubitOperator#isClose",
    "access": "public",
    "description": "Returns true if other (QubitOperator) is close to this.\n\nComparison is done for each term individually. Return true\nif the difference between each term in self and other is\nless than the relative tolerance w.r.t. either other or self\n(symmetric test) or if the difference is less than the absolute\ntolerance.",
    "lineNumber": 226,
    "params": [
      {
        "nullable": null,
        "types": [
          "QubitOperator"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "QubitOperator to compare against."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "realTolerance",
        "description": "Relative tolerance, must be greater than 0.0"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "absTolerance",
        "description": "Absolute tolerance, must be at least 0.0"
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 919,
    "kind": "method",
    "name": "imul",
    "memberof": "src/ops/qubitoperator.js~QubitOperator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/qubitoperator.js~QubitOperator#imul",
    "access": "public",
    "description": "In-place multiply (*=) terms with scalar or QubitOperator.",
    "lineNumber": 259,
    "params": [
      {
        "nullable": null,
        "types": [
          "Complex",
          "number",
          "QubitOperator"
        ],
        "spread": false,
        "optional": false,
        "name": "multiplier",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 921,
    "kind": "method",
    "name": "mul",
    "memberof": "src/ops/qubitoperator.js~QubitOperator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/qubitoperator.js~QubitOperator#mul",
    "access": "public",
    "description": "Return self * multiplier for a scalar, or a QubitOperator.",
    "lineNumber": 343,
    "params": [
      {
        "nullable": null,
        "types": [
          "Complex",
          "number",
          "QubitOperator"
        ],
        "spread": false,
        "optional": false,
        "name": "multiplier",
        "description": "A scalar, or a QubitOperator."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "QubitOperator"
      ],
      "spread": false,
      "description": ""
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "Invalid type cannot be multiply with QubitOperator."
      }
    ]
  },
  {
    "__docId__": 922,
    "kind": "method",
    "name": "iadd",
    "memberof": "src/ops/qubitoperator.js~QubitOperator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/qubitoperator.js~QubitOperator#iadd",
    "access": "public",
    "description": "in-Place add",
    "lineNumber": 356,
    "params": [
      {
        "nullable": null,
        "types": [
          "Complex",
          "number",
          "QubitOperator"
        ],
        "spread": false,
        "optional": false,
        "name": "addend",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "QubitOperator"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 923,
    "kind": "method",
    "name": "add",
    "memberof": "src/ops/qubitoperator.js~QubitOperator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/qubitoperator.js~QubitOperator#add",
    "access": "public",
    "description": "",
    "lineNumber": 383,
    "params": [
      {
        "nullable": null,
        "types": [
          "Complex",
          "number",
          "QubitOperator"
        ],
        "spread": false,
        "optional": false,
        "name": "addend",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "QubitOperator"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 924,
    "kind": "method",
    "name": "div",
    "memberof": "src/ops/qubitoperator.js~QubitOperator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/qubitoperator.js~QubitOperator#div",
    "access": "public",
    "description": null,
    "lineNumber": 389,
    "undocument": true,
    "params": [
      {
        "name": "divisor",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 925,
    "kind": "method",
    "name": "idiv",
    "memberof": "src/ops/qubitoperator.js~QubitOperator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/qubitoperator.js~QubitOperator#idiv",
    "access": "public",
    "description": "in-Place dived by divisor",
    "lineNumber": 402,
    "params": [
      {
        "nullable": null,
        "types": [
          "Complex",
          "number",
          "QubitOperator"
        ],
        "spread": false,
        "optional": false,
        "name": "divisor",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "QubitOperator"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 926,
    "kind": "method",
    "name": "isub",
    "memberof": "src/ops/qubitoperator.js~QubitOperator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/qubitoperator.js~QubitOperator#isub",
    "access": "public",
    "description": "in-Place subtract",
    "lineNumber": 415,
    "params": [
      {
        "nullable": null,
        "types": [
          "Complex",
          "number",
          "QubitOperator"
        ],
        "spread": false,
        "optional": false,
        "name": "subtrahend",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "QubitOperator"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 927,
    "kind": "method",
    "name": "sub",
    "memberof": "src/ops/qubitoperator.js~QubitOperator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/qubitoperator.js~QubitOperator#sub",
    "access": "public",
    "description": null,
    "lineNumber": 436,
    "undocument": true,
    "params": [
      {
        "name": "subtrahend",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 928,
    "kind": "method",
    "name": "negative",
    "memberof": "src/ops/qubitoperator.js~QubitOperator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/qubitoperator.js~QubitOperator#negative",
    "access": "public",
    "description": "return negative of current qubit operator",
    "lineNumber": 445,
    "return": {
      "nullable": null,
      "types": [
        "QubitOperator"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 929,
    "kind": "method",
    "name": "copy",
    "memberof": "src/ops/qubitoperator.js~QubitOperator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/qubitoperator.js~QubitOperator#copy",
    "access": "public",
    "description": "return copy of current qubit operator",
    "lineNumber": 453,
    "return": {
      "nullable": null,
      "types": [
        "QubitOperator"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 930,
    "kind": "method",
    "name": "toString",
    "memberof": "src/ops/qubitoperator.js~QubitOperator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/qubitoperator.js~QubitOperator#toString",
    "access": "public",
    "description": "string description of current qubit operator",
    "lineNumber": 465,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 931,
    "kind": "file",
    "name": "src/ops/qubitoperator.spec.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport {expect} from 'chai'\r\nimport math from 'mathjs'\r\nimport QubitOperator, {PAULI_OPERATOR_PRODUCTS} from './qubitoperator'\r\nimport {tuple} from '../libs/util'\r\n\r\nconst mc = math.complex\r\n\r\ndescribe('qubit operator test', () => {\r\n  it('should test pauli operator product unchanged', () => {\r\n    const correct = {\r\n      [['I', 'I']]: [1.0, 'I'],\r\n      [['I', 'X']]: [1.0, 'X'],\r\n      [['X', 'I']]: [1.0, 'X'],\r\n      [['I', 'Y']]: [1.0, 'Y'],\r\n      [['Y', 'I']]: [1.0, 'Y'],\r\n      [['I', 'Z']]: [1.0, 'Z'],\r\n      [['Z', 'I']]: [1.0, 'Z'],\r\n      [['X', 'X']]: [1.0, 'I'],\r\n      [['Y', 'Y']]: [1.0, 'I'],\r\n      [['Z', 'Z']]: [1.0, 'I'],\r\n      [['X', 'Y']]: [mc(0, 1), 'Z'],\r\n      [['X', 'Z']]: [mc(0, -1), 'Y'],\r\n      [['Y', 'X']]: [mc(0, -1), 'Z'],\r\n      [['Y', 'Z']]: [mc(0, 1), 'X'],\r\n      [['Z', 'X']]: [mc(0, 1), 'Y'],\r\n      [['Z', 'Y']]: [mc(0, -1), 'X']\r\n    }\r\n\r\n    Object.keys(correct).forEach((key) => {\r\n      const value = correct[key]\r\n      const v2 = PAULI_OPERATOR_PRODUCTS[key]\r\n      expect(value).to.deep.equal(v2)\r\n    })\r\n  });\r\n\r\n  it('should test init defaults', () => {\r\n    const op = new QubitOperator()\r\n    expect(Object.keys(op.terms).length).to.equal(0)\r\n  });\r\n\r\n  it('should test_init_tuple', () => {\r\n    const coefficients = [0.5, mc(0, 0.6), 2.303, mc(0, -1)]\r\n    coefficients.forEach((coefficient) => {\r\n      const loc_op = tuple([0, 'X'], [5, 'Y'], [6, 'Z'])\r\n      const qubit_op = new QubitOperator(loc_op, coefficient)\r\n      expect(Object.keys(qubit_op.terms).length).to.equal(1)\r\n      expect(math.equal(qubit_op.terms[loc_op], coefficient)).to.equal(true)\r\n    })\r\n  });\r\n\r\n  it('should test_init_str', () => {\r\n    const qubit_op = new QubitOperator('X0 Y5 Z12', -1.0)\r\n    const correct = tuple([0, 'X'], [5, 'Y'], [12, 'Z'])\r\n    const value = qubit_op.terms[correct]\r\n    expect(typeof value !== 'undefined').to.equal(true)\r\n    expect(value).to.equal(-1.0)\r\n  });\r\n\r\n  it('should test_init_str_identity', () => {\r\n    const qubit_op = new QubitOperator('', 2.0)\r\n    expect(Object.keys(qubit_op.terms).length).to.equal(1)\r\n    const value = qubit_op.terms[[]]\r\n    expect(typeof value !== 'undefined').to.equal(true)\r\n    expect(value).to.equal(2.0)\r\n  });\r\n\r\n  it('should test_init_bad_coefficient', () => {\r\n    expect(() => new QubitOperator('X0', '0.5')).to.throw()\r\n  });\r\n\r\n  it('should test_init_bad_action', () => {\r\n    expect(() => new QubitOperator('Q0')).to.throw()\r\n  });\r\n\r\n  it('should test_init_bad_action_in_tuple', () => {\r\n    expect(() => new QubitOperator(tuple([1, 'Q']))).to.throw()\r\n  });\r\n\r\n  it('should test_init_bad_qubit_num_in_tuple', () => {\r\n    expect(() => new QubitOperator(tuple(['1', 'X']))).to.throw()\r\n  });\r\n\r\n  it('should test_init_bad_tuple', () => {\r\n    expect(() => new QubitOperator(tuple([0, 1, 'X']))).to.throw()\r\n  });\r\n\r\n  it('should test_init_bad_str', () => {\r\n    expect(() => new QubitOperator('X')).to.throw()\r\n  });\r\n\r\n  it('should test_init_bad_qubit_num', () => {\r\n    expect(() => new QubitOperator('X-1')).to.throw()\r\n  });\r\n\r\n  it('should test_isclose_abs_tol', () => {\r\n    let a = new QubitOperator('X0', -1.0)\r\n    let b = new QubitOperator('X0', -1.05)\r\n    let c = new QubitOperator('X0', -1.11)\r\n\r\n    expect(a.isClose(b, 1e-14, 0.1)).to.equal(true)\r\n    expect(a.isClose(c, 1e-14, 0.1)).to.equal(false)\r\n    a = new QubitOperator('X0', mc(0, -1.0))\r\n    b = new QubitOperator('X0', mc(0, -1.05))\r\n    c = new QubitOperator('X0', mc(0, -1.11))\r\n    expect(a.isClose(b, 1e-14, 0.1)).to.equal(true)\r\n    expect(a.isClose(c, 1e-14, 0.1)).to.equal(false)\r\n  });\r\n\r\n  it('should test compress', () => {\r\n    const Complex = mc().constructor\r\n    let a = new QubitOperator('X0', 0.9e-12)\r\n    expect(Object.keys(a.terms).length).to.equal(1)\r\n    a.compress()\r\n    expect(Object.keys(a.terms).length).to.equal(0)\r\n    a = new QubitOperator('X0', mc(1.0, 1))\r\n    a.compress(0.5)\r\n    expect(Object.keys(a.terms).length).to.equal(1)\r\n    Object.keys(a.terms).forEach((key) => {\r\n      const v = a.terms[key]\r\n      expect(math.equal(v, mc(1.0, 1))).to.equal(true)\r\n    })\r\n\r\n    a = new QubitOperator('X0', mc(1.1, 1))\r\n    a.compress(1.0)\r\n\r\n    expect(Object.keys(a.terms).length).to.equal(1)\r\n    Object.keys(a.terms).forEach((key) => {\r\n      const v = a.terms[key]\r\n      expect(math.equal(v, 1.1)).to.equal(true)\r\n    })\r\n\r\n    a = new QubitOperator('X0', mc(1.1, 1)).add(new QubitOperator('X1', mc(0, 1.e-6)))\r\n    a.compress()\r\n    expect(Object.keys(a.terms).length).to.equal(2)\r\n    Object.keys(a.terms).forEach((key) => {\r\n      const v = a.terms[key]\r\n      expect(v instanceof Complex).to.equal(true)\r\n    })\r\n\r\n    a.compress(1.e-5)\r\n    expect(Object.keys(a.terms).length).to.equal(1)\r\n    Object.keys(a.terms).forEach((key) => {\r\n      const v = a.terms[key]\r\n      expect(v instanceof Complex).to.equal(true)\r\n    })\r\n\r\n    a.compress(1.0)\r\n    expect(Object.keys(a.terms).length).to.equal(1)\r\n    Object.keys(a.terms).forEach((key) => {\r\n      const v = a.terms[key]\r\n      expect(typeof v === 'number').to.equal(true)\r\n    })\r\n  });\r\n\r\n  it('should test_isclose_rel_tol', () => {\r\n    const a = new QubitOperator('X0', 1)\r\n    const b = new QubitOperator('X0', 2)\r\n    expect(a.isClose(b, 2.5, 0.1)).to.equal(true)\r\n    // Test symmetry\r\n    expect(a.isClose(b, 1, 0.1)).to.equal(true)\r\n    expect(b.isClose(a, 1, 0.1)).to.equal(true)\r\n  });\r\n\r\n  it('should test_isclose_zero_terms', () => {\r\n    const op = new QubitOperator(tuple([1, 'Y'], [0, 'X']), mc(0, -1)).mul(0)\r\n    expect(op.isClose(new QubitOperator([], 0.0), 1e-12, 1e-12)).to.equal(true)\r\n    expect(new QubitOperator([], 0.0).isClose(op, 1e-12, 1e-12)).to.equal(true)\r\n  });\r\n\r\n  it('should test_isclose_different_terms', () => {\r\n    const a = new QubitOperator(tuple([1, 'Y']), mc(0, -0.1))\r\n    const b = new QubitOperator(tuple([1, 'X']), mc(0, -0.1))\r\n    expect(a.isClose(b, 1e-12, 0.2)).to.equal(true)\r\n    expect(a.isClose(b, 1e-12, 0.05)).to.equal(false)\r\n    expect(b.isClose(a, 1e-12, 0.2)).to.equal(true)\r\n    expect(b.isClose(a, 1e-12, 0.05)).to.equal(false)\r\n  });\r\n\r\n  it('should test_isclose_different_num_terms', () => {\r\n    const a = new QubitOperator(tuple([1, 'Y']), mc(0, -0.1))\r\n    a.iadd(new QubitOperator(tuple([2, 'Y']), mc(0, -0.1)))\r\n    const b = new QubitOperator(tuple([1, 'X']), mc(0, -0.1))\r\n\r\n    expect(a.isClose(b, 1e-12, 0.05)).to.equal(false)\r\n    expect(b.isClose(a, 1e-12, 0.05)).to.equal(false)\r\n  });\r\n\r\n  it('should test_imul_inplace', () => {\r\n    const qubit_op = new QubitOperator('X1')\r\n    const prev_id = qubit_op\r\n    qubit_op.imul(3)\r\n    expect(qubit_op === prev_id).to.equal(true)\r\n  });\r\n\r\n  it('should test_imul_scalar', () => {\r\n    const data = [0.5, mc(0, 0.6), 2.303, mc(0, -1)]\r\n    data.forEach((multiplier) => {\r\n      const loc_op = tuple([1, 'X'], [2, 'Y'])\r\n      const qubit_op = new QubitOperator(loc_op)\r\n      qubit_op.imul(multiplier)\r\n      const v = qubit_op.terms[loc_op]\r\n      expect(math.equal(v, multiplier)).to.equal(true)\r\n    })\r\n  });\r\n\r\n  it('should test_imul_qubit_op', () => {\r\n    const op1 = new QubitOperator(tuple([0, 'Y'], [3, 'X'], [8, 'Z'], [11, 'X']), mc(0, 3.0))\r\n    const op2 = new QubitOperator(tuple([1, 'X'], [3, 'Y'], [8, 'Z']), 0.5)\r\n    op1.imul(op2)\r\n    const correct_coefficient = math.multiply(math.multiply(mc(0, 1.0), mc(0, 3.0)), 0.5)\r\n    const correct_term = tuple([0, 'Y'], [1, 'X'], [3, 'Z'], [11, 'X'])\r\n\r\n    expect(Object.keys(op1.terms).length).to.equal(1)\r\n    const v = op1.terms[correct_term]\r\n    expect(math.equal(v, correct_coefficient)).to.equal(true)\r\n  });\r\n\r\n  it('should test_imul_qubit_op_2', () => {\r\n    const op3 = new QubitOperator(tuple([1, 'Y'], [0, 'X']), mc(0, -1))\r\n    const op4 = new QubitOperator(tuple([1, 'Y'], [0, 'X'], [2, 'Z']), -1.5)\r\n\r\n    op3.imul(op4)\r\n    op4.imul(op3)\r\n    const v = op3.terms[[2, 'Z']]\r\n    expect(!!v).to.equal(true)\r\n    expect(math.equal(v, mc(0, 1.5))).to.equal(true)\r\n  });\r\n\r\n  it('should test_imul_bidir', () => {\r\n    const op_a = new QubitOperator(tuple([1, 'Y'], [0, 'X']), mc(0, -1))\r\n    const op_b = new QubitOperator(tuple([1, 'Y'], [0, 'X'], [2, 'Z']), -1.5)\r\n    op_a.imul(op_b)\r\n    op_b.imul(op_a)\r\n\r\n    const v = op_a.terms[[2, 'Z']]\r\n    expect(math.equal(v, mc(0, 1.5))).to.equal(true)\r\n    const c = op_b.terms[[[0, 'X'], [1, 'Y']]]\r\n    expect(math.equal(c, mc(0, -2.25))).to.equal(true)\r\n  });\r\n\r\n  it('should test_imul_bad_multiplier', () => {\r\n    const op = new QubitOperator(tuple([1, 'Y'], [0, 'X']), mc(0, -1))\r\n    expect(() => op.imul('1')).to.throw()\r\n  });\r\n\r\n  it('should test_mul_by_scalarzero', () => {\r\n    const op = new QubitOperator(tuple([1, 'Y'], [0, 'X']), mc(0, -1)).mul(0)\r\n    const key = [[0, 'X'], [1, 'Y']]\r\n    const v = op.terms[key]\r\n    expect(math.equal(v, mc(0, 0))).to.equal(true)\r\n  });\r\n\r\n  it('should test_mul_bad_multiplier', () => {\r\n    let op = new QubitOperator(tuple([1, 'Y'], [0, 'X']), mc(0, -1))\r\n    expect(() => op = op.mul('0.5')).to.throw()\r\n  });\r\n\r\n  it('should test_mul_out_of_place', () => {\r\n    const op1 = new QubitOperator(tuple([0, 'Y'], [3, 'X'], [8, 'Z'], [11, 'X']), mc(0, 3.0))\r\n    const op2 = new QubitOperator(tuple([1, 'X'], [3, 'Y'], [8, 'Z']), 0.5)\r\n    const op3 = op1.mul(op2)\r\n    const correct_coefficient = math.multiply(math.multiply(mc(0, 1), mc(0, 3)), 0.5)\r\n    const correct_term = tuple([0, 'Y'], [1, 'X'], [3, 'Z'], [11, 'X'])\r\n\r\n    expect(op1.isClose(new QubitOperator(tuple([0, 'Y'], [3, 'X'], [8, 'Z'], [11, 'X']), mc(0, 3.0)))).to.equal(true)\r\n    expect(op2.isClose(new QubitOperator(tuple([1, 'X'], [3, 'Y'], [8, 'Z']), 0.5))).to.equal(true)\r\n    expect(op3.isClose(new QubitOperator(correct_term, correct_coefficient))).to.equal(true)\r\n  });\r\n\r\n  it('should test_mul_npfloat64', () => {\r\n    const op = new QubitOperator(tuple([1, 'X'], [3, 'Y']), 0.5)\r\n    const res = op.mul(0.5)\r\n    expect(res.isClose(new QubitOperator(tuple([1, 'X'], [3, 'Y']), 0.5 * 0.5))).to.equal(true)\r\n  });\r\n\r\n  it('should test_mul_multiple_terms', () => {\r\n    const op = new QubitOperator(tuple([1, 'X'], [3, 'Y'], [8, 'Z']), 0.5)\r\n    op.iadd(new QubitOperator(tuple([1, 'Z'], [3, 'X'], [8, 'Z']), 1.2))\r\n    op.iadd(new QubitOperator(tuple([1, 'Z'], [3, 'Y'], [9, 'Z']), mc(0, 1.4)))\r\n    const res = op.mul(op)\r\n    const correct = new QubitOperator([], math.add((0.5 ** 2) + (1.2 ** 2), math.pow(mc(0, 1.4), 2)))\r\n    correct.iadd(new QubitOperator(tuple([1, 'Y'], [3, 'Z']), math.multiply(math.multiply(mc(0, 2), mc(0, 1)), 0.6)))\r\n    expect(res.isClose(correct)).to.equal(true)\r\n  });\r\n\r\n  it('should test_truediv_and_div', () => {\r\n    const divisors = [0.5, mc(0, 0.6), 2.303, mc(0, -1), 2]\r\n    divisors.forEach((divisor) => {\r\n      const op = new QubitOperator(tuple([1, 'X'], [3, 'Y'], [8, 'Z']), 0.5)\r\n      const op2 = op.copy()\r\n      const original = op.copy()\r\n      const res = op.div(divisor)\r\n      const correct = op.mul(math.divide(1.0, divisor))\r\n\r\n      expect(res.isClose(correct)).to.equal(true)\r\n      // Test if done out of place\r\n      expect(op.isClose(original)).to.equal(true)\r\n      expect(op2.isClose(original)).to.equal(true)\r\n    })\r\n  });\r\n\r\n  it('should test_truediv_bad_divisor', () => {\r\n    const op = new QubitOperator(tuple([1, 'X'], [3, 'Y'], [8, 'Z']), 0.5)\r\n    expect(() => op.div('0.5')).to.throw()\r\n  });\r\n\r\n  it('should test_itruediv_and_idiv', () => {\r\n    const divisors = [0.5, mc(0, 0.6), 2.303, mc(0, -1), 2]\r\n    divisors.forEach((divisor) => {\r\n      const op = new QubitOperator(tuple([1, 'X'], [3, 'Y'], [8, 'Z']), 0.5)\r\n      const op2 = op.copy()\r\n      const original = op.copy()\r\n      const correct = op.mul(math.divide(1.0, divisor))\r\n\r\n      op.idiv(divisor)\r\n      op2.idiv(divisor)\r\n\r\n      expect(op.isClose(correct)).to.equal(true)\r\n      expect(op2.isClose(correct)).to.equal(true)\r\n\r\n      // Test if done out of place\r\n      expect(op.isClose(original)).to.equal(false)\r\n      expect(op2.isClose(original)).to.equal(false)\r\n    })\r\n  });\r\n\r\n  it('should test_itruediv_bad_divisor', () => {\r\n    const op = new QubitOperator(tuple([1, 'X'], [3, 'Y'], [8, 'Z']), 0.5)\r\n    expect(() => op.idiv('0.5')).to.throw()\r\n  });\r\n\r\n  it('should test_iadd_cancellation', () => {\r\n    const term_a = tuple([1, 'X'], [3, 'Y'], [8, 'Z'])\r\n    const term_b = tuple([1, 'X'], [3, 'Y'], [8, 'Z'])\r\n    const a = new QubitOperator(term_a, 1.0)\r\n    a.iadd(new QubitOperator(term_b, -1.0))\r\n    expect(Object.keys(a.terms).length).to.equal(0)\r\n  });\r\n\r\n  it('should test_iadd_different_term', () => {\r\n    const term_a = tuple([1, 'X'], [3, 'Y'], [8, 'Z'])\r\n    const term_b = tuple([1, 'Z'], [3, 'Y'], [8, 'Z'])\r\n    const a = new QubitOperator(term_a, 1.0)\r\n    a.iadd(new QubitOperator(term_b, 0.5))\r\n    expect(Object.keys(a.terms).length).to.equal(2)\r\n    expect(a.terms[term_a]).to.be.closeTo(1.0, 1e-12)\r\n    expect(a.terms[term_b]).to.be.closeTo(0.5, 1e-12)\r\n\r\n    a.iadd(new QubitOperator(term_b, 0.5))\r\n\r\n    expect(Object.keys(a.terms).length).to.equal(2)\r\n    expect(a.terms[term_a]).to.be.closeTo(1.0, 1e-12)\r\n    expect(a.terms[term_b]).to.be.closeTo(1.0, 1e-12)\r\n  });\r\n\r\n  it('should test_iadd_bad_addend', () => {\r\n    const op = new QubitOperator(tuple([1, 'X'], [3, 'Y'], [8, 'Z']), 0.5)\r\n    expect(() => op.iadd('0.5')).to.throw()\r\n  });\r\n\r\n  it('should test add', () => {\r\n    const term_a = tuple([1, 'X'], [3, 'Y'], [8, 'Z'])\r\n    const term_b = tuple([1, 'Z'], [3, 'Y'], [8, 'Z'])\r\n    const a = new QubitOperator(term_a, 1.0)\r\n    const b = new QubitOperator(term_b, 0.5)\r\n    const res = a.add(b).add(b)\r\n    expect(Object.keys(res.terms).length).to.equal(2)\r\n    expect(res.terms[term_a]).to.be.closeTo(1.0, 1e-12)\r\n    expect(res.terms[term_b]).to.be.closeTo(1.0, 1e-12)\r\n    // Test out of place\r\n    expect(a.isClose(new QubitOperator(term_a, 1.0))).to.equal(true)\r\n    expect(b.isClose(new QubitOperator(term_b, 0.5))).to.equal(true)\r\n  });\r\n\r\n  it('should test_add_bad_addend', () => {\r\n    const op = new QubitOperator(tuple([1, 'X'], [3, 'Y'], [8, 'Z']), 0.5)\r\n    expect(() => op.add('0.5')).to.throw()\r\n  });\r\n\r\n  it('should test sub', () => {\r\n    const term_a = tuple([1, 'X'], [3, 'Y'], [8, 'Z'])\r\n    const term_b = tuple([1, 'Z'], [3, 'Y'], [8, 'Z'])\r\n    const a = new QubitOperator(term_a, 1.0)\r\n    const b = new QubitOperator(term_b, 0.5)\r\n    const res = a.sub(b)\r\n    expect(Object.keys(res.terms).length).to.equal(2)\r\n    expect(res.terms[term_a]).to.be.closeTo(1.0, 1e-12)\r\n    expect(res.terms[term_b]).to.be.closeTo(-0.5, 1e-12)\r\n\r\n    const res2 = b.sub(a)\r\n    expect(Object.keys(res2.terms).length).to.equal(2)\r\n    expect(res2.terms[term_a]).to.be.closeTo(-1.0, 1e-12)\r\n    expect(res2.terms[term_b]).to.be.closeTo(0.5, 1e-12)\r\n  });\r\n\r\n  it('should test_sub_bad_addend', () => {\r\n    const op = new QubitOperator(tuple([1, 'X'], [3, 'Y'], [8, 'Z']), 0.5)\r\n    expect(() => op.sub('0.5')).to.throw()\r\n  });\r\n\r\n  it('should test_isub_different_term', () => {\r\n    const term_a = tuple([1, 'X'], [3, 'Y'], [8, 'Z'])\r\n    const term_b = tuple([1, 'Z'], [3, 'Y'], [8, 'Z'])\r\n    const a = new QubitOperator(term_a, 1.0)\r\n    a.isub(new QubitOperator(term_b, 0.5))\r\n    expect(Object.keys(a.terms).length).to.equal(2)\r\n    expect(a.terms[term_a]).to.be.closeTo(1.0, 1e-12)\r\n    expect(a.terms[term_b]).to.be.closeTo(-0.5, 1e-12)\r\n\r\n    a.isub(new QubitOperator(term_b, 0.5))\r\n    expect(Object.keys(a.terms).length).to.equal(2)\r\n    expect(a.terms[term_a]).to.be.closeTo(1.0, 1e-12)\r\n    expect(a.terms[term_b]).to.be.closeTo(-1, 1e-12)\r\n  });\r\n\r\n  it('should test_isub_bad_addend', () => {\r\n    const op = new QubitOperator(tuple([1, 'X'], [3, 'Y'], [8, 'Z']), 0.5)\r\n    expect(() => op.isub('0.5')).to.throw()\r\n  });\r\n\r\n  it('should test_neg', () => {\r\n    const op = new QubitOperator(tuple([1, 'X'], [3, 'Y'], [8, 'Z']), 0.5)\r\n    op.negative()\r\n    // out of place\r\n    expect(op.isClose(new QubitOperator(tuple([1, 'X'], [3, 'Y'], [8, 'Z']), 0.5))).to.equal(true)\r\n    const correct = op.mul(-1)\r\n    expect(correct.isClose(op.negative())).to.equal(true)\r\n  });\r\n\r\n  it('should test to string', () => {\r\n    const op = new QubitOperator(tuple([1, 'X'], [3, 'Y'], [8, 'Z']), 0.5)\r\n    expect(op.toString()).to.equal('0.5 X1 Y3 Z8')\r\n    const op2 = new QubitOperator([], 2)\r\n    expect(op2.toString()).to.equal('2 I')\r\n  });\r\n\r\n  it('should test_str_empty', () => {\r\n    const op = new QubitOperator()\r\n    expect(op.toString()).to.equal('0')\r\n  });\r\n\r\n  it('should test_str_multiple_terms', () => {\r\n    const op = new QubitOperator(tuple([1, 'X'], [3, 'Y'], [8, 'Z']), 0.5)\r\n    op.iadd(new QubitOperator(tuple([1, 'Y'], [3, 'Y'], [8, 'Z']), 0.6))\r\n    expect(op.toString() === '0.5 X1 Y3 Z8 +\\n0.6 Y1 Y3 Z8' || op.toString() === '0.6 Y1 Y3 Z8 +\\n0.5 X1 Y3 Z8').to.equal(true)\r\n    const op2 = new QubitOperator([], 2)\r\n    expect(op2.toString()).to.equal('2 I')\r\n  });\r\n})\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/ops/qubitoperator.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 932,
    "kind": "variable",
    "name": "mc",
    "memberof": "src/ops/qubitoperator.spec.js",
    "static": true,
    "longname": "src/ops/qubitoperator.spec.js~mc",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/ops/qubitoperator.spec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 933,
    "kind": "file",
    "name": "src/ops/shortcuts.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport {C} from './metagates'\r\nimport {Rz, NOT, Z} from './gates'\r\n\r\nexport function CRz(angle) {\r\n  return C(new Rz(angle), 1)\r\n}\r\n\r\nexport const CNOT = C(NOT)\r\n\r\nexport const CX = CNOT\r\n\r\nexport const CZ = C(Z)\r\n\r\nexport const Toffoli = C(CNOT)\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/ops/shortcuts.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 934,
    "kind": "function",
    "name": "CRz",
    "memberof": "src/ops/shortcuts.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/ops/shortcuts.js~CRz",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/shortcuts.js",
    "importStyle": "{CRz}",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "params": [
      {
        "name": "angle",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 935,
    "kind": "variable",
    "name": "CNOT",
    "memberof": "src/ops/shortcuts.js",
    "static": true,
    "longname": "src/ops/shortcuts.js~CNOT",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/shortcuts.js",
    "importStyle": "{CNOT}",
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 936,
    "kind": "variable",
    "name": "CX",
    "memberof": "src/ops/shortcuts.js",
    "static": true,
    "longname": "src/ops/shortcuts.js~CX",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/shortcuts.js",
    "importStyle": "{CX}",
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 937,
    "kind": "variable",
    "name": "CZ",
    "memberof": "src/ops/shortcuts.js",
    "static": true,
    "longname": "src/ops/shortcuts.js~CZ",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/shortcuts.js",
    "importStyle": "{CZ}",
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 938,
    "kind": "variable",
    "name": "Toffoli",
    "memberof": "src/ops/shortcuts.js",
    "static": true,
    "longname": "src/ops/shortcuts.js~Toffoli",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/shortcuts.js",
    "importStyle": "{Toffoli}",
    "description": null,
    "lineNumber": 30,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 939,
    "kind": "file",
    "name": "src/ops/shortcuts.spec.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport {expect} from 'chai'\r\nimport {CRz} from './shortcuts'\r\nimport {Rz} from './gates'\r\nimport {ControlledGate} from './metagates'\r\n\r\ndescribe('shortcuts test', () => {\r\n  it('should test crz', () => {\r\n    const gate = new CRz(0.5)\r\n    expect(gate instanceof ControlledGate).to.equal(true)\r\n    expect(gate.gate.equal(new Rz(0.5))).to.equal(true)\r\n    expect(gate.n).to.equal(1)\r\n  });\r\n})\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/ops/shortcuts.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 940,
    "kind": "file",
    "name": "src/ops/timeevolution.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport assert from 'assert'\r\nimport math from 'mathjs'\r\nimport {BasicGate} from './basics'\r\nimport QubitOperator, {stringToArray} from './qubitoperator'\r\nimport {setEqual, isComplex, isNumeric} from '../libs/polyfill'\r\nimport {Ph} from './gates'\r\nimport {NotMergeable} from \"../meta/error\";\r\n\r\n/**\r\n * @class TimeEvolution\r\n * @desc\r\nGate for time evolution under a Hamiltonian (QubitOperator object).\r\n\r\nThis gate is the unitary time evolution propagator:\r\n    exp(-i * H * t),\r\n        where H is the Hamiltonian of the system and t is the time. Note that -i\r\nfactor is stored implicitely.\r\n\r\n    @example\r\n\r\nwavefunction = eng.allocateQureg(5)\r\nhamiltonian = 0.5 * QubitOperator(\"X0 Z1 Y5\")\r\n# Apply exp(-i * H * t) to the wavefunction:\r\n    TimeEvolution(time=2.0, hamiltonian=hamiltonian) | wavefunction\r\n\r\nAttributes:\r\n    time(float, int): time t\r\nhamiltonian(QubitOperator): hamiltonaian H\r\n */\r\nexport default class TimeEvolution extends BasicGate {\r\n  /**\r\n   * @constructor\r\n    Note:\r\nThe hamiltonian must be hermitian and therefore only terms with\r\n    real coefficients are allowed.\r\n    Coefficients are internally converted to float.\r\n\r\n    @param {number} time time to evolve under (can be negative).\r\n    @param {QubitOperator} hamiltonian hamiltonian to evolve under.\r\n\r\n    @throws {Error} If time is not a numeric type and hamiltonian is not a QubitOperator.\r\n    @throws {NotHermitianOperatorError} If the input hamiltonian is not hermitian (only real coefficients).\r\n   */\r\n  constructor(time, hamiltonian) {\r\n    super()\r\n    if (typeof time !== 'number') {\r\n      throw new Error('time needs to be a (real) numeric type.')\r\n    }\r\n\r\n    if (!(hamiltonian instanceof QubitOperator)) {\r\n      throw new Error('hamiltonian needs to be QubitOperator object.')\r\n    }\r\n\r\n    this.time = time\r\n    this.hamiltonian = hamiltonian.copy()\r\n    Object.keys(hamiltonian.terms).forEach((term) => {\r\n      const item = this.hamiltonian.terms[term]\r\n      if (isNumeric(item)) {\r\n        if (isComplex(item)) {\r\n          if (math.im(item) === 0) {\r\n            this.hamiltonian.terms[term] = math.re(item)\r\n          } else {\r\n            throw new Error('hamiltonian must be '\r\n                + 'hermitian and hence only '\r\n                + 'have real coefficients.')\r\n          }\r\n        } else {\r\n          this.hamiltonian.terms[term] = item\r\n        }\r\n      } else {\r\n        throw new Error('hamiltonian must be '\r\n        + 'hermitian and hence only '\r\n        + 'have real coefficients.')\r\n      }\r\n    })\r\n  }\r\n\r\n  getInverse() {\r\n    return new TimeEvolution(-this.time, this.hamiltonian)\r\n  }\r\n\r\n  /**\r\n  Return self merged with another TimeEvolution gate if possible.\r\n\r\n    Two TimeEvolution gates are merged if:\r\n1) both have the same terms\r\n2) the proportionality factor for each of the terms\r\nmust have relative error <= 1e-9 compared to the\r\nproportionality factors of the other terms.\r\n\r\n    Note:\r\nWhile one could merge gates for which both hamiltonians commute,\r\n    we are not doing this as in general the resulting gate would have\r\nto be decomposed again.\r\n\r\n    Note:\r\nWe are not comparing if terms are proportional to each other with\r\n    an absolute tolerance. It is up to the user to remove terms close\r\nto zero because we cannot choose a suitable absolute error which\r\nworks for everyone. Use, e.g., a decomposition rule for that.\r\n\r\n   @param {TimeEvolution} other TimeEvolution gate\r\n\r\n   @throws {NotMergeable} If the other gate is not a TimeEvolution gate or\r\n    hamiltonians are not suitable for merging.\r\n\r\n   @return {TimeEvolution} New TimeEvolution gate equivalent to the two merged gates.\r\n   */\r\n  getMerged(other) {\r\n    const rel_tol = 1e-9\r\n    if (!(other instanceof TimeEvolution)) {\r\n      throw new NotMergeable('Cannot merge these two gates.')\r\n    }\r\n    const k1 = Object.keys(this.hamiltonian.terms)\r\n    const k2 = Object.keys(other.hamiltonian.terms)\r\n    if (setEqual(new Set(k1), new Set(k2))) {\r\n      let factor\r\n      Object.keys(this.hamiltonian.terms).forEach((term) => {\r\n        const v1 = this.hamiltonian.terms[term]\r\n        const v2 = other.hamiltonian.terms[term]\r\n        if (typeof factor === 'undefined') {\r\n          factor = math.divide(v1, v2)\r\n        } else {\r\n          const tmp = math.divide(v1, v2)\r\n          if (math.abs(math.subtract(factor, tmp)) > rel_tol * math.max(math.abs(factor), math.abs(tmp))) {\r\n            throw new NotMergeable('Cannot merge these two gates.')\r\n          }\r\n        }\r\n      })\r\n\r\n      const newTime = this.time + other.time / factor\r\n      return new TimeEvolution(newTime, this.hamiltonian)\r\n    } else {\r\n      throw new NotMergeable('Cannot merge these two gates.')\r\n    }\r\n  }\r\n\r\n  /**\r\n  Operator| overload which enables the following syntax:\r\n\r\n   @example\r\n\r\nTimeEvolution(...) | qureg\r\nTimeEvolution(...) | (qureg,)\r\nTimeEvolution(...) | qubit\r\nTimeEvolution(...) | (qubit,)\r\n\r\nUnlike other gates, this gate is only allowed to be applied to one\r\nquantum register or one qubit.\r\n\r\n    @example\r\n\r\nwavefunction = eng.allocateQureg(5)\r\nhamiltonian = QubitOperator(\"X1 Y3\", 0.5)\r\nTimeEvolution(time=2.0, hamiltonian=hamiltonian) | wavefunction\r\n\r\nWhile in the above example the TimeEvolution gate is applied to 5\r\nqubits, the hamiltonian of this TimeEvolution gate acts only\r\nnon-trivially on the two qubits wavefunction[1] and wavefunction[3].\r\n    Therefore, the operator| will rescale the indices in the hamiltonian\r\nand sends the equivalent of the following new gate to the MainEngine:\r\n\r\n   @example\r\n\r\nh = QubitOperator(\"X0 Y1\", 0.5)\r\nTimeEvolution(2.0, h) | [wavefunction[1], wavefunction[3]]\r\n\r\nwhich is only a two qubit gate.\r\n\r\n    @param {Array.<Qubit>|Qureg|Qubit} qubits one Qubit object, one list of Qubit objects, one Qureg\r\n      object, or a tuple of the former three cases.\r\n  */\r\n  or(qubits) {\r\n    // Check that input is only one qureg or one qubit\r\n    qubits = BasicGate.makeTupleOfQureg(qubits)\r\n    if (qubits.length !== 1) {\r\n      throw new Error('Only one qubit or qureg allowed.')\r\n    }\r\n    // Check that if hamiltonian has only an identity term,\r\n    // apply a global phase\r\n    const keys = Object.keys(this.hamiltonian.terms)\r\n    const v = this.hamiltonian.terms[[]]\r\n    if (keys.length === 1 && typeof v !== 'undefined') {\r\n      new Ph(math.multiply(-this.time, v)).or(qubits[0][0])\r\n      return\r\n    }\r\n    const num_qubits = qubits[0].length\r\n    let non_trivial_qubits = new Set()\r\n\r\n    keys.forEach(key => {\r\n      const term = stringToArray(key)\r\n      term.forEach(([index, action]) => {\r\n        non_trivial_qubits.add(index)\r\n      })\r\n    })\r\n\r\n    if (Math.max(...non_trivial_qubits) >= num_qubits) {\r\n      throw new Error('hamiltonian acts on more qubits than the gate is applied to.')\r\n    }\r\n    // create new TimeEvolution gate with rescaled qubit indices in\r\n    // this.hamiltonian which are ordered from\r\n    // 0,...,len(non_trivial_qubits) - 1\r\n    const new_index = {}\r\n    non_trivial_qubits = Array.from(non_trivial_qubits).sort()\r\n\r\n    non_trivial_qubits.forEach((looper, i) => {\r\n      new_index[looper] = i\r\n    })\r\n\r\n    const new_hamiltonian = new QubitOperator()\r\n    assert(Object.keys(new_hamiltonian.terms).length === 0, '')\r\n\r\n    Object.keys(this.hamiltonian.terms).forEach((term) => {\r\n      const parts = stringToArray(term)\r\n      const newTerm = parts.map(([index, action]) => [new_index[index], action])\r\n      new_hamiltonian.terms[newTerm] = this.hamiltonian.terms[term]\r\n    })\r\n\r\n    const new_gate = new TimeEvolution(this.time, new_hamiltonian)\r\n    const new_qubits = non_trivial_qubits.map((looper) => qubits[0][looper])\r\n    // Apply new gate\r\n    const cmd = new_gate.generateCommand(new_qubits)\r\n    cmd.apply()\r\n  }\r\n\r\n  equal() {\r\n    throw new Error('Not implemented')\r\n  }\r\n\r\n  toString() {\r\n    return `exp(${-this.time}j * (${this.hamiltonian}))`\r\n  }\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/ops/timeevolution.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 941,
    "kind": "class",
    "name": "TimeEvolution",
    "memberof": "src/ops/timeevolution.js",
    "static": true,
    "longname": "src/ops/timeevolution.js~TimeEvolution",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/timeevolution.js",
    "importStyle": "TimeEvolution",
    "description": "Gate for time evolution under a Hamiltonian (QubitOperator object).\n\nThis gate is the unitary time evolution propagator:\nexp(-i * H * t),\nwhere H is the Hamiltonian of the system and t is the time. Note that -i\nfactor is stored implicitely.",
    "examples": [
      "\nwavefunction = eng.allocateQureg(5)\nhamiltonian = 0.5 * QubitOperator(\"X0 Z1 Y5\")\n# Apply exp(-i * H * t) to the wavefunction:\nTimeEvolution(time=2.0, hamiltonian=hamiltonian) | wavefunction\n\nAttributes:\ntime(float, int): time t\nhamiltonian(QubitOperator): hamiltonaian H"
    ],
    "lineNumber": 46,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "TimeEvolution"
      }
    ],
    "interface": false,
    "extends": [
      "src/ops/basics.js~BasicGate"
    ]
  },
  {
    "__docId__": 942,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/ops/timeevolution.js~TimeEvolution",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/timeevolution.js~TimeEvolution#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 60,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": "Note:\nThe hamiltonian must be hermitian and therefore only terms with\nreal coefficients are allowed.\nCoefficients are internally converted to float."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "time",
        "description": "time to evolve under (can be negative)."
      },
      {
        "nullable": null,
        "types": [
          "QubitOperator"
        ],
        "spread": false,
        "optional": false,
        "name": "hamiltonian",
        "description": "hamiltonian to evolve under."
      }
    ],
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If time is not a numeric type and hamiltonian is not a QubitOperator."
      },
      {
        "types": [
          "NotHermitianOperatorError"
        ],
        "description": "If the input hamiltonian is not hermitian (only real coefficients)."
      }
    ]
  },
  {
    "__docId__": 943,
    "kind": "member",
    "name": "time",
    "memberof": "src/ops/timeevolution.js~TimeEvolution",
    "static": false,
    "longname": "src/ops/timeevolution.js~TimeEvolution#time",
    "access": "public",
    "description": null,
    "lineNumber": 70,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 944,
    "kind": "member",
    "name": "hamiltonian",
    "memberof": "src/ops/timeevolution.js~TimeEvolution",
    "static": false,
    "longname": "src/ops/timeevolution.js~TimeEvolution#hamiltonian",
    "access": "public",
    "description": null,
    "lineNumber": 71,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 945,
    "kind": "method",
    "name": "getInverse",
    "memberof": "src/ops/timeevolution.js~TimeEvolution",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/timeevolution.js~TimeEvolution#getInverse",
    "access": "public",
    "description": null,
    "lineNumber": 94,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 946,
    "kind": "method",
    "name": "getMerged",
    "memberof": "src/ops/timeevolution.js~TimeEvolution",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/timeevolution.js~TimeEvolution#getMerged",
    "access": "public",
    "description": "Return self merged with another TimeEvolution gate if possible.\n\nTwo TimeEvolution gates are merged if:\n1) both have the same terms\n2) the proportionality factor for each of the terms\nmust have relative error <= 1e-9 compared to the\nproportionality factors of the other terms.\n\nNote:\nWhile one could merge gates for which both hamiltonians commute,\nwe are not doing this as in general the resulting gate would have\nto be decomposed again.\n\nNote:\nWe are not comparing if terms are proportional to each other with\nan absolute tolerance. It is up to the user to remove terms close\nto zero because we cannot choose a suitable absolute error which\nworks for everyone. Use, e.g., a decomposition rule for that.",
    "lineNumber": 125,
    "params": [
      {
        "nullable": null,
        "types": [
          "TimeEvolution"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "TimeEvolution gate"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "TimeEvolution"
      ],
      "spread": false,
      "description": "New TimeEvolution gate equivalent to the two merged gates."
    },
    "throws": [
      {
        "types": [
          "NotMergeable"
        ],
        "description": "If the other gate is not a TimeEvolution gate or\nhamiltonians are not suitable for merging."
      }
    ]
  },
  {
    "__docId__": 947,
    "kind": "method",
    "name": "or",
    "memberof": "src/ops/timeevolution.js~TimeEvolution",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/timeevolution.js~TimeEvolution#or",
    "access": "public",
    "description": "Operator| overload which enables the following syntax:",
    "examples": [
      "\nTimeEvolution(...) | qureg\nTimeEvolution(...) | (qureg,)\nTimeEvolution(...) | qubit\nTimeEvolution(...) | (qubit,)\n\nUnlike other gates, this gate is only allowed to be applied to one\nquantum register or one qubit.",
      "\nwavefunction = eng.allocateQureg(5)\nhamiltonian = QubitOperator(\"X1 Y3\", 0.5)\nTimeEvolution(time=2.0, hamiltonian=hamiltonian) | wavefunction\n\nWhile in the above example the TimeEvolution gate is applied to 5\nqubits, the hamiltonian of this TimeEvolution gate acts only\nnon-trivially on the two qubits wavefunction[1] and wavefunction[3].\nTherefore, the operator| will rescale the indices in the hamiltonian\nand sends the equivalent of the following new gate to the MainEngine:",
      "\nh = QubitOperator(\"X0 Y1\", 0.5)\nTimeEvolution(2.0, h) | [wavefunction[1], wavefunction[3]]\n\nwhich is only a two qubit gate."
    ],
    "lineNumber": 189,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array.<Qubit>",
          "Qureg",
          "Qubit"
        ],
        "spread": false,
        "optional": false,
        "name": "qubits",
        "description": "one Qubit object, one list of Qubit objects, one Qureg\nobject, or a tuple of the former three cases."
      }
    ],
    "return": null
  },
  {
    "__docId__": 948,
    "kind": "method",
    "name": "equal",
    "memberof": "src/ops/timeevolution.js~TimeEvolution",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/timeevolution.js~TimeEvolution#equal",
    "access": "public",
    "description": null,
    "lineNumber": 242,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 949,
    "kind": "method",
    "name": "toString",
    "memberof": "src/ops/timeevolution.js~TimeEvolution",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/ops/timeevolution.js~TimeEvolution#toString",
    "access": "public",
    "description": null,
    "lineNumber": 246,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 950,
    "kind": "file",
    "name": "src/ops/timeevolution.spec.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport {expect} from 'chai'\r\nimport math from 'mathjs'\r\nimport QubitOperator from './qubitoperator'\r\nimport TimeEvolution from './timeevolution'\r\nimport {tuple} from '../libs/util'\r\nimport {BasicGate} from './basics'\r\nimport MainEngine from '../cengines/main'\r\nimport {DummyEngine} from '../cengines/testengine'\r\nimport {Ph} from './gates';\r\n\r\nconst mc = math.complex\r\n\r\ndescribe('time evolution test', () => {\r\n  it('should test_time_evolution_init_int_time', () => {\r\n    const coefficients = [0.5, 2.303]\r\n    coefficients.forEach((coefficient) => {\r\n      const hamiltonian = new QubitOperator('X0 Z1').mul(coefficient)\r\n      hamiltonian.iadd(new QubitOperator('Z2', 0.5))\r\n      const gate1 = new TimeEvolution(2, hamiltonian)\r\n      expect(gate1.hamiltonian.isClose(hamiltonian)).to.equal(true)\r\n      expect(gate1.time).to.equal(2)\r\n    })\r\n  });\r\n\r\n  it('should test_init_float_time', () => {\r\n    const coefficients = [0.5, 2.303]\r\n    coefficients.forEach((coefficient) => {\r\n      const hamiltonian = new QubitOperator('X0 Z1').mul(coefficient)\r\n      hamiltonian.iadd(new QubitOperator('Z2', 0.5))\r\n      const gate1 = new TimeEvolution(2.1, hamiltonian)\r\n      expect(gate1.hamiltonian.isClose(hamiltonian)).to.equal(true)\r\n      expect(gate1.time).to.equal(2.1)\r\n    })\r\n  });\r\n\r\n  it('should test_init_makes_copy', () => {\r\n    let hamiltonian = new QubitOperator('X0 Z1')\r\n    const gate = new TimeEvolution(2.1, hamiltonian)\r\n    hamiltonian = undefined\r\n    expect(typeof gate.hamiltonian !== 'undefined').to.equal(true)\r\n  });\r\n\r\n  it('should test_init_bad_time', () => {\r\n    const hamiltonian = new QubitOperator('Z2', 0.5)\r\n    expect(() => new TimeEvolution(mc(0, 1.5), hamiltonian)).to.throw()\r\n  });\r\n\r\n  it('should test_init_bad_hamiltonian', () => {\r\n    expect(() => new TimeEvolution(2, 'something else')).to.throw()\r\n  });\r\n\r\n  it('should test_init_not_hermitian', () => {\r\n    const hamiltonian = new QubitOperator('Z2', mc(0, 1e-12))\r\n    expect(() => new TimeEvolution(1, hamiltonian)).to.throw()\r\n  });\r\n\r\n  it('should test_init_cast_complex_to_float', () => {\r\n    const hamiltonian = new QubitOperator('Z2', mc(2, 0))\r\n    const gate = new TimeEvolution(1, hamiltonian)\r\n    const v = gate.hamiltonian.terms[tuple([2, 'Z'])]\r\n    expect(typeof v === 'number').to.equal(true)\r\n    expect(v).to.equal(2.0)\r\n  });\r\n\r\n  it('should test_init_negative_time', () => {\r\n    const hamiltonian = new QubitOperator('Z2', 2)\r\n    const gate = new TimeEvolution(-1, hamiltonian)\r\n    expect(gate.time).to.equal(-1)\r\n  });\r\n\r\n  it('should test_get_inverse', () => {\r\n    const hamiltonian = new QubitOperator('Z2', 2)\r\n    const gate = new TimeEvolution(2, hamiltonian)\r\n    const inverse = gate.getInverse()\r\n    expect(gate.time).to.equal(2)\r\n    expect(gate.hamiltonian.isClose(hamiltonian)).to.equal(true)\r\n    expect(inverse.time).to.equal(-2)\r\n    expect(inverse.hamiltonian.isClose(hamiltonian)).to.equal(true)\r\n  });\r\n\r\n  it('should test_get_merged_one_term', () => {\r\n    const hamiltonian = new QubitOperator('Z2', 2)\r\n    const gate = new TimeEvolution(2, hamiltonian)\r\n    const hamiltonian2 = new QubitOperator('Z2', 4)\r\n    const gate2 = new TimeEvolution(5, hamiltonian2)\r\n    const merged = gate.getMerged(gate2)\r\n    // This is not a requirement, the hamiltonian could also be the other\r\n    // if we change implementation\r\n    expect(merged.hamiltonian.isClose(hamiltonian)).to.equal(true)\r\n    expect(merged.time).to.equal(12)\r\n  });\r\n\r\n  it('should test_get_merged_multiple_terms', () => {\r\n    const hamiltonian = new QubitOperator('Z2', 2)\r\n    hamiltonian.iadd(new QubitOperator('X3', 1))\r\n    const gate = new TimeEvolution(2, hamiltonian)\r\n    const hamiltonian2 = new QubitOperator('Z2', 4)\r\n    hamiltonian2.iadd(new QubitOperator('X3', 2 + 1e-10))\r\n    const gate2 = new TimeEvolution(5, hamiltonian2)\r\n    const merged = gate.getMerged(gate2)\r\n    // This is not a requirement, the hamiltonian could also be the other\r\n    // if we change implementation\r\n    expect(merged.hamiltonian.isClose(hamiltonian)).to.equal(true)\r\n    expect(merged.time).to.equal(12)\r\n  });\r\n\r\n  it('should test_get_merged_not_close_enough', () => {\r\n    const hamiltonian = new QubitOperator('Z2', 2)\r\n    hamiltonian.iadd(new QubitOperator('X3', 1))\r\n    const gate = new TimeEvolution(2, hamiltonian)\r\n    const hamiltonian2 = new QubitOperator('Z2', 4)\r\n    hamiltonian2.iadd(new QubitOperator('X3', 2 + 1e-8))\r\n    const gate2 = new TimeEvolution(5, hamiltonian2)\r\n    expect(() => gate.getMerged(gate2)).to.throw()\r\n  });\r\n\r\n  it('should test_get_merged_bad_gate', () => {\r\n    const hamiltonian = new QubitOperator('Z2', 2)\r\n    const gate = new TimeEvolution(2, hamiltonian)\r\n    const other = new BasicGate()\r\n    expect(() => gate.getMerged(other)).to.throw()\r\n  });\r\n\r\n  it('should test_get_merged_different_hamiltonian', () => {\r\n    const hamiltonian = new QubitOperator('Z2', 2)\r\n    const gate = new TimeEvolution(2, hamiltonian)\r\n    const hamiltonian2 = new QubitOperator('Y2', 2)\r\n    const gate2 = new TimeEvolution(2, hamiltonian2)\r\n    expect(() => gate.getMerged(gate2)).to.throw()\r\n  });\r\n\r\n  it('should test_or_one_qubit', () => {\r\n    const saving_backend = new DummyEngine(true)\r\n    const eng = new MainEngine(saving_backend, [])\r\n    const qubit = eng.allocateQubit()\r\n    const hamiltonian = new QubitOperator('Z0', 2)\r\n    new TimeEvolution(2.1, hamiltonian).or(qubit[0])\r\n    new TimeEvolution(3, hamiltonian).or(tuple(qubit[0]))\r\n    eng.flush()\r\n\r\n    const cmd1 = saving_backend.receivedCommands[1]\r\n    expect(cmd1.gate.hamiltonian.isClose(hamiltonian)).to.equal(true)\r\n    expect(cmd1.gate.time).to.equal(2.1)\r\n    expect(cmd1.qubits.length === 1 && cmd1.qubits[0].length === 1).to.equal(true)\r\n    expect(cmd1.qubits[0][0].id === qubit[0].id).to.equal(true)\r\n\r\n    const cmd2 = saving_backend.receivedCommands[2]\r\n\r\n    expect(cmd2.gate.hamiltonian.isClose(hamiltonian)).to.equal(true)\r\n    expect(cmd2.gate.time).to.equal(3)\r\n    expect(cmd2.qubits.length === 1 && cmd2.qubits[0].length === 1).to.equal(true)\r\n    expect(cmd2.qubits[0][0].id === qubit[0].id).to.equal(true)\r\n  });\r\n\r\n  it('should test_eq_not_implemented', () => {\r\n    const hamiltonian = new QubitOperator('X0 Z1')\r\n    const gate = new TimeEvolution(2.1, hamiltonian)\r\n    expect(() => gate.equal()).to.throw()\r\n  });\r\n\r\n  it('should test string', () => {\r\n    const hamiltonian = new QubitOperator('X0 Z1')\r\n    hamiltonian.iadd(new QubitOperator('Y1', 0.5))\r\n    const gate = new TimeEvolution(2.1, hamiltonian)\r\n    expect(gate.toString() === 'exp(-2.1j * (0.5 Y1 +\\n1 X0 Z1))' || gate.toString() === 'exp(-2.1j * (1 X0 Z1 +\\n0.5 Y1))').to.equal(true)\r\n  });\r\n\r\n  it('should test_or_one_qureg', () => {\r\n    const saving_backend = new DummyEngine(true)\r\n    const eng = new MainEngine(saving_backend, [])\r\n    const qureg = eng.allocateQureg(5)\r\n    const hamiltonian = new QubitOperator('X0 Z4', 2)\r\n    new TimeEvolution(2.1, hamiltonian).or(qureg)\r\n    new TimeEvolution(3, hamiltonian).or(tuple(qureg))\r\n    eng.flush()\r\n\r\n    const rescaled_h = new QubitOperator('X0 Z1', 2)\r\n    const cmd1 = saving_backend.receivedCommands[5]\r\n    expect(cmd1.gate.hamiltonian.isClose(rescaled_h)).to.equal(true)\r\n    expect(cmd1.gate.time).to.equal(2.1)\r\n    expect(cmd1.qubits.length === 1 && cmd1.qubits[0].length === 2).to.equal(true)\r\n    expect(cmd1.qubits[0][0].id === qureg[0].id).to.equal(true)\r\n    expect(cmd1.qubits[0][1].id === qureg[4].id).to.equal(true)\r\n\r\n    const cmd2 = saving_backend.receivedCommands[6]\r\n    expect(cmd2.gate.hamiltonian.isClose(rescaled_h)).to.equal(true)\r\n    expect(cmd2.gate.time).to.equal(3)\r\n    expect(cmd2.qubits.length === 1 && cmd2.qubits[0].length === 2).to.equal(true)\r\n    expect(cmd2.qubits[0][0].id === qureg[0].id).to.equal(true)\r\n    expect(cmd2.qubits[0][1].id === qureg[4].id).to.equal(true)\r\n  });\r\n\r\n  it('should test_or_two_qubits_error', () => {\r\n    const saving_backend = new DummyEngine(true)\r\n    const eng = new MainEngine(saving_backend, [])\r\n    const qureg = eng.allocateQureg(2)\r\n    const hamiltonian = new QubitOperator('Z0', 2)\r\n    expect(() => new TimeEvolution(2.1, hamiltonian).or(tuple(qureg[0], qureg[1]))).to.throw()\r\n  });\r\n\r\n  it('should test_or_two_quregs_error', () => {\r\n    const saving_backend = new DummyEngine(true)\r\n    const eng = new MainEngine(saving_backend, [])\r\n    const qureg = eng.allocateQureg(2)\r\n    const qureg2 = eng.allocateQureg(2)\r\n    const hamiltonian = new QubitOperator('Z0', 2)\r\n    expect(() => new TimeEvolution(2.1, hamiltonian).or(tuple(qureg, qureg2))).to.throw()\r\n  });\r\n\r\n  it('should test_or_not_enough_qubits', () => {\r\n    const saving_backend = new DummyEngine(true)\r\n    const eng = new MainEngine(saving_backend, [])\r\n    const qureg = eng.allocateQureg(2)\r\n    const hamiltonian = new QubitOperator('Z0 X3', 2)\r\n    expect(() => new TimeEvolution(2.1, hamiltonian).or(qureg)).to.throw()\r\n  });\r\n\r\n  it('should test_or_multiple_terms', () => {\r\n    const saving_backend = new DummyEngine(true)\r\n    const eng = new MainEngine(saving_backend, [])\r\n    const qureg = eng.allocateQureg(4)\r\n    const hamiltonian = new QubitOperator('X0 Z3', 2)\r\n    hamiltonian.iadd(new QubitOperator('Y1', 0.5))\r\n    new TimeEvolution(2.1, hamiltonian).or(qureg)\r\n    eng.flush()\r\n\r\n    const rescaled_h = new QubitOperator('X0 Z2', 2)\r\n    rescaled_h.iadd(new QubitOperator('Y1', 0.5))\r\n\r\n    const cmd1 = saving_backend.receivedCommands[4]\r\n    expect(cmd1.gate.hamiltonian.isClose(rescaled_h)).to.equal(true)\r\n    expect(cmd1.gate.time).to.equal(2.1)\r\n    expect(cmd1.qubits.length === 1 && cmd1.qubits[0].length === 3).to.equal(true)\r\n\r\n    expect(cmd1.qubits[0][0].id === qureg[0].id).to.equal(true)\r\n    expect(cmd1.qubits[0][1].id === qureg[1].id).to.equal(true)\r\n    expect(cmd1.qubits[0][2].id === qureg[3].id).to.equal(true)\r\n  });\r\n\r\n  it('should test_or_gate_not_mutated', () => {\r\n    const saving_backend = new DummyEngine(true)\r\n    const eng = new MainEngine(saving_backend, [])\r\n    const qureg = eng.allocateQureg(4)\r\n    const hamiltonian = new QubitOperator('X0 Z3', 2)\r\n    hamiltonian.iadd(new QubitOperator('Y1', 0.5))\r\n    const correct_h = hamiltonian.copy()\r\n    const gate = new TimeEvolution(2.1, hamiltonian)\r\n    gate.or(qureg)\r\n    eng.flush()\r\n\r\n    expect(gate.hamiltonian.isClose(correct_h)).to.equal(true)\r\n    expect(gate.time).to.equal(2.1)\r\n  });\r\n\r\n  it('should test_or_gate_identity', () => {\r\n    const saving_backend = new DummyEngine(true)\r\n    const eng = new MainEngine(saving_backend, [])\r\n    const qureg = eng.allocateQureg(4)\r\n    const hamiltonian = new QubitOperator([], 3.4)\r\n    const correct_h = hamiltonian.copy()\r\n    const gate = new TimeEvolution(2.1, hamiltonian)\r\n    gate.or(qureg)\r\n    eng.flush()\r\n    const cmd = saving_backend.receivedCommands[4]\r\n\r\n    expect(cmd.gate instanceof Ph).to.equal(true)\r\n    expect(cmd.gate.equal(new Ph(-3.4 * 2.1))).to.equal(true)\r\n    const correct = math.matrix([\r\n      [math.exp(mc(0, -3.4 * 2.1)), 0],\r\n      [0, math.exp(mc(0, -3.4 * 2.1))]])\r\n\r\n    expect(math.deepEqual(cmd.gate.matrix, correct)).to.equal(true)\r\n  });\r\n})\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/ops/timeevolution.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 951,
    "kind": "variable",
    "name": "mc",
    "memberof": "src/ops/timeevolution.spec.js",
    "static": true,
    "longname": "src/ops/timeevolution.spec.js~mc",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/ops/timeevolution.spec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 952,
    "kind": "file",
    "name": "src/ops/_cycle.js",
    "content": "\r\n/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nconst shared = {}\r\n\r\nexport function add(key, value) {\r\n  shared[key] = value\r\n}\r\n\r\nexport function get(key) {\r\n  return shared[key]\r\n}\r\n\r\n\r\n/**\r\nReturn the inverse of a gate.\r\n\r\n    Tries to call gate.getInverse and, upon failure, creates a DaggeredGate\r\ninstead.\r\n\r\n    @param {BasicGate} gate Gate of which to get the inverse\r\n\r\n@example\r\n\r\ngetInverse(H) // returns a Hadamard gate (HGate object)\r\n */\r\nexport function getInverse(gate) {\r\n  try {\r\n    return gate.getInverse()\r\n  } catch (e) {\r\n    const DaggeredGate = get('DaggeredGate')\r\n    return new DaggeredGate(gate)\r\n  }\r\n}\r\n\r\nexport default {\r\n  add,\r\n  get\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/ops/_cycle.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 953,
    "kind": "variable",
    "name": "shared",
    "memberof": "src/ops/_cycle.js",
    "static": true,
    "longname": "src/ops/_cycle.js~shared",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/ops/_cycle.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 954,
    "kind": "function",
    "name": "add",
    "memberof": "src/ops/_cycle.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/ops/_cycle.js~add",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/_cycle.js",
    "importStyle": "{add}",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 955,
    "kind": "function",
    "name": "get",
    "memberof": "src/ops/_cycle.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/ops/_cycle.js~get",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/_cycle.js",
    "importStyle": "{get}",
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "params": [
      {
        "name": "key",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 956,
    "kind": "function",
    "name": "getInverse",
    "memberof": "src/ops/_cycle.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/ops/_cycle.js~getInverse",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/ops/_cycle.js",
    "importStyle": "{getInverse}",
    "description": "Return the inverse of a gate.\n\nTries to call gate.getInverse and, upon failure, creates a DaggeredGate\ninstead.",
    "examples": [
      "\ngetInverse(H) // returns a Hadamard gate (HGate object)"
    ],
    "lineNumber": 41,
    "params": [
      {
        "nullable": null,
        "types": [
          "BasicGate"
        ],
        "spread": false,
        "optional": false,
        "name": "gate",
        "description": "Gate of which to get the inverse"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 957,
    "kind": "file",
    "name": "src/setups/decompositions/arb1qubit2rzandry.js",
    "content": "import math from 'mathjs'\r\nimport {Control} from '../../meta';\r\nimport {len, productLoop, productLoop3} from '../../libs/polyfill';\r\nimport DecompositionRule from '../../cengines/replacer/decompositionrule';\r\nimport {\r\n  BasicGate, Rz, Ry, Ph\r\n} from '../../ops';\r\n\r\nconst TOLERANCE = 1e-12\r\n\r\nexport function phase(c) {\r\n  if (typeof c === 'number') {\r\n    return Math.atan2(0, c)\r\n  }\r\n  return Math.atan2(c.im, c.re)\r\n}\r\n\r\n/**\r\nRecognize an arbitrary one qubit gate which has a matrix property.\r\n\r\n    It does not allow gates which have control qubits as otherwise the\r\nAutoReplacer might go into an infinite loop. Use\r\ncarb1qubit2cnotrzandry instead.\r\n @param {Command} cmd\r\n @return {boolean}\r\n */\r\nexport const _recognize_arb1qubit = (cmd) => {\r\n  try {\r\n    const m = cmd.gate.matrix\r\n    return len(m) === 2 && cmd.controlCount === 0\r\n  } catch (e) {\r\n    return false\r\n  }\r\n}\r\n\r\n/**\r\nIt builds matrix U with parameters (a, b/2, c/2, d/2) and compares against\r\nmatrix.\r\n\r\n    U = [[exp(j*(a-b/2-d/2))*cos(c/2), -exp(j*(a-b/2+d/2))*sin(c/2)],\r\n  [exp(j*(a+b/2-d/2))*sin(c/2), exp(j*(a+b/2+d/2))*cos(c/2)]]\r\n\r\n  @param {Array.<number[]>} matrix 2x2 matrix\r\n  @param {number} a parameter of U\r\n  @param {number} b_half b/2. parameter of U\r\n  @param {number} c_half c/2. parameter of U\r\n  @param {number} d_half d/2. parameter of U\r\n\r\n@return {boolean} true if matrix elements of U and `matrix` are TOLERANCE close.\r\n */\r\nconst _test_parameters = (matrix, a, b_half, c_half, d_half) => {\r\n  const mc = math.complex\r\n  const mm = math.multiply\r\n  const U = [\r\n    [\r\n      mm(math.exp(mc(0, a - b_half - d_half)), math.cos(c_half)),\r\n      mm(mm(math.exp(mc(0, a - b_half + d_half)), -1), math.sin(c_half))\r\n    ],\r\n    [\r\n      mm(math.exp(mc(0, a + b_half - d_half)), math.sin(c_half)),\r\n      mm(math.exp(mc(0, a + b_half + d_half)), math.cos(c_half))\r\n    ]\r\n  ]\r\n  return math.deepEqual(U, matrix)\r\n}\r\n\r\n/**\r\nGiven a 2x2 unitary matrix, find the parameters\r\na, b/2, c/2, and d/2 such that\r\nmatrix == [[exp(j*(a-b/2-d/2))*cos(c/2), -exp(j*(a-b/2+d/2))*sin(c/2)],\r\n  [exp(j*(a+b/2-d/2))*sin(c/2), exp(j*(a+b/2+d/2))*cos(c/2)]]\r\n\r\nNote:\r\n    If the matrix is element of SU(2) (determinant == 1), then\r\nwe can choose a = 0.\r\n\r\n@param {Array.<number[]>} matrix 2x2 unitary matrix\r\n\r\n@return {number[]} parameters of the matrix: (a, b/2, c/2, d/2)\r\n */\r\nexport const _find_parameters = (matrix) => {\r\n  // Determine a, b/2, c/2 and d/2 (3 different cases).\r\n// Note: everything is modulo 2pi.\r\n  let a\r\n  let b_half\r\n  let c_half\r\n  let d_half\r\n  const mm = math.multiply\r\n  // Case 1: sin(c/2) == 0:\r\n  if (math.abs(matrix[0][1]) < TOLERANCE) {\r\n    const t = phase(mm(matrix[0][0], matrix[1][1]))\r\n    const two_a = math.mod(t, 2 * math.pi)\r\n    if (math.abs(two_a) < TOLERANCE || math.abs(two_a) > 2 * math.pi - TOLERANCE) {\r\n      // from 2a==0 (mod 2pi), it follows that a==0 or a==pi,\r\n      // w.l.g. we can choose a==0 because (see U above)\r\n      // c/2 -> c/2 + pi would have the same effect as as a==0 -> a==pi.\r\n      a = 0\r\n    } else {\r\n      a = two_a / 2.0\r\n    }\r\n    d_half = 0 // w.l.g\r\n    const b = phase(matrix[1][1]) - phase(matrix[0][0])\r\n    const possible_b_half = [math.mod(b / 2.0, 2 * math.pi), math.mod(b / 2.0 + math.pi, 2 * math.pi)]\r\n    // As we have fixed a, we need to find correct sign for cos(c/2)\r\n    const possible_c_half = [0.0, math.pi]\r\n    let found = false\r\n    productLoop(possible_b_half, possible_c_half, (_b, _c) => {\r\n      b_half = _b\r\n      c_half = _c\r\n      if (_test_parameters(matrix, a, b_half, c_half, d_half)) {\r\n        found = true\r\n        return true\r\n      }\r\n    })\r\n\r\n    if (!found) {\r\n      throw new Error(`Couldn't find parameters for matrix ${matrix},\r\n        This shouldn't happen. Maybe the matrix is \r\n        not unitary?`)\r\n    }\r\n  }\r\n  // Case 2: cos(c/2) == 0:\r\n  else if (math.abs(matrix[0][0]) < TOLERANCE) {\r\n    const t = phase(mm(mm(matrix[0][1], matrix[1][0]), -1))\r\n    const two_a = math.mod(t, 2 * math.pi)\r\n    if (math.abs(two_a) < TOLERANCE || math.abs(two_a) > 2 * math.pi - TOLERANCE) {\r\n      // from 2a==0 (mod 2pi), it follows that a==0 or a==pi,\r\n      // w.l.g. we can choose a==0 because (see U above)\r\n      // c/2 -> c/2 + pi would have the same effect as as a==0 -> a==pi.\r\n      a = 0\r\n    } else {\r\n      a = two_a / 2.0\r\n    }\r\n    d_half = 0 // w.l.g\r\n    const b = phase(matrix[1][0]) - phase(matrix[0][1]) + math.pi\r\n    const possible_b_half = [math.mod(b / 2.0, 2 * math.pi), math.mod(b / 2.0 + math.pi, 2 * math.pi)]\r\n    // As we have fixed a, we need to find correct sign for sin(c/2)\r\n    const possible_c_half = [math.pi / 2.0, 3.0 / 2.0 * math.pi]\r\n    let found = false\r\n    productLoop(possible_b_half, possible_c_half, (_b, _c) => {\r\n      b_half = _b\r\n      c_half = _c\r\n      if (_test_parameters(matrix, a, b_half, c_half, d_half)) {\r\n        found = true\r\n        return true\r\n      }\r\n    })\r\n    if (!found) {\r\n      throw new Error(`Couldn't find parameters for matrix ${matrix},\r\n        This shouldn't happen. Maybe the matrix is \r\n        not unitary?`)\r\n    }\r\n  }\r\n  // Case 3: sin(c/2) != 0 and cos(c/2) !=0:\r\n  else {\r\n    const t = phase(mm(matrix[0][0], matrix[1][1]))\r\n    const two_a = math.mod(t, 2 * math.pi)\r\n    if (math.abs(two_a) < TOLERANCE || math.abs(two_a) > 2 * math.pi - TOLERANCE) {\r\n      // from 2a==0 (mod 2pi), it follows that a==0 or a==pi,\r\n      // w.l.g. we can choose a==0 because (see U above)\r\n      // c/2 -> c/2 + pi would have the same effect as as a==0 -> a==pi.\r\n      a = 0\r\n    } else {\r\n      a = two_a / 2.0\r\n    }\r\n    const two_d = 2.0 * phase(matrix[0][1]) - 2.0 * phase(matrix[0][0])\r\n    const possible_d_half = [\r\n      math.mod(two_d / 4.0, 2 * math.pi),\r\n      math.mod(two_d / 4.0 + math.pi / 2.0, 2 * math.pi),\r\n      math.mod(two_d / 4.0 + math.pi, 2 * math.pi),\r\n      math.mod(two_d / 4.0 + 3.0 / 2.0 * math.pi, 2 * math.pi)]\r\n    const two_b = 2.0 * phase(matrix[1][0]) - 2.0 * phase(matrix[0][0])\r\n    const possible_b_half = [\r\n      math.mod(two_b / 4.0, 2 * math.pi),\r\n      math.mod(two_b / 4.0 + math.pi / 2.0, 2 * math.pi),\r\n      math.mod(two_b / 4.0 + math.pi, 2 * math.pi),\r\n      math.mod(two_b / 4.0 + 3.0 / 2.0 * math.pi, 2 * math.pi)]\r\n    const tmp = math.acos(math.abs(matrix[1][1]))\r\n    const possible_c_half = [\r\n      math.mod(tmp, 2 * math.pi),\r\n      math.mod(tmp + math.pi, 2 * math.pi),\r\n      math.mod(-1.0 * tmp, 2 * math.pi),\r\n      math.mod(-1.0 * tmp + math.pi, 2 * math.pi)]\r\n    let found = false\r\n    productLoop3(possible_b_half, possible_c_half, possible_d_half, (_b, _c, _d) => {\r\n      b_half = _b\r\n      c_half = _c\r\n      d_half = _d\r\n      if (_test_parameters(matrix, a, b_half, c_half, d_half)) {\r\n        found = true\r\n        return true\r\n      }\r\n    })\r\n    if (!found) {\r\n      throw new Error(`Couldn't find parameters for matrix ${matrix},\r\n        This shouldn't happen. Maybe the matrix is \r\n        not unitary?`)\r\n    }\r\n  }\r\n  return [a, b_half, c_half, d_half]\r\n}\r\n\r\n/**\r\n * @param {Command} cmd\r\nUse Z-Y decomposition of Nielsen and Chuang (Theorem 4.1).\r\n\r\nAn arbitrary one qubit gate matrix can be writen as\r\nU = [[exp(j*(a-b/2-d/2))*cos(c/2), -exp(j*(a-b/2+d/2))*sin(c/2)],\r\n  [exp(j*(a+b/2-d/2))*sin(c/2), exp(j*(a+b/2+d/2))*cos(c/2)]]\r\nwhere a,b,c,d are real numbers.\r\n    Then U = exp(j*a) Rz(b) Ry(c) Rz(d).\r\n    If the matrix is element of SU(2) (determinant == 1), then\r\nwe can choose a = 0.\r\n */\r\nconst _decompose_arb1qubit = (cmd) => {\r\n  const matrix = cmd.gate.matrix._data.slice(0)\r\n  const [a, b_half, c_half, d_half] = _find_parameters(matrix)\r\n  const qb = cmd.qubits\r\n  const eng = cmd.engine\r\n  Control(eng, cmd.controlQubits, () => {\r\n    if (!new Rz(2 * d_half).equal(new Rz(0))) {\r\n      new Rz(2 * d_half).or(qb)\r\n    }\r\n\r\n    if (!new Ry(2 * c_half).equal(new Ry(0))) {\r\n      new Ry(2 * c_half).or(qb)\r\n    }\r\n    if (!new Rz(2 * b_half).equal(new Rz(0))) {\r\n      new Rz(2 * b_half).or(qb)\r\n    }\r\n    if (a !== 0) {\r\n      new Ph(a).or(qb)\r\n    }\r\n  })\r\n}\r\n\r\n\r\nexport default [\r\n  new DecompositionRule(BasicGate, _decompose_arb1qubit, _recognize_arb1qubit)\r\n]\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/decompositions/arb1qubit2rzandry.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 958,
    "kind": "variable",
    "name": "TOLERANCE",
    "memberof": "src/setups/decompositions/arb1qubit2rzandry.js",
    "static": true,
    "longname": "src/setups/decompositions/arb1qubit2rzandry.js~TOLERANCE",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/arb1qubit2rzandry.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 959,
    "kind": "function",
    "name": "phase",
    "memberof": "src/setups/decompositions/arb1qubit2rzandry.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/arb1qubit2rzandry.js~phase",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/setups/decompositions/arb1qubit2rzandry.js",
    "importStyle": "{phase}",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "params": [
      {
        "name": "c",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 960,
    "kind": "function",
    "name": "_recognize_arb1qubit",
    "memberof": "src/setups/decompositions/arb1qubit2rzandry.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/arb1qubit2rzandry.js~_recognize_arb1qubit",
    "access": "private",
    "export": true,
    "importPath": "projectq/src/setups/decompositions/arb1qubit2rzandry.js",
    "importStyle": "{_recognize_arb1qubit}",
    "description": "Recognize an arbitrary one qubit gate which has a matrix property.\n\nIt does not allow gates which have control qubits as otherwise the\nAutoReplacer might go into an infinite loop. Use\ncarb1qubit2cnotrzandry instead.",
    "lineNumber": 27,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 961,
    "kind": "function",
    "name": "_test_parameters",
    "memberof": "src/setups/decompositions/arb1qubit2rzandry.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/arb1qubit2rzandry.js~_test_parameters",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/arb1qubit2rzandry.js",
    "importStyle": null,
    "description": "It builds matrix U with parameters (a, b/2, c/2, d/2) and compares against\nmatrix.\n\nU = [[exp(j*(a-b/2-d/2))*cos(c/2), -exp(j*(a-b/2+d/2))*sin(c/2)],\n[exp(j*(a+b/2-d/2))*sin(c/2), exp(j*(a+b/2+d/2))*cos(c/2)]]",
    "lineNumber": 51,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array.<number[]>"
        ],
        "spread": false,
        "optional": false,
        "name": "matrix",
        "description": "2x2 matrix"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "a",
        "description": "parameter of U"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "b_half",
        "description": "b/2. parameter of U"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "c_half",
        "description": "c/2. parameter of U"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "d_half",
        "description": "d/2. parameter of U"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if matrix elements of U and `matrix` are TOLERANCE close."
    },
    "ignore": true
  },
  {
    "__docId__": 962,
    "kind": "function",
    "name": "_find_parameters",
    "memberof": "src/setups/decompositions/arb1qubit2rzandry.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/arb1qubit2rzandry.js~_find_parameters",
    "access": "private",
    "export": true,
    "importPath": "projectq/src/setups/decompositions/arb1qubit2rzandry.js",
    "importStyle": "{_find_parameters}",
    "description": "Given a 2x2 unitary matrix, find the parameters\na, b/2, c/2, and d/2 such that\nmatrix == [[exp(j*(a-b/2-d/2))*cos(c/2), -exp(j*(a-b/2+d/2))*sin(c/2)],\n[exp(j*(a+b/2-d/2))*sin(c/2), exp(j*(a+b/2+d/2))*cos(c/2)]]\n\nNote:\nIf the matrix is element of SU(2) (determinant == 1), then\nwe can choose a = 0.",
    "lineNumber": 81,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array.<number[]>"
        ],
        "spread": false,
        "optional": false,
        "name": "matrix",
        "description": "2x2 unitary matrix"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number[]"
      ],
      "spread": false,
      "description": "parameters of the matrix: (a, b/2, c/2, d/2)"
    }
  },
  {
    "__docId__": 963,
    "kind": "function",
    "name": "_decompose_arb1qubit",
    "memberof": "src/setups/decompositions/arb1qubit2rzandry.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/arb1qubit2rzandry.js~_decompose_arb1qubit",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/arb1qubit2rzandry.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 215,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": "Use Z-Y decomposition of Nielsen and Chuang (Theorem 4.1).\n\nAn arbitrary one qubit gate matrix can be writen as\nU = [[exp(j*(a-b/2-d/2))*cos(c/2), -exp(j*(a-b/2+d/2))*sin(c/2)],\n[exp(j*(a+b/2-d/2))*sin(c/2), exp(j*(a+b/2+d/2))*cos(c/2)]]\nwhere a,b,c,d are real numbers.\nThen U = exp(j*a) Rz(b) Ry(c) Rz(d).\nIf the matrix is element of SU(2) (determinant == 1), then\nwe can choose a = 0."
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 964,
    "kind": "file",
    "name": "src/setups/decompositions/arb1qubit2rzandry.spec.js",
    "content": "import {expect} from 'chai'\r\nimport math from 'mathjs'\r\nimport {AutoReplacer, DummyEngine, InstructionFilter} from '../../cengines';\r\nimport MainEngine from '../../cengines/main'\r\nimport {\r\n  BasicGate, ClassicalInstructionGate,\r\n  Ph, R, Rx, Ry, Rz, X, Measure\r\n} from '../../ops';\r\nimport arb1q, {_recognize_arb1qubit} from './arb1qubit2rzandry';\r\nimport {Control} from '../../meta';\r\nimport Simulator from '../../backends/simulators/simulator';\r\nimport DecompositionRuleSet from '../../cengines/replacer/decompositionruleset';\r\n\r\n/*\r\nCreates a unitary 2x2 matrix given parameters.\r\n\r\n  Any unitary 2x2 matrix can be parametrized by:\r\n  U = exp(ia) [[exp(j*b) * cos(d), exp(j*c) * sin(d)],\r\n      [-exp(-j*c) * sin(d), exp(-j*b) * cos(d)]]\r\nwith 0 <= d <= pi/2 and 0 <= a,b,c < 2pi. If a==0, then\r\ndet(U) == 1 and hence U is element of SU(2).\r\n\r\n  @param\r\na,b,c (float): parameters 0 <= a,b,c < 2pi\r\nd (float): parameter 0 <= d <= pi/2\r\n\r\n@returns\r\n  2x2 matrix as nested lists\r\n*/\r\nfunction create_unitary_matrix(a, b, c, d) {\r\n  const mc = math.complex\r\n  const mm = math.multiply\r\n  const exp = math.exp\r\n  const ph = math.exp(mc(0, a)) // global phase\r\n  const cosd = math.cos(d)\r\n  const sind = math.sin(d)\r\n  const result = mm(math.matrix([\r\n    [mm(exp(mc(0, b)), cosd), mm(exp(mc(0, c)), sind)],\r\n    [mm(mm(exp(mc(0, -c)), -1), sind), mm(exp(mc(0, -b)), cosd)]]), ph)\r\n  return result\r\n}\r\n\r\nexport function create_test_matrices() {\r\n  const params = [[0.2, 0.3, 0.5, math.pi * 0.4],\r\n    [1e-14, 0.3, 0.5, 0],\r\n    [0.4, 0.0, math.pi * 2, 0.7],\r\n    [0.0, 0.2, math.pi * 1.2, 1.5], // element of SU[2]\r\n    [0.4, 0.0, math.pi * 1.3, 0.8],\r\n    [0.4, 4.1, math.pi * 1.3, 0],\r\n    [5.1, 1.2, math.pi * 1.5, math.pi / 2.0],\r\n    [1e-13, 1.2, math.pi * 3.7, math.pi / 2.0],\r\n    [0, math.pi / 2.0, 0, 0],\r\n    [math.pi / 2.0, -math.pi / 2.0, 0, 0],\r\n    [math.pi / 2.0, math.pi / 2.0, 0.1, 0.4],\r\n    [math.pi * 1.5, math.pi / 2.0, 0, 0.4]]\r\n  const matrices = []\r\n  params.forEach(([a, b, c, d]) => matrices.push(create_unitary_matrix(a, b, c, d)))\r\n  return matrices\r\n}\r\n\r\ndescribe('arb1qubit to rz & ry test', () => {\r\n  it('should test_recognize_correct_gates', () => {\r\n    const saving_backend = new DummyEngine(true)\r\n    const eng = new MainEngine(saving_backend)\r\n    const qubit = eng.allocateQubit()\r\n    new Ph(0.1).or(qubit)\r\n    new R(0.2).or(qubit)\r\n    new Rx(0.3).or(qubit)\r\n    X.or(qubit)\r\n    eng.flush(true)\r\n    // Don't test initial allocate and trailing deallocate and flush gate.\r\n    const cmds = saving_backend.receivedCommands\r\n    cmds.slice(1, cmds.length - 2).forEach(cmd => expect(_recognize_arb1qubit(cmd)).to.equal(true))\r\n  });\r\n\r\n  it('should test_recognize_incorrect_gates', () => {\r\n    const saving_backend = new DummyEngine(true)\r\n    const eng = new MainEngine(saving_backend)\r\n    const qubit = eng.allocateQubit()\r\n    // Does not have matrix attribute:\r\n    new BasicGate().or(qubit)\r\n    // Two qubit gate:\r\n    const two_qubit_gate = new BasicGate()\r\n    two_qubit_gate.matrix = math.matrix([[1, 0, 0, 0], [0, 1, 0, 0],\r\n      [0, 0, 1, 0], [0, 0, 0, 1]])\r\n    two_qubit_gate.or(qubit)\r\n    // Controlled single qubit gate:\r\n    const ctrl_qubit = eng.allocateQubit()\r\n    Control(eng, ctrl_qubit, () => new Rz(0.1).or(qubit))\r\n    eng.flush(true)\r\n\r\n    saving_backend.receivedCommands.forEach(cmd => expect(_recognize_arb1qubit(cmd)).to.equal(false))\r\n  });\r\n\r\n\r\n  function z_y_decomp_gates(eng, cmd) {\r\n    const g = cmd.gate\r\n    if (g instanceof ClassicalInstructionGate) {\r\n      return true\r\n    }\r\n    if (cmd.controlQubits.length === 0) {\r\n      if ((g instanceof Ry) || (g instanceof Rz) || (g instanceof Ph)) return true\r\n    }\r\n    return false\r\n  }\r\n\r\n  it('should test_decomposition', () => {\r\n    const data = create_test_matrices()\r\n    data.forEach((gate_matrix) => {\r\n      const states = [[1, 0], [0, 1]]\r\n      states.forEach((basis_state) => {\r\n        // Create single qubit gate with gate_matrix\r\n        const test_gate = new BasicGate()\r\n        test_gate.matrix = gate_matrix\r\n\r\n        const correct_dummy_eng = new DummyEngine(true)\r\n        const correct_eng = new MainEngine(new Simulator(), [correct_dummy_eng])\r\n\r\n        const rule_set = new DecompositionRuleSet(arb1q)\r\n        const test_dummy_eng = new DummyEngine(true)\r\n        const test_eng = new MainEngine(new Simulator(),\r\n          [new AutoReplacer(rule_set),\r\n            new InstructionFilter(z_y_decomp_gates), test_dummy_eng])\r\n\r\n        const correct_qb = correct_eng.allocateQubit()\r\n        correct_eng.flush()\r\n        const test_qb = test_eng.allocateQubit()\r\n        test_eng.flush()\r\n\r\n        correct_eng.backend.setWavefunction(basis_state, correct_qb)\r\n        test_eng.backend.setWavefunction(basis_state, test_qb)\r\n\r\n        test_gate.or(test_qb)\r\n        test_gate.or(correct_qb)\r\n\r\n        test_eng.flush()\r\n        correct_eng.flush()\r\n\r\n        expect(correct_dummy_eng.receivedCommands[2].gate.equal(test_gate)).to.equal(true)\r\n        expect(test_dummy_eng.receivedCommands[2].gate.equal(test_gate)).to.equal(false)\r\n\r\n        const ss = ['0', '1']\r\n        ss.forEach((fstate) => {\r\n          const test = test_eng.backend.getAmplitude(fstate, test_qb)\r\n          const correct = correct_eng.backend.getAmplitude(fstate, correct_qb)\r\n          expect(correct.re).to.be.closeTo(test.re, 1e-12)\r\n          expect(correct.im).to.be.closeTo(test.im, 1e-12)\r\n        })\r\n\r\n        Measure.or(test_qb)\r\n        Measure.or(correct_qb)\r\n      })\r\n    })\r\n  });\r\n\r\n  it('should test_decomposition_errors', () => {\r\n    const data = [[[2, 0], [0, 4]],\r\n      [[0, 2], [4, 0]],\r\n      [[1, 2], [4, 0]]]\r\n    data.forEach((gate_matrix) => {\r\n      const test_gate = new BasicGate()\r\n      test_gate.matrix = math.matrix(gate_matrix)\r\n      const rule_set = new DecompositionRuleSet(arb1q)\r\n      const eng = new MainEngine(new DummyEngine(),\r\n        [new AutoReplacer(rule_set),\r\n          new InstructionFilter(z_y_decomp_gates)])\r\n      const qb = eng.allocateQubit()\r\n      expect(() => test_gate.or(qb)).to.throw()\r\n    })\r\n  });\r\n})\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/decompositions/arb1qubit2rzandry.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 965,
    "kind": "function",
    "name": "create_unitary_matrix",
    "memberof": "src/setups/decompositions/arb1qubit2rzandry.spec.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/arb1qubit2rzandry.spec.js~create_unitary_matrix",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/arb1qubit2rzandry.spec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 30,
    "undocument": true,
    "params": [
      {
        "name": "a",
        "types": [
          "*"
        ]
      },
      {
        "name": "b",
        "types": [
          "*"
        ]
      },
      {
        "name": "c",
        "types": [
          "*"
        ]
      },
      {
        "name": "d",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 966,
    "kind": "function",
    "name": "create_test_matrices",
    "memberof": "src/setups/decompositions/arb1qubit2rzandry.spec.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/arb1qubit2rzandry.spec.js~create_test_matrices",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/setups/decompositions/arb1qubit2rzandry.spec.js",
    "importStyle": "{create_test_matrices}",
    "description": null,
    "lineNumber": 43,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 967,
    "kind": "file",
    "name": "src/setups/decompositions/barrier.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport DecompositionRule from '../../cengines/replacer/decompositionrule'\r\nimport {BarrierGate} from '../../ops/gates'\r\n\r\nexport function _decompose_barrier(cmd) {\r\n  // Throw out all barriers if they are not supported.\r\n}\r\n\r\nexport function _recognize_barrier(cmd) {\r\n  // Recognize all barriers. \"\r\n  return true\r\n}\r\n\r\nexport default [\r\n  new DecompositionRule(BarrierGate, _decompose_barrier, _recognize_barrier)\r\n]\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/decompositions/barrier.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 968,
    "kind": "function",
    "name": "_decompose_barrier",
    "memberof": "src/setups/decompositions/barrier.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/barrier.js~_decompose_barrier",
    "access": "private",
    "export": true,
    "importPath": "projectq/src/setups/decompositions/barrier.js",
    "importStyle": "{_decompose_barrier}",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 969,
    "kind": "function",
    "name": "_recognize_barrier",
    "memberof": "src/setups/decompositions/barrier.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/barrier.js~_recognize_barrier",
    "access": "private",
    "export": true,
    "importPath": "projectq/src/setups/decompositions/barrier.js",
    "importStyle": "{_recognize_barrier}",
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 970,
    "kind": "file",
    "name": "src/setups/decompositions/barrier.spec.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport {expect} from 'chai'\r\nimport {_recognize_barrier } from './barrier'\r\nimport {DummyEngine} from '../../cengines/testengine'\r\nimport MainEngine from '../../cengines/main'\r\nimport {R, Barrier} from '../../ops/gates'\r\n\r\ndescribe('barrier test', () => {\r\n  it('should test_recognize_barrier', () => {\r\n    const saving_backend = new DummyEngine(true)\r\n    const eng = new MainEngine(saving_backend, [])\r\n    const qubit = eng.allocateQubit()\r\n    new R(0.2).or(qubit)\r\n    Barrier.or(qubit)\r\n    eng.flush(true)\r\n    // Don't test initial allocate and trailing deallocate and flush gate.\r\n    let count = 0\r\n    const cmds = saving_backend.receivedCommands\r\n    cmds.slice(1, cmds.length - 2).forEach((cmd) => {\r\n      count += _recognize_barrier(cmd)\r\n    })\r\n    expect(count).to.equal(2) // recognizes all gates\r\n  });\r\n\r\n  it('should test_remove_barrier', () => {\r\n    const saving_backend = new DummyEngine(true)\r\n\r\n    const my_is_available = cmd => cmd.gate !== Barrier\r\n\r\n    saving_backend.isAvailable = my_is_available\r\n    const eng = new MainEngine(saving_backend)\r\n    const qubit = eng.allocateQubit()\r\n    new R(0.2).or(qubit)\r\n    Barrier.or(qubit)\r\n    eng.flush(true)\r\n    // Don't test initial allocate and trailing deallocate and flush gate.\r\n    const cmds = saving_backend.receivedCommands\r\n    const sub = cmds.slice(1, cmds.length - 2)\r\n    sub.forEach((cmd) => {\r\n      expect(cmd.gate.equal(Barrier)).to.equal(false)\r\n    })\r\n    expect(sub.length).to.equal(1)\r\n  });\r\n})\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/decompositions/barrier.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 971,
    "kind": "file",
    "name": "src/setups/decompositions/carb1qubit2cnotrzandry.js",
    "content": "import math from 'mathjs'\r\nimport assert from 'assert'\r\nimport DecompositionRule from '../../cengines/replacer/decompositionrule';\r\nimport {\r\n  BasicGate, Ph, Ry, Rz, X\r\n} from '../../ops';\r\nimport {Control} from '../../meta';\r\nimport {len, productLoop} from '../../libs/polyfill';\r\nimport {_find_parameters, phase} from './arb1qubit2rzandry'\r\n\r\nconst mm = math.multiply\r\nconst mc = math.complex\r\nconst TOLERANCE = 1e-12\r\n\r\n// Recognize single controlled one qubit gates with a matrix.\r\nexport function _recognize_carb1qubit(cmd) {\r\n  if (cmd.controlCount === 1) {\r\n    try {\r\n      const m = cmd.gate.matrix\r\n      if (len(m) === 2) {\r\n        return true\r\n      }\r\n    } catch (e) {\r\n      return false\r\n    }\r\n  }\r\n  return false\r\n}\r\n\r\n/**\r\nIt builds matrix V with parameters (a, b, c/2) and compares against\r\nmatrix.\r\n\r\n    V = [[-sin(c/2) * exp(j*a), exp(j*(a-b)) * cos(c/2)],\r\n  [exp(j*(a+b)) * cos(c/2), exp(j*a) * sin(c/2)]]\r\n\r\n  @param {Array.<number[]>} matrix 2x2 matrix\r\n  @param {number} a Parameter of V\r\n  @param {number} b Parameter of V\r\n  @param {number} c_half c/2. Parameter of V\r\n\r\n  @return {boolean} true if matrix elements of V and `matrix` are TOLERANCE close.\r\n */\r\nfunction _test_parameters(matrix, a, b, c_half) {\r\n  const {exp} = math\r\n  const cosc = math.cos(c_half)\r\n  const sinc = math.sin(c_half)\r\n  const V = [\r\n    [mm(mm(sinc, exp(mc(0, a))), -1), mm(exp(mc(0, a - b)), cosc)],\r\n    [mm(exp(mc(0, a + b)), cosc), mm(exp(mc(0, a)), sinc)]]\r\n  return math.deepEqual(V, matrix)\r\n}\r\n\r\n/**\r\nRecognizes a matrix which can be written in the following form:\r\n\r\n    V = [[-sin(c/2) * exp(j*a), exp(j*(a-b)) * cos(c/2)],\r\n      [exp(j*(a+b)) * cos(c/2), exp(j*a) * sin(c/2)]]\r\n\r\n  @param {Array.<number[]>} matrix 2x2 matrix\r\n  @return {boolean} false if it is not possible otherwise (a, b, c/2)\r\n */\r\nexport function _recognize_v(matrix) {\r\n  let a\r\n  let b\r\n  let c_half\r\n  if (math.abs(matrix[0][0]) < TOLERANCE) {\r\n    const t = phase(mm(matrix[0][1], matrix[1][0]))\r\n    const two_a = math.mod(t, 2 * math.pi)\r\n    if (math.abs(two_a) < TOLERANCE || math.abs(two_a) > 2 * math.pi - TOLERANCE) {\r\n      // from 2a==0 (mod 2pi), it follows that a==0 or a==pi,\r\n      // w.l.g. we can choose a==0 because (see U above)\r\n      // c/2 -> c/2 + pi would have the same effect as as a==0 -> a==pi.\r\n      a = 0\r\n    } else {\r\n      a = two_a / 2.0\r\n    }\r\n    const two_b = phase(matrix[1][0]) - phase(matrix[0][1])\r\n    const possible_b = [math.mod(two_b / 2.0, 2 * math.pi),\r\n      math.mod(two_b / 2.0 + math.pi, 2 * math.pi)]\r\n    const possible_c_half = [0, math.pi]\r\n    let found = false\r\n    productLoop(possible_b, possible_c_half, (_b, _c) => {\r\n      b = _b\r\n      c_half = _c\r\n      if (_test_parameters(matrix, a, b, c_half)) {\r\n        found = true\r\n        return true\r\n      }\r\n    })\r\n\r\n    assert(found) // It should work for all matrices with matrix[0][0]==0.\r\n    return [a, b, c_half]\r\n  } else if (math.abs(matrix[0][1]) < TOLERANCE) {\r\n    const t = phase(mm(mm(matrix[0][0], matrix[1][1]), -1))\r\n    const two_a = math.mod(t, 2 * math.pi)\r\n    if (math.abs(two_a) < TOLERANCE || math.abs(two_a) > 2 * math.pi - TOLERANCE) {\r\n      // from 2a==0 (mod 2pi), it follows that a==0 or a==pi,\r\n      // w.l.g. we can choose a==0 because (see U above)\r\n      // c/2 -> c/2 + pi would have the same effect as as a==0 -> a==pi.\r\n      a = 0\r\n    } else {\r\n      a = two_a / 2.0\r\n    }\r\n    b = 0\r\n    const possible_c_half = [math.pi / 2.0, 3.0 / 2.0 * math.pi]\r\n    const found = false\r\n    for (let i = 0; i < possible_c_half.length; ++i) {\r\n      c_half = possible_c_half[i]\r\n      if (_test_parameters(matrix, a, b, c_half)) {\r\n        return [a, b, c_half]\r\n      }\r\n    }\r\n    return []\r\n  } else {\r\n    const t = mm(mm(-1.0, matrix[0][0]), matrix[1][1])\r\n    const two_a = math.mod(phase(t), 2 * math.pi)\r\n    if (math.abs(two_a) < TOLERANCE || math.abs(two_a) > 2 * math.pi - TOLERANCE) {\r\n      // from 2a==0 (mod 2pi), it follows that a==0 or a==pi,\r\n      // w.l.g. we can choose a==0 because (see U above)\r\n      // c/2 -> c/2 + pi would have the same effect as as a==0 -> a==pi.\r\n      a = 0\r\n    } else {\r\n      a = two_a / 2.0\r\n    }\r\n    const two_b = phase(matrix[1][0]) - phase(matrix[0][1])\r\n    const possible_b = [\r\n      math.mod((two_b / 2.0), 2 * math.pi),\r\n      math.mod((two_b / 2.0 + math.pi), 2 * math.pi)]\r\n    const tmp = math.acos(math.abs(matrix[1][0]))\r\n    const possible_c_half = [\r\n      math.mod(tmp, 2 * math.pi),\r\n      math.mod(tmp + math.pi, 2 * math.pi),\r\n      math.mod(-1.0 * tmp, 2 * math.pi),\r\n      math.mod(-1.0 * tmp + math.pi, 2 * math.pi)]\r\n    let found = false\r\n    productLoop(possible_b, possible_c_half, (_b, _c) => {\r\n      b = _b\r\n      c_half = _c\r\n      if (_test_parameters(matrix, a, b, c_half)) {\r\n        found = true\r\n        return true\r\n      }\r\n    })\r\n    if (!found) {\r\n      return []\r\n    }\r\n    return [a, b, c_half]\r\n  }\r\n}\r\n\r\n/**\r\nDecompose the single controlled 1 qubit gate into CNOT, Rz, Ry, C(Ph).\r\n\r\n    See Nielsen and Chuang chapter 4.3.\r\n\r\n    An arbitrary one qubit gate matrix can be writen as\r\nU = [[exp(j*(a-b/2-d/2))*cos(c/2), -exp(j*(a-b/2+d/2))*sin(c/2)],\r\n  [exp(j*(a+b/2-d/2))*sin(c/2), exp(j*(a+b/2+d/2))*cos(c/2)]]\r\nwhere a,b,c,d are real numbers.\r\n    Then U = exp(j*a) Rz(b) Ry(c) Rz(d).\r\n\r\n    Then C(U) = C(exp(ja)) * A * CNOT * B * CNOT * C with\r\n    A = Rz(b) * Ry(c/2)\r\n  B = Ry(-c/2) * Rz(-(d+b)/2)\r\nC = Rz((d-b)/2)\r\nNote that a == 0 if U is element of SU(2). Also note that\r\nthe controlled phase C(exp(ia)) can be implemented with single\r\n  qubit gates.\r\n\r\n    If the one qubit gate matrix can be writen as\r\nV = [[-sin(c/2) * exp(j*a), exp(j*(a-b)) * cos(c/2)],\r\n  [exp(j*(a+b)) * cos(c/2), exp(j*a) * sin(c/2)]]\r\nThen C(V) = C(exp(ja))* E * CNOT * D with\r\n    E = Rz(b)Ry(c/2)\r\nD = Ry(-c/2)Rz(-b)\r\nThis improvement is important for C(Y) or C(Z)\r\n\r\nFor a proof follow Lemma 5.5 of Barenco et al.\r\n @param {Command} cmd\r\n */\r\nfunction _decompose_carb1qubit(cmd) {\r\n  const matrix = cmd.gate.matrix._data\r\n  const qb = cmd.qubits\r\n  const eng = cmd.engine\r\n\r\n  // Case 1: Unitary matrix which can be written in the form of V:\r\n  const parameters_for_v = _recognize_v(matrix)\r\n  if (parameters_for_v.length > 0) {\r\n    const [a, b, c_half] = parameters_for_v\r\n    if (!new Rz(-b).equal(new Rz(0))) {\r\n      new Rz(-b).or(qb)\r\n    }\r\n    if (!new Ry(-c_half).equal(new Ry(0))) {\r\n      new Ry(-c_half).or(qb)\r\n    }\r\n    Control(eng, cmd.controlQubits, () => X.or(qb))\r\n    if (!new Ry(c_half).equal(new Ry(0))) {\r\n      new Ry(c_half).or(qb)\r\n    }\r\n    if (!new Rz(b).equal(new Rz(0))) {\r\n      new Rz(b).or(qb)\r\n    }\r\n    if (a !== 0) {\r\n      Control(eng, cmd.controlQubits, () => new Ph(a).or(qb))\r\n    }\r\n    // Case 2: General matrix U:\r\n  } else {\r\n    const [a, b_half, c_half, d_half] = _find_parameters(matrix)\r\n    const d = 2 * d_half\r\n    const b = 2 * b_half\r\n    if (!new Rz((d - b) / 2.0).equal(new Rz(0))) {\r\n      new Rz((d - b) / 2.0).or(qb)\r\n    }\r\n    Control(eng, cmd.controlQubits, () => X.or(qb))\r\n    if (!new Rz(-(d + b) / 2.0).equal(new Rz(0))) {\r\n      new Rz(-(d + b) / 2.0).or(qb)\r\n    }\r\n    if (!new Ry(-c_half).equal(new Ry(0))) {\r\n      new Ry(-c_half).or(qb)\r\n    }\r\n    Control(eng, cmd.controlQubits, () => X.or(qb))\r\n    if (!new Ry(c_half).equal(new Ry(0))) {\r\n      new Ry(c_half).or(qb)\r\n    }\r\n    if (!new Rz(b).equal(new Rz(0))) {\r\n      new Rz(b).or(qb)\r\n    }\r\n    if (a !== 0) {\r\n      Control(eng, cmd.controlQubits, () => new Ph(a).or(qb))\r\n    }\r\n  }\r\n}\r\n\r\nexport default [\r\n  new DecompositionRule(BasicGate, _decompose_carb1qubit, _recognize_carb1qubit)\r\n]\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/decompositions/carb1qubit2cnotrzandry.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 972,
    "kind": "variable",
    "name": "mm",
    "memberof": "src/setups/decompositions/carb1qubit2cnotrzandry.js",
    "static": true,
    "longname": "src/setups/decompositions/carb1qubit2cnotrzandry.js~mm",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/carb1qubit2cnotrzandry.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 973,
    "kind": "variable",
    "name": "mc",
    "memberof": "src/setups/decompositions/carb1qubit2cnotrzandry.js",
    "static": true,
    "longname": "src/setups/decompositions/carb1qubit2cnotrzandry.js~mc",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/carb1qubit2cnotrzandry.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 974,
    "kind": "variable",
    "name": "TOLERANCE",
    "memberof": "src/setups/decompositions/carb1qubit2cnotrzandry.js",
    "static": true,
    "longname": "src/setups/decompositions/carb1qubit2cnotrzandry.js~TOLERANCE",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/carb1qubit2cnotrzandry.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 975,
    "kind": "function",
    "name": "_recognize_carb1qubit",
    "memberof": "src/setups/decompositions/carb1qubit2cnotrzandry.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/carb1qubit2cnotrzandry.js~_recognize_carb1qubit",
    "access": "private",
    "export": true,
    "importPath": "projectq/src/setups/decompositions/carb1qubit2cnotrzandry.js",
    "importStyle": "{_recognize_carb1qubit}",
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 976,
    "kind": "function",
    "name": "_test_parameters",
    "memberof": "src/setups/decompositions/carb1qubit2cnotrzandry.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/carb1qubit2cnotrzandry.js~_test_parameters",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/carb1qubit2cnotrzandry.js",
    "importStyle": null,
    "description": "It builds matrix V with parameters (a, b, c/2) and compares against\nmatrix.\n\nV = [[-sin(c/2) * exp(j*a), exp(j*(a-b)) * cos(c/2)],\n[exp(j*(a+b)) * cos(c/2), exp(j*a) * sin(c/2)]]",
    "lineNumber": 44,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array.<number[]>"
        ],
        "spread": false,
        "optional": false,
        "name": "matrix",
        "description": "2x2 matrix"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "a",
        "description": "Parameter of V"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "b",
        "description": "Parameter of V"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "c_half",
        "description": "c/2. Parameter of V"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "true if matrix elements of V and `matrix` are TOLERANCE close."
    },
    "ignore": true
  },
  {
    "__docId__": 977,
    "kind": "function",
    "name": "_recognize_v",
    "memberof": "src/setups/decompositions/carb1qubit2cnotrzandry.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/carb1qubit2cnotrzandry.js~_recognize_v",
    "access": "private",
    "export": true,
    "importPath": "projectq/src/setups/decompositions/carb1qubit2cnotrzandry.js",
    "importStyle": "{_recognize_v}",
    "description": "Recognizes a matrix which can be written in the following form:\n\nV = [[-sin(c/2) * exp(j*a), exp(j*(a-b)) * cos(c/2)],\n[exp(j*(a+b)) * cos(c/2), exp(j*a) * sin(c/2)]]",
    "lineNumber": 63,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array.<number[]>"
        ],
        "spread": false,
        "optional": false,
        "name": "matrix",
        "description": "2x2 matrix"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "false if it is not possible otherwise (a, b, c/2)"
    }
  },
  {
    "__docId__": 978,
    "kind": "function",
    "name": "_decompose_carb1qubit",
    "memberof": "src/setups/decompositions/carb1qubit2cnotrzandry.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/carb1qubit2cnotrzandry.js~_decompose_carb1qubit",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/carb1qubit2cnotrzandry.js",
    "importStyle": null,
    "description": "Decompose the single controlled 1 qubit gate into CNOT, Rz, Ry, C(Ph).\n\nSee Nielsen and Chuang chapter 4.3.\n\nAn arbitrary one qubit gate matrix can be writen as\nU = [[exp(j*(a-b/2-d/2))*cos(c/2), -exp(j*(a-b/2+d/2))*sin(c/2)],\n[exp(j*(a+b/2-d/2))*sin(c/2), exp(j*(a+b/2+d/2))*cos(c/2)]]\nwhere a,b,c,d are real numbers.\nThen U = exp(j*a) Rz(b) Ry(c) Rz(d).\n\nThen C(U) = C(exp(ja)) * A * CNOT * B * CNOT * C with\nA = Rz(b) * Ry(c/2)\nB = Ry(-c/2) * Rz(-(d+b)/2)\nC = Rz((d-b)/2)\nNote that a == 0 if U is element of SU(2). Also note that\nthe controlled phase C(exp(ia)) can be implemented with single\nqubit gates.\n\nIf the one qubit gate matrix can be writen as\nV = [[-sin(c/2) * exp(j*a), exp(j*(a-b)) * cos(c/2)],\n[exp(j*(a+b)) * cos(c/2), exp(j*a) * sin(c/2)]]\nThen C(V) = C(exp(ja))* E * CNOT * D with\nE = Rz(b)Ry(c/2)\nD = Ry(-c/2)Rz(-b)\nThis improvement is important for C(Y) or C(Z)\n\nFor a proof follow Lemma 5.5 of Barenco et al.",
    "lineNumber": 182,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": ""
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 979,
    "kind": "file",
    "name": "src/setups/decompositions/carb1qubit2cnotrzandry.spec.js",
    "content": "import {expect} from 'chai'\r\nimport math from 'mathjs'\r\nimport {AutoReplacer, DummyEngine, InstructionFilter} from '../../cengines';\r\nimport MainEngine from '../../cengines/main';\r\nimport {Control} from '../../meta';\r\nimport {\r\n  All,\r\n  BasicGate, ClassicalInstructionGate, Measure, Ph, R, Rx, Ry, Rz, X, XGate\r\n} from '../../ops';\r\nimport carb1q, {_recognize_carb1qubit, _recognize_v} from './carb1qubit2cnotrzandry';\r\nimport {instanceOf} from '../../libs/util';\r\nimport {create_test_matrices} from './arb1qubit2rzandry.spec';\r\nimport Simulator from '../../backends/simulators/simulator';\r\nimport DecompositionRuleSet from '../../cengines/replacer/decompositionruleset'\r\n\r\ndescribe('carb1qubit to cnot rz & ry test', () => {\r\n  it('should test_recognize_correct_gates', () => {\r\n    const saving_backend = new DummyEngine(true)\r\n    const eng = new MainEngine(saving_backend)\r\n    const qubit = eng.allocateQubit()\r\n    const ctrl_qubit = eng.allocateQubit()\r\n    eng.flush()\r\n    Control(eng, ctrl_qubit, () => {\r\n      new Ph(0.1).or(qubit)\r\n      new R(0.2).or(qubit)\r\n      new Rx(0.3).or(qubit)\r\n      X.or(qubit)\r\n    })\r\n\r\n    eng.flush(true)\r\n    // Don't test initial two allocate and flush and trailing deallocate\r\n    // and flush gate.\r\n    const cmds = saving_backend.receivedCommands\r\n    cmds.slice(3, cmds.length - 3).forEach(cmd => expect(_recognize_carb1qubit(cmd)).to.equal(true))\r\n  });\r\n\r\n  it('should test_recognize_incorrect_gates', () => {\r\n    const saving_backend = new DummyEngine(true)\r\n    const eng = new MainEngine(saving_backend)\r\n    const qubit = eng.allocateQubit()\r\n    const ctrl_qubit = eng.allocateQubit()\r\n    const ctrl_qureg = eng.allocateQureg(2)\r\n    eng.flush()\r\n    Control(eng, ctrl_qubit, () => {\r\n      // Does not have matrix attribute:\r\n      new BasicGate().or(qubit)\r\n      // Two qubit gate:\r\n      const two_qubit_gate = new BasicGate()\r\n      two_qubit_gate.matrix = [[1, 0, 0, 0], [0, 1, 0, 0],\r\n        [0, 0, 1, 0], [0, 0, 0, 1]]\r\n      two_qubit_gate.or(qubit)\r\n    })\r\n\r\n    Control(eng, ctrl_qureg, () => {\r\n      // Too many Control qubits:\r\n      new Rx(0.3).or(qubit)\r\n    })\r\n    eng.flush(true)\r\n    saving_backend.receivedCommands.forEach(cmd => expect(_recognize_carb1qubit(cmd)).to.equal(false))\r\n  });\r\n\r\n  function _decomp_gates(eng, cmd) {\r\n    const g = cmd.gate\r\n    if (g instanceof ClassicalInstructionGate) {\r\n      return true\r\n    }\r\n    const cn = cmd.controlCount\r\n    if (cn === 0 && instanceOf(g, [Ry, Rz, Ph])) {\r\n      return true\r\n    }\r\n    if (cn === 1 && instanceOf(g, [XGate, Ph])) {\r\n      return true\r\n    }\r\n    return false\r\n  }\r\n\r\n  it('should test_recognize_v', () => {\r\n    const mc = math.complex\r\n    const data = [[[1, 0], [0, -1]],\r\n      [[0, mc(0, -1)], [mc(0, 1), 0]]]\r\n    data.forEach(gate_matrix => expect(_recognize_v(gate_matrix).length).to.equal(3))\r\n  });\r\n\r\n  it('should test_decomposition', () => {\r\n    const data = create_test_matrices()\r\n    data.forEach((gate_matrix) => {\r\n      // Create single qubit gate with gate_matrix\r\n      const test_gate = new BasicGate()\r\n      test_gate.matrix = gate_matrix\r\n      const states = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0],\r\n        [0, 0, 0, 1]]\r\n      states.forEach((basis_state) => {\r\n        const correct_dummy_eng = new DummyEngine(true)\r\n        const correct_eng = new MainEngine(new Simulator(),\r\n          [correct_dummy_eng])\r\n\r\n        const rule_set = new DecompositionRuleSet(carb1q)\r\n        const test_dummy_eng = new DummyEngine(true)\r\n        const test_eng = new MainEngine(new Simulator(),\r\n          [new AutoReplacer(rule_set),\r\n            new InstructionFilter(_decomp_gates),\r\n            test_dummy_eng])\r\n        const test_sim = test_eng.backend\r\n        const correct_sim = correct_eng.backend\r\n\r\n        const correct_qb = correct_eng.allocateQubit()\r\n        const correct_ctrl_qb = correct_eng.allocateQubit()\r\n        correct_eng.flush()\r\n        const test_qb = test_eng.allocateQubit()\r\n        const test_ctrl_qb = test_eng.allocateQubit()\r\n        test_eng.flush()\r\n\r\n        correct_sim.setWavefunction(basis_state, correct_qb.concat(correct_ctrl_qb))\r\n        test_sim.setWavefunction(basis_state, test_qb.concat(test_ctrl_qb))\r\n\r\n        Control(test_eng, test_ctrl_qb, () => test_gate.or(test_qb))\r\n        Control(correct_eng, correct_ctrl_qb, () => test_gate.or(correct_qb))\r\n\r\n        test_eng.flush()\r\n        correct_eng.flush()\r\n\r\n        expect(correct_dummy_eng.receivedCommands[3].gate.equal(test_gate)).to.equal(true)\r\n        expect(test_dummy_eng.receivedCommands[3].gate.equal(test_gate)).to.equal(false)\r\n\r\n        const bs = ['00', '01', '10', '11']\r\n        bs.forEach((fstate) => {\r\n          const test = test_sim.getAmplitude(fstate, test_qb.concat(test_ctrl_qb))\r\n          const correct = correct_sim.getAmplitude(fstate, correct_qb.concat(correct_ctrl_qb))\r\n          expect(correct.re).to.be.closeTo(test.re, 1e-12)\r\n          expect(correct.im).to.be.closeTo(test.im, 1e-12)\r\n        })\r\n\r\n        new All(Measure).or(test_qb.concat(test_ctrl_qb))\r\n        new All(Measure).or(correct_qb.concat(correct_ctrl_qb))\r\n        test_eng.flush(true)\r\n        correct_eng.flush(true)\r\n      })\r\n    })\r\n  });\r\n})\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/decompositions/carb1qubit2cnotrzandry.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 980,
    "kind": "file",
    "name": "src/setups/decompositions/cnot2cz.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n// Decompose CNOT gates\r\nimport {Compute, Uncompute} from '../../meta/compute';\r\nimport {H, XGate} from '../../ops/gates';\r\nimport {tuple} from '../../libs/util';\r\n\r\nimport {CZ} from '../../ops/shortcuts'\r\nimport DecompositionRule from '../../cengines/replacer/decompositionrule';\r\n\r\nconst _decompose_cnot = (cmd) => {\r\n  const ctrl = cmd.controlQubits\r\n  const eng = cmd.engine\r\n  Compute(eng, () => {\r\n    H.or(cmd.qubits[0])\r\n  })\r\n  CZ.or(tuple(ctrl[0], cmd.qubits[0][0]))\r\n  Uncompute(eng)\r\n}\r\n\r\nexport const _recognize_cnot = cmd => (cmd.controlCount === 1)\r\n\r\nexport default [\r\n  new DecompositionRule(XGate, _decompose_cnot, _recognize_cnot)\r\n]\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/decompositions/cnot2cz.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 981,
    "kind": "function",
    "name": "_decompose_cnot",
    "memberof": "src/setups/decompositions/cnot2cz.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/cnot2cz.js~_decompose_cnot",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/cnot2cz.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 982,
    "kind": "function",
    "name": "_recognize_cnot",
    "memberof": "src/setups/decompositions/cnot2cz.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/cnot2cz.js~_recognize_cnot",
    "access": "private",
    "export": true,
    "importPath": "projectq/src/setups/decompositions/cnot2cz.js",
    "importStyle": "{_recognize_cnot}",
    "description": null,
    "lineNumber": 35,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 983,
    "kind": "file",
    "name": "src/setups/decompositions/cnot2cz.spec.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport {expect} from 'chai'\r\nimport {getEngineList} from '../index';\r\nimport {tuple} from '../../libs/util'\r\nimport {CNOT, CZ} from '../../ops/shortcuts'\r\nimport {Control} from '../../meta/control';\r\nimport {Measure, X, Z} from '../../ops/gates';\r\nimport {_recognize_cnot} from './cnot2cz'\r\nimport {DummyEngine} from '../../cengines/testengine';\r\nimport MainEngine from '../../cengines/main';\r\nimport {All} from '../../ops/metagates';\r\nimport DecompositionRuleSet from '../../cengines/replacer/decompositionruleset';\r\nimport {AutoReplacer, InstructionFilter} from '../../cengines/replacer/replacer';\r\nimport Simulator from \"../../backends/simulators/simulator\";\r\nimport cnot2cz from \"./cnot2cz\";\r\n\r\ndescribe('cnot2cz test', () => {\r\n  it('should test_recognize_gates', () => {\r\n    const saving_backend = new DummyEngine(true)\r\n    const eng = new MainEngine(saving_backend, getEngineList(), true)\r\n    const qubit1 = eng.allocateQubit()\r\n    const qubit2 = eng.allocateQubit()\r\n    const qubit3 = eng.allocateQubit()\r\n    eng.flush()\r\n    CZ.or(tuple(qubit1, qubit2))\r\n    Control(eng, qubit2, () => {\r\n      Z.or(qubit1)\r\n      X.or(qubit1)\r\n    })\r\n    Control(eng, qubit2.concat(qubit3), () => {\r\n      Z.or(qubit1)\r\n    })\r\n\r\n    eng.flush() // To make sure gates arrive before deallocate gates\r\n    eng.flush(true)\r\n    // Don't test initial 4 allocate and flush\r\n\r\n    saving_backend.receivedCommands.slice(5, 7).forEach(cmd => expect(_recognize_cnot(cmd)).to.equal(true))\r\n    saving_backend.receivedCommands.slice(7, 9).forEach(cmd => expect(_recognize_cnot(cmd)).to.equal(false))\r\n  });\r\n\r\n  it('should test_cnot_decomposition', () => {\r\n    const _decomp_gates = (eng, cmd) => {\r\n      const g = cmd.gate\r\n      if (cmd.controlQubits.length === 1 && cmd.gate instanceof X.constructor) {\r\n        return false\r\n      }\r\n      return true\r\n    }\r\n\r\n    for (let basis_state_index = 0; basis_state_index < 4; ++basis_state_index) {\r\n      const basis_state = [0, 0, 0, 0]\r\n      basis_state[basis_state_index] = 1.0\r\n      const correct_dummy_eng = new DummyEngine(true)\r\n      const correct_eng = new MainEngine(new Simulator(), [correct_dummy_eng])\r\n      const rule_set = new DecompositionRuleSet(cnot2cz)\r\n      const test_dummy_eng = new DummyEngine(true)\r\n\r\n      const test_eng = new MainEngine(new Simulator(),\r\n        [new AutoReplacer(rule_set), new InstructionFilter(_decomp_gates), test_dummy_eng])\r\n      const test_sim = test_eng.backend\r\n      const correct_sim = correct_eng.backend\r\n      const correct_qb = correct_eng.allocateQubit()\r\n      const correct_ctrl_qb = correct_eng.allocateQubit()\r\n      correct_eng.flush()\r\n      const test_qb = test_eng.allocateQubit()\r\n      const test_ctrl_qb = test_eng.allocateQubit()\r\n      test_eng.flush()\r\n\r\n      correct_sim.setWavefunction(basis_state, correct_qb.concat(correct_ctrl_qb))\r\n      test_sim.setWavefunction(basis_state, test_qb.concat(test_ctrl_qb))\r\n      CNOT.or(tuple(test_ctrl_qb, test_qb))\r\n      CNOT.or(tuple(correct_ctrl_qb, correct_qb))\r\n\r\n      test_eng.flush()\r\n      correct_eng.flush()\r\n\r\n      expect(correct_dummy_eng.receivedCommands.length).to.equal(5)\r\n      expect(test_dummy_eng.receivedCommands.length).to.equal(7)\r\n\r\n      for (let fstate = 0; fstate < 4; ++fstate) {\r\n        let binary_state = fstate.toString(2)\r\n        if (binary_state.length < 2) {\r\n          binary_state = `0${binary_state}`\r\n        }\r\n        console.log(binary_state)\r\n        const test = test_sim.getAmplitude(binary_state, test_qb.concat(test_ctrl_qb))\r\n        const correct = correct_sim.getAmplitude(binary_state, correct_qb.concat(correct_ctrl_qb))\r\n\r\n        expect(correct.re).to.be.closeTo(test.re, 1e-12, 1e-12)\r\n        expect(correct.im).to.be.closeTo(test.im, 1e-12, 1e-12)\r\n      }\r\n\r\n      new All(Measure).or(test_qb.concat(test_ctrl_qb))\r\n      new All(Measure).or(correct_qb.concat(correct_ctrl_qb))\r\n      test_eng.flush(true)\r\n      correct_eng.flush(true)\r\n    }\r\n  });\r\n})\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/decompositions/cnot2cz.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 984,
    "kind": "file",
    "name": "src/setups/decompositions/cnu2toffoliandcu.js",
    "content": "\r\nimport {Control} from '../../meta/control'\r\nimport {XGate} from '../../ops/gates';\r\nimport DecompositionRule from '../../cengines/replacer/decompositionrule';\r\nimport {BasicGate} from '../../ops/basics';\r\nimport {Compute, Uncompute} from '../../meta/compute';\r\nimport {Toffoli} from '../../ops/shortcuts';\r\nimport {tuple} from '../../libs/util';\r\n\r\n/**\r\n Recognize an arbitrary gate which has n>=2 control qubits, except a Toffoli gate.\r\n*/\r\nexport const _recognize_CnU = (cmd) => {\r\n  const count = cmd.controlCount\r\n  if (count === 2) {\r\n    if (!(cmd.gate instanceof XGate)) {\r\n      return true\r\n    }\r\n  } else if (count > 2) {\r\n    return true\r\n  }\r\n  return false\r\n}\r\n\r\n/**\r\nDecompose a multi-controlled gate U into a single-controlled U.\r\n    It uses (n-1) work qubits and 2 * (n-1) Toffoli gates.\r\n */\r\nexport const _decompose_CnU = (cmd) => {\r\n  const eng = cmd.engine\r\n  const ctrl_qureg = cmd.controlQubits\r\n  const {qubits, gate} = cmd\r\n  const n = cmd.controlCount\r\n  const ancilla_qureg = eng.allocateQureg(n - 1)\r\n\r\n  Compute(eng, () => {\r\n    Toffoli.or(tuple(ctrl_qureg[0], ctrl_qureg[1], ancilla_qureg[0]))\r\n    for (let ctrl_index = 2; ctrl_index < n; ++ctrl_index) {\r\n      Toffoli.or(tuple(ctrl_qureg[ctrl_index], ancilla_qureg[ctrl_index - 2], ancilla_qureg[ctrl_index - 1]))\r\n    }\r\n  })\r\n\r\n  Control(eng, ancilla_qureg[ancilla_qureg.length - 1], () => gate.or(qubits))\r\n  Uncompute(eng)\r\n}\r\n\r\nexport default [\r\n  new DecompositionRule(BasicGate, _decompose_CnU, _recognize_CnU)\r\n]\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/decompositions/cnu2toffoliandcu.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 985,
    "kind": "function",
    "name": "_recognize_CnU",
    "memberof": "src/setups/decompositions/cnu2toffoliandcu.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/cnu2toffoliandcu.js~_recognize_CnU",
    "access": "private",
    "export": true,
    "importPath": "projectq/src/setups/decompositions/cnu2toffoliandcu.js",
    "importStyle": "{_recognize_CnU}",
    "description": "Recognize an arbitrary gate which has n>=2 control qubits, except a Toffoli gate.",
    "lineNumber": 13,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 986,
    "kind": "function",
    "name": "_decompose_CnU",
    "memberof": "src/setups/decompositions/cnu2toffoliandcu.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/cnu2toffoliandcu.js~_decompose_CnU",
    "access": "private",
    "export": true,
    "importPath": "projectq/src/setups/decompositions/cnu2toffoliandcu.js",
    "importStyle": "{_decompose_CnU}",
    "description": "Decompose a multi-controlled gate U into a single-controlled U.\nIt uses (n-1) work qubits and 2 * (n-1) Toffoli gates.",
    "lineNumber": 29,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 987,
    "kind": "file",
    "name": "src/setups/decompositions/cnu2toffoliandcu.spec.js",
    "content": "import {expect} from 'chai'\r\nimport {\r\n  Measure,\r\n  Ph, Rx, Ry, X, XGate\r\n} from '../../ops/gates';\r\nimport {Control} from '../../meta/control';\r\nimport {QFT} from '../../ops/qftgate';\r\nimport {_recognize_CnU} from './cnu2toffoliandcu';\r\nimport {DummyEngine} from '../../cengines/testengine';\r\nimport MainEngine from '../../cengines/main';\r\nimport {ClassicalInstructionGate} from '../../ops/basics';\r\nimport {len} from '../../libs/polyfill';\r\nimport Simulator from '../../backends/simulators/simulator';\r\nimport DecompositionRuleSet from '../../cengines/replacer/decompositionruleset';\r\nimport cnu2toffoliandcu from './cnu2toffoliandcu';\r\nimport {AutoReplacer, InstructionFilter} from '../../cengines/replacer/replacer';\r\nimport {All} from '../../ops/metagates';\r\n\r\ndescribe('cnu 2 toffoli and cu test', () => {\r\n  it('should test_recognize_correct_gates', () => {\r\n    const saving_backend = new DummyEngine(true)\r\n    const eng = new MainEngine(saving_backend)\r\n    const qubit = eng.allocateQubit()\r\n    const ctrl_qureg = eng.allocateQureg(2)\r\n    const ctrl_qureg2 = eng.allocateQureg(3)\r\n    eng.flush()\r\n    Control(eng, ctrl_qureg, () => {\r\n      new Ph(0.1).or(qubit)\r\n      new Ry(0.2).or(qubit)\r\n    })\r\n\r\n    Control(eng, ctrl_qureg2, () => {\r\n      QFT.or(qubit.concat(ctrl_qureg))\r\n      X.or(qubit)\r\n    })\r\n    eng.flush() // To make sure gates arrive before deallocate gates\r\n    eng.flush(true)\r\n    // Don't test initial 6 allocate and flush and trailing deallocate\r\n    // and two flush gates.\r\n    const cmds = saving_backend.receivedCommands\r\n    cmds.slice(7, cmds.length - 8).forEach(cmd => expect(_recognize_CnU(cmd)).to.equal(true))\r\n  });\r\n\r\n  it('should test_recognize_incorrect_gates', () => {\r\n    const saving_backend = new DummyEngine(true)\r\n    const eng = new MainEngine(saving_backend)\r\n    const qubit = eng.allocateQubit()\r\n    const ctrl_qubit = eng.allocateQubit()\r\n    const ctrl_qureg = eng.allocateQureg(2)\r\n    eng.flush()\r\n\r\n    Control(eng, ctrl_qubit, () => new Rx(0.3).or(qubit))\r\n    X.or(qubit)\r\n\r\n    Control(eng, ctrl_qureg, () => X.or(qubit))\r\n    eng.flush(true)\r\n\r\n    saving_backend.receivedCommands.forEach(cmd => expect(_recognize_CnU(cmd)).to.equal(false))\r\n  });\r\n\r\n  it('should test_decomposition', () => {\r\n    const _decomp_gates = (eng, cmd) => {\r\n      const g = cmd.gate\r\n      if (g instanceof ClassicalInstructionGate) {\r\n        return true\r\n      }\r\n\r\n      const n = len(cmd.controlQubits)\r\n      if (n <= 1) {\r\n        return true\r\n      }\r\n      return n === 2 && g instanceof XGate\r\n    }\r\n\r\n    for (let basis_state_index = 0; basis_state_index < 16; ++basis_state_index) {\r\n      const basis_state = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\r\n      basis_state[basis_state_index] = 1.0\r\n      const correct_dummy_eng = new DummyEngine(true)\r\n      const correct_eng = new MainEngine(new Simulator(), [correct_dummy_eng])\r\n      const rule_set = new DecompositionRuleSet(cnu2toffoliandcu)\r\n      const test_dummy_eng = new DummyEngine(true)\r\n      const test_eng = new MainEngine(new Simulator(), [new AutoReplacer(rule_set),\r\n        new InstructionFilter(_decomp_gates), test_dummy_eng])\r\n      const test_sim = test_eng.backend\r\n\r\n      const correct_sim = correct_eng.backend\r\n      const correct_qb = correct_eng.allocateQubit()\r\n      const correct_ctrl_qureg = correct_eng.allocateQureg(3)\r\n      correct_eng.flush()\r\n\r\n      const test_qb = test_eng.allocateQubit()\r\n      const test_ctrl_qureg = test_eng.allocateQureg(3)\r\n      test_eng.flush()\r\n\r\n      correct_sim.setWavefunction(basis_state, correct_qb.concat(correct_ctrl_qureg))\r\n      test_sim.setWavefunction(basis_state, test_qb.concat(test_ctrl_qureg))\r\n\r\n      Control(test_eng, test_ctrl_qureg.slice(0, 2), () => new Rx(0.4).or(test_qb))\r\n      Control(test_eng, test_ctrl_qureg, () => new Ry(0.6).or(test_qb))\r\n\r\n      Control(correct_eng, correct_ctrl_qureg.slice(0, 2), () => new Rx(0.4).or(correct_qb))\r\n      Control(correct_eng, correct_ctrl_qureg, () => new Ry(0.6).or(correct_qb))\r\n\r\n      test_eng.flush()\r\n      correct_eng.flush()\r\n\r\n      expect(len(correct_dummy_eng.receivedCommands)).to.equal(8)\r\n      correct_dummy_eng.receivedCommands.forEach(cmd => console.log(cmd.toString()))\r\n      expect(len(test_dummy_eng.receivedCommands)).to.equal(20)\r\n\r\n      for (let fstate = 0; fstate < 16; ++fstate) {\r\n        let binary_state = fstate.toString(2)\r\n        const append = 4 - binary_state.length\r\n        if (append > 0) {\r\n          for (let i = 0; i < append; ++i) {\r\n            binary_state = `0${binary_state}`\r\n          }\r\n        }\r\n\r\n        const test = test_sim.getAmplitude(binary_state, test_qb.concat(test_ctrl_qureg))\r\n        const correct = correct_sim.getAmplitude(binary_state, correct_qb.concat(correct_ctrl_qureg))\r\n        expect(test.re).to.be.closeTo(correct.re, 1e-12)\r\n      }\r\n\r\n      new All(Measure).or(test_qb.concat(test_ctrl_qureg))\r\n      new All(Measure).or(correct_qb.concat(correct_ctrl_qureg))\r\n      test_eng.flush(true)\r\n      correct_eng.flush(true)\r\n    }\r\n  });\r\n})\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/decompositions/cnu2toffoliandcu.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 988,
    "kind": "file",
    "name": "src/setups/decompositions/crz2cxandrz.js",
    "content": ";\r\nimport {NOT, Rz} from '../../ops/gates';\r\nimport {C} from '../../ops/metagates';\r\nimport {tuple} from '../../libs/util';\r\nimport DecompositionRule from '../../cengines/replacer/decompositionrule';\r\n\r\nconst _decompose_CRz = (cmd) => {\r\n  const qubit = cmd.qubits[0]\r\n  const ctrl = cmd.controlQubits\r\n  const gate = cmd.gate\r\n  const n = cmd.controlCount\r\n\r\n  new Rz(0.5 * gate.angle).or(qubit)\r\n  C(NOT, n).or(tuple(ctrl, qubit))\r\n  new Rz(-0.5 * gate.angle).or(qubit)\r\n  C(NOT, n).or(tuple(ctrl, qubit))\r\n}\r\n\r\nconst _recognize_CRz = cmd => cmd.controlCount >= 1\r\n\r\nexport default [\r\n  new DecompositionRule(Rz, _decompose_CRz, _recognize_CRz)\r\n]\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/decompositions/crz2cxandrz.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 989,
    "kind": "function",
    "name": "_decompose_CRz",
    "memberof": "src/setups/decompositions/crz2cxandrz.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/crz2cxandrz.js~_decompose_CRz",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/crz2cxandrz.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 990,
    "kind": "function",
    "name": "_recognize_CRz",
    "memberof": "src/setups/decompositions/crz2cxandrz.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/crz2cxandrz.js~_recognize_CRz",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/crz2cxandrz.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 991,
    "kind": "file",
    "name": "src/setups/decompositions/entangle.js",
    "content": "\r\n// Decompose the entangle gate.\r\nimport {Control} from '../../meta/control';\r\nimport {All} from '../../ops/metagates';\r\nimport {\r\n  X, H, EntangleGate\r\n} from '../../ops/gates';\r\nimport DecompositionRule from '../../cengines/replacer/decompositionrule';\r\n\r\nconst _decompose_entangle = (cmd) => {\r\n  const qr = cmd.qubits[0]\r\n  const eng = cmd.engine\r\n\r\n  Control(eng, cmd.controlQubits, () => {\r\n    H.or(qr[0])\r\n    Control(eng, qr[0], () => new All(X).or(qr.slice(1)))\r\n  })\r\n}\r\n\r\nexport default [\r\n  new DecompositionRule(EntangleGate, _decompose_entangle)\r\n]\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/decompositions/entangle.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 992,
    "kind": "function",
    "name": "_decompose_entangle",
    "memberof": "src/setups/decompositions/entangle.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/entangle.js~_decompose_entangle",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/entangle.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 993,
    "kind": "file",
    "name": "src/setups/decompositions/gates.spec.js",
    "content": "import {expect} from 'chai'\r\nimport math from 'mathjs'\r\nimport {ClassicalInstructionGate} from '../../ops/basics';\r\nimport {len} from '../../libs/polyfill';\r\nimport Gates, {\r\n  Entangle, Ph, Rz, T, X, Measure, H, R\r\n} from '../../ops/gates';\r\nimport {AutoReplacer, InstructionFilter} from '../../cengines/replacer/replacer';\r\nimport DecompositionRuleSet from '../../cengines/replacer/decompositionruleset';\r\nimport Simulator from '../../backends/simulators/simulator';\r\nimport MainEngine from '../../cengines/main'\r\nimport entangle from './entangle'\r\nimport {All} from '../../ops/metagates'\r\nimport globalphase from './globalphase'\r\nimport r2rzandph from './r2rzandph'\r\nimport {DummyEngine} from '../../cengines/testengine';\r\nimport {tuple} from '../../libs/util';\r\nimport {CRz, Toffoli} from '../../ops/shortcuts';\r\nimport {Control} from '../../meta/control'\r\nimport crz2cxandrz from './crz2cxandrz'\r\nimport ph2r from './ph2r'\r\nimport toffoli2cnotandtgate from './toffoli2cnotandtgate'\r\n\r\nconst {Tdag} = Gates\r\n\r\ndescribe('gates test', () => {\r\n  const low_level_gates = (eng, cmd) => {\r\n    const g = cmd.gate\r\n    if (g instanceof ClassicalInstructionGate) {\r\n      return true\r\n    }\r\n\r\n    if (len(cmd.controlQubits) === 0) {\r\n      if (g.equal(T) || g.equal(Tdag) || g.equal(H) || g instanceof Rz || g instanceof Ph) {\r\n        return true\r\n      }\r\n    } else if (len(cmd.controlQubits) === 1 && g.equal(X)) {\r\n      return true\r\n    }\r\n    return false\r\n  }\r\n\r\n  it('should test_entangle', () => {\r\n    const rule_set = new DecompositionRuleSet(entangle)\r\n    const sim = new Simulator()\r\n    const eng = new MainEngine(sim,\r\n      [new AutoReplacer(rule_set),\r\n        new InstructionFilter(low_level_gates)])\r\n    const qureg = eng.allocateQureg(4)\r\n    Entangle.or(qureg)\r\n\r\n    const m = sim.cheat()[1]\r\n    const v1 = m[0]\r\n    const v2 = m[len(m) - 1]\r\n    expect(v1.re).to.be.closeTo(Math.SQRT1_2, 1e-12)\r\n    expect(v2.re).to.be.closeTo(Math.SQRT1_2, 1e-12)\r\n\r\n    new All(Measure).or(qureg)\r\n  });\r\n\r\n  it('should test_globalphase', () => {\r\n    const low_level_gates_noglobalphase = (eng, cmd) => (low_level_gates(eng, cmd)\r\n    && !(cmd.gate instanceof Ph) && !(cmd.gate instanceof R))\r\n\r\n\r\n    const rule_set = new DecompositionRuleSet([...globalphase, ...r2rzandph])\r\n    const dummy = new DummyEngine(true)\r\n    const eng = new MainEngine(dummy, [new AutoReplacer(rule_set), new InstructionFilter(low_level_gates_noglobalphase)])\r\n\r\n    const qubit = eng.allocateQubit()\r\n    new R(1.2).or(qubit)\r\n\r\n    let rz_count = 0\r\n    dummy.receivedCommands.forEach((cmd) => {\r\n      expect(cmd.gate instanceof R).to.equal(false)\r\n      if (cmd.gate instanceof Rz) {\r\n        rz_count += 1\r\n        expect(cmd.gate.equal(new Rz(1.2))).to.equal(true)\r\n      }\r\n    })\r\n    expect(rz_count).to.equal(1)\r\n  });\r\n\r\n  it('should test_gate_decompositions', () => {\r\n    const run_circuit = (eng) => {\r\n      const qureg = eng.allocateQureg(4)\r\n      new All(H).or(qureg)\r\n      CRz(3.0).or(tuple(qureg[0], qureg[1]))\r\n      Toffoli.or(tuple(qureg[1], qureg[2], qureg[3]))\r\n\r\n      Control(eng, qureg.slice(0, 2), () => new Ph(1.43).or(qureg[2]))\r\n      return qureg\r\n    }\r\n\r\n    const sim = new Simulator()\r\n    const eng = new MainEngine(sim, [])\r\n    const rule_set = new DecompositionRuleSet([...r2rzandph, ...crz2cxandrz, ...toffoli2cnotandtgate, ...ph2r])\r\n\r\n    const qureg = run_circuit(eng)\r\n\r\n    const sim2 = new Simulator()\r\n    const eng_lowlevel = new MainEngine(sim2, [new AutoReplacer(rule_set), new InstructionFilter(low_level_gates)])\r\n    const qureg2 = run_circuit(eng_lowlevel)\r\n\r\n    const m = sim.cheat()[1]\r\n    const m2 = sim2.cheat()[1]\r\n    m.forEach((val, idx) => {\r\n      const v2 = m2[idx]\r\n      expect(val.re).to.be.closeTo(v2.re, 1e-12)\r\n      expect(val.im).to.be.closeTo(v2.im, 1e-12)\r\n    })\r\n\r\n    new All(Measure).or(qureg)\r\n    new All(Measure).or(qureg2)\r\n  });\r\n})\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/decompositions/gates.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 994,
    "kind": "variable",
    "name": "Tdag",
    "memberof": "src/setups/decompositions/gates.spec.js",
    "static": true,
    "longname": "src/setups/decompositions/gates.spec.js~Tdag",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/gates.spec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 995,
    "kind": "file",
    "name": "src/setups/decompositions/globalphase.js",
    "content": "\r\n// Throw out global phases (no controls).\r\n;\r\nimport DecompositionRule from '../../cengines/replacer/decompositionrule';\r\nimport {Ph} from '../../ops/gates';\r\n\r\nconst _decompose_PhNoCtrl = (cmd) => { };\r\n\r\n// Recognize global phases (no controls).\r\nconst _recognize_PhNoCtrl = cmd => cmd.controlCount === 0\r\n\r\nexport default [\r\n  new DecompositionRule(Ph, _decompose_PhNoCtrl, _recognize_PhNoCtrl)\r\n]\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/decompositions/globalphase.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 996,
    "kind": "function",
    "name": "_decompose_PhNoCtrl",
    "memberof": "src/setups/decompositions/globalphase.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/globalphase.js~_decompose_PhNoCtrl",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/globalphase.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 997,
    "kind": "function",
    "name": "_recognize_PhNoCtrl",
    "memberof": "src/setups/decompositions/globalphase.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/globalphase.js~_recognize_PhNoCtrl",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/globalphase.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 998,
    "kind": "file",
    "name": "src/setups/decompositions/index.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nimport arb1qubit2rzandry from './arb1qubit2rzandry'\r\nimport barrier from './barrier'\r\nimport cnot2cz from './cnot2cz'\r\nimport carb1qubit2cnotrzandry from './carb1qubit2cnotrzandry'\r\nimport entangle from './entangle'\r\nimport globalphase from './globalphase'\r\nimport ph2r from './ph2r'\r\nimport toffoli2cnotandtgate from './toffoli2cnotandtgate'\r\nimport crz2cxandrz from './crz2cxandrz'\r\nimport cnu2toffoliandcu from './cnu2toffoliandcu'\r\nimport qft2crandhadamard from './qft2crandhadamard'\r\nimport r2rzandph from './r2rzandph'\r\nimport rx2rz from './rx2rz'\r\nimport ry2rz from './ry2rz'\r\nimport swap2cnot from './swap2cnot'\r\nimport timeevolution from './time_evolution'\r\n\r\nexport default [\r\n  ...arb1qubit2rzandry,\r\n  ...barrier,\r\n  ...cnot2cz,\r\n  ...carb1qubit2cnotrzandry,\r\n  ...crz2cxandrz,\r\n  ...cnu2toffoliandcu,\r\n  ...entangle,\r\n  ...globalphase,\r\n  ...ph2r,\r\n  ...qft2crandhadamard,\r\n  ...r2rzandph,\r\n  ...rx2rz,\r\n  ...ry2rz,\r\n  ...swap2cnot,\r\n  ...toffoli2cnotandtgate,\r\n  ...timeevolution\r\n]\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/decompositions/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 999,
    "kind": "file",
    "name": "src/setups/decompositions/ph2r.js",
    "content": "import {Control} from '../../meta/control'\r\nimport {Ph, R} from '../../ops/gates';\r\nimport DecompositionRule from '../../cengines/replacer/decompositionrule';\r\n\r\n// Decompose the controlled phase gate (C^nPh(phase)).\r\nconst _decompose_Ph = (cmd) => {\r\n  const ctrl = cmd.controlQubits\r\n  const gate = cmd.gate\r\n  const eng = cmd.engine\r\n\r\n  Control(eng, ctrl.slice(1), () => new R(gate.angle).or(ctrl[0]))\r\n}\r\n\r\n// Recognize the controlled phase gate.\r\nconst _recognize_Ph = cmd => cmd.controlCount >= 1\r\n\r\nexport default [\r\n  new DecompositionRule(Ph, _decompose_Ph, _recognize_Ph)\r\n]\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/decompositions/ph2r.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1000,
    "kind": "function",
    "name": "_decompose_Ph",
    "memberof": "src/setups/decompositions/ph2r.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/ph2r.js~_decompose_Ph",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/ph2r.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 1001,
    "kind": "function",
    "name": "_recognize_Ph",
    "memberof": "src/setups/decompositions/ph2r.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/ph2r.js~_recognize_Ph",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/ph2r.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 1002,
    "kind": "file",
    "name": "src/setups/decompositions/qft2crandhadamard.js",
    "content": "import math from 'mathjs'\r\nimport {Control} from '../../meta/control';\r\nimport {H, R} from '../../ops/gates';\r\nimport DecompositionRule from '../../cengines/replacer/decompositionrule';\r\nimport QFTGate from '../../ops/qftgate';\r\n\r\nconst _decompose_QFT = (cmd) => {\r\n  const qb = cmd.qubits[0]\r\n  const eng = cmd.engine\r\n  Control(eng, cmd.controlQubits, () => {\r\n    for (let i = 0; i < qb.length; ++i) {\r\n      const count = qb.length - 1 - i\r\n      H.or(qb[count])\r\n      for (let j = 0; j < count; ++j) {\r\n        Control(eng, qb[qb.length - 1 - (j + i + 1)], () => {\r\n          new R(math.pi / (1 << (1 + j))).or(qb[count])\r\n        })\r\n      }\r\n    }\r\n  })\r\n}\r\n\r\nexport default [\r\n  new DecompositionRule(QFTGate, _decompose_QFT)\r\n]\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/decompositions/qft2crandhadamard.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1003,
    "kind": "function",
    "name": "_decompose_QFT",
    "memberof": "src/setups/decompositions/qft2crandhadamard.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/qft2crandhadamard.js~_decompose_QFT",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/qft2crandhadamard.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 1004,
    "kind": "file",
    "name": "src/setups/decompositions/r2rzandph.js",
    "content": "import {Control} from '../../meta/control';\r\nimport DecompositionRule from '../../cengines/replacer/decompositionrule';\r\nimport {R, Rz, Ph} from '../../ops/gates';\r\n\r\nconst _decompose_R = (cmd) => {\r\n  const ctrl = cmd.controlQubits\r\n  const eng = cmd.engine\r\n  const gate = cmd.gate\r\n\r\n  Control(eng, ctrl, () => {\r\n    new Ph(0.5 * gate.angle).or(cmd.qubits)\r\n    new Rz(gate.angle).or(cmd.qubits)\r\n  })\r\n}\r\n\r\nexport default [\r\n  new DecompositionRule(R, _decompose_R)\r\n]\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/decompositions/r2rzandph.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1005,
    "kind": "function",
    "name": "_decompose_R",
    "memberof": "src/setups/decompositions/r2rzandph.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/r2rzandph.js~_decompose_R",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/r2rzandph.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 1006,
    "kind": "file",
    "name": "src/setups/decompositions/rx2rz.js",
    "content": "import {Control} from '../../meta/control'\r\nimport {Compute, Uncompute} from '../../meta/compute';\r\nimport {H, Rx, Rz} from '../../ops/gates';\r\nimport DecompositionRule from '../../cengines/replacer/decompositionrule';\r\n\r\nconst _decompose_rx = (cmd) => {\r\n  const qubit = cmd.qubits[0]\r\n  const eng = cmd.engine\r\n  const angle = cmd.gate.angle\r\n\r\n  Control(eng, cmd.controlQubits, () => {\r\n    Compute(eng, () => {\r\n      H.or(qubit)\r\n    })\r\n    new Rz(angle).or(qubit)\r\n    Uncompute(eng)\r\n  })\r\n}\r\n\r\nexport const _recognize_RxNoCtrl = cmd => cmd.controlCount === 0\r\n\r\nexport default [\r\n  new DecompositionRule(Rx, _decompose_rx, _recognize_RxNoCtrl)\r\n]\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/decompositions/rx2rz.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1007,
    "kind": "function",
    "name": "_decompose_rx",
    "memberof": "src/setups/decompositions/rx2rz.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/rx2rz.js~_decompose_rx",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/rx2rz.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 1008,
    "kind": "function",
    "name": "_recognize_RxNoCtrl",
    "memberof": "src/setups/decompositions/rx2rz.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/rx2rz.js~_recognize_RxNoCtrl",
    "access": "private",
    "export": true,
    "importPath": "projectq/src/setups/decompositions/rx2rz.js",
    "importStyle": "{_recognize_RxNoCtrl}",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 1009,
    "kind": "file",
    "name": "src/setups/decompositions/rx2rz.spec.js",
    "content": "import {expect} from 'chai'\r\nimport math from 'mathjs'\r\nimport {DummyEngine} from '../../cengines/testengine';\r\nimport MainEngine from '../../cengines/main';\r\nimport {Measure, Rx} from '../../ops/gates';\r\nimport {Control} from '../../meta/control';\r\nimport {_recognize_RxNoCtrl} from './rx2rz';\r\nimport DecompositionRuleSet from '../../cengines/replacer/decompositionruleset';\r\nimport Simulator from '../../backends/simulators/simulator';\r\nimport {AutoReplacer, InstructionFilter} from '../../cengines/replacer/replacer';\r\nimport rx2rz from './rx2rz';\r\n\r\ndescribe('rx2rz test', () => {\r\n  it('should test_recognize_correct_gates', () => {\r\n    const saving_backend = new DummyEngine(true)\r\n    const eng = new MainEngine(saving_backend)\r\n    const qubit = eng.allocateQubit()\r\n    const ctrl_qubit = eng.allocateQubit()\r\n    eng.flush()\r\n    new Rx(0.3).or(qubit)\r\n    Control(eng, ctrl_qubit, () => new Rx(0.4).or(qubit))\r\n    eng.flush(true)\r\n\r\n    expect(_recognize_RxNoCtrl(saving_backend.receivedCommands[3])).to.equal(true)\r\n    expect(_recognize_RxNoCtrl(saving_backend.receivedCommands[4])).to.equal(false)\r\n  });\r\n\r\n  it('should test_decomposition', () => {\r\n    const rx_decomp_gates = (eng, cmd) => !(cmd.gate instanceof Rx)\r\n    const angles = [0, math.pi, 2 * math.pi, 4 * math.pi, 0.5]\r\n    angles.forEach((angle) => {\r\n      const a = [[1, 0], [0, 1]]\r\n      a.forEach((basis_state) => {\r\n        const correct_dummy_eng = new DummyEngine(true)\r\n        const correct_eng = new MainEngine(new Simulator(), [correct_dummy_eng])\r\n\r\n        const rule_set = new DecompositionRuleSet(rx2rz)\r\n        const test_dummy_eng = new DummyEngine(true)\r\n        const test_eng = new MainEngine(new Simulator(), [new AutoReplacer(rule_set), new InstructionFilter(rx_decomp_gates), test_dummy_eng])\r\n\r\n        const correct_qb = correct_eng.allocateQubit()\r\n        new Rx(angle).or(correct_qb)\r\n        correct_eng.flush()\r\n\r\n        const test_qb = test_eng.allocateQubit()\r\n        new Rx(angle).or(test_qb)\r\n        test_eng.flush()\r\n\r\n        expect(correct_dummy_eng.receivedCommands[1].gate.equal(new Rx(angle))).to.equal(true)\r\n        expect(test_dummy_eng.receivedCommands[1].gate.equal(new Rx(angle))).to.equal(false)\r\n\r\n        const states = ['0', '1']\r\n        states.forEach((fstate) => {\r\n          const test = test_eng.backend.getAmplitude(fstate, test_qb)\r\n          const correct = correct_eng.backend.getAmplitude(fstate, correct_qb)\r\n\r\n          expect(test.re).to.be.closeTo(correct.re, 1e-12)\r\n          expect(test.im).to.be.closeTo(correct.im, 1e-12)\r\n        })\r\n\r\n        Measure.or(test_qb)\r\n        Measure.or(correct_qb)\r\n      })\r\n    })\r\n  });\r\n})\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/decompositions/rx2rz.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1010,
    "kind": "file",
    "name": "src/setups/decompositions/ry2rz.js",
    "content": "import {Control} from '../../meta/control'\r\nimport {Compute, Uncompute} from '../../meta/compute';\r\nimport {Rx, Ry, Rz} from '../../ops/gates';\r\nimport DecompositionRule from '../../cengines/replacer/decompositionrule';\r\n\r\nexport const _decompose_ry = (cmd) => {\r\n  const qubit = cmd.qubits[0]\r\n  const eng = cmd.engine\r\n  const angle = cmd.gate.angle\r\n\r\n  Control(eng, cmd.controlQubits, () => {\r\n    Compute(eng, () => {\r\n      new Rx(Math.PI / 2.0).or(qubit)\r\n    })\r\n    new Rz(angle).or(qubit)\r\n    Uncompute(eng)\r\n  })\r\n}\r\n\r\nexport const _recognize_RyNoCtrl = cmd => cmd.controlCount === 0\r\n\r\nexport default [\r\n  new DecompositionRule(Ry, _decompose_ry, _recognize_RyNoCtrl)\r\n]\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/decompositions/ry2rz.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1011,
    "kind": "function",
    "name": "_decompose_ry",
    "memberof": "src/setups/decompositions/ry2rz.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/ry2rz.js~_decompose_ry",
    "access": "private",
    "export": true,
    "importPath": "projectq/src/setups/decompositions/ry2rz.js",
    "importStyle": "{_decompose_ry}",
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 1012,
    "kind": "function",
    "name": "_recognize_RyNoCtrl",
    "memberof": "src/setups/decompositions/ry2rz.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/ry2rz.js~_recognize_RyNoCtrl",
    "access": "private",
    "export": true,
    "importPath": "projectq/src/setups/decompositions/ry2rz.js",
    "importStyle": "{_recognize_RyNoCtrl}",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 1013,
    "kind": "file",
    "name": "src/setups/decompositions/ry2rz.spec.js",
    "content": "import {expect} from 'chai'\r\nimport math from 'mathjs'\r\nimport {DummyEngine} from '../../cengines/testengine';\r\nimport MainEngine from '../../cengines/main';\r\nimport {Measure, Ry} from '../../ops/gates';\r\nimport ry2rz, {_recognize_RyNoCtrl} from './ry2rz';\r\nimport {Control} from '../../meta/control';\r\nimport DecompositionRuleSet from '../../cengines/replacer/decompositionruleset';\r\nimport {AutoReplacer, InstructionFilter} from '../../cengines/replacer/replacer';\r\nimport Simulator from \"../../backends/simulators/simulator\";\r\n\r\ndescribe('ry2rz test', () => {\r\n  it('should test_recognize_correct_gates', () => {\r\n    const saving_backend = new DummyEngine(true)\r\n    const eng = new MainEngine(saving_backend)\r\n    const qubit = eng.allocateQubit()\r\n    const ctrl_qubit = eng.allocateQubit()\r\n    eng.flush()\r\n    new Ry(0.3).or(qubit)\r\n    Control(eng, ctrl_qubit, () => new Ry(0.4).or(qubit))\r\n    eng.flush(true)\r\n    expect(_recognize_RyNoCtrl(saving_backend.receivedCommands[3])).to.equal(true)\r\n    expect(_recognize_RyNoCtrl(saving_backend.receivedCommands[4])).to.equal(false)\r\n  });\r\n\r\n  const ry_decomp_gates = (eng, cmd) => {\r\n    return !(cmd.gate instanceof Ry)\r\n  }\r\n\r\n  it('should test_decomposition', () => {\r\n    const angles = [0, math.pi, 2 * math.pi, 4 * math.pi, 0.5]\r\n    angles.forEach((angle) => {\r\n      const states = [[1, 0], [0, 1]]\r\n      states.forEach((basis_state) => {\r\n        const correct_dummy_eng = new DummyEngine(true)\r\n        const correct_eng = new MainEngine(new Simulator(), [correct_dummy_eng])\r\n\r\n        const rule_set = new DecompositionRuleSet(ry2rz)\r\n        const test_dummy_eng = new DummyEngine(true)\r\n        const test_eng = new MainEngine(new Simulator(), [\r\n          new AutoReplacer(rule_set),\r\n          new InstructionFilter(ry_decomp_gates),\r\n          test_dummy_eng])\r\n\r\n        const correct_qb = correct_eng.allocateQubit()\r\n        new Ry(angle).or(correct_qb)\r\n        correct_eng.flush()\r\n\r\n        const test_qb = test_eng.allocateQubit()\r\n        new Ry(angle).or(test_qb)\r\n        test_eng.flush()\r\n\r\n        expect(correct_dummy_eng.receivedCommands[1].gate.equal(new Ry(angle))).to.equal(true)\r\n        expect(test_dummy_eng.receivedCommands[1].gate.equal(new Ry(angle))).to.equal(false)\r\n\r\n        const arr = ['0', '1']\r\n        arr.forEach((fstate) => {\r\n          const test = test_eng.backend.getAmplitude(fstate, test_qb)\r\n          const correct = correct_eng.backend.getAmplitude(fstate, correct_qb)\r\n\r\n          expect(test.re).to.be.closeTo(correct.re, 1e-12)\r\n          expect(test.im).to.be.closeTo(correct.im, 1e-12)\r\n        })\r\n        Measure.or(test_qb)\r\n        Measure.or(correct_qb)\r\n      })\r\n    })\r\n  });\r\n})\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/decompositions/ry2rz.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1014,
    "kind": "file",
    "name": "src/setups/decompositions/swap2cnot.js",
    "content": "import {Compute, Uncompute} from '../../meta/compute';\r\nimport {CNOT} from '../../ops/shortcuts';\r\nimport {tuple} from '../../libs/util';\r\nimport {Control} from '../../meta/control';\r\nimport DecompositionRule from '../../cengines/replacer/decompositionrule';\r\nimport {SwapGate} from '../../ops/gates';\r\n\r\nconst _decompose_swap = (cmd) => {\r\n  const ctrl = cmd.controlQubits\r\n  const eng = cmd.engine\r\n  Compute(eng, () => {\r\n    CNOT.or(tuple(cmd.qubits[0], cmd.qubits[1]))\r\n  })\r\n  Control(eng, ctrl, () => {\r\n    CNOT.or(tuple(cmd.qubits[1], cmd.qubits[0]))\r\n  })\r\n  Uncompute(eng)\r\n}\r\n\r\nexport default [\r\n  new DecompositionRule(SwapGate, _decompose_swap)\r\n]\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/decompositions/swap2cnot.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1015,
    "kind": "function",
    "name": "_decompose_swap",
    "memberof": "src/setups/decompositions/swap2cnot.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/swap2cnot.js~_decompose_swap",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/swap2cnot.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 1016,
    "kind": "file",
    "name": "src/setups/decompositions/time_evolution.js",
    "content": "\r\n/*\r\nRegisters decomposition for the TimeEvolution gates.\r\n\r\n    An exact straight forward decomposition of a TimeEvolution gate is possible\r\nif the hamiltonian has only one term or if all the terms commute with each\r\n  other in which case one can implement each term individually.\r\n*/\r\n\r\nimport assert from 'assert'\r\nimport QubitOperator, {stringToArray} from '../../ops/qubitoperator';\r\nimport {len, setEqual, setFromRange} from '../../libs/polyfill';\r\nimport {Compute, Control, Uncompute} from '../../meta';\r\nimport TimeEvolution from '../../ops/timeevolution';\r\nimport {tuple} from '../../libs/util';\r\nimport DecompositionRule from '../../cengines/replacer/decompositionrule';\r\nimport {\r\n  CNOT, Rx, Ry, Rz, H\r\n} from '../../ops';\r\n\r\n// Recognize all TimeEvolution gates with >1 terms but which all commute.\r\nfunction _recognize_time_evolution_commuting_terms(cmd) {\r\n  const {hamiltonian} = cmd.gate\r\n  if (len(hamiltonian.terms) === 1) {\r\n    return false\r\n  } else {\r\n    const id_op = new QubitOperator([], 0.0)\r\n    const keys = Object.keys(hamiltonian.terms)\r\n    for (let i = 0; i < keys.length; ++i) {\r\n      const k = keys[i]\r\n      const term = stringToArray(k)\r\n      const coefficient = hamiltonian.terms[k]\r\n      const test_op = new QubitOperator(term, coefficient)\r\n      for (let j = 0; j < keys.length; ++j) {\r\n        const other = keys[j]\r\n        const other_op = new QubitOperator(stringToArray(other), hamiltonian.terms[other])\r\n        const commutator = test_op.mul(other_op).sub(other_op.mul(test_op))\r\n        if (!commutator.isClose(id_op, 1e-9, 1e-9)) {\r\n          return false\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return true\r\n}\r\n\r\nfunction _decompose_time_evolution_commuting_terms(cmd) {\r\n  const qureg = cmd.qubits\r\n  const eng = cmd.engine\r\n  const {hamiltonian, time} = cmd.gate\r\n  Control(eng, cmd.controlQubits, () => {\r\n    Object.keys(hamiltonian.terms).forEach((key) => {\r\n      const coefficient = hamiltonian.terms[key]\r\n      const term = stringToArray(key)\r\n      const ind_operator = new QubitOperator(term, coefficient)\r\n      new TimeEvolution(time, ind_operator).or(qureg)\r\n    })\r\n  })\r\n}\r\n\r\nfunction _recognize_time_evolution_individual_terms(cmd) {\r\n  return len(cmd.gate.hamiltonian.terms) === 1\r\n}\r\n\r\n/**\r\nImplements a TimeEvolution gate with a hamiltonian having only one term.\r\n\r\n    To implement exp(-i * t * hamiltonian), where the hamiltonian is only one\r\nterm, e.g., hamiltonian = X0 x Y1 X Z2, we first perform local\r\ntransformations to in order that all Pauli operators in the hamiltonian\r\nare Z. We then implement  exp(-i * t * (Z1 x Z2 x Z3) and transform the\r\nbasis back to the original. For more details see, e.g.,\r\n\r\n    James D. Whitfield, Jacob Biamonte & Aspuru-Guzik\r\nSimulation of electronic structure Hamiltonians using quantum computers,\r\n    Molecular Physics, 109:5, 735-750 (2011).\r\n\r\n    or\r\n\r\nNielsen and Chuang, Quantum Computation and Information.\r\n @param {Command} cmd\r\n */\r\nfunction _decompose_time_evolution_individual_terms(cmd) {\r\n  assert(len(cmd.qubits) === 1)\r\n  const qureg = cmd.qubits[0]\r\n  const eng = cmd.engine\r\n  const {time, hamiltonian} = cmd.gate\r\n  assert(len(hamiltonian.terms) === 1)\r\n  let term = Object.keys(hamiltonian.terms)[0]\r\n  term = stringToArray(term)\r\n  const coefficient = hamiltonian.terms[term]\r\n  const check_indices = new Set()\r\n\r\n  // Check that hamiltonian is not identity term,\r\n  // Previous __or__ operator should have apply a global phase instead:\r\n  assert(term.length !== 0)\r\n\r\n  // hamiltonian has only a single local operator\r\n  if (len(term) === 1) {\r\n    Control(eng, cmd.controlQubits, () => {\r\n      const [idx, action] = term[0]\r\n      if (action === 'X') {\r\n        new Rx(time * coefficient * 2.0).or(qureg[idx])\r\n      } else if (action === 'Y') {\r\n        new Ry(time * coefficient * 2.0).or(qureg[idx])\r\n      } else {\r\n        new Rz(time * coefficient * 2.0).or(qureg[idx])\r\n      }\r\n    })\r\n\r\n    // hamiltonian has more than one local operator\r\n  } else {\r\n    Control(eng, cmd.controlQubits, () => {\r\n      Compute(eng, () => {\r\n        // Apply local basis rotations\r\n        term.forEach(([index, action]) => {\r\n          check_indices.add(index)\r\n          if (action === 'X') {\r\n            H.or(qureg[index])\r\n          } else if (action === 'Y') {\r\n            new Rx(Math.PI / 2.0).or(qureg[index])\r\n          }\r\n        })\r\n\r\n        // Check that qureg had exactly as many qubits as indices:\r\n        assert(setEqual(check_indices, setFromRange(qureg.length)))\r\n        // Compute parity\r\n        for (let i = 0; i < qureg.length - 1; ++i) {\r\n          CNOT.or(tuple(qureg[i], qureg[i + 1]))\r\n        }\r\n      })\r\n\r\n      new Rz(time * coefficient * 2.0).or(qureg[qureg.length - 1])\r\n      // Uncompute parity and basis change\r\n      Uncompute(eng)\r\n    })\r\n  }\r\n}\r\n\r\nexport const rule_commuting_terms = new DecompositionRule(\r\n  TimeEvolution,\r\n  _decompose_time_evolution_commuting_terms,\r\n  _recognize_time_evolution_commuting_terms\r\n)\r\n\r\n\r\nexport const rule_individual_terms = new DecompositionRule(\r\n  TimeEvolution,\r\n  _decompose_time_evolution_individual_terms,\r\n  _recognize_time_evolution_individual_terms\r\n)\r\n\r\nexport default [rule_commuting_terms, rule_individual_terms]\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/decompositions/time_evolution.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1017,
    "kind": "function",
    "name": "_recognize_time_evolution_commuting_terms",
    "memberof": "src/setups/decompositions/time_evolution.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/time_evolution.js~_recognize_time_evolution_commuting_terms",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/time_evolution.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1018,
    "kind": "function",
    "name": "_decompose_time_evolution_commuting_terms",
    "memberof": "src/setups/decompositions/time_evolution.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/time_evolution.js~_decompose_time_evolution_commuting_terms",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/time_evolution.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 47,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 1019,
    "kind": "function",
    "name": "_recognize_time_evolution_individual_terms",
    "memberof": "src/setups/decompositions/time_evolution.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/time_evolution.js~_recognize_time_evolution_individual_terms",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/time_evolution.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 61,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1020,
    "kind": "function",
    "name": "_decompose_time_evolution_individual_terms",
    "memberof": "src/setups/decompositions/time_evolution.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/time_evolution.js~_decompose_time_evolution_individual_terms",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/time_evolution.js",
    "importStyle": null,
    "description": "Implements a TimeEvolution gate with a hamiltonian having only one term.\n\nTo implement exp(-i * t * hamiltonian), where the hamiltonian is only one\nterm, e.g., hamiltonian = X0 x Y1 X Z2, we first perform local\ntransformations to in order that all Pauli operators in the hamiltonian\nare Z. We then implement  exp(-i * t * (Z1 x Z2 x Z3) and transform the\nbasis back to the original. For more details see, e.g.,\n\nJames D. Whitfield, Jacob Biamonte & Aspuru-Guzik\nSimulation of electronic structure Hamiltonians using quantum computers,\nMolecular Physics, 109:5, 735-750 (2011).\n\nor\n\nNielsen and Chuang, Quantum Computation and Information.",
    "lineNumber": 83,
    "params": [
      {
        "nullable": null,
        "types": [
          "Command"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": ""
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 1021,
    "kind": "variable",
    "name": "rule_commuting_terms",
    "memberof": "src/setups/decompositions/time_evolution.js",
    "static": true,
    "longname": "src/setups/decompositions/time_evolution.js~rule_commuting_terms",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/setups/decompositions/time_evolution.js",
    "importStyle": "{rule_commuting_terms}",
    "description": null,
    "lineNumber": 140,
    "undocument": true,
    "type": {
      "types": [
        "src/cengines/replacer/decompositionrule.js~DecompositionRule"
      ]
    }
  },
  {
    "__docId__": 1022,
    "kind": "variable",
    "name": "rule_individual_terms",
    "memberof": "src/setups/decompositions/time_evolution.js",
    "static": true,
    "longname": "src/setups/decompositions/time_evolution.js~rule_individual_terms",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/setups/decompositions/time_evolution.js",
    "importStyle": "{rule_individual_terms}",
    "description": null,
    "lineNumber": 147,
    "undocument": true,
    "type": {
      "types": [
        "src/cengines/replacer/decompositionrule.js~DecompositionRule"
      ]
    }
  },
  {
    "__docId__": 1023,
    "kind": "file",
    "name": "src/setups/decompositions/time_evolution.spec.js",
    "content": "import {expect} from 'chai'\r\nimport math from 'mathjs';\r\nimport MainEngine from '../../cengines/main';\r\nimport {AutoReplacer, DummyEngine, InstructionFilter} from '../../cengines';\r\nimport QubitOperator from '../../ops/qubitoperator';\r\nimport TimeEvolution from '../../ops/timeevolution';\r\nimport {rule_commuting_terms, rule_individual_terms} from './time_evolution'\r\nimport {len} from '../../libs/polyfill';\r\nimport {\r\n  All, ClassicalInstructionGate, Measure, Ph, Rx, Ry, Rz\r\n} from '../../ops';\r\nimport DecompositionRuleSet from '../../cengines/replacer/decompositionruleset';\r\nimport {Control} from '../../meta';\r\nimport Simulator from '../../backends/simulators/simulator';\r\n\r\nfunction convertNativeMatrix(vec) {\r\n  const m = math.zeros(vec.length)\r\n  vec.forEach((val, idx) => {\r\n    m.subset(math.index(idx), math.complex(val.re, val.im))\r\n  })\r\n  return m\r\n}\r\n\r\ndescribe('time evolution test', () => {\r\n  it('should test_recognize_commuting_terms', () => {\r\n    const saving_backend = new DummyEngine(true)\r\n    const eng = new MainEngine(saving_backend, [])\r\n    const wavefunction = eng.allocateQureg(5)\r\n    const op1 = new QubitOperator('X1 Y2', 0.5)\r\n    const op2 = new QubitOperator('Y2 X4', -0.5)\r\n    const op3 = new QubitOperator([], 0.5)\r\n    const op4 = new QubitOperator('X1 Y2', 0.5).add(new QubitOperator('X2', 1e-10))\r\n    const op5 = new QubitOperator('X1 Y2', 0.5).add(new QubitOperator('X2', 1e-8))\r\n    const op6 = new QubitOperator('X2', 1.0)\r\n    new TimeEvolution(1.0, op1.add(op2).add(op3).add(op4)).or(wavefunction)\r\n    new TimeEvolution(1.0, op1.add(op5)).or(wavefunction)\r\n    new TimeEvolution(1.0, op1.add(op6)).or(wavefunction)\r\n    new TimeEvolution(1.0, op1).or(wavefunction)\r\n\r\n    const cmd1 = saving_backend.receivedCommands[5]\r\n    const cmd2 = saving_backend.receivedCommands[6]\r\n    const cmd3 = saving_backend.receivedCommands[7]\r\n    const cmd4 = saving_backend.receivedCommands[8]\r\n\r\n    expect(rule_commuting_terms.gateRecognizer(cmd1)).to.equal(true)\r\n    expect(rule_commuting_terms.gateRecognizer(cmd2)).to.equal(false)\r\n    expect(rule_commuting_terms.gateRecognizer(cmd3)).to.equal(false)\r\n    expect(rule_commuting_terms.gateRecognizer(cmd4)).to.equal(false)\r\n  });\r\n\r\n  it('should test_decompose_commuting_terms', () => {\r\n    const saving_backend = new DummyEngine(true)\r\n\r\n    const my_filter = (_, cmd) => {\r\n      return (len(cmd.qubits[0]) <= 2 || cmd.gate instanceof ClassicalInstructionGate)\r\n    }\r\n\r\n    const rules = new DecompositionRuleSet([rule_commuting_terms])\r\n    const replacer = new AutoReplacer(rules)\r\n    const filter_eng = new InstructionFilter(my_filter)\r\n    const eng = new MainEngine(saving_backend, [replacer, filter_eng])\r\n    const qureg = eng.allocateQureg(5)\r\n    Control(eng, qureg[3], () => {\r\n      const op1 = new QubitOperator('X1 Y2', 0.7)\r\n      const op2 = new QubitOperator('Y2 X4', -0.8)\r\n      const op3 = new QubitOperator([], 0.6)\r\n      new TimeEvolution(1.5, op1.add(op2).add(op3)).or(qureg)\r\n    })\r\n    const cmd1 = saving_backend.receivedCommands[5]\r\n    const cmd2 = saving_backend.receivedCommands[6]\r\n    const cmd3 = saving_backend.receivedCommands[7]\r\n\r\n    const found = [false, false, false]\r\n    const scaled_op1 = new QubitOperator('X0 Y1', 0.7)\r\n    const scaled_op2 = new QubitOperator('Y0 X1', -0.8)\r\n    const cmds = [cmd1, cmd2, cmd3]\r\n    const pgate = new Ph(-1.5 * 0.6)\r\n    cmds.forEach((cmd) => {\r\n      if (pgate.equal(cmd.gate)\r\n      && cmd.qubits[0][0].id === qureg[1].id // 1st qubit of [1,2,4]\r\n      && cmd.controlQubits[0].id === qureg[3].id) {\r\n        found[0] = true\r\n      } else if ((cmd.gate instanceof TimeEvolution)\r\n      && cmd.gate.hamiltonian.isClose(scaled_op1)\r\n      && Math.abs(cmd.gate.time - 1.5) < 1e-12\r\n      && cmd.qubits[0][0].id === qureg[1].id\r\n      && cmd.qubits[0][1].id === qureg[2].id\r\n      && cmd.controlQubits[0].id === qureg[3].id) {\r\n        found[1] = true\r\n      } else if ((cmd.gate instanceof TimeEvolution)\r\n      && cmd.gate.hamiltonian.isClose(scaled_op2)\r\n          && Math.abs(cmd.gate.time - 1.5) < 1e-12\r\n      && cmd.qubits[0][0].id === qureg[2].id\r\n      && cmd.qubits[0][1].id === qureg[4].id\r\n      && cmd.controlQubits[0].id === qureg[3].id) {\r\n        found[2] = true\r\n      }\r\n    })\r\n\r\n    expect(found.indexOf(false) === -1).to.equal(true)\r\n  });\r\n\r\n  it('should test_recognize_individual_terms', () => {\r\n    const saving_backend = new DummyEngine(true)\r\n    const eng = new MainEngine(saving_backend, [])\r\n    const wavefunction = eng.allocateQureg(5)\r\n    const op1 = new QubitOperator('X1 Y2', 0.5)\r\n    const op2 = new QubitOperator('Y2 X4', -0.5)\r\n    const op3 = new QubitOperator('X2', 1.0)\r\n    new TimeEvolution(1.0, op1.add(op2)).or(wavefunction)\r\n    new TimeEvolution(1.0, op2).or(wavefunction)\r\n    new TimeEvolution(1.0, op3).or(wavefunction)\r\n\r\n    const cmd1 = saving_backend.receivedCommands[5]\r\n    const cmd2 = saving_backend.receivedCommands[6]\r\n    const cmd3 = saving_backend.receivedCommands[7]\r\n\r\n    expect(rule_individual_terms.gateRecognizer(cmd1)).to.equal(false)\r\n    expect(rule_individual_terms.gateRecognizer(cmd2)).to.equal(true)\r\n    expect(rule_individual_terms.gateRecognizer(cmd3)).to.equal(true)\r\n  });\r\n\r\n  it('should test_decompose_individual_terms', () => {\r\n    const saving_eng = new DummyEngine(true)\r\n\r\n    function my_filter(_, cmd) {\r\n      return !(cmd.gate instanceof TimeEvolution)\r\n    }\r\n\r\n    const rules = new DecompositionRuleSet([rule_individual_terms])\r\n    const replacer = new AutoReplacer(rules)\r\n    const filter_eng = new InstructionFilter(my_filter)\r\n    const eng = new MainEngine(new Simulator(), [replacer, filter_eng, saving_eng])\r\n    const qureg = eng.allocateQureg(5)\r\n    // initialize in random wavefunction by applying some gates:\r\n    new Rx(0.1).or(qureg[0])\r\n    new Ry(0.2).or(qureg[1])\r\n    new Rx(0.45).or(qureg[2])\r\n    new Rx(0.6).or(qureg[3])\r\n    new Ry(0.77).or(qureg[4])\r\n    eng.flush()\r\n    // Use cheat to get initial start wavefunction:\r\n    let [qubit_to_bit_map, init_wavefunction] = eng.backend.cheat()\r\n    // Apply one qubit gates:\r\n    const op1 = new QubitOperator([], 0.6)\r\n    const op2 = new QubitOperator('X2', 0.21)\r\n    const op3 = new QubitOperator('Y1', 0.33)\r\n    const op4 = new QubitOperator('Z3', 0.42)\r\n    const op5 = new QubitOperator('X0 Y1 Z2 Z4', -0.5)\r\n    new TimeEvolution(1.1, op1).or(qureg)\r\n    eng.flush()\r\n    let [qbit_to_bit_map1, final_wavefunction1] = eng.backend.cheat()\r\n    final_wavefunction1 = math.flatten(final_wavefunction1)\r\n    final_wavefunction1 = convertNativeMatrix(final_wavefunction1)\r\n    new TimeEvolution(1.2, op2).or(qureg)\r\n    eng.flush()\r\n    let [qbit_to_bit_map2, final_wavefunction2] = eng.backend.cheat()\r\n    final_wavefunction2 = math.flatten(final_wavefunction2)\r\n    final_wavefunction2 = convertNativeMatrix(final_wavefunction2)\r\n\r\n    new TimeEvolution(1.3, op3).or(qureg)\r\n    eng.flush()\r\n    let [qbit_to_bit_map3, final_wavefunction3] = eng.backend.cheat()\r\n    new TimeEvolution(1.4, op4).or(qureg)\r\n    eng.flush()\r\n    let [qbit_to_bit_map4, final_wavefunction4] = eng.backend.cheat()\r\n    new TimeEvolution(1.5, op5).or(qureg)\r\n    eng.flush()\r\n    let [qbit_to_bit_map5, final_wavefunction5] = eng.backend.cheat()\r\n    new All(Measure).or(qureg)\r\n    // Check manually:\r\n\r\n    const build_matrix = (list_single_matrices) => {\r\n      let res = list_single_matrices[0]\r\n      for (let i = 1; i < len(list_single_matrices); ++i) {\r\n        res = math.kron(res, list_single_matrices[i])\r\n      }\r\n      return res\r\n    }\r\n\r\n    const mc = math.complex\r\n    const id_sp = math.identity(2, 'sparse')\r\n    const x_sp = math.sparse([[0.0, 1.0], [1.0, 0.0]])\r\n    const y_sp = math.sparse([[0.0, mc(0, -1.0)], [mc(0, 1.0), 0.0]])\r\n    const z_sp = math.sparse([[1.0, 0.0], [0.0, -1.0]])\r\n\r\n    const matrix1 = math.multiply(math.identity(2 ** 5), mc(0, -0.6 * 1.1))\r\n    init_wavefunction = math.flatten(init_wavefunction)\r\n    init_wavefunction = convertNativeMatrix(init_wavefunction)\r\n    const step1 = math.multiply(math.expm(matrix1), math.matrix(init_wavefunction))\r\n    expect(math.deepEqual(step1, final_wavefunction1)).to.equal(true)\r\n\r\n    const matrix2_list = []\r\n    for (let i = 0; i < 5; ++i) {\r\n      if (i === qbit_to_bit_map2[qureg[2].id]) {\r\n        matrix2_list.push(x_sp)\r\n      } else {\r\n        matrix2_list.push(id_sp)\r\n      }\r\n    }\r\n    matrix2_list.reverse()\r\n    const matrix2 = math.multiply(build_matrix(matrix2_list), mc(0, 0.21 * 1.2 * -1.0))\r\n    const step2 = math.multiply(math.expm(matrix2), step1)\r\n    expect(math.deepEqual(step2, final_wavefunction2)).to.equal(true)\r\n\r\n    final_wavefunction3 = math.flatten(final_wavefunction3)\r\n    final_wavefunction3 = convertNativeMatrix(final_wavefunction3)\r\n    const matrix3_list = []\r\n    for (let i = 0; i < 5; ++i) {\r\n      if (i === qbit_to_bit_map3[qureg[1].id]) {\r\n        matrix3_list.push(y_sp)\r\n      } else {\r\n        matrix3_list.push(id_sp)\r\n      }\r\n    }\r\n    matrix3_list.reverse()\r\n    const matrix3 = math.multiply(build_matrix(matrix3_list), mc(0, 0.33 * 1.3 * -1.0))\r\n    const step3 = math.multiply(math.expm(matrix3), final_wavefunction2)\r\n    expect(math.deepEqual(step3, final_wavefunction3)).to.equal(true)\r\n\r\n    final_wavefunction4 = convertNativeMatrix(math.flatten(final_wavefunction4))\r\n    const matrix4_list = []\r\n    for (let i = 0; i < 5; ++i) {\r\n      if (i === qbit_to_bit_map4[qureg[3].id]) {\r\n        matrix4_list.push(z_sp)\r\n      } else {\r\n        matrix4_list.push(id_sp)\r\n      }\r\n    }\r\n    matrix4_list.reverse()\r\n    const matrix4 = math.multiply(build_matrix(matrix4_list), mc(0, 0.42 * 1.4 * -1.0))\r\n    const step4 = math.multiply(math.expm(matrix4), final_wavefunction3)\r\n    expect(math.deepEqual(step4, final_wavefunction4)).to.equal(true)\r\n\r\n    const matrix5_list = []\r\n    for (let i = 0; i < 5; ++i) {\r\n      if (i === qbit_to_bit_map5[qureg[0].id]) {\r\n        matrix5_list.push(x_sp)\r\n      } else if (i === qbit_to_bit_map5[qureg[1].id]) {\r\n        matrix5_list.push(y_sp)\r\n      } else if (i === qbit_to_bit_map5[qureg[2].id]) {\r\n        matrix5_list.push(z_sp)\r\n      } else if (i === qbit_to_bit_map5[qureg[4].id]) {\r\n        matrix5_list.push(z_sp)\r\n      } else {\r\n        matrix5_list.push(id_sp)\r\n      }\r\n    }\r\n    matrix5_list.reverse()\r\n    const matrix5 = math.multiply(build_matrix(matrix5_list), mc(0, -0.5 * 1.5 * -1.0))\r\n    const step5 = math.multiply(math.expm(matrix5), final_wavefunction4)\r\n\r\n    final_wavefunction5 = convertNativeMatrix(math.flatten(final_wavefunction5))\r\n    expect(math.deepEqual(step5, final_wavefunction5)).to.equal(true)\r\n  });\r\n});\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/decompositions/time_evolution.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1024,
    "kind": "function",
    "name": "convertNativeMatrix",
    "memberof": "src/setups/decompositions/time_evolution.spec.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/time_evolution.spec.js~convertNativeMatrix",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/time_evolution.spec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "params": [
      {
        "name": "vec",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1025,
    "kind": "file",
    "name": "src/setups/decompositions/toffoli2cnotandtgate.js",
    "content": "// \"\"\" Decompose the Toffoli gate into CNOT, H, T, and Tdagger gates. \"\"\"\r\nimport {tuple} from '../../libs/util';\r\nimport Gates, {H, NOT, T} from '../../ops/gates';\r\nimport {CNOT} from '../../ops/shortcuts';\r\n;\r\nimport DecompositionRule from '../../cengines/replacer/decompositionrule';\r\n\r\nconst {Tdag} = Gates\r\n\r\nconst _decompose_toffoli = (cmd) => {\r\n  const ctrl = cmd.controlQubits\r\n\r\n  const target = cmd.qubits[0]\r\n  const c1 = ctrl[0]\r\n  const c2 = ctrl[1]\r\n\r\n  H.or(target)\r\n  CNOT.or(tuple(c1, target))\r\n  T.or(c1)\r\n  Tdag.or(target)\r\n  CNOT.or(tuple(c2, target))\r\n  CNOT.or(tuple(c2, c1))\r\n  Tdag.or(c1)\r\n  T.or(target)\r\n  CNOT.or(tuple(c2, c1))\r\n  CNOT.or(tuple(c1, target))\r\n  Tdag.or(target)\r\n  CNOT.or(tuple(c2, target))\r\n  T.or(target)\r\n  T.or(c2)\r\n  H.or(target)\r\n}\r\n\r\nconst _recognize_toffoli = cmd => cmd.controlCount === 2\r\n\r\nexport default [\r\n  new DecompositionRule(NOT.constructor, _decompose_toffoli, _recognize_toffoli)\r\n]\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/decompositions/toffoli2cnotandtgate.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1026,
    "kind": "variable",
    "name": "Tdag",
    "memberof": "src/setups/decompositions/toffoli2cnotandtgate.js",
    "static": true,
    "longname": "src/setups/decompositions/toffoli2cnotandtgate.js~Tdag",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/toffoli2cnotandtgate.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1027,
    "kind": "function",
    "name": "_decompose_toffoli",
    "memberof": "src/setups/decompositions/toffoli2cnotandtgate.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/toffoli2cnotandtgate.js~_decompose_toffoli",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/toffoli2cnotandtgate.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 1028,
    "kind": "function",
    "name": "_recognize_toffoli",
    "memberof": "src/setups/decompositions/toffoli2cnotandtgate.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/decompositions/toffoli2cnotandtgate.js~_recognize_toffoli",
    "access": "private",
    "export": false,
    "importPath": "projectq/src/setups/decompositions/toffoli2cnotandtgate.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 34,
    "undocument": true,
    "params": [
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 1029,
    "kind": "file",
    "name": "src/setups/grid.js",
    "content": "\r\nimport assert from 'assert'\r\nimport {\r\n  BasicMathGate, ClassicalInstructionGate, CNOT, ControlledGate, QFT, Swap\r\n} from '../ops';\r\nimport {getInverse} from '../ops/_cycle';\r\nimport DecompositionRuleSet from '../cengines/replacer/decompositionruleset';\r\nimport {instanceOf, isKindclassOf} from '../libs/util';\r\nimport {AutoReplacer, InstructionFilter} from '../cengines';\r\nimport TagRemover from '../cengines/tagremover'\r\nimport LocalOptimizer from '../cengines/optimize'\r\nimport math from '../libs/math/defaultrules'\r\nimport decompositions from './decompositions'\r\nimport GridMapper from '../cengines/twodmapper';\r\n\r\n/**\r\n * @desc Remove any MathGates\r\n */\r\nexport function high_level_gates(eng, cmd) {\r\n  const {gate} = cmd\r\n  if (gate.equal(QFT) || getInverse(gate).equal(QFT) || gate.equal(Swap)) {\r\n    return true\r\n  }\r\n  if (gate instanceof BasicMathGate) {\r\n    return false\r\n  }\r\n  return true\r\n}\r\n\r\nfunction one_and_two_qubit_gates(eng, cmd) {\r\n  const allqubits = []\r\n  cmd.allQubits.forEach(qr => qr.forEach(q => allqubits.push(q)))\r\n\r\n  // This is required to allow Measure, Allocate, Deallocate, Flush\r\n  if (cmd.gate instanceof ClassicalInstructionGate) {\r\n    return true\r\n  } else if (allqubits.length <= 2) {\r\n    return true\r\n  }\r\n  return false\r\n}\r\n\r\n/**\r\n * Returns an engine list to compile to a 2-D grid of qubits.\r\n\r\n Note:\r\n If you choose a new gate set for which the compiler does not yet have\r\n standard rules, it raises an `NoGateDecompositionError` or a\r\n `RuntimeError: maximum recursion depth exceeded...`. Also note that\r\n even the gate sets which work might not yet be optimized. So make sure\r\n to double check and potentially extend the decomposition rules.\r\n This implemention currently requires that the one qubit gates must\r\n contain Rz and at least one of {Ry(best), Rx, H} and the two qubit gate\r\n must contain CNOT (recommended) or CZ.\r\n\r\n Note:\r\n Classical instructions gates such as e.g. Flush and Measure are\r\n automatically allowed.\r\n\r\n Example:\r\n get_engine_list(num_rows=2, num_columns=3,\r\n one_qubit_gates=(Rz, Ry, Rx, H),\r\n two_qubit_gates=(CNOT,))\r\n\r\n Args:\r\n num_rows(int): Number of rows in the grid\r\n num_columns(int): Number of columns in the grid.\r\n one_qubit_gates: \"any\" allows any one qubit gate, otherwise provide\r\n a tuple of the allowed gates. If the gates are\r\n instances of a class (e.g. X), it allows all gates\r\n which are equal to it. If the gate is a class (Rz), it\r\n allows all instances of this class. Default is \"any\"\r\n two_qubit_gates: \"any\" allows any two qubit gate, otherwise provide\r\n a tuple of the allowed gates. If the gates are\r\n instances of a class (e.g. CNOT), it allows all gates\r\n which are equal to it. If the gate is a class, it\r\n allows all instances of this class.\r\n Default is (CNOT, Swap).\r\n Raises:\r\n TypeError: If input is for the gates is not \"any\" or a tuple.\r\n\r\n Returns:\r\n A list of suitable compiler engines.\r\n * @param {number} num_rows\r\n * @param {number} num_columns\r\n * @param {string|Array.<BasicGate>} one_qubit_gates\r\n * @param {string|Array.<BasicGate>} two_qubit_gates\r\n */\r\nexport function getEngineList(num_rows, num_columns, one_qubit_gates = 'any', two_qubit_gates = [CNOT, Swap]) {\r\n  if (two_qubit_gates !== 'any' && !Array.isArray(two_qubit_gates)) {\r\n    throw new Error(\"two_qubit_gates parameter must be 'any' or a tuple. \"\r\n        + 'When supplying only one gate, make sure to correctly '\r\n        + \"create the tuple (don't miss the comma), \"\r\n        + 'e.g. two_qubit_gates=(CNOT,)')\r\n  }\r\n  if (one_qubit_gates !== 'any' && !Array.isArray(one_qubit_gates)) {\r\n    throw new Error(\"one_qubit_gates parameter must be 'any' or a tuple.\")\r\n  }\r\n  const rule_set = new DecompositionRuleSet([...math, ...decompositions])\r\n  const allowed_gate_classes = []\r\n  const allowed_gate_instances = []\r\n\r\n  if (one_qubit_gates !== 'any') {\r\n    one_qubit_gates.forEach((gate) => {\r\n      if (typeof gate === 'function') {\r\n        allowed_gate_classes.push(gate)\r\n      } else {\r\n        allowed_gate_instances.push([gate, 0])\r\n      }\r\n    })\r\n  }\r\n  if (two_qubit_gates !== 'any') {\r\n    two_qubit_gates.forEach((gate) => {\r\n      if (typeof gate === 'function') {\r\n        //  Controlled gate classes don't yet exists and would require\r\n        //  separate treatment\r\n        assert(!isKindclassOf(gate, ControlledGate))\r\n        allowed_gate_classes.push(gate)\r\n      } else if (gate instanceof ControlledGate) {\r\n        allowed_gate_instances.push([gate.gate, gate.n])\r\n      } else {\r\n        allowed_gate_instances.push([gate, 0])\r\n      }\r\n    })\r\n  }\r\n\r\n  function low_level_gates(eng, cmd) {\r\n    const allqubits = []\r\n    cmd.allQubits.forEach(qr => qr.forEach(q => allqubits.push(q)))\r\n\r\n    assert(allqubits.length <= 2)\r\n    if (cmd.gate instanceof ClassicalInstructionGate) {\r\n      // This is required to allow Measure, Allocate, Deallocate, Flush\r\n      return true\r\n    } else if (one_qubit_gates === 'any' && allqubits.length === 1) {\r\n      return true\r\n    } else if (two_qubit_gates === 'any' && allqubits.length === 2) {\r\n      return true\r\n    } else if (instanceOf(cmd.gate, allowed_gate_classes)) {\r\n      return true\r\n    } else {\r\n      const cn = cmd.controlQubits.length\r\n      const idx = allowed_gate_instances.findIndex((looper) => {\r\n        try {\r\n          return cmd.gate.equal(looper[0]) && cn === looper[1]\r\n        } catch (e) {\r\n          return false\r\n        }\r\n      })\r\n      if (idx !== -1) {\r\n        return true\r\n      }\r\n    }\r\n    return false\r\n  }\r\n  return [\r\n    new AutoReplacer(rule_set),\r\n    new TagRemover(),\r\n    new InstructionFilter(high_level_gates),\r\n    new LocalOptimizer(5),\r\n    new AutoReplacer(rule_set),\r\n    new TagRemover(),\r\n    new InstructionFilter(one_and_two_qubit_gates),\r\n    new LocalOptimizer(5),\r\n    new GridMapper({num_rows, num_columns}),\r\n    new AutoReplacer(rule_set),\r\n    new TagRemover(),\r\n    new InstructionFilter(low_level_gates),\r\n    new LocalOptimizer(5),\r\n  ]\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/grid.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1030,
    "kind": "function",
    "name": "high_level_gates",
    "memberof": "src/setups/grid.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/grid.js~high_level_gates",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/setups/grid.js",
    "importStyle": "{high_level_gates}",
    "description": "Remove any MathGates",
    "lineNumber": 19,
    "params": [
      {
        "name": "eng",
        "types": [
          "*"
        ]
      },
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 1031,
    "kind": "function",
    "name": "one_and_two_qubit_gates",
    "memberof": "src/setups/grid.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/grid.js~one_and_two_qubit_gates",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/setups/grid.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 30,
    "undocument": true,
    "params": [
      {
        "name": "eng",
        "types": [
          "*"
        ]
      },
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1032,
    "kind": "function",
    "name": "getEngineList",
    "memberof": "src/setups/grid.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/grid.js~getEngineList",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/setups/grid.js",
    "importStyle": "{getEngineList}",
    "description": "Returns an engine list to compile to a 2-D grid of qubits.\n\nNote:\nIf you choose a new gate set for which the compiler does not yet have\nstandard rules, it raises an `NoGateDecompositionError` or a\n`RuntimeError: maximum recursion depth exceeded...`. Also note that\neven the gate sets which work might not yet be optimized. So make sure\nto double check and potentially extend the decomposition rules.\nThis implemention currently requires that the one qubit gates must\ncontain Rz and at least one of {Ry(best), Rx, H} and the two qubit gate\nmust contain CNOT (recommended) or CZ.\n\nNote:\nClassical instructions gates such as e.g. Flush and Measure are\nautomatically allowed.\n\nExample:\nget_engine_list(num_rows=2, num_columns=3,\none_qubit_gates=(Rz, Ry, Rx, H),\ntwo_qubit_gates=(CNOT,))\n\nArgs:\nnum_rows(int): Number of rows in the grid\nnum_columns(int): Number of columns in the grid.\none_qubit_gates: \"any\" allows any one qubit gate, otherwise provide\na tuple of the allowed gates. If the gates are\ninstances of a class (e.g. X), it allows all gates\nwhich are equal to it. If the gate is a class (Rz), it\nallows all instances of this class. Default is \"any\"\ntwo_qubit_gates: \"any\" allows any two qubit gate, otherwise provide\na tuple of the allowed gates. If the gates are\ninstances of a class (e.g. CNOT), it allows all gates\nwhich are equal to it. If the gate is a class, it\nallows all instances of this class.\nDefault is (CNOT, Swap).\nRaises:\nTypeError: If input is for the gates is not \"any\" or a tuple.\n\nReturns:\nA list of suitable compiler engines.",
    "lineNumber": 89,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "num_rows",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "num_columns",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string",
          "Array.<BasicGate>"
        ],
        "spread": false,
        "optional": false,
        "name": "one_qubit_gates",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string",
          "Array.<BasicGate>"
        ],
        "spread": false,
        "optional": false,
        "name": "two_qubit_gates",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 1033,
    "kind": "file",
    "name": "src/setups/grid.spec.js",
    "content": "import {expect} from 'chai'\r\nimport {getEngineList} from './grid';\r\nimport GridMapper from '../cengines/twodmapper';\r\nimport {DummyEngine} from '../cengines';\r\nimport MainEngine from '../cengines/main';\r\nimport {\r\n  BasicGate, CNOT, Swap, H, Rx, Rz, X, Measure\r\n} from '../ops';\r\nimport {tuple} from '../libs/util';\r\nimport {len} from '../libs/polyfill';\r\nimport {AddConstant} from '../libs/math/gates';\r\n\r\ndescribe('grid test', () => {\r\n  it('should test_mapper_present_and_correct_params', () => {\r\n    let found = false\r\n    let mapper\r\n    const engines = getEngineList(3, 2)\r\n    engines.forEach((engine) => {\r\n      if (engine instanceof GridMapper) {\r\n        mapper = engine\r\n        found = true\r\n      }\r\n    })\r\n\r\n    expect(found).to.equal(true)\r\n    expect(mapper.num_rows).to.equal(3)\r\n    expect(mapper.num_columns).to.equal(2)\r\n  })\r\n\r\n  it('should test_parameter_any', () => {\r\n    const engine_list = getEngineList(3, 2, 'any', 'any')\r\n    const backend = new DummyEngine(true)\r\n    const eng = new MainEngine(backend, engine_list)\r\n    const qubit1 = eng.allocateQubit()\r\n    const qubit2 = eng.allocateQubit()\r\n    const gate = new BasicGate()\r\n    gate.or(tuple(qubit1, qubit2))\r\n    gate.or(qubit1)\r\n    eng.flush()\r\n    console.log(len(backend.receivedCommands))\r\n    expect(backend.receivedCommands[2].gate.equal(gate)).to.equal(true)\r\n    expect(backend.receivedCommands[3].gate.equal(gate)).to.equal(true)\r\n  })\r\n\r\n  it('should test_restriction', () => {\r\n    const engine_list = getEngineList(3, 2, [Rz, H], [CNOT, AddConstant])\r\n    const backend = new DummyEngine(true)\r\n    const eng = new MainEngine(backend, engine_list)\r\n    const qubit1 = eng.allocateQubit()\r\n    const qubit2 = eng.allocateQubit()\r\n    const qubit3 = eng.allocateQubit()\r\n    eng.flush()\r\n    CNOT.or(tuple(qubit1, qubit2))\r\n    H.or(qubit1)\r\n    new Rz(0.2).or(qubit1)\r\n    Measure.or(qubit1)\r\n    Swap.or(tuple(qubit1, qubit2))\r\n    new Rx(0.1).or(qubit1)\r\n    new AddConstant(1).or(qubit1.concat(qubit2).concat(qubit3))\r\n    eng.flush()\r\n    expect(backend.receivedCommands[4].gate.equal(X)).to.equal(true)\r\n    expect(len(backend.receivedCommands[4].controlQubits)).to.equal(1)\r\n    expect(backend.receivedCommands[5].gate.equal(H)).to.equal(true)\r\n    expect(backend.receivedCommands[6].gate.equal(new Rz(0.2))).to.equal(true)\r\n    expect(backend.receivedCommands[7].gate.equal(Measure)).to.equal(true)\r\n    backend.receivedCommands.slice(7).forEach((cmd) => {\r\n      expect(cmd.gate.equal(Swap)).to.equal(false)\r\n      expect(cmd.gate instanceof Rx).to.equal(false)\r\n      expect(cmd.gate instanceof AddConstant).to.equal(false)\r\n    })\r\n  });\r\n\r\n  it('should test_wrong_init', () => {\r\n    expect(() => getEngineList(3, 2, 'any', CNOT)).to.throw()\r\n    expect(() => getEngineList(3, 2, 'Any', [CNOT])).to.throw()\r\n  });\r\n})\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/grid.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1034,
    "kind": "file",
    "name": "src/setups/ibm.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n\r\nimport DecompositionRuleSet from '../cengines/replacer/decompositionruleset'\r\nimport TagRemover from '../cengines/tagremover'\r\nimport LocalOptimizer from '../cengines/optimize'\r\nimport { AutoReplacer } from '../cengines/replacer/replacer'\r\nimport SwapAndCNOTFlipper from '../cengines/swapandcnotflipper'\r\nimport decompositions from './decompositions'\r\nimport IBM5QubitMapper, {ibmqx4_connections} from '../cengines/ibm5qubitmapper';\r\n\r\nexport function getEngineList() {\r\n  const rule_set = new DecompositionRuleSet(decompositions)\r\n  return [new TagRemover(),\r\n    new LocalOptimizer(10),\r\n    new AutoReplacer(rule_set),\r\n    new TagRemover(),\r\n    new IBM5QubitMapper(),\r\n    new SwapAndCNOTFlipper(ibmqx4_connections),\r\n    new LocalOptimizer(10)\r\n  ]\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/ibm.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1035,
    "kind": "function",
    "name": "getEngineList",
    "memberof": "src/setups/ibm.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/ibm.js~getEngineList",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/setups/ibm.js",
    "importStyle": "{getEngineList}",
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 1036,
    "kind": "file",
    "name": "src/setups/ibm.spec.js",
    "content": "import {expect} from 'chai'\r\nimport {getEngineList} from './ibm'\r\nimport IBM5QubitMapper from '../cengines/ibm5qubitmapper';\r\nimport SwapAndCNOTFlipper from '../cengines/swapandcnotflipper';\r\n\r\ndescribe('ibm test', () => {\r\n  it('should test_ibm_cnot_mapper_in_cengines', () => {\r\n    let found = 0\r\n    const engines = getEngineList()\r\n    engines.forEach((engine) => {\r\n      if (engine instanceof IBM5QubitMapper) {\r\n        found |= 1\r\n      }\r\n      if (engine instanceof SwapAndCNOTFlipper) {\r\n        found |= 2\r\n      }\r\n    })\r\n    expect(found).to.equal(3)\r\n  });\r\n})\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/ibm.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1037,
    "kind": "file",
    "name": "src/setups/ibm16.js",
    "content": "\r\nimport DecompositionRuleSet from '../cengines/replacer/decompositionruleset'\r\nimport {AutoReplacer, InstructionFilter} from '../cengines'\r\nimport TagRemover from '../cengines/tagremover'\r\nimport LocalOptimizer from '../cengines/optimize'\r\nimport GridMapper from '../cengines/twodmapper'\r\nimport math from '../libs/math/defaultrules'\r\nimport decompositions from './decompositions'\r\nimport SwapAndCNOTFlipper from '../cengines/swapandcnotflipper';\r\nimport {high_level_gates} from './grid'\r\n\r\nexport const ibmqx5_connections = new Set([\r\n  '1,0', '1,2', '2,3', '3,4', '3,14', '5,4',\r\n  '6,5', '6,7', '6,11', '7,10', '8,7', '9,8',\r\n  '9,10', '11,10', '12,5', '12,11', '12,13',\r\n  '13,4', '13,14', '15,0', '15,2', '15,14'])\r\n\r\n\r\nconst grid_to_physical = {\r\n  0: 1,\r\n  1: 2,\r\n  2: 3,\r\n  3: 4,\r\n  4: 5,\r\n  5: 6,\r\n  6: 7,\r\n  7: 8,\r\n  8: 0,\r\n  9: 15,\r\n  10: 14,\r\n  11: 13,\r\n  12: 12,\r\n  13: 11,\r\n  14: 10,\r\n  15: 9\r\n}\r\n\r\n\r\nexport function getEngineList() {\r\n  const rule_set = new DecompositionRuleSet([...math, ...decompositions])\r\n  return [\r\n    new TagRemover(),\r\n    new LocalOptimizer(5),\r\n    new AutoReplacer(rule_set),\r\n    new InstructionFilter(high_level_gates),\r\n    new TagRemover(),\r\n    new LocalOptimizer(5),\r\n    new AutoReplacer(rule_set),\r\n    new TagRemover(),\r\n    new GridMapper({num_rows: 2, num_columns: 8, mapped_ids_to_backend_ids: grid_to_physical}),\r\n    new LocalOptimizer(5),\r\n    new SwapAndCNOTFlipper(ibmqx5_connections),\r\n    new LocalOptimizer(5)]\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/ibm16.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1038,
    "kind": "variable",
    "name": "ibmqx5_connections",
    "memberof": "src/setups/ibm16.js",
    "static": true,
    "longname": "src/setups/ibm16.js~ibmqx5_connections",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/setups/ibm16.js",
    "importStyle": "{ibmqx5_connections}",
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1039,
    "kind": "variable",
    "name": "grid_to_physical",
    "memberof": "src/setups/ibm16.js",
    "static": true,
    "longname": "src/setups/ibm16.js~grid_to_physical",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/setups/ibm16.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "{\"0\": number, \"1\": number, \"2\": number, \"3\": number, \"4\": number, \"5\": number, \"6\": number, \"7\": number, \"8\": *, \"9\": number, \"10\": number, \"11\": number, \"12\": number, \"13\": number, \"14\": number, \"15\": number}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1040,
    "kind": "function",
    "name": "getEngineList",
    "memberof": "src/setups/ibm16.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/ibm16.js~getEngineList",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/setups/ibm16.js",
    "importStyle": "{getEngineList}",
    "description": null,
    "lineNumber": 39,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 1041,
    "kind": "file",
    "name": "src/setups/ibm16.spec.js",
    "content": "import {expect} from 'chai'\r\nimport {getEngineList} from './ibm16';\r\nimport GridMapper from '../cengines/twodmapper';\r\nimport SwapAndCNOTFlipper from '../cengines/swapandcnotflipper';\r\nimport {DummyEngine} from '../cengines';\r\nimport MainEngine from '../cengines/main';\r\nimport {AddConstant} from '../libs/math/gates';\r\nimport {QFT} from '../ops';\r\nimport {getInverse} from '../ops/_cycle';\r\n\r\ndescribe('ibm16 test', () => {\r\n  it('should test_mappers_in_cengines', () => {\r\n    let found = 0\r\n    getEngineList().forEach((engine) => {\r\n      if (engine instanceof GridMapper) {\r\n        found |= 1\r\n      }\r\n      if (engine instanceof SwapAndCNOTFlipper) {\r\n        found |= 2\r\n      }\r\n    })\r\n    expect(found).to.equal(3)\r\n  })\r\n\r\n  it('should test_high_level_gate_set', () => {\r\n    let mod_list = getEngineList()\r\n    const saving_engine = new DummyEngine(true)\r\n    mod_list = mod_list.slice(0, 6).concat([saving_engine]).concat(mod_list.slice(6))\r\n    const eng = new MainEngine(new DummyEngine(), mod_list)\r\n    const qureg = eng.allocateQureg(3)\r\n    new AddConstant(3).or(qureg)\r\n    QFT.or(qureg)\r\n    eng.flush()\r\n    const received_gates = saving_engine.receivedCommands.map(cmd => cmd.gate)\r\n    const sum = received_gates.filter(g => g.equal(QFT)).length\r\n    expect(sum).to.equal(1)\r\n\r\n    let foundQFT = false\r\n    let foundAddConstant = false\r\n    received_gates.forEach((g) => {\r\n      if (g.equal(getInverse(QFT))) {\r\n        foundQFT = true\r\n      }\r\n      if (g.equal(new AddConstant(3))) {\r\n        foundAddConstant = true\r\n      }\r\n    })\r\n\r\n    expect(foundQFT).to.equal(false)\r\n    expect(foundAddConstant).to.equal(false)\r\n  });\r\n})\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/ibm16.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1042,
    "kind": "file",
    "name": "src/setups/index.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport DecompositionRuleSet from '../cengines/replacer/decompositionruleset'\r\nimport TagRemover from '../cengines/tagremover'\r\nimport decompositions from './decompositions'\r\nimport LocalOptimizer from '../cengines/optimize'\r\nimport {AutoReplacer} from '../cengines/replacer/replacer'\r\n\r\nexport function getEngineList() {\r\n  const rule_set = new DecompositionRuleSet(decompositions)\r\n  return [new TagRemover(),\r\n    new LocalOptimizer(10),\r\n    new AutoReplacer(rule_set),\r\n    new TagRemover(),\r\n    new LocalOptimizer(10)]\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1043,
    "kind": "function",
    "name": "getEngineList",
    "memberof": "src/setups/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/index.js~getEngineList",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/setups/index.js",
    "importStyle": "{getEngineList}",
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 1044,
    "kind": "file",
    "name": "src/setups/linear.js",
    "content": "import assert from 'assert'\r\nimport {\r\n  BasicMathGate, ClassicalInstructionGate, CNOT, ControlledGate, QFT, Swap\r\n} from '../ops';\r\nimport {getInverse} from '../ops/_cycle';\r\nimport DecompositionRuleSet from '../cengines/replacer/decompositionruleset';\r\nimport {instanceOf, isKindclassOf, tuple} from '../libs/util';\r\nimport {len} from '../libs/polyfill';\r\nimport {AutoReplacer, InstructionFilter} from '../cengines';\r\nimport TagRemover from '../cengines/tagremover';\r\nimport LocalOptimizer from '../cengines/optimize';\r\nimport LinearMapper from '../cengines/linearmapper';\r\nimport math from '../libs/math/defaultrules'\r\nimport decompositions from './decompositions'\r\n\r\nfunction high_level_gates(eng, cmd) {\r\n  const g = cmd.gate\r\n  if (g.equal(QFT) || getInverse(g).equal(QFT) || g.equal(Swap)) {\r\n    return true\r\n  } else if (g instanceof BasicMathGate) {\r\n    return false\r\n  }\r\n  return true\r\n}\r\n\r\nfunction one_and_two_qubit_gates(eng, cmd) {\r\n  const all_qubits = []\r\n  cmd.allQubits.forEach(qr => qr.forEach(q => all_qubits.push(q)))\r\n\r\n  if (cmd.gate instanceof ClassicalInstructionGate) {\r\n    // This is required to allow Measure, Allocate, Deallocate, Flush\r\n    return true\r\n  } else if (all_qubits.length <= 2) {\r\n    return true\r\n  } else {\r\n    return false\r\n  }\r\n}\r\n\r\n/**\r\nReturns an engine list to compile to a linear chain of qubits.\r\n\r\n    Note:\r\nIf you choose a new gate set for which the compiler does not yet have\r\nstandard rules, it raises an `NoGateDecompositionError` or a\r\n    `RuntimeError: maximum recursion depth exceeded...`. Also note that\r\neven the gate sets which work might not yet be optimized. So make sure\r\nto double check and potentially extend the decomposition rules.\r\n    This implemention currently requires that the one qubit gates must\r\ncontain Rz and at least one of {Ry(best), Rx, H} and the two qubit gate\r\nmust contain CNOT (recommended) or CZ.\r\n\r\n    Note:\r\nClassical instructions gates such as e.g. Flush and Measure are\r\nautomatically allowed.\r\n\r\n    @example\r\nget_engine_list(num_qubits=10, cyclic=false,\r\n    one_qubit_gates=(Rz, Ry, Rx, H),\r\n    two_qubit_gates=(CNOT,))\r\n\r\n@param {number} num_qubits Number of qubits in the chain\r\n @param {boolean} cyclic If a circle or not. Default is false\r\n@param {string|Array.<BasicGate>} one_qubit_gates \"any\" allows any one qubit gate, otherwise provide\r\na tuple of the allowed gates. If the gates are instances of a class (e.g. X), it allows all gates\r\nwhich are equal to it. If the gate is a class (Rz), it allows all instances of this class. Default is \"any\"\r\n@param {string|Array.<BasicGate>} two_qubit_gates \"any\" allows any two qubit gate, otherwise provide\r\na tuple of the allowed gates. If the gates are instances of a class (e.g. CNOT), it allows all gates\r\nwhich are equal to it. If the gate is a class, it allows all instances of this class.\r\nDefault is (CNOT, Swap).\r\n    @throws {Error} If input is for the gates is not \"any\" or a tuple.\r\n\r\n    @return {Array} A list of suitable compiler engines.\r\n */\r\nexport function getEngineList(num_qubits, cyclic = false, one_qubit_gates = 'any', two_qubit_gates = [CNOT, Swap]) {\r\n  if (two_qubit_gates !== 'any' && !Array.isArray(two_qubit_gates)) {\r\n    throw new Error(\"two_qubit_gates parameter must be 'any' or a tuple. \"\r\n    + 'When supplying only one gate, make sure to correctly '\r\n    + \"create the tuple (don't miss the comma), \"\r\n    + 'e.g. two_qubit_gates=(CNOT,)')\r\n  }\r\n  if (one_qubit_gates !== 'any' && !Array.isArray(one_qubit_gates)) {\r\n    throw new Error(\"one_qubit_gates parameter must be 'any' or a tuple.\")\r\n  }\r\n  const rule_set = new DecompositionRuleSet([...math, ...decompositions])\r\n  const allowed_gate_classes = []\r\n  const allowed_gate_instances = []\r\n  if (one_qubit_gates !== 'any') {\r\n    one_qubit_gates.forEach((gate) => {\r\n      if (typeof gate === 'function') {\r\n        allowed_gate_classes.push(gate)\r\n      } else {\r\n        allowed_gate_instances.push([gate, 0])\r\n      }\r\n    })\r\n  }\r\n  if (two_qubit_gates !== 'any') {\r\n    two_qubit_gates.forEach((gate) => {\r\n      if (typeof gate === 'function') {\r\n        //  Controlled gate classes don't yet exists and would require\r\n        //  separate treatment\r\n        assert(!isKindclassOf(gate, ControlledGate))\r\n        allowed_gate_classes.push(gate)\r\n      } else if (gate instanceof ControlledGate) {\r\n        allowed_gate_instances.push([gate.gate, gate.n])\r\n      } else {\r\n        allowed_gate_instances.push([gate, 0])\r\n      }\r\n    })\r\n  }\r\n\r\n  function low_level_gates(eng, cmd) {\r\n    const all_qubits = []\r\n    cmd.allQubits.forEach(qr => qr.forEach(q => all_qubits.push(q)))\r\n\r\n    assert(all_qubits.length <= 2)\r\n    if (cmd.gate instanceof ClassicalInstructionGate) {\r\n      // This is required to allow Measure, Allocate, Deallocate, Flush\r\n      return true\r\n    } else if (one_qubit_gates === 'any' && len(all_qubits) === 1) {\r\n      return true\r\n    } else if (two_qubit_gates === 'any' && len(all_qubits) === 2) {\r\n      return true\r\n    } else if (instanceOf(cmd.gate, allowed_gate_classes)) {\r\n      return true\r\n    } else {\r\n      const cn = cmd.controlQubits.length\r\n      const idx = allowed_gate_instances.findIndex(looper => cmd.gate.equal(looper[0]) && cn === looper[1])\r\n      if (idx !== -1) {\r\n        return true\r\n      }\r\n    }\r\n    return false\r\n  }\r\n  return [new AutoReplacer(rule_set),\r\n    new TagRemover(),\r\n    new InstructionFilter(high_level_gates),\r\n    new LocalOptimizer(5),\r\n    new AutoReplacer(rule_set),\r\n    new TagRemover(),\r\n    new InstructionFilter(one_and_two_qubit_gates),\r\n    new LocalOptimizer(5),\r\n    new LinearMapper(num_qubits, cyclic),\r\n    new AutoReplacer(rule_set),\r\n    new TagRemover(),\r\n    new InstructionFilter(low_level_gates),\r\n    new LocalOptimizer(5),\r\n  ]\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/linear.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1045,
    "kind": "function",
    "name": "high_level_gates",
    "memberof": "src/setups/linear.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/linear.js~high_level_gates",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/setups/linear.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "params": [
      {
        "name": "eng",
        "types": [
          "*"
        ]
      },
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1046,
    "kind": "function",
    "name": "one_and_two_qubit_gates",
    "memberof": "src/setups/linear.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/linear.js~one_and_two_qubit_gates",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/setups/linear.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "params": [
      {
        "name": "eng",
        "types": [
          "*"
        ]
      },
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1047,
    "kind": "function",
    "name": "getEngineList",
    "memberof": "src/setups/linear.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/linear.js~getEngineList",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/setups/linear.js",
    "importStyle": "{getEngineList}",
    "description": "Returns an engine list to compile to a linear chain of qubits.\n\nNote:\nIf you choose a new gate set for which the compiler does not yet have\nstandard rules, it raises an `NoGateDecompositionError` or a\n`RuntimeError: maximum recursion depth exceeded...`. Also note that\neven the gate sets which work might not yet be optimized. So make sure\nto double check and potentially extend the decomposition rules.\nThis implemention currently requires that the one qubit gates must\ncontain Rz and at least one of {Ry(best), Rx, H} and the two qubit gate\nmust contain CNOT (recommended) or CZ.\n\nNote:\nClassical instructions gates such as e.g. Flush and Measure are\nautomatically allowed.",
    "examples": [
      "get_engine_list(num_qubits=10, cyclic=false,\none_qubit_gates=(Rz, Ry, Rx, H),\ntwo_qubit_gates=(CNOT,))"
    ],
    "lineNumber": 75,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "num_qubits",
        "description": "Number of qubits in the chain"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "cyclic",
        "description": "If a circle or not. Default is false"
      },
      {
        "nullable": null,
        "types": [
          "string",
          "Array.<BasicGate>"
        ],
        "spread": false,
        "optional": false,
        "name": "one_qubit_gates",
        "description": "\"any\" allows any one qubit gate, otherwise provide\na tuple of the allowed gates. If the gates are instances of a class (e.g. X), it allows all gates\nwhich are equal to it. If the gate is a class (Rz), it allows all instances of this class. Default is \"any\""
      },
      {
        "nullable": null,
        "types": [
          "string",
          "Array.<BasicGate>"
        ],
        "spread": false,
        "optional": false,
        "name": "two_qubit_gates",
        "description": "\"any\" allows any two qubit gate, otherwise provide\na tuple of the allowed gates. If the gates are instances of a class (e.g. CNOT), it allows all gates\nwhich are equal to it. If the gate is a class, it allows all instances of this class.\nDefault is (CNOT, Swap)."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": "A list of suitable compiler engines."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If input is for the gates is not \"any\" or a tuple."
      }
    ]
  },
  {
    "__docId__": 1048,
    "kind": "file",
    "name": "src/setups/linear.spec.js",
    "content": "import {expect} from 'chai'\r\nimport {getEngineList} from './linear'\r\nimport LinearMapper from '../cengines/linearmapper';\r\nimport {DummyEngine} from '../cengines';\r\nimport {\r\n  BasicGate, Rx, Rz, H, CNOT, Measure, Swap, X\r\n} from '../ops';\r\nimport MainEngine from '../cengines/main';\r\nimport {tuple} from '../libs/util';\r\nimport {AddConstant} from '../libs/math/gates';\r\n\r\ndescribe('linear test', () => {\r\n  it('should test_mapper_present_and_correct_params', () => {\r\n    let found = false\r\n    let mapper = null\r\n\r\n    const list = getEngineList(10, true)\r\n    list.forEach((engine) => {\r\n      if (engine instanceof LinearMapper) {\r\n        mapper = engine\r\n        found = true\r\n      }\r\n    })\r\n\r\n    expect(found).to.equal(true)\r\n    expect(mapper.num_qubits).to.equal(10)\r\n    expect(mapper.cyclic).to.equal(true)\r\n  });\r\n\r\n  it('should test_parameter_any', () => {\r\n    const engine_list = getEngineList(10, false, 'any', 'any')\r\n    const backend = new DummyEngine(true)\r\n    const eng = new MainEngine(backend, engine_list)\r\n    const qubit1 = eng.allocateQubit()\r\n    const qubit2 = eng.allocateQubit()\r\n    const gate = new BasicGate()\r\n    gate.or(tuple(qubit1, qubit2))\r\n    gate.or(qubit1)\r\n    eng.flush()\r\n    console.log(backend.receivedCommands.length)\r\n    expect(backend.receivedCommands[2].gate.equal(gate)).to.equal(true)\r\n    expect(backend.receivedCommands[3].gate.equal(gate)).to.equal(true)\r\n  })\r\n\r\n  it('should test_restriction', () => {\r\n    const engine_list = getEngineList(10, false, [Rz, H], [CNOT, AddConstant])\r\n    const backend = new DummyEngine(true)\r\n    const eng = new MainEngine(backend, engine_list)\r\n    const qubit1 = eng.allocateQubit()\r\n    const qubit2 = eng.allocateQubit()\r\n    const qubit3 = eng.allocateQubit()\r\n    eng.flush()\r\n    CNOT.or(tuple(qubit1, qubit2))\r\n    H.or(qubit1)\r\n    new Rz(0.2).or(qubit1)\r\n    Measure.or(qubit1)\r\n    Swap.or(tuple(qubit1, qubit2))\r\n    new Rx(0.1).or(tuple(qubit1))\r\n    new AddConstant(1).or(qubit1.concat(qubit2).concat(qubit3))\r\n    eng.flush()\r\n    expect(backend.receivedCommands[4].gate.equal(X)).to.equal(true)\r\n    expect(backend.receivedCommands[4].controlQubits.length).equal(1)\r\n    expect(backend.receivedCommands[5].gate.equal(H)).to.equal(true)\r\n    expect(backend.receivedCommands[6].gate.equal(new Rz(0.2))).to.equal(true)\r\n    expect(backend.receivedCommands[7].gate.equal(Measure)).to.equal(true)\r\n\r\n    backend.receivedCommands.slice(7).forEach((cmd) => {\r\n      expect(cmd.gate.equal(Swap)).to.equal(false)\r\n      expect(cmd.gate instanceof Rx).to.equal(false)\r\n      expect(cmd.gate instanceof AddConstant).to.equal(false)\r\n    })\r\n  });\r\n\r\n  it('should test_wrong_init', () => {\r\n    expect(() => getEngineList(10, false, 'any', CNOT)).to.throw()\r\n    expect(() => getEngineList(10, false, 'Any', [CNOT])).to.throw()\r\n  });\r\n})\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/linear.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1049,
    "kind": "file",
    "name": "src/setups/restrictedgateset.js",
    "content": "import assert from 'assert'\r\nimport {\r\n  BasicMathGate, ClassicalInstructionGate, CNOT, ControlledGate, QFT, Swap\r\n} from '../ops';\r\nimport {getInverse} from '../ops/_cycle';\r\nimport DecompositionRuleSet from '../cengines/replacer/decompositionruleset';\r\nimport {instanceOf, isKindclassOf} from '../libs/util';\r\nimport {len} from '../libs/polyfill';\r\nimport {AutoReplacer, InstructionFilter} from '../cengines';\r\nimport TagRemover from '../cengines/tagremover'\r\nimport LocalOptimizer from '../cengines/optimize'\r\nimport math from '../libs/math/defaultrules'\r\nimport decompositions from './decompositions'\r\n\r\nfunction high_level_gates(eng, cmd) {\r\n  const g = cmd.gate\r\n  if (eng.next.isAvailable(cmd)) {\r\n    return true\r\n  }\r\n  if (QFT.equal(g) || QFT.equal(getInverse(g)) || Swap.equal(g)) {\r\n    return true\r\n  }\r\n  if (g instanceof BasicMathGate) {\r\n    return false\r\n  }\r\n  return true\r\n}\r\n\r\nfunction one_and_two_qubit_gates(eng, cmd) {\r\n  const all_qubits = []\r\n  cmd.allQubits.forEach(qr => qr.forEach(q => all_qubits.push(q)))\r\n\r\n  if (cmd.gate instanceof ClassicalInstructionGate) {\r\n    // This is required to allow Measure, Allocate, Deallocate, Flush\r\n    return true\r\n  } else if (eng.next.isAvailable(cmd)) {\r\n    return true\r\n  } else if (all_qubits.length <= 2) {\r\n    return true\r\n  } else {\r\n    return false\r\n  }\r\n}\r\n\r\n/**\r\nReturns an engine list to compile to a restricted gate set.\r\n\r\n    Note:\r\nIf you choose a new gate set for which the compiler does not yet have\r\nstandard rules, it raises an `NoGateDecompositionError` or a\r\n    `RuntimeError: maximum recursion depth exceeded...`. Also note that\r\neven the gate sets which work might not yet be optimized. So make sure\r\nto double check and potentially extend the decomposition rules.\r\n    This implemention currently requires that the one qubit gates must\r\ncontain Rz and at least one of {Ry(best), Rx, H} and the two qubit gate\r\nmust contain CNOT (recommended) or CZ.\r\n\r\n    Note:\r\nClassical instructions gates such as e.g. Flush and Measure are\r\nautomatically allowed.\r\n\r\n    @example\r\nget_engine_list(one_qubit_gates=(Rz, Ry, Rx, H),\r\n    two_qubit_gates=(CNOT,),\r\n    other_gates=(TimeEvolution,))\r\n\r\n@param {string|Array.<BasicGate>} one_qubit_gates \"any\" allows any one qubit gate, otherwise provide\r\na tuple of the allowed gates. If the gates are instances of a class (e.g. X), it allows all gates\r\nwhich are equal to it. If the gate is a class (Rz), it allows all instances of this class. Default is \"any\"\r\n @param {string|Array.<BasicGate>} two_qubit_gates \"any\" allows any two qubit gate, otherwise provide\r\na tuple of the allowed gates. If the gates are instances of a class (e.g. CNOT), it allows all gates\r\nwhich are equal to it. If the gate is a class, it allows all instances of this class.\r\nDefault is (CNOT,).\r\n @param {string|Array.<BasicGate>} other_gates A tuple of the allowed gates. If the gates are\r\ninstances of a class (e.g. QFT), it allows all gates which are equal to it. If the gate is a\r\nclass, it allows all instances of this class.\r\n@throws {Error} If input is for the gates is not \"any\" or a tuple.\r\n\r\n    @return {Array} A list of suitable compiler engines.\r\n */\r\nexport function getEngineList(one_qubit_gates = 'any', two_qubit_gates = [CNOT], other_gates = []) {\r\n  if (two_qubit_gates !== 'any' && !Array.isArray(two_qubit_gates)) {\r\n    throw new Error(\"two_qubit_gates parameter must be 'any' or a tuple. \"\r\n        + 'When supplying only one gate, make sure to correctly '\r\n        + \"create the tuple (don't miss the comma), \"\r\n        + 'e.g. two_qubit_gates=(CNOT,)')\r\n  }\r\n  if (one_qubit_gates !== 'any' && !Array.isArray(one_qubit_gates)) {\r\n    throw new Error(\"one_qubit_gates parameter must be 'any' or a tuple.\")\r\n  }\r\n\r\n  if (!Array.isArray(other_gates)) {\r\n    throw new Error('other_gates parameter must be a tuple.')\r\n  }\r\n  const rule_set = new DecompositionRuleSet([...math, ...decompositions])\r\n  const allowed_gate_classes = []\r\n  const allowed_gate_instances = []\r\n  if (one_qubit_gates !== 'any') {\r\n    one_qubit_gates.forEach((gate) => {\r\n      if (typeof gate === 'function') {\r\n        allowed_gate_classes.push(gate)\r\n      } else {\r\n        allowed_gate_instances.push([gate, 0])\r\n      }\r\n    })\r\n  }\r\n  if (two_qubit_gates !== 'any') {\r\n    two_qubit_gates.forEach((gate) => {\r\n      if (typeof gate === 'function') {\r\n        //  Controlled gate classes don't yet exists and would require\r\n        //  separate treatment\r\n        assert(!isKindclassOf(gate, ControlledGate))\r\n        allowed_gate_classes.push(gate)\r\n      } else if (gate instanceof ControlledGate) {\r\n        allowed_gate_instances.push([gate.gate, gate.n])\r\n      } else {\r\n        allowed_gate_instances.push([gate, 0])\r\n      }\r\n    })\r\n  }\r\n\r\n  other_gates.forEach((gate) => {\r\n    if (typeof gate === 'function') {\r\n      //  Controlled gate classes don't yet exists and would require\r\n      //  separate treatment\r\n      assert(!isKindclassOf(gate, ControlledGate))\r\n      allowed_gate_classes.push(gate)\r\n    } else if (gate instanceof ControlledGate) {\r\n      allowed_gate_instances.push([gate.gate, gate.n])\r\n    } else {\r\n      allowed_gate_instances.push([gate, 0])\r\n    }\r\n  })\r\n\r\n  function low_level_gates(eng, cmd) {\r\n    const all_qubits = []\r\n    cmd.allQubits.forEach(qr => qr.forEach(q => all_qubits.push(q)))\r\n\r\n    if (cmd.gate instanceof ClassicalInstructionGate) {\r\n      // This is required to allow Measure, Allocate, Deallocate, Flush\r\n      return true\r\n    } else if (one_qubit_gates === 'any' && len(all_qubits) === 1) {\r\n      return true\r\n    } else if (two_qubit_gates === 'any' && len(all_qubits) === 2) {\r\n      return true\r\n    } else if (instanceOf(cmd.gate, allowed_gate_classes)) {\r\n      return true\r\n    } else {\r\n      const cn = cmd.controlQubits.length\r\n      const idx = allowed_gate_instances.findIndex((looper) => {\r\n        try {\r\n          return cmd.gate.equal(looper[0]) && cn === looper[1]\r\n        } catch (e) {\r\n          return false\r\n        }\r\n      })\r\n      if (idx !== -1) {\r\n        return true\r\n      }\r\n    }\r\n    return false\r\n  }\r\n\r\n  return [\r\n    new AutoReplacer(rule_set),\r\n    new TagRemover(),\r\n    new InstructionFilter(high_level_gates),\r\n    new LocalOptimizer(5),\r\n    new AutoReplacer(rule_set),\r\n    new TagRemover(),\r\n    new InstructionFilter(one_and_two_qubit_gates),\r\n    new LocalOptimizer(5),\r\n    new AutoReplacer(rule_set),\r\n    new TagRemover(),\r\n    new InstructionFilter(low_level_gates),\r\n    new LocalOptimizer(5),\r\n  ]\r\n}\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/restrictedgateset.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1050,
    "kind": "function",
    "name": "high_level_gates",
    "memberof": "src/setups/restrictedgateset.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/restrictedgateset.js~high_level_gates",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/setups/restrictedgateset.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "params": [
      {
        "name": "eng",
        "types": [
          "*"
        ]
      },
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1051,
    "kind": "function",
    "name": "one_and_two_qubit_gates",
    "memberof": "src/setups/restrictedgateset.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/restrictedgateset.js~one_and_two_qubit_gates",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/setups/restrictedgateset.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 29,
    "undocument": true,
    "params": [
      {
        "name": "eng",
        "types": [
          "*"
        ]
      },
      {
        "name": "cmd",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1052,
    "kind": "function",
    "name": "getEngineList",
    "memberof": "src/setups/restrictedgateset.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/setups/restrictedgateset.js~getEngineList",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/setups/restrictedgateset.js",
    "importStyle": "{getEngineList}",
    "description": "Returns an engine list to compile to a restricted gate set.\n\nNote:\nIf you choose a new gate set for which the compiler does not yet have\nstandard rules, it raises an `NoGateDecompositionError` or a\n`RuntimeError: maximum recursion depth exceeded...`. Also note that\neven the gate sets which work might not yet be optimized. So make sure\nto double check and potentially extend the decomposition rules.\nThis implemention currently requires that the one qubit gates must\ncontain Rz and at least one of {Ry(best), Rx, H} and the two qubit gate\nmust contain CNOT (recommended) or CZ.\n\nNote:\nClassical instructions gates such as e.g. Flush and Measure are\nautomatically allowed.",
    "examples": [
      "get_engine_list(one_qubit_gates=(Rz, Ry, Rx, H),\ntwo_qubit_gates=(CNOT,),\nother_gates=(TimeEvolution,))"
    ],
    "lineNumber": 81,
    "params": [
      {
        "nullable": null,
        "types": [
          "string",
          "Array.<BasicGate>"
        ],
        "spread": false,
        "optional": false,
        "name": "one_qubit_gates",
        "description": "\"any\" allows any one qubit gate, otherwise provide\na tuple of the allowed gates. If the gates are instances of a class (e.g. X), it allows all gates\nwhich are equal to it. If the gate is a class (Rz), it allows all instances of this class. Default is \"any\""
      },
      {
        "nullable": null,
        "types": [
          "string",
          "Array.<BasicGate>"
        ],
        "spread": false,
        "optional": false,
        "name": "two_qubit_gates",
        "description": "\"any\" allows any two qubit gate, otherwise provide\na tuple of the allowed gates. If the gates are instances of a class (e.g. CNOT), it allows all gates\nwhich are equal to it. If the gate is a class, it allows all instances of this class.\nDefault is (CNOT,)."
      },
      {
        "nullable": null,
        "types": [
          "string",
          "Array.<BasicGate>"
        ],
        "spread": false,
        "optional": false,
        "name": "other_gates",
        "description": "A tuple of the allowed gates. If the gates are\ninstances of a class (e.g. QFT), it allows all gates which are equal to it. If the gate is a\nclass, it allows all instances of this class."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": "A list of suitable compiler engines."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If input is for the gates is not \"any\" or a tuple."
      }
    ]
  },
  {
    "__docId__": 1053,
    "kind": "file",
    "name": "src/setups/restrictedgateset.spec.js",
    "content": "import {expect} from 'chai'\r\nimport {getEngineList} from './restrictedgateset'\r\nimport {DummyEngine} from '../cengines';\r\nimport {\r\n  BasicGate, Rx, Rz, H, CNOT, Measure, Swap, X, Toffoli, QFT\r\n} from '../ops';\r\nimport MainEngine from '../cengines/main';\r\nimport {tuple} from '../libs/util';\r\nimport {AddConstant, AddConstantModN, MultiplyByConstantModN} from '../libs/math/gates';\r\nimport TimeEvolution from '../ops/timeevolution';\r\nimport QubitOperator from '../ops/qubitoperator';\r\n\r\ndescribe('restricted gate set test', () => {\r\n  it('should test_parameter_any', () => {\r\n    const engine_list = getEngineList('any', 'any')\r\n    const backend = new DummyEngine(true)\r\n    const eng = new MainEngine(backend, engine_list)\r\n    const qubit1 = eng.allocateQubit()\r\n    const qubit2 = eng.allocateQubit()\r\n    const gate = new BasicGate()\r\n    gate.or(tuple(qubit1, qubit2))\r\n    gate.or(qubit1)\r\n    eng.flush()\r\n    console.log(backend.receivedCommands.length)\r\n    expect(backend.receivedCommands[2].gate.equal(gate)).to.equal(true)\r\n    expect(backend.receivedCommands[3].gate.equal(gate)).to.equal(true)\r\n  });\r\n\r\n  it('should test_restriction', () => {\r\n    const engine_list = getEngineList(\r\n      [Rz, H],\r\n      [CNOT, AddConstant, Swap],\r\n      [Toffoli, AddConstantModN, new MultiplyByConstantModN(2, 8)]\r\n    )\r\n    const backend = new DummyEngine(true)\r\n    const eng = new MainEngine(backend, engine_list)\r\n    const qubit1 = eng.allocateQubit()\r\n    const qubit2 = eng.allocateQubit()\r\n    const qubit3 = eng.allocateQubit()\r\n    eng.flush()\r\n    CNOT.or(tuple(qubit1, qubit2))\r\n    H.or(qubit1)\r\n    new Rz(0.2).or(qubit1)\r\n    Measure.or(qubit1)\r\n    new AddConstant(1).or(qubit1.concat(qubit2))\r\n    new AddConstantModN(1, 9).or(qubit1.concat(qubit2).concat(qubit3))\r\n    Toffoli.or(tuple(qubit1.concat(qubit2), qubit3))\r\n    Swap.or(tuple(qubit1, qubit2))\r\n    new MultiplyByConstantModN(2, 8).or(qubit1.concat(qubit2).concat(qubit3))\r\n    new TimeEvolution(0.5, new QubitOperator('X0 Y1 Z2')).or(qubit1.concat(qubit2).concat(qubit3))\r\n    QFT.or(qubit1.concat(qubit2).concat(qubit3))\r\n    new Rx(0.1).or(qubit1)\r\n    new MultiplyByConstantModN(2, 9).or(qubit1.concat(qubit2).concat(qubit3))\r\n    eng.flush()\r\n    expect(backend.receivedCommands[4].gate.equal(X)).to.equal(true)\r\n    expect(backend.receivedCommands[4].controlQubits.length).to.equal(1)\r\n    expect(backend.receivedCommands[5].gate.equal(H)).to.equal(true)\r\n    expect(backend.receivedCommands[6].gate.equal(new Rz(0.2))).to.equal(true)\r\n    expect(backend.receivedCommands[7].gate.equal(Measure)).to.equal(true)\r\n    expect(backend.receivedCommands[8].gate.equal(new AddConstant(1))).to.equal(true)\r\n    expect(backend.receivedCommands[9].gate.equal(new AddConstantModN(1, 9))).to.equal(true)\r\n    expect(backend.receivedCommands[10].gate.equal(X)).to.equal(true)\r\n    expect(backend.receivedCommands[10].controlQubits.length).to.equal(2)\r\n    expect(backend.receivedCommands[11].gate.equal(Swap)).to.equal(true)\r\n    expect(backend.receivedCommands[12].gate.equal(new MultiplyByConstantModN(2, 8))).to.equal(true)\r\n\r\n    backend.receivedCommands.slice(13).forEach((cmd) => {\r\n      expect(cmd.gate.equal(QFT)).to.equal(false)\r\n      expect(cmd.gate instanceof Rx).to.equal(false)\r\n      expect(cmd.gate instanceof MultiplyByConstantModN).to.equal(false)\r\n      expect(cmd.gate instanceof TimeEvolution).to.equal(false)\r\n    })\r\n  })\r\n\r\n  it('should test_wrong_init', () => {\r\n    expect(() => getEngineList('any', CNOT)).to.throw()\r\n    expect(() => getEngineList('Any')).to.throw()\r\n    expect(() => getEngineList('any', 'any', 'any')).to.throw()\r\n  });\r\n})\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/setups/restrictedgateset.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1054,
    "kind": "file",
    "name": "src/types/qubit.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/**\r\n    This file defines BasicQubit, Qubit, WeakQubit and Qureg.\r\n\r\n    A Qureg represents a list of Qubit or WeakQubit objects.\r\n    Qubit represents a (logical-level) qubit with a unique index provided by the\r\n    MainEngine. Qubit objects are automatically deallocated if they go out of\r\n    scope and intented to be used within Qureg objects in user code.\r\n\r\n @example\r\n      import MainEngine\r\n      const eng = new MainEngine()\r\n      const qubit = eng.allocateQubit()\r\n\r\n    qubit is a Qureg of size 1 with one Qubit object which is deallocated once\r\n    qubit goes out of scope.\r\n\r\n    WeakQubit are used inside the Command object and are not automatically deallocated.\r\n*/\r\nimport {arrayEqual} from '../libs/polyfill'\r\n\r\n/**\r\n * @class BasicQubit\r\n * @desc\r\n * objects represent qubits. They have an id and a reference to the owning engine.\r\n */\r\nexport class BasicQubit {\r\n  /**\r\n   *  @constructor\r\n   *  Initialize a BasicQubit object.\r\n   *  @param {BasicEngine} engine Owning engine / engine that created the qubit\r\n   *  @param {number} idx Unique index of the qubit referenced by this qubit\r\n   */\r\n  constructor(engine, idx) {\r\n    this.engine = engine\r\n    this.id = idx\r\n  }\r\n\r\n  /**\r\n    Return string representation of this qubit.\r\n   @return {string}\r\n   */\r\n  toString() {\r\n    return `${this.id}`\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @return {string}\r\n   */\r\n  inspect() {\r\n    return this.toString()\r\n  }\r\n\r\n  /**\r\n    Access the result of a previous measurement and return false / true (0 / 1)\r\n    @return {boolean}\r\n  */\r\n  toBoolean() {\r\n    return this.engine.main.getMeasurementResult(this)\r\n  }\r\n\r\n  /**\r\n   * @return {number}\r\n   */\r\n  toNumber() {\r\n    return this.toBoolean() ? 1 : 0\r\n  }\r\n\r\n  /**\r\n   * Compare with other qubit (Returns true if equal id and engine).\r\n   *\r\n   * @param other {BasicQubit|Object} BasicQubit to which to compare this one\r\n   * @return {boolean}\r\n   */\r\n  equal(other) {\r\n    if (this === other) {\r\n      return true\r\n    }\r\n    return other instanceof BasicQubit && this.id === other.id && this.engine === other.engine\r\n  }\r\n\r\n  weakCopy() {\r\n    return new BasicQubit(this.engine, this.id)\r\n  }\r\n\r\n  static copyArray(array) {\r\n    return array.map(i => i.weakCopy())\r\n  }\r\n}\r\n\r\n/**\r\n * @class Qubit\r\n * @desc\r\n    Represents a (logical-level) qubit with a unique index provided by the\r\n    MainEngine. Once the qubit goes out of scope (and is garbage-collected),\r\n    it deallocates itself automatically, allowing automatic resource management.\r\n\r\n    Thus the qubit is not copyable only returns a reference to the same object.\r\n */\r\nexport class Qubit extends BasicQubit {\r\n  deallocate() {\r\n    // # If a user directly calls this function, then the qubit gets id == -1\r\n    // # but stays in active_qubits as it is not yet deleted, hence remove\r\n    // # it manually (if the garbage collector calls this function, then the\r\n    // # WeakRef in active qubits is already gone):\r\n    if (this.id === -1) {\r\n      return\r\n    }\r\n\r\n    try {\r\n      const qubits = this.engine.main.activeQubits\r\n      if (qubits.has(this)) {\r\n        qubits.delete(this)\r\n      }\r\n      this.engine.deallocateQubit(this)\r\n    } catch (e) {\r\n      throw e\r\n    } finally {\r\n      this.id = -1\r\n    }\r\n  }\r\n\r\n  /**\r\n    Non-copyable (returns reference to self).\r\n    Note:\r\n      To prevent problems with automatic deallocation, qubits are not copyable!\r\n  */\r\n  copy() {\r\n    return this\r\n  }\r\n}\r\n\r\n/**\r\n * @interface\r\n * @class Qureg\r\n * @desc Quantum register class.\r\nSimplifies accessing measured values for single-qubit registers (no []-access necessary)\r\n and enables pretty-printing of general quantum registers).\r\n */\r\nexport function Qureg(...args) {\r\n  const arg0 = args[0]\r\n  let inst\r\n  if (Array.isArray(arg0)) {\r\n    inst = Array.from(arg0)\r\n  } else {\r\n    inst = new Array(...args)\r\n  }\r\n  inst.__proto__ = Qureg.prototype\r\n  return inst\r\n}\r\n\r\nQureg.prototype = Object.create(Array.prototype)\r\n\r\n/**\r\n * @param {Qureg|Object} other\r\n * @return {boolean}\r\n */\r\nQureg.prototype.equal = function (other) {\r\n  if (other instanceof Qureg) {\r\n    return arrayEqual(this, other, (x, y) => x.equal(y))\r\n  }\r\n  return false\r\n}\r\n\r\n/**\r\n  Return measured value if Qureg consists of 1 qubit only.\r\n\r\n @throws {Error} if more than 1 qubit resides in this register (then you\r\n    need to specify which value to get using qureg[???])\r\n  @return {boolean}\r\n*/\r\nQureg.prototype.toBoolean = function () {\r\n  if (this.length === 1) {\r\n    return this[0].toBoolean()\r\n  }\r\n  throw new Error('qureg.toBoolean(): Quantum register contains more \"\\n'\r\n    + '\"than 1 qubit. Use qureg[idx].toBoolean() instead.')\r\n}\r\n\r\n/**\r\n * @return {number}\r\n */\r\nQureg.prototype.toNumber = function () {\r\n  return this.toBoolean() ? 1 : 0\r\n}\r\n\r\n/**\r\n * @return {string}\r\n */\r\nQureg.prototype.toString = function () {\r\n  if (this.length === 0) return 'Qureg[]'\r\n  const ids = this.slice(1).map(({id}) => id)\r\n  ids.push(null) // Forces a flush on last loop iteration.\r\n\r\n  const out_list = []\r\n  let start_id = this[0].id\r\n  let count = 1\r\n  ids.forEach((qubit_id) => {\r\n    if (qubit_id === start_id + count) {\r\n      count += 1\r\n    } else {\r\n      // TODO\r\n      if (count > 1) {\r\n        out_list.push(`${start_id}-${start_id + count - 1}`)\r\n      } else {\r\n        out_list.push(`${start_id}`)\r\n      }\r\n      start_id = qubit_id\r\n      count = 1\r\n    }\r\n  })\r\n\r\n  return `Qureg[${out_list.join(', ')}]`\r\n}\r\n\r\n/**\r\n * @param {Qureg|Array.<Qubit>} other\r\n * @return {Qureg}\r\n */\r\nQureg.prototype.add = function (other) {\r\n  const array = this.concat(other)\r\n  return new Qureg(array)\r\n}\r\n\r\nQureg.prototype.deallocate = function () {\r\n  this.forEach(qubit => qubit.deallocate())\r\n  this.length = 0\r\n}\r\n\r\n// fix class hierarchy\r\nQureg.__proto__ = Array\r\n\r\n/**\r\n * @property {BasicEngine} engine\r\n */\r\nObject.defineProperty(Qureg.prototype, 'engine', {\r\n  get() {\r\n    return this[0].engine\r\n  },\r\n  set(newEngine) {\r\n    this.forEach(looper => looper.engine = newEngine)\r\n  }\r\n})\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/types/qubit.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1055,
    "kind": "class",
    "name": "BasicQubit",
    "memberof": "src/types/qubit.js",
    "static": true,
    "longname": "src/types/qubit.js~BasicQubit",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/types/qubit.js",
    "importStyle": "{BasicQubit}",
    "description": "objects represent qubits. They have an id and a reference to the owning engine.",
    "lineNumber": 42,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "BasicQubit"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 1056,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/types/qubit.js~BasicQubit",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/types/qubit.js~BasicQubit#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 49,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": " Initialize a BasicQubit object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "BasicEngine"
        ],
        "spread": false,
        "optional": false,
        "name": "engine",
        "description": "Owning engine / engine that created the qubit"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "idx",
        "description": "Unique index of the qubit referenced by this qubit"
      }
    ]
  },
  {
    "__docId__": 1057,
    "kind": "member",
    "name": "engine",
    "memberof": "src/types/qubit.js~BasicQubit",
    "static": false,
    "longname": "src/types/qubit.js~BasicQubit#engine",
    "access": "public",
    "description": null,
    "lineNumber": 50,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1058,
    "kind": "member",
    "name": "id",
    "memberof": "src/types/qubit.js~BasicQubit",
    "static": false,
    "longname": "src/types/qubit.js~BasicQubit#id",
    "access": "public",
    "description": null,
    "lineNumber": 51,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1059,
    "kind": "method",
    "name": "toString",
    "memberof": "src/types/qubit.js~BasicQubit",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/types/qubit.js~BasicQubit#toString",
    "access": "public",
    "description": "Return string representation of this qubit.",
    "lineNumber": 58,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 1060,
    "kind": "method",
    "name": "inspect",
    "memberof": "src/types/qubit.js~BasicQubit",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/types/qubit.js~BasicQubit#inspect",
    "access": "public",
    "description": "",
    "lineNumber": 66,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 1061,
    "kind": "method",
    "name": "toBoolean",
    "memberof": "src/types/qubit.js~BasicQubit",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/types/qubit.js~BasicQubit#toBoolean",
    "access": "public",
    "description": "Access the result of a previous measurement and return false / true (0 / 1)",
    "lineNumber": 74,
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 1062,
    "kind": "method",
    "name": "toNumber",
    "memberof": "src/types/qubit.js~BasicQubit",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/types/qubit.js~BasicQubit#toNumber",
    "access": "public",
    "description": "",
    "lineNumber": 81,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 1063,
    "kind": "method",
    "name": "equal",
    "memberof": "src/types/qubit.js~BasicQubit",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/types/qubit.js~BasicQubit#equal",
    "access": "public",
    "description": "Compare with other qubit (Returns true if equal id and engine).",
    "lineNumber": 91,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": "{BasicQubit|Object} BasicQubit to which to compare this one"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1064,
    "kind": "method",
    "name": "weakCopy",
    "memberof": "src/types/qubit.js~BasicQubit",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/types/qubit.js~BasicQubit#weakCopy",
    "access": "public",
    "description": null,
    "lineNumber": 98,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1065,
    "kind": "method",
    "name": "copyArray",
    "memberof": "src/types/qubit.js~BasicQubit",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/types/qubit.js~BasicQubit.copyArray",
    "access": "public",
    "description": null,
    "lineNumber": 102,
    "undocument": true,
    "params": [
      {
        "name": "array",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1066,
    "kind": "class",
    "name": "Qubit",
    "memberof": "src/types/qubit.js",
    "static": true,
    "longname": "src/types/qubit.js~Qubit",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/types/qubit.js",
    "importStyle": "{Qubit}",
    "description": "Represents a (logical-level) qubit with a unique index provided by the\nMainEngine. Once the qubit goes out of scope (and is garbage-collected),\nit deallocates itself automatically, allowing automatic resource management.\n\nThus the qubit is not copyable only returns a reference to the same object.",
    "lineNumber": 116,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "Qubit"
      }
    ],
    "interface": false,
    "extends": [
      "BasicQubit"
    ]
  },
  {
    "__docId__": 1067,
    "kind": "method",
    "name": "deallocate",
    "memberof": "src/types/qubit.js~Qubit",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/types/qubit.js~Qubit#deallocate",
    "access": "public",
    "description": null,
    "lineNumber": 117,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 1068,
    "kind": "member",
    "name": "id",
    "memberof": "src/types/qubit.js~Qubit",
    "static": false,
    "longname": "src/types/qubit.js~Qubit#id",
    "access": "public",
    "description": null,
    "lineNumber": 135,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1069,
    "kind": "method",
    "name": "copy",
    "memberof": "src/types/qubit.js~Qubit",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/types/qubit.js~Qubit#copy",
    "access": "public",
    "description": "Non-copyable (returns reference to self).\nNote:\nTo prevent problems with automatic deallocation, qubits are not copyable!",
    "lineNumber": 144,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1070,
    "kind": "function",
    "name": "Qureg",
    "memberof": "src/types/qubit.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/types/qubit.js~Qureg",
    "access": "public",
    "export": true,
    "importPath": "projectq/src/types/qubit.js",
    "importStyle": "{Qureg}",
    "description": "Quantum register class.\nSimplifies accessing measured values for single-qubit registers (no []-access necessary)\nand enables pretty-printing of general quantum registers).",
    "lineNumber": 156,
    "unknown": [
      {
        "tagName": "@interface",
        "tagValue": ""
      },
      {
        "tagName": "@class",
        "tagValue": "Qureg"
      }
    ],
    "params": [
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1071,
    "kind": "function",
    "name": "equal",
    "memberof": "src/types/qubit.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/types/qubit.js~equal",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/types/qubit.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 174,
    "params": [
      {
        "nullable": null,
        "types": [
          "Qureg",
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 1072,
    "kind": "function",
    "name": "toBoolean",
    "memberof": "src/types/qubit.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/types/qubit.js~toBoolean",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/types/qubit.js",
    "importStyle": null,
    "description": "Return measured value if Qureg consists of 1 qubit only.",
    "lineNumber": 188,
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "if more than 1 qubit resides in this register (then you\nneed to specify which value to get using qureg[???])"
      }
    ],
    "params": [],
    "ignore": true
  },
  {
    "__docId__": 1073,
    "kind": "function",
    "name": "toNumber",
    "memberof": "src/types/qubit.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/types/qubit.js~toNumber",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/types/qubit.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 199,
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    },
    "params": [],
    "ignore": true
  },
  {
    "__docId__": 1074,
    "kind": "function",
    "name": "toString",
    "memberof": "src/types/qubit.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/types/qubit.js~toString",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/types/qubit.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 206,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": [],
    "ignore": true
  },
  {
    "__docId__": 1075,
    "kind": "function",
    "name": "add",
    "memberof": "src/types/qubit.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/types/qubit.js~add",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/types/qubit.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 236,
    "params": [
      {
        "nullable": null,
        "types": [
          "Qureg",
          "Array.<Qubit>"
        ],
        "spread": false,
        "optional": false,
        "name": "other",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Qureg"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 1076,
    "kind": "function",
    "name": "deallocate",
    "memberof": "src/types/qubit.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/types/qubit.js~deallocate",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/types/qubit.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 241,
    "undocument": true,
    "params": [],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 1077,
    "kind": "file",
    "name": "src/types/qubit.spec.js",
    "content": "/*\r\n * Copyright (c) 2018 Isaac Phoenix (tearsofphoenix@icloud.com).\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport {assert, expect} from 'chai'\r\nimport math from 'mathjs'\r\nimport {BasicQubit, Qubit, Qureg} from './qubit'\r\nimport {BasicEngine} from '../cengines/basics'\r\nimport MainEngine from '../cengines/main'\r\nimport {DummyEngine} from '../cengines/testengine'\r\nimport {Deallocate} from '../ops/gates';\r\n\r\nconst mc = math.complex\r\nconst mm = math.matrix\r\n\r\ndescribe('Qubit test', () => {\r\n  it('should test math complex type', () => {\r\n    const c = mc(1, -1)\r\n    console.log(c.re, c.im)\r\n    const a = mm([[1, 0], [0, 1]])\r\n    console.log(a._data)\r\n  });\r\n\r\n  it('should test basic qubit', () => {\r\n    const qubitID = [0, 1]\r\n    const fakeEngine = 'Fake'\r\n    const qubit = new BasicQubit(fakeEngine, qubitID)\r\n    expect(qubit.toString()).to.equal(qubitID.toString())\r\n    expect(qubit.toString()).to.equal(qubit.inspect())\r\n  });\r\n\r\n  it('should test basic qubit measurement', () => {\r\n    const eng = new MainEngine(new DummyEngine(), [new DummyEngine()])\r\n    const qubit0 = eng.allocateQubit()[0]\r\n    const qubit1 = eng.allocateQubit()[0]\r\n    eng.setMeasurementResult(qubit0, false)\r\n    eng.setMeasurementResult(qubit1, true)\r\n\r\n    expect(qubit0.toBoolean()).to.equal(false)\r\n    expect(qubit1.toBoolean()).to.equal(true)\r\n    expect(qubit0.toNumber()).to.equal(0)\r\n    expect(qubit1.toNumber()).to.equal(1)\r\n  });\r\n\r\n  it('should test basic qubit comparison', () => {\r\n    const data = [\r\n      [0, 0, true],\r\n      [0, 1, false]\r\n    ]\r\n\r\n    const fakeEngine = 'Fake'\r\n    const fakeEngine2 = 'Fake 2'\r\n\r\n    data.forEach((item) => {\r\n      const [id0, id1, expected] = item\r\n\r\n      const qubit0 = new BasicQubit(fakeEngine, id0)\r\n      const qubit1 = new BasicQubit(fakeEngine, id1)\r\n      const qubit2 = new BasicQubit(fakeEngine2, id0)\r\n\r\n      expect(qubit2.equal(qubit0)).to.equal(false)\r\n      expect(qubit2.equal(qubit1)).to.equal(false)\r\n      expect(qubit0.equal(qubit1)).to.equal(expected)\r\n    })\r\n  });\r\n\r\n  it('should test basic qubit equal', () => {\r\n    const fakeEngine = 'Engine'\r\n    const q1 = new BasicQubit(fakeEngine, 1)\r\n    const q2 = new BasicQubit(fakeEngine, 2)\r\n    const q3 = new BasicQubit(null, 3)\r\n    const q4 = new BasicQubit(fakeEngine, 1)\r\n\r\n    expect(q1.equal(q2)).to.equal(false)\r\n    expect(q1.equal(q3)).to.equal(false)\r\n    expect(q2.equal(q3)).to.equal(false)\r\n    expect(q4.equal(q1)).to.equal(true)\r\n  });\r\n\r\n  class MockMainEngine {\r\n    constructor() {\r\n      this.numCalls = 0\r\n      this.activeQubits = new Set()\r\n      this.main = this\r\n    }\r\n\r\n    deallocateQubit(qubit) {\r\n      this.numCalls += 1\r\n      this.qubitID = qubit.id\r\n    }\r\n  }\r\n\r\n  it('should test qubit del', () => {\r\n    const engine = new MockMainEngine()\r\n    const qubit = new Qubit(engine, 10)\r\n    assert(qubit.id === 10)\r\n    qubit.deallocate()\r\n    assert(qubit.id === -1)\r\n    assert(engine.numCalls === 1)\r\n    assert(engine.qubitID === 10)\r\n  });\r\n\r\n  it('should qubit not copyable', () => {\r\n    const eng = new MainEngine(new DummyEngine(), [new DummyEngine()])\r\n    const qubit = new Qubit(eng, 10)\r\n    const qubit_copy = qubit.copy()\r\n    assert(qubit === qubit_copy)\r\n  })\r\n\r\n  it('should test qureg str', () => {\r\n    const eng = new MainEngine(new DummyEngine(), [])\r\n    const reg = new Qureg()\r\n    expect(reg.toString()).to.equal('Qureg[]')\r\n\r\n    const a = eng.allocateQureg(10)\r\n    const b = eng.allocateQureg(50)\r\n    const c = eng.allocateQubit()\r\n    const d = eng.allocateQubit()\r\n    const e = eng.allocateQubit()\r\n\r\n    expect(a.toString()).to.equal('Qureg[0-9]')\r\n    assert(b.toString() === 'Qureg[10-59]')\r\n    assert(c.toString() === 'Qureg[60]')\r\n    assert(d.toString() === 'Qureg[61]')\r\n    assert(e.toString() === 'Qureg[62]')\r\n\r\n    expect(c.add(e).toString()).to.equal('Qureg[60, 62]')\r\n    expect(a.add(b).toString()).to.equal('Qureg[0-59]')\r\n    expect(a.add(b).add(c).toString()).to.equal('Qureg[0-60]')\r\n    expect(a.add(b).add(d).toString()).to.equal('Qureg[0-59, 61]')\r\n    expect(a.add(b).add(e).toString()).to.equal('Qureg[0-59, 62]')\r\n    expect(b.add(a).toString()).to.equal('Qureg[10-59, 0-9]')\r\n    expect(e.add(b).add(a).toString()).to.equal('Qureg[62, 10-59, 0-9]')\r\n  });\r\n\r\n  it('should test qureg measure if qubit', () => {\r\n    const eng = new MainEngine(new DummyEngine(), [new DummyEngine()])\r\n    const qureg0 = new Qureg(eng.allocateQubit())\r\n    const qureg1 = new Qureg(eng.allocateQubit())\r\n    eng.setMeasurementResult(qureg0[0], false)\r\n    eng.setMeasurementResult(qureg1[0], true)\r\n\r\n    expect(qureg0.toBoolean()).to.equal(false)\r\n    expect(qureg1.toBoolean()).to.equal(true)\r\n    expect(qureg0.toNumber()).to.equal(0)\r\n    expect(qureg1.toNumber()).to.equal(1)\r\n  });\r\n\r\n  it('should qureg measure exception', () => {\r\n    const eng = new MainEngine(new DummyEngine(), [new DummyEngine()])\r\n    const qureg = new Qureg()\r\n    const ids = [0, 1]\r\n    ids.forEach((id) => {\r\n      const qubit = new Qubit(eng, id)\r\n      qureg.push(qubit)\r\n    })\r\n    expect(qureg.toBoolean).to.throw()\r\n  });\r\n\r\n  it('should qureg engine', () => {\r\n    const eng1 = new MainEngine(new DummyEngine(), [new DummyEngine()])\r\n    const eng2 = new MainEngine(new DummyEngine(), [new DummyEngine()])\r\n    const qureg = new Qureg([new Qubit(eng1, 0), new Qubit(eng1, 1)])\r\n    expect(eng1).to.equal(qureg.engine)\r\n    qureg.engine = eng2\r\n    expect(qureg[0].engine === eng2 && qureg[1].engine === eng2).to.equal(true)\r\n  });\r\n\r\n  it('should idempotent del', () => {\r\n    const rec = new DummyEngine(true)\r\n    const eng = new MainEngine(rec, [])\r\n    const q = eng.allocateQubit()[0]\r\n    rec.receivedCommands = []\r\n    assert(rec.receivedCommands.length === 0)\r\n    q.deallocate()\r\n    assert(rec.receivedCommands.length === 1)\r\n    q.deallocate()\r\n    assert(rec.receivedCommands.length === 1)\r\n  });\r\n\r\n  it('should test qureg deallocate', () => {\r\n    const rec = new DummyEngine(true)\r\n    const eng = new MainEngine(rec, [])\r\n    const q = eng.allocateQureg(1)\r\n    rec.receivedCommands = []\r\n    assert(rec.receivedCommands.length === 0)\r\n    q.deallocate()\r\n    assert(rec.receivedCommands.length === 1)\r\n    q.deallocate()\r\n    assert(rec.receivedCommands.length === 1)\r\n  });\r\n\r\n  it('should test qureg to Number', function () {\r\n    const rec = new DummyEngine(true)\r\n    const eng = new MainEngine(rec, [])\r\n    const q = eng.allocateQureg(2)\r\n    expect(() => q.toNumber()).to.throw()\r\n    expect(() => q.toBoolean()).to.throw()\r\n\r\n    const q2 = eng.allocateQureg(1)\r\n    expect(() => q2.toNumber()).to.throw()\r\n  });\r\n\r\n  it('should test qureg equal', function () {\r\n    const rec = new DummyEngine(true)\r\n    const eng = new MainEngine(rec, [])\r\n    const q = eng.allocateQureg(2)\r\n    const q2 = eng.allocateQureg(2)\r\n    const q3 = new Qureg(...q)\r\n    expect(q.equal(q2)).to.equal(false)\r\n    expect(q.equal(q3)).to.equal(true)\r\n    expect(q.equal(new Array(...q))).to.equal(false)\r\n  });\r\n\r\n  it('should test basic qubit array copy', function () {\r\n    const q = new BasicQubit(null, 0)\r\n    const array = [q]\r\n    const copy = BasicQubit.copyArray(array)\r\n    expect(array).to.deep.equal(copy)\r\n  });\r\n\r\n  it('should idempotent del on failure', () => {\r\n    class InjectedBugEngine extends BasicEngine {\r\n      receive(cmds) {\r\n        cmds.forEach((cmd) => {\r\n          if (cmd.gate === Deallocate) {\r\n            throw new Error('Value error')\r\n          }\r\n        })\r\n      }\r\n    }\r\n\r\n    const eng = new MainEngine(new InjectedBugEngine(), [])\r\n    const q = eng.allocateQubit()[0]\r\n\r\n    // First call to __del__ triggers the bug.\r\n    try {\r\n      q.deallocate()\r\n      assert(false)\r\n    } catch (e) {\r\n\r\n    } finally {\r\n      // Later calls to __del__ do nothing.\r\n      expect(q.id).to.equal(-1)\r\n      q.deallocate()\r\n    }\r\n  });\r\n})\r\n",
    "static": true,
    "longname": "E:/workpace/Q/src/types/qubit.spec.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1078,
    "kind": "variable",
    "name": "mc",
    "memberof": "src/types/qubit.spec.js",
    "static": true,
    "longname": "src/types/qubit.spec.js~mc",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/types/qubit.spec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1079,
    "kind": "variable",
    "name": "mm",
    "memberof": "src/types/qubit.spec.js",
    "static": true,
    "longname": "src/types/qubit.spec.js~mm",
    "access": "public",
    "export": false,
    "importPath": "projectq/src/types/qubit.spec.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "kind": "index",
    "content": "# Q-js\r\nNodeJS version of [ProjectQ](https://github.com/ProjectQ-Framework/ProjectQ)\r\n\r\nCircleCI build status: [![CircleCI](https://circleci.com/gh/tearsofphoenix/Q-js/tree/master.svg?style=svg)](https://circleci.com/gh/tearsofphoenix/Q-js/tree/master)\r\n\r\n### install\r\n 1. use `git` to clone the repository \r\n 2. run `yarn install` \r\n 3. run `yarn build` to build native cpp simulator \r\n 4. run `yarn test`, check examples \r\n \r\n### notice\r\n  1. Most of the `class` have same name with the original ProjectQ project\r\n  2. Using `camelcase` rules to renamed most class methods. `get_inverse`\r\n     has been changed to `getInverse`.\r\n  3. Some class (like `GridMapper`) have too much arguments for it's constructor,\r\n     so changed to only pass an `Object` which contains all original arguments.\r\n  4. Python `tuple` type has been ported to Javascript `Array`. It's the programmer's\r\n     responsibility to make sure not to mutate immutable object, but not the language.  \r\n  5. `ibm` and `GridMapper` is still under porting. \r\n  6. Issues and pull requests are welcome.      ",
    "longname": "E:\\workpace\\Q\\README.md",
    "name": "./README.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "packageJSON",
    "content": "{\r\n  \"name\": \"projectq\",\r\n  \"version\": \"0.0.1\",\r\n  \"libq\": \"0.0.1\",\r\n  \"private\": false,\r\n  \"license\": \"Apache\",\r\n  \"author\": \"Isaac Phoenix (tearsofphoenix@icloud.com)\",\r\n  \"scripts\": {\r\n    \"install\": \"node scripts/install.js\",\r\n    \"cover\": \"cross-env NODE_ENV=test nyc mocha --recursive ./src\",\r\n    \"test\": \"mocha --require babel-register --require babel-polyfill --recursive ./src\",\r\n    \"build\": \"node scripts/build.js --force\",\r\n    \"doc\": \"./node_modules/.bin/esdoc\"\r\n  },\r\n  \"dependencies\": {\r\n    \"axios\": \"^0.18.0\",\r\n    \"big-integer\": \"^1.6.34\",\r\n    \"decimal.js\": \"^10.0.1\",\r\n    \"itertools\": \"^1.3.0\",\r\n    \"mathjs\": \"^5.1.0\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"babel-core\": \"^6.26.3\",\r\n    \"babel-eslint\": \"^8.2.6\",\r\n    \"babel-plugin-istanbul\": \"^4.1.6\",\r\n    \"babel-polyfill\": \"^6.26.0\",\r\n    \"babel-preset-env\": \"^1.7.0\",\r\n    \"babel-preset-stage-0\": \"^6.24.1\",\r\n    \"babel-register\": \"^6.26.0\",\r\n    \"chai\": \"^4.1.2\",\r\n    \"cross-env\": \"^5.2.0\",\r\n    \"cross-spawn\": \"^6.0.5\",\r\n    \"esdoc\": \"^1.1.0\",\r\n    \"esdoc-standard-plugin\": \"^1.0.0\",\r\n    \"esdoc-coverage-plugin\": \"^1.1.0\",\r\n    \"eslint\": \"^5.4.0\",\r\n    \"eslint-config-airbnb\": \"^17.1.0\",\r\n    \"eslint-loader\": \"^2.1.0\",\r\n    \"eslint-plugin-import\": \"^2.14.0\",\r\n    \"eslint-plugin-jsx-a11y\": \"^6.1.1\",\r\n    \"eslint-plugin-react\": \"^7.11.1\",\r\n    \"istanbul\": \"^0.4.5\",\r\n    \"jshint\": \"^2.9.6\",\r\n    \"mkdirp\": \"^0.5.1\",\r\n    \"mocha\": \"^5.2.0\",\r\n    \"nan\": \"^2.10.0\",\r\n    \"node-gyp\": \"^3.8.0\",\r\n    \"npmlog\": \"^4.1.2\",\r\n    \"nyc\": \"^12.0.2\",\r\n    \"request\": \"^2.88.0\",\r\n    \"sinon\": \"^6.1.5\",\r\n    \"true-case-path\": \"^1.0.2\"\r\n  },\r\n  \"nyc\": {\r\n    \"require\": [\r\n      \"babel-register\",\r\n      \"babel-polyfill\"\r\n    ],\r\n    \"reporter\": [\r\n      \"lcov\",\r\n      \"text\"\r\n    ],\r\n    \"sourceMap\": false,\r\n    \"instrument\": false\r\n  }\r\n}\r\n",
    "longname": "E:\\workpace\\Q\\package.json",
    "name": "package.json",
    "static": true,
    "access": "public"
  }
]